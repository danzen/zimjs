/*! ZIM - JavaScript Canvas Framework - Code Creativity
https://zimjs.com (c) 2023 modified MIT License
Donations welcome https://zimjs.com/donate
Node module - also see ES6 modules at https://zimjs.com/cdn
*/

// A zim namespace can be turned on with zns=true in a script before calling ZIM
// There is an ES6 module version available at https://zimjs.com/es6
// We have provided Node packages for ZIM and CreateJS at https://zimjs.com/npm 
// There is ZIM SHIM for Adobe Animate at https://zimjs.com/animate
// There are templates for React and VUE at https://dev.zimjs.com
// We are happy to help with integration - join us on https://zimjs.com/slack

// We would recommend you try ZIM on its own.
// It is just so easy to paste the template into a text editor and go.
// Leave all your outside worries behind and simply enjoy coding with ZIM!
// Let us handle the complexities as a scroll through the code will show! ;-)

// Cheers,
// Dr Abstract, Pragma and ZIM Team

// With thanks...
// Thanks to Yoan Herrera for the NPM / Vue, Svelte, React and Angular 
// templates at https://github.com/yoanhg421/zimjs-templates
// Thanks to ZzFX - Zuper Zmall Zound Zynth - Micro Edition for play() method of Synth
// MIT License - Copyright 2019 Frank Force - https://github.com/KilledByAPixel/ZzFX
// MIT License - Copyright 2021 George Francis - spline - https://github.com/georgedoescode
// Thanks to Josh Forisha - https://github.com/joshforisha for open-simplex-noise-js
// Thanks to David Bau - see copyright at http://davidbau.com/encode/seedrandom.js
// ZIM converted Noise() from https://www.npmjs.com/package/open-simplex-noise
// Thanks to Frank Los for coding the ZIM Keyboard()
// Thanks to Karel Rosseel for proof-reading the site
// Thanks Ami Hanya and team for such prolific work with ZIM and all the suggestions
// Of course, thanks to all the ZIM users - it is always nice to hear from you 
// at https://forum.zimjs.com and https://zimjs.com/discord
// There are several dozen thanks through out the code as well - cheers!

// This is used for the build but in a browser would be
// import createjs from "https://zimjs.org/cdn/1.4.0/createjs";
import "@zimjs/createjs";

var WW = window||{}; // minify does not shorten window so this saves 1.5k
var createjs = WW.createjs; // the expected CreateJS namespace - import CreateJS first
var zns = WW.zns; // sets from outside whether zim namespace is to be used 
var zon = WW.zon==null?true:WW.zon; // sets from outside whether zog() will output to console
var zimBlob; // stores zim.Blob (and zim.Window below) to not obscure JS Blob and Window on export
var zimWindow; // where we use export {zimBlob as Blob} and {zimWindow as Window}
var z_i; // iterator i in global namespace

// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
// ZIM CODE

// INTRODUCTION
// The code is broken into modules that once were individually available.
// We then introduced ZIM Distill (tree-shaking) as a more efficient way to reduce code
// but we have kept the modules as follows:

// WRAP, CODE, DISPLAY, METHODS, CONTROLS, FRAME, META, and docs only: GAME, THREE, SOCKET, CAM, PIZZAZZ
// You can text search a bunch of ////... to get to these.

// The docs also have these modules but ordered differently
// FRAME, DISPLAY, METHODS, CONTROLS, CODE, WRAP, META, GAME, THREE, SOCKET, PIZZAZZ.
// Each entry in the Docs has a VIEW button at the bottom
// that will nicely display the code for that entry - from this document.
// So... there is perhaps, little need to be here ;-).
// The docs are created from the description in this document.
// https://zimjs.com/docs.html

// WARNING: the WRAP and the CODE module at the start here
// are not the focus of the ZIM Framework but rather helper functions
// and even some helper functions for DOM manipulation.
// You may want to skip ahead using ////  with a space after to find your way ;-)


////////////////  ZIM WRAP  //////////////
// Zim Wrap creates global wrapper functions for less typing


/*--
zog(item1, item2, etc.)         ~ log

zog
global function

DESCRIPTION
Short version of console.log()
to log the item(s) to the console.
Use F12 to open your Browser console.
zog is dedicated to Pragma (Madeline Zen) who was coding with Dr Abstract (Dan Zen) from the start

Also comes in six ZIM colors:
	zogg("green");
	zogp("pink");
	zogb("blue");
	zogr("red");
	zogy("yellow");
	zogo("orange");

Note: If zon (comments on) is set to false before ZIM runs, then all zog() commands are turned off

EXAMPLE
zog("hello"); // logs hello to the console
END EXAMPLE

EXAMPLE
const circle = new Circle().center();
zogb(circle); // logs the circle object to the console with a blue Z marker
END EXAMPLE

EXAMPLE
const x = 10;
const y = 20;
zogo(x, y); // 10 20 with an orange Z marker
END EXAMPLE

PARAMETERS
item1, item2 (optional), etc. - items (expressions) to log to the console

RETURNS items it is logging separated by a space if more than one
--*///+0
// reported a bug in Firefox: https://bugzilla.mozilla.org/show_bug.cgi?id=1280818
// that after FF 46 binding the console did not show file and line number
// this is fixed in FF 50 - quite the conversation this stirred
var zog = zon?console.log.bind(console):function(){};
// Thanks Ami and Yalon for the technique
var zogStyle = " border:thin solid black; color: black";
var zogg = zon?console.log.bind(console, "%c Z ", "background: #acd241;"+zogStyle):function(){};
var zogp = zon?console.log.bind(console, "%c Z ", "background: #e472c4;"+zogStyle):function(){};
var zogb = zon?console.log.bind(console, "%c Z ", "background: #50c4b7;"+zogStyle):function(){};
var zogr = zon?console.log.bind(console, "%c Z ", "background: #fb4758;"+zogStyle):function(){};
var zogy = zon?console.log.bind(console, "%c Z ", "background: #ebcb35;"+zogStyle):function(){};
var zogo = zon?console.log.bind(console, "%c Z ", "background: #f58e25;"+zogStyle):function(){};
var zogl = zon?console.log.bind(console, "%c Z ", "background: #eeeeee;"+zogStyle):function(){};
var zogd = zon?console.log.bind(console, "%c Z ", "background: #444444; border:thin solid black; color: white"):function(){};
//-0

/*--
zid(string)                     ~ id

zid
global function

DESCRIPTION
Short version of document.getElementById(string)
to access an HTML tag by its id.

EXAMPLE
zid("logo").addEventListener("click", ()=>{});
END EXAMPLE

PARAMETERS
string - the id of the tag you are wanting to access

RETURNS HTML tag with id of string or null if not found
--*///+1
function zid(s) {
	z_d("1");
	return document.getElementById(s);
} //-1

/*--
zss(string)                     ~ css

zss
global function

DESCRIPTION
Short version of document.getElementById(string).style
to access the style property of an HTML tag by the tag id.

EXAMPLE
zss("logo").margin = "10px";
END EXAMPLE

PARAMETERS
string - the id of the tag whose style you are wanting to access

RETURNS style property of HTML tag with id of string or undefined if not found
--*///+2
function zss(s) {
	z_d("2");
	if (document.getElementById(s)) {return document.getElementById(s).style;}
	else if (zon) zogy("zss(): id not found");
} //-2

/*--
zgo(url, target, width, height, fullscreen, modal)         ~ go

zgo
global function

DESCRIPTION
Short version of either window.location.href or window.open
to open a link in the same window or a specified window.

EXAMPLE
zid("logo").addEventListener("click", ()=>{zgo("https://zimjs.com");});

// with a ZIM object:
const button = new Button();
button.center();
button.on("click", ()=>{zgo("https://zimjs.com");});
END EXAMPLE

EXAMPLE
// all on one line and open url in new tab
new Button().center().tap(()=>{zgo("https://zimjs.com", "_blank");})
END EXAMPLE

PARAMETERS
url - the link to use (Absolute, Relative or Virtual)
target - (default null) the string name of a window (tab) _blank for new window each time
width - (default null) width of window (use with fullscreen true)
height - (default null) height of window (use with fullscreen true)
fullscreen - (default null) not really full screen but rather opens in a new window not tab
modal - (default false) set to true to force user to close window

RETURNS null if opening in same window or reference to the window otherwise
--*///+3
function zgo(u,t,w,h,f,m) {
	z_d("3");
	if ((zot(t) && t != "") || t == "_self") {
		WW.location.href = u;
	} else {
		var added = "";
		if (w) added += "width=" + w + ",";
		if (h) added += "height=" + h + ",";
		if (f) added += "fullscreen=yes,";
		if (m) added += "modal=yes,alwaysRaised=yes";
		return WW.open(u,t,added);
	}
} //-3

/*--
zum(string)                     ~ num

zum
global function

DESCRIPTION
Takes the units off a string number.
Converts "10px" string from styles to number 10, for instance.
If there is no value then this will return 0.

EXAMPLE
// in HTML
<div id="logo" style="position:relative; left:10px">LOGO</div>

// in JavaScript
let left = zum(zss("logo").left); // converts 10px to the Number 10
left += 20; // adds 20 to 10
zss("logo").left = left + "px"; // assigns 30px to left style
END EXAMPLE

PARAMETERS
string - the string representation of a number eg. "10px"

RETURNS a Number
--*///+4
function zum(s) {
	z_d("4");
	if (zot(s)) return;
	return Number(String(s).replace(/[^\d.-]/g, ''));
} //-4

/*--
zot(value)                      ~ not

zot
global function

DESCRIPTION
Test to see if value has no value (value must exist as var or parameter)
or if value has been set to null.
Good for setting function defaults.
Really just asking if the value == null.
Often we forget exactly how to do this - it is tricky:
value === null, value == undefined, value == 0, !value DO NOT WORK.

EXAMPLE
if (zot(width)) width = 100;
// equivalent to
if (width == null) width = 100;
END EXAMPLE

PARAMETERS
value - a variable or parameter you want to see if there is no value assigned

RETURNS Boolean true if value does not exist
--*///+4.5
function zot(v) {
	return v==null; // both null and undefined match but not false or 0
}//-4.5

/*--
zop(e)                          ~ stop

zop
global function

DESCRIPTION
Stop event propagation to subsequently added existing listeners.
Must pass it e || window.event from your event function.
NOTE: this is not canceling the default action -
to cancel default action use e.preventDefault();

EXAMPLE
zid("button").addEventListener("click", e=>{
	// do something
	zop(e||window.event);
});
END EXAMPLE

PARAMETERS
e - the event object from your event function
 	collect the event object as e and then pass in e || window.event

RETURNS null
--*///+5
function zop(e) {
	z_d("5");
	if (zot(e)) return;
	if (e.stopImmediatePropagation) e.stopImmediatePropagation();
	if (WW.event) WW.event.cancelBubble=true;
} //-5

/*--
zil()                           ~ still

zil
global function

DESCRIPTION
Stop keys from moving content - arrows, spacebar, pgup, pgdown, home, end.
Stop scroll wheel from moving content - scrolling the canvas for instance.
ZIM Frame does this in the full, fit and outside scale modes.
If not using Frame, then you can do this once at the start of your code.
Returns an array of references to three listeners: [keydown, wheel and DOMMouseScroll].
Use these to removeEventListeners.
Also stores these on Window at window.zilK, window.zilW, window.zilS.
The arrows, etc, still work but just not their default window behaviour.

EXAMPLE
// at the top of your code
let listenersArray = zil();
// key and mousewheel arrows, spacebar, etc.
// will have their default actions stopped until you remove the listeners:
// window.removeEventListener("keydown", listenersArray[0]); // etc.
END EXAMPLE

RETURNS an Array
--*///+6
function zil() {
	z_d("6");
	if (WW.zilK) { // do not double apply
		WW.removeEventListener("keydown", WW.zilK);
		WW.removeEventListener("wheel", WW.zilW);
		WW.removeEventListener("DOMMouseScroll", WW.zilS);
	}
	WW.zilK = function(e) {if (!e) e = event; if (e.keyCode && (e.keyCode >= 32 && e.keyCode <= 40)) e.preventDefault();};
	WW.zilW = function(e) {if (!e) e = event; e.preventDefault();};
	WW.zilS = WW.zilW;
	WW.addEventListener("keydown", WW.zilK, {passive:false});
	WW.addEventListener("wheel", WW.zilW, {passive:false});
	WW.addEventListener("DOMMouseScroll", WW.zilS, {passive:false});
	return [WW.zilK, WW.zilW, WW.zilS];
} //-6

/*--
zet(selector, first)            ~ set

zet
global function

DESCRIPTION
Uses document.querySelectorAll() to get a list of tags.
Returns a ZIM Zet object which can be used to add events or styles to the set.

EXAMPLE
zet(".class").on("click", ()=>{}); // would add function event to all tags with the class
zet("p").css("color", "goldenrod"); // would make the text of all paragraphs goldenrod
zet("#test").css({color:"red", "background-color":"blue", paddingLeft:"20px"});

// set a custom open property on all section bars to false
zet("section .bar").prop("open", false);
// set the custom open property on all section bars to true and set the innerHTML to CLOSE
zet("section .bar").prop({open: true, innerHTML: "CLOSE"});
END EXAMPLE

PARAMETERS
selector -  a CSS query selector such as a class, id, tag, or multiple selectors separated by commands
	can also be complex selectors suchs as ".class img"
first - get the first occurance only of the set

METHODS (on the returned Zet object)
zet(selector).on(type, function) - a shortcut for addEventListener() and will be added to all tags matching the selector
zet(selector).off(type, function) - a shortcut for removeEventListener() and will be remove from all tags matching the selector
zet(selector).css(property, value) - gets and sets styles
	- gets the first programmatic property if a single string property is passed
	- sets the property to the value on each of the Zet's tags from the selector passed to zet()
	- if an object of properties and values is passed as the single parameter then sets all these properties
	- NOTE: style names do not need quotes unless the dash is used - so camelCase does not require quotes
	- NOTE: remember that commas are used for objects - not the semi-colon as in CSS
zet(selector).prop(property, value) - gets or sets a property on a set of tags
	- if an object of properties and values is provided as a single parameter, then sets all these on the set
	- else if no value is set then returns an array of the set tags values for the property
	- else if value is a single value then sets the property of the tags in the set to the value

PROPERTIES  (on the returned Zet object)
tags - an HTML NodeList tag list

RETURNS Zet object with on(), off(), css() methods and tags property (NodeList tag list)
--*///+6.1
function zet(selector, first) {
	z_d("6.1");
	function Zet() {
		var that = this;
		this.on = function(type, call) {
			if (zot(selector) || zot(type) || zot(call)) return;
			var tags = that.tags;
			for (var i=0; i<tags.length; i++) {
				tags[i].addEventListener(type, call);
			}
		};
		this.off = function(type, call) {
			if (zot(selector) || zot(type) || zot(call)) return;
			var tags = that.tags;
			for (var i=0; i<tags.length; i++) {
				tags[i].removeEventListener(type, call);
			}
		};
		Object.defineProperty(that, 'tags', {
			get: function() {
				if (zot(selector)) return [];
				if (typeof selector == 'string' || selector instanceof String) {
					if (first) zogo(selector, document.querySelector(selector))
					if (first) return [document.querySelector(selector)];
					else return document.querySelectorAll(selector);
				} else { // selector is already an object - assume a tag
					if (typeof (selector).innerHTML == "string") return [selector];
					return [];
				}
			},
			set: function() {
			}
		});
		this.css = function(property, value) {
			// if property is object then assign all props in object
			var tags = that.tags;
			for (var i=0; i<tags.length; i++) {
				if (arguments.length == 1 && arguments[0].constructor === {}.constructor) {
					for (var p in property) {
						tags[i].style[p] = property[p];
					}
				} else if (arguments.length == 1) {
					return that.tags[0].style[property];
				} else {
					tags[i].style[property] = value;
				}
			}
		};
		this.prop = function(property, value) {
			if (zot(property)) return;
			var tags = that.tags;
			var a = [];
			for (var i=0; i<tags.length; i++) {
				if (zot(value)) {
					if (property.constructor === {}.constructor) {
						for (var p in property) {
							tags[i][p] = property[p];
						}
					} else {
						a.push(tags[i][property]);
					}
				} else {
						tags[i][property] = value;
				}
			}
			if (zot(value)) return a;
		};
	}
	return new Zet();
} //-6.1

/*--
zob(func, args, sig, scope)     ~ object

zob
global function

DESCRIPTION
A system to build functions or classes that allow traditional parameters
or a configuration object passed in as a single parameter.
The configuration object has property names that match the function arguments.

To use zob on your own functions, pass in a function and the function's arguments
and insert zob into first line of your function as shown below.
Replace yourFunction with a reference to your function but keep arguments as is.

NOTE: in ES6 classes when extending a ZIM class, 
do not use ZIM DUO when passing in parameters to super()
or else the methods might be obscured.

EXAMPLE
function test(a,b,c){
	let duo; if (duo = zob(test, arguments)) return duo;
};
test(1,null,3); // traditional parameters in order
test({a:1,c:3}); // configuration object with zob
END EXAMPLE

NOTE: if you are running the function as a constructor with the new keyword
then you need to pass in this (keyword) as the last parameter (sig can be null)
this allows zob() to test to see if we need to rerun the function as a constructor

EXAMPLE
let duo; if (duo = zob(yourFunction, arguments, sig, this)) return duo;
END EXAMPLE

NOTE: if using an ES6 Class or minifying the file then you need to do an extra step
add a string version of the signature of your function above the duo call
then pass the signature in as a parameter to zob()

EXAMPLE
class Test extends Container {
	constructor(a=1,b=2,c=3) {
		super();
		const sig = "a,b,c";
		let duo; if (duo = zob(Test, arguments, sig, this)) return duo;
	}
}
END EXAMPLE

many of the ZIM functions and classes use this "DUO" technique
the documentation for parameters will tell you if they support DUO
works also with JS6 default parameter values

PARAMETERS
func - reference to the function you want to use params or a config object with
args - reference to the arguments property of the function (literally, use "arguments" with no quotes)
sig - (default null) a string listing of the parameters just how they are in the () not including the ()
	required if you are minifying the file as minifying changes the signature
scope - (default null) reference to this (litterally, use "this" without the quotes)
	required if the function is being run with the new keyword

RETURNS um... a Boolean
--*///+7
function isDUO(a) {return a.length == 1 && a[0] != undefined && a[0].constructor === {}.constructor;}
function zob(func, args, sig, scope) {
	var zimon = (zim && (zim.ZIMONON || ZIMONON));
	if (isDUO(args)) {
		z_d("7");		
		var zp = args[0];
		var zm; for (var z in zp) {if (zm=z.match(/^(.+)gColor$/)) {zp[zm[1]+"ackgroundColor"] = zp[z]; delete zp[z];}}
		var za = (zot(sig))?func.toString().split(/\n/,1)[0].match(/\((.*)\)/)[1].replace(/\s+/g,"").split(","):sig.replace(/\s+/g,"").split(",");
		var zv = []; var zi; var zt;
		for (zi=0; zi<za.length; zi++) {zt=za[zi].split("=")[0]; za[zi]=zt; zv.push(zp[zt]);}
		for (zi in zp) {if (za.indexOf(zi)<0) {if (zon) zogy(func,"bad argument "+zi);}}
		var zr; if (zr=(Object.prototype.isPrototypeOf.call(func.prototype,scope))?new (func.bind.apply(func,[null].concat(zv)))():func.apply(null,zv)) {if (zimon && !zr.arguments) {zr.arguments = [zp];} return zr;} else {return true;}
	} else {
		if (zimon && scope && args && zot(scope.arguments)) {
			scope.arguments = Array.prototype.slice.call(args);
		}
	}
}//-7

/*--
zik(Array|function|object|Pick) ~ pick

zik
global function

DESCRIPTION - DEPRECIATED as of ZIM 10
Has now been replaced with ZIM Pick() class which formalizes zik() and ZIM VEE into a more general class.
See ZIM Pick() under the Code module Classes.
--*///+7.5
function zik(v) {
	z_d("7.5");
	z_d("17.6");
	if (zot(v)) return;
	return zim.Pick.choose(v);
}//-7.5

/*--
zta(item1, item2, etc.)         ~ table

zta
global function

DESCRIPTION
Short version of console.table()
to log the Arrays or Objects to the console as a table
Use F12 to open your Browser console.

Note: if zon (comments on) is set to false before ZIM runs then all zta() commands will be turned off

EXAMPLE
zta(["will", "this", "wind"]); // logs as a table
END EXAMPLE

PARAMETERS
item1, item2 (optional), etc. - Arrays or Objects to log to the console

RETURNS items it is logging
--*///+7.6
var zta = console.table&&zon?console.table.bind(console):function(){};
//-7.6

/*--
zor(item1, item2, etc.)         ~ or

zor
global function

DESCRIPTION
picks the first non-null defined item so WILL pick a 0

EXAMPLE
const a = 0;
const x = zor(a,10); // x is 0
const y = zor(x,10); // y is 0
// note:
const z = a||10; // z is 10
const c;
const w = zor(c,a,20); // w is 0
END EXAMPLE

PARAMETERS
item1, item2 (optional), etc. - objects to test in order

RETURNS first non-null defined item or undefined if no valid items
--*///+7.7
var zor = function() {
	for(var i=0; i<arguments.length; i++) {
		if (!zot(arguments[i])) return arguments[i];
	}
};
//-7.7

// the above functions are global for quick usage
// start the zim module pattern - from here on, everything is stored on the zim namespace

var zim = function(zim) {


////////////////  ZIM CODE  //////////////

// Zim Code adds some general code functionality along with Browser and DOM code
// some of these are common Web solutions over the years (sorry for lack of credit)

// SUBSECTION FEATURED

/*--
zim.chop = function(obj, cols, rows, tile, margin, scale)

chop
zim function

DESCRIPTION
Breaks up any DisplayObject into a grid of cols and rows and returns Tile or an array of Bitmap objects.
Handy to pass to a Scrambler().
See https://zimjs.com/explore/chop.html
See https://zimjs.com/cat/scrambler.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// A chopped Circle animating like pixels
chop(new Circle(200,red),20,20)
	.center()
	.noMouse()
	.animate({
		props:{alpha:0},
		time:{min:.1, max:.4},
		rewind:true,
		loop:true,
		sequence:.02
	});
END EXAMPLE

EXAMPLE
// preload the pic in Frame() or F.loadAssets() assets parameter
new Scrambler(chop(new Pic("pic.jpg"),4,4)).center();
END EXAMPLE

PARAMETERS
obj - a ZIM DisplayObject like an asset() or Circle(), etc.
cols - the number of cols to break object into 
rows - the number of rows to break object into 
tile - (default true) return a Tile - set to false to return an array of Bitmaps 
margin - (default 0) add a margin to image - will be outside bounds
scale - (default 1) set the scale - will scale vectors as caching to preserve quality

RETURNS a Tile or an array of Bitmaps depending on tile parameter
--*///+7.8
	zim.chop = function(obj, cols, rows, tile, margin, scale) {
		z_d("7.8");
		if (zot(obj)) return;
		if (zot(cols)) cols = 3;
		if (zot(rows)) rows = 3;
		if (zot(tile)) tile = true;
		if (zot(margin)) margin = 0;
		if (zot(scale)) scale = 1;	
		// removed in ZIM ZIM 01 patch - causing parts to be same size canvas as original	
		// if (obj.uncache) { // testing if it has a CreateJS uncache method
		// 	obj = obj.cache(null,null,null,null,scale).cacheCanvas;
		// }
		// var w = obj.width/cols;
		// var h = obj.height/rows;
		if (!obj.getBounds) obj = new zim.Bitmap(obj); // added ZIM ZIM 02
		var b = obj.getBounds();
		if (zot(b)) zogy("ZIM chop() - obj must have bounds");
		var w = b.width/cols;
		var h = b.height/rows;
		var m = margin;
		var pieces = [];
		zim.loop(rows, function (r) {
			zim.loop(cols, function (c) {		
				var p = new zim.Bitmap(obj, w+m*2, h+m*2, c*w-m, r*h-m, scale);
				if (margin != 0) {
					p.setBounds(m,m,w,h);
					p.regX = m;
					p.regY = m;
				} else {
					p.setBounds(m,m,w,h);
				}
				pieces.push(p);
			});
		});
		if (tile) return new zim.Tile(pieces,cols,rows,0,0,true).sca(obj.scaleX,obj.scaleY);
		else return pieces;
	};//-7.8
	
/*--
zim.shuffle = function(array)

shuffle
zim function

DESCRIPTION
Randomly shuffles elements of an array.
Actually changes the original array (and also returns it).

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const array = ["happy", "sad", "spooked"];
const randomFromArray = shuffle(array)[0];
// this will be randomized each time it is run
END EXAMPLE

EXAMPLE
const array = shuffle(["happy", "sad", "spooked"]);
for (let i=0; i<array.length, i++) zog(array[i]);
// this will get random and unique elements of the array
END EXAMPLE

PARAMETERS
array - the Array to shuffle - or pass in any number of parameters which will be turned into an array and shuffled
different - (default false) set to true to make sure the resulting array is different in some way from the original 
	note: make sure to pass in an array for the first parameter

RETURNS the modified Array
--*///+8
	zim.shuffle = function(array, different) {
		z_d("8");
		if (zot(array)) return;
		if (!Array.isArray(array)) array = Object.values(arguments);
		var i = array.length, j, temp;
		if (i == 0) return array;
		if (different) {
			var original = zim.copy(array);
			while (zim.arraysEqual(original, array)) {
				zim.shuffle(array);
			} 
			return array;
		} else {
			while(--i) {
				j = Math.floor(Math.random()*(i+1));
				temp=array[i];
				array[i]=array[j];
				array[j]=temp;
			}
			return array;
		}
	};//-8
	
/*--
zim.pluck = function(array, remove)

pluck
zim function

DESCRIPTION
Returns a random element from an array.
Same as array[Math.floor(Math.random()*array.length)].
Or if remove is true (default is false) then returns and removes random element from array.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const colors = [orange, green, red];
zog(pluck(colors)); // orange, green or red
const answer = pluck(colors, true); // if this were red, red would be removed from array
END EXAMPLE

PARAMETERS
array - an array of objects - or pass in any number of parameters to pick from
remove - (default false) set to true to remove the selected item from the array (original array must be provided)
	
RETURNS a random item from an array
--*///+9.26
	zim.pluck = function(array, remove) {
		z_d("9.26");
		if (zot(array) || array.length==0) return null;
		if (!Array.isArray(array)) array = Object.values(arguments);
		var i = Math.floor(Math.random()*array.length);
		var answer = array[i];
		if (remove) array.splice(i,1);
		return answer;
	};//-9.26
	
/*--
zim.rand = function(a, b, integer, negative)

rand
zim function

DESCRIPTION
Returns a random integer between and including a and b if integer is true.
Returns a random number (with decimals) including a and up to b but not b if integer is false.
b is optional and if left out will default to 0 (includes 0).
integer is a boolean and defaults to true.
If a and b are 0 then just returns Math.random().

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const speed = rand(10,20); // 10, 11, 12... 18, 19 or 20

const colors = [blue, yellow, green];
const color = colors[rand(colors.length-1)]; // note the length-1

// the equivalent of:
const color = colors[Math.floor(Math.random()*colors.length)];

// OR a technique often used without using rand():
const color = shuffle(colors)[0];

// here we get a speed that is either from 5 to 10 or -5 to -10
const speed = rand(5,10,null,true);
END EXAMPLE

PARAMETERS
a - the first Number for the range
	if a and b are not provided, rand() acts like Math.random()
	if parameter b is not provided, rand will use range 0 to and including a
b - (default 0) second Number for the range
	it does not matter if a>b or a<b
integer - (default true) set to false to include decimals in results
	if false, range will include decimals up to but not including the highest number
	if a or b have decimals this is set to false
negative - (default false) includes the negative range as well as the positive

RETURNS a Number
--*///+9
	zim.rand = function(a, b, integer, negative) {
		z_d("9");
		
		if (zot(a) && zot(b)) return Math.random();
		if (zot(a) || isNaN(a)) a = 0;
		if (zot(b) || isNaN(b)) b = 0;
		if (a%1!=0 || b%1!=0) integer = false;
		if (zot(integer)) integer = true;
		if (negative) if (Math.random()>.5) {a*=-1; b*=-1;}
		if (integer) if (a>b) {a++;} else if (b>a) {b++;}
		var r;
		if (a == 0 && b == 0) return 0;
		else if (b == 0) r = Math.random()*a;
		else r = Math.min(a,b) + Math.random()*(Math.max(a,b)-Math.min(a,b));
		if (integer) return Math.floor(r);
		else return r;
	};//-9
	
/*--
zim.seedRandom = function(seed)

seedRandom
zim function

DESCRIPTION
Makes Math.random() work from a seed.
If set then ZIM rand() and ZIM VEE values will also be seeded with its value.
This means that rand() will repeat in order of its random results.

This allows, for instance, a generative art piece to be the same for a certain user.
Or lets a player replay a same random game level if the seedRandom() is set again with the same seed.
Setting the seedRandom() with no parameter returns to regular rand(), Math.random(), etc.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
seedRandom("hello");
zog(rand(10,100)) // each time the app is run, this will be the same random number between 10 and 100
zog(rand(10,100)) // this will probably be a different random number than the first - but the same each time
zog(rand()) // and this will be the same random number between 0 and 1 not including 1.
END EXAMPLE

EXAMPLE 
// Remember the seed for a user with localStorage (like a cookie)
let seed = rand(100000000);
if (localStorage) {
	if (localStorage.seed) seed = localStorage.seed;
	else localStorage.seed = seed;
} 
seedRandom(seed);
new Circle(100, [red, green, blue]).center();

// the user will always have the same random color
// unless no localStorage or localStorage is cleared

seedRandom(seed);
// below will make another circle the same color as the first
new Circle(100, [red, green, blue]).center().mov(0,300);

seedRandom(); // clears the seed
// below will be a random color each time
new Circle(100, [red, green, blue]).center().mov(200,300);
END EXAMPLE

PARAMETERS 
seed - (default null) add any string or number to seed the Math.random()
	and subsequently, ZIM rand() and ZIM VEE values from [] and {min, max}
	passing in nothing or null will use/reset to regular Math.random()

RETURNS the seed
--*///+9.01
	zim.seedRandom = function(seed) {
		z_d("9.01");		
		// Copyright 2014 David Bau.
		// See message at https://davidbau.com/encode/seedrandom.js
		!function(a,b,c,d,e,f,g,h,i){function j(a){var b,c=a.length,e=this,f=0,g=e.i=e.j=0,h=e.S=[];for(c||(a=[c++]);d>f;)h[f]=f++;for(f=0;d>f;f++)h[f]=h[g=s&g+a[f%c]+(b=h[f])],h[g]=b;(e.g=function(a){for(var b,c=0,f=e.i,g=e.j,h=e.S;a--;)b=h[f=s&f+1],c=c*d+h[s&(h[f]=h[g=s&g+b])+(h[g]=b)];return e.i=f,e.j=g,c})(d)}function k(a,b){var c,d=[],e=typeof a;if(b&&"object"==e)for(c in a)try{d.push(k(a[c],b-1))}catch(f){+function(){}();}return d.length?d:"string"==e?a:a+"\0"}function l(a,b){for(var c,d=a+"",e=0;e<d.length;)b[s&e]=s&(c^=19*b[s&e])+d.charCodeAt(e++);return n(b)}function m(c){try{return o?n(o.randomBytes(d)):(a.crypto.getRandomValues(c=new Uint8Array(d)),n(c))}catch(e){return[+new Date,a,(c=a.navigator)&&c.plugins,a.screen,n(b)]}}function n(a){return String.fromCharCode.apply(0,a)}var o,p=c.pow(d,e),q=c.pow(2,f),r=2*q,s=d-1,t=c["seed"+i]=function(a,f,g){var h=[];f=1==f?{entropy:!0}:f||{};var o=l(k(f.entropy?[a,n(b)]:null==a?m():a,3),h),s=new j(h);return l(n(s.S),b),(f.pass||g||function(a,b,d){return d?(c[i]=a,b):a})(function(){for(var a=s.g(e),b=p,c=0;q>a;)a=(a+c)*d,b*=d,c=s.g(1);for(;a>=r;)a/=2,b/=2,c>>>=1;return(a+c)/b},o,"global"in f?f.global:this==c)};if(l(c[i](),b),g&&g.exports){g.exports=t;try{o=require("crypto")}catch(u){}}else h&&h.amd&&h(function(){return t})}(this,[],Math,256,6,52,"object"==typeof module&&module,"function"==typeof define&&define,"random");
		if (!zim.randomO) zim.randomO = Math.random;
		if (zot(seed)) Math.random = zim.randomO;
		else Math.seedrandom(seed);
		return seed;		
	};//-9.01
	
/*--
zim.odds = function(percent)

odds
zim function

DESCRIPTION
Returns true if random percent is within (less than or equal to) the percent parameter provided.
So, odds(20) would be if Math.random() <= .2 
and odds(80) would be if Math.random() <= .8
and odds(50) would be half the time.

NOTE: odds(20) is the same as rand() <= .2 but just a little easier to remember and read.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
if (odds(20)) new Rectangle().center(); // 20% the time there will be a Rectangle 

if (odds()) new Aud("yay.mp3").play(); // half the time play yay otherwise play boo
else new Aud("boo.mp3").play();
END EXAMPLE

PARAMETERS
percent - (default 50) odds() will return true if random percent is less than or equal to this percent

RETURNS a Boolean
--*///+9.1
	zim.odds = function(percent) {
		z_d("9.1");
		if (zot(percent) || isNaN(percent)) percent = 50;
		return Math.random() <= percent/100;
	};//-9.1
    
/*--
zim.rarity = function(weights, shuffle, zimColors, dynamicPayload)

rarity
zim function

DESCRIPTION
Receives an object with properties each having a number value as to their frequency.
Returns an array with these properties multiplied by their frequency.
The array is shuffled so get any element such as the first to pick randomly from the weighted array.
Or pass in to any ZIM VEE value to pick in a weighted manner.
Can also pass into a series() to pick them in order.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const colors = rarity({blue:50, green:40, yellow:10});
zog(colors[0]); // 50% chance blue, 40% chance green, 10% chance yellow
END EXAMPLE

EXAMPLE
const radius = rarity({10:5, 20:2, 30:1});
// The properties are 10, 20 and 30.  
// The frequencies are 5, 2 and 1.
// The frequency numbers do not need to add to 100 
// These add to 8 - so there is a 5/8 chance the radius is 10 
// and 2/8 chance it is 20 and 1/8 chance it is 30

// radius is an array such as [20,10,10,30,10,10,20,10]
// or some such scrambled array
// An array is a ZIM VEE value 
// and the radius will be picked randomly from the array
new Circle(radius, red).center(); 

// instead, a series might be desired:
radius = series(radius); 
// this would tile radii of 20,10,10,30,10,10,20,10
new Tile(new Circle(radius, red), 4,2).center()
END EXAMPLE

EXAMPLE 
STYLE = {color:rarity(red:99,black:1)}
loop(100, ()=>{
    // probably 1 black circle - but very well could be more or less
    new Circle(50).loc(rand(W), rand(H));
});
END EXAMPLE

EXAMPLE 
// payload array example to easily set scale
// remember that rarity is shuffled automatically so [0] is a random item
const size = rarity({Big:[1,5], Med:[10,1], Small:[1,.5]})[0]; 
// the first item of each array above is the frequency 
// the second item of each array above is the payload
const circle = new Circle(100,red).center().sca(size.payload); // 5, 1 or .5
new Label(size + " Circle").center(circle); // matching "Big", "Med" or "Small"

// otherwise this is the alternative
const size = rarity({Big:1, Med:10, Small:1})[0];
const lookup = {Big:5, Med:1, Small:.5};
const circle = new Circle(100,red).center().sca(lookup[size]); // 5, 1 or .5
new Label(size + " Circle").center(circle); // matching "Big", "Med" or "Small"
END EXAMPLE 

EXAMPLE 
// ZIM VEE 
// the payload example with a range of scales for each size 
// and picking randomly from a one of two sets of colors
const size = rarity({
	Big:[1,{min:4, max:6}], // ZIM VEE range
	Med:[10,{min:.5, max:1.5}], 
	Small:[1,{min:.2, max:.4}]
})[0]; 
const color = rarity({
	Grey:[1,[grey,light,tin,silver,moon,fog]], // ZIM VEE random from array
	Colored:[20,[pink,purple,blue,red]]
})[0]; // either Grey or Colored
const circle = new Circle(100,color.payload) // will pick from payload array
	.center()
	.sca(size.payload); // a scale picked from range
new Label(color + " " + size + " Circle").center(circle); 
END EXAMPLE

EXAMPLE 
// ZIM VEE without dynamicPayload (default) 
const damage = rarity({large:[50,{min:20,max:30}], small:[50, {min:5,max:10}]})[0];
// imagine large is picked
zog(damage.payload) // imagine 25.5 is picked
zog(damage.payload) // so this will be 25.5
zog(damage.payload) // this will still be 25.5

// ZIM VEE with dynamicPayload parameter set to true
const damage = rarity({large:[50,{min:20,max:30}], small:[50, {min:5,max:10}]}, null, null, true)[0];
// imagine large is picked
zogr(damage.payload) // imagine 25.5 is picked
zogr(damage.payload) // this picks again - so it could be 22.4
zogg(damage.payload) // and this could be 29.0

damage.dynamicPayload = false; // turn off picking
zogg(damage.payload) // this will be 29.0
zogg(damage.payload) // this will be 29.0

damage.dynamicPayload = true; // back to picking
zogr(damage.payload) // this could be 21.3
zogr(damage.payload) // this could be 28.8
END EXAMPLE 

PARAMETERS
weights - (default null) an object literal with options (property name) and frequencies (property value) 
	or the property value can be an array with [frequency, payload] (see further down)
	eg. {green:70, blue:20, red:10} or {10:2, 20:2, 30:1}
	The frequencies should be whole numbers 
		The frequencies can add to 100 to easily visualize percentage 
		but they can add up to any number and this will be used 
		to calculate the pick ratio for each one using frequency/total frequency
		For instance with {10:2, 20:2, 30:1} the frequencies add up to 5
		so the the chances of being picked are 2/5 for 10, 2/5 for 20 and 1/5 for 30
	If an array with [frequency, payload] is provided then the frequency is used as the frequency 
		the payload is any object that will be added as a payload property to the option string 
		(the option is converted from a primative string to a String object so it can hold the payload)
		This arrangement replaces the need for a look-up table (see examples)
		| ZIM VEE |
		The payload can be any object but will also be processed by ZIM VEE (Pick) 
		So if an array or object literal is desired use {noPick:[]} or {noPick:{}} 
		Also see dynamicPayload parameter
		ZIM VEE literal types are: 
			[1,3,2] - random; {min:10, max:20} - range; 
			series(1,2,3) - order, function(){return result;} - function
shuffle - (default true) shuffle the resulting array
zimColors - (default true) set to false to not convert "blue" property value to ZIM blue
dynamicPayload - (default false) only pick once from ZIM VEE value in payload
	or set to true to continue to pick from ZIM VEE value in payload each time property is accessed
	note: at any time after rarity() is called, this can be set to true or false
	
RETURNS an array of properties repeated according to frequency
these properties may have a payload property if payloads are used
--*///+9.2
	zim.rarity = function(weights, shuffle, zimColors, dynamicPayload) {
		z_d("9.2");
		if (zot(weights) || weights.constructor != {}.constructor) return [];
        if (zot(shuffle)) shuffle = true;
		if (zot(zimColors)) zimColors = true;
        if (zot(dynamicPayload)) dynamicPayload = false;
        var all = [];
        zim.loop(weights, function (key,val) {
			var i = zim.colors.indexOf(key);
			if (i != -1) key = zim.colorsHex[i];
			var num;
			if (Array.isArray(val)) {
				if (+key === +key) key = new Number(key);
				else key = new String(key);
				key._payload = val[1];
				key.dynamicPayload = dynamicPayload;			
				Object.defineProperty(key, "payload", {
					get:function() {
						if (!this.dynamicPayload && this._lastPayload!=null) return this._lastPayload;
						this._lastPayload = zim.Pick.choose(this._payload);
						return this._lastPayload;
					},
						set:function(v) {
						this._lastPayload = null;
						this._payload = v;
					}
				});
				num = val[0];
				zim.loop(num, function() {					
					all.push(key);
				});
			} else {
				num = val;
				zim.loop(num, function() {
					if (+key === +key) key = +key; // if number use number
					all.push(key);
				});
			}            
		});
        if (shuffle) zim.shuffle(all);
        return all;
	};//-9.2

/*--
zim.repeats = function(array, total)

repeats
zim function

DESCRIPTION
Returns the number of repeats in an array.
By default, this will be the max number of repeats - not the total repeats.
The number of repeats often offers a rarity feature.

NOTE: this does not determine the repeated value - this is not needed for rarity.

NOTE: a repeat is one less than the number of objects that are the same.
So if no objects are the same the repeats are 0.
If two objects are the same the repeats are 1.
If three objects are the same the repeats are 2, etc.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const colors = [orange, green, red, orange, orange, green];
zog(repeats(colors)); // 2 - note, one less than the number of objects that repeat
zog(repeats(colors, false)) // 3 - two repeats with orange, one repeat with green
END EXAMPLE

PARAMETERS
array - an array of objects 
total - (default false) set to true to return the total repeats
	
RETURNS the max number of repeats in an array or 0 if no objects are the same, one if two objects are the same, etc.
if total is true then returns all the repeats - possibly from different sets
--*///+9.25
	zim.repeats = function(array, total) {
		z_d("9.25");
		if (zot(array) || !Array.isArray(array)) return 0;
		var counter = {};
		var max = 0;
		var tot = 0;
        zim.loop(array, function (a) {
            if (counter[a] != null) {
				counter[a]++;
				tot++;
			}
			else counter[a] = 0;
			if (counter[a] > max) max = counter[a];
        });        
        return total?tot:max;
	};//-9.25
	
/*--
zim.series = function(array|item1|obj, item2, item3)

series
zim function

DESCRIPTION
Returns a function that will return each value passed as a parameter (or an Array) in order
or an object literal with min and max.
This goes in sequence each time the function is called.
Use this to pass a series in to any ZIM VEE value so a looping series is obtained.

NOTE: was called makeSeries() which is now depricated

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// note - do not call the variable name series
const colors = series(red, green, blue);
colors(); // red
colors(); // green
colors(); // blue
colors(); // red, etc.

// or
const colors = [red, green, blue];
const s = series(colors);
s(); // red
s(); // green
s(); // blue
s(); // red, etc.

new Tile(new Rectangle(10,10,[blue, red]), 10, 10).center(); // would randomize colors
new Tile(new Rectangle(10,10,series(blue, red)), 10, 10).center(); // would alternate colors
END EXAMPLE

EXAMPLE
STYLE = {color:series(pink, green, blue)}
loop(9, i=>{
	new Circle(100).loc(110+i*100, 400)
});
END EXAMPLE

EXAMPLE
// ten rectangles getting higher by 20 each time
const s = series({min:10, max:200}).step(20);
loop(10, i=>{
	new Rectangle(10, s, red).sca(1,-1).loc(100+i*20, 400);
});
END EXAMPLE

EXAMPLE
// added functionality as of ZIM 10.9.0
// start at index 3, reverse and don't go past 0
const nums = series(0, 1, 2, 3, 4).jump(3).reverse().constrain();
loop(5, ()=>{
	zogb(nums()); // 3,2,1,0,0 (blue in console)
});
nums.reverse(false); // go forward - note, still starting at index 0
zogg(nums()); // 0 (green in console)
zogg(nums()); // 1
zogg(nums()); // 2
nums.bounce(); // go back and forth rather than default loop
loop(5, ()=>{
	zogy(nums()); // 3,4,3,2,1 (yellow in console)
});
nums.step(3); // sitting at 0 then increase the step to 3
loop(5, ()=>{
	zogr(nums()); // 0,3,2,1,4 (red in console)
	// 3->6 bounces off 4 with two back to 2
	// 2->-1 bounces off 0 with one forward to 1
	// tricky but correct
});
zogp(nums.index); // 1 - coming back 3 steps from 4 to 1 as current index
END EXAMPLE

EXAMPLE 
// make a checkerboard 
const colors = series(black,white,black,white,black,white,black,white).flip();
const board = new Tile(new Rectangle(80,80,colors),8,8,1,1).center();
END EXAMPLE 

PARAMETERS
array|item1|{min,max,step} - the first item - or an array of results that will be called in order as the resulting function is called
	or an object with min, max and step properties to make a series of numbers from and including min and max (step defaults to 0)
	this will make an array of values and then it is just like an array was entered initially.
    when used with ZIM VEE - the values may be further ZIM VEE values (including more series values)
item2 - the second item if the first is not an array
item3 - the third item, etc. to as many items as needed

METHODS
step(num) - num defaults to 1 - the number of items to move the index - or use index property
every(num) - num defaults to 0 - steps to wait before moving to the next index - remain on blue for five, then go to yellow for five, etc.
jump(index) - jump to an index but do not run it - the next call to the series will run here
reverse(boolean) - boolean defaults to true - reverses direction - or pass in false to cancel reverse
bounce(boolean) - boolean defaults to true - back and forth between 0 and length-1 - or pass in false to cancel bounce
flip(boolean) - boolean defaults to true - go to the end then go in reverse - will do last one and first one twice - or pass false to cancel flip
constrain(boolean) - boolean defaults to true - keeps index between 0 and length-1 - or pass in false to cancel constrain
random(boolean) - boolean defaults to true - randomizes order of series each time it finishes - or pass in false to cancel random 	
mix(boolean) - boolean defaults to true - randomizes order of series but avoids duplicating on ends - or pass in false to cancel mix
shuffle(boolean) - boolean defaults to true - shuffles order of series but then will repeat with same order - or pass in false to cancel shuffle

PROPERTIES
type - a string of the type of object in this case, "series"
array - an array of items passed in to the function
length - the length of the series
index - get or set the current index of the series - what will run next
original - a copy of the original order

RETURNS a function that can be called many times - each time returning the next value in the series
--*///+13.61
	zim.series = function() {
		z_d("13.61");
		var array;
		var range;

		if (arguments[0] == null) return null;
		if (arguments.length == 0) return function(){};
		if (arguments.length == 1 && Array.isArray(arguments[0])) {
			array = arguments[0];
		} else if (arguments.length == 1 && arguments[0].constructor == {}.constructor) {			
			range = arguments[0];
			if (zot(range.min)) range.min = 0;
			if (zot(range.max)) range.max = 1;
			if (zot(range.step)) range.step = 1;
			array = [];
			zim.loop(Math.floor(Math.abs(range.max-range.min)+range.step), function (i) {
				array.push(i+range.min);
			}, null, null, range.step);
			range = null;
		} else {
			array = Array.prototype.slice.call(arguments);
		}
        var count = 0;
		var dir = 1;
		var step = 1;
		var every = 0;
		var everyCount = 0;
		var bounce = false;
		var flip = false;
		var constrain = false;
		var randomize = false;
		var mix = false;
		var firstVal;
		var lastVal;

        var f = function(target, fromPick) {
			if (every && everyCount%(every) != 0) {
				everyCount++;
				return lastVal;
			}
			everyCount++;
			var length = array.length;
			var val;
			if ((randomize || mix) && count%length==0) zim.shuffle(array);				
			val = array[(length*10+count)%length];
			if (count==0) firstVal = val;
			if (mix && count%length==0 && length>1) {				
				while(val==lastVal) {
					zim.shuffle(array);
					val = array[(length*10+count)%length];
				}				
			}
            if (bounce) {
				if (dir > 0 && count+dir*step >= length) {
					dir = -1;
					count = (length-1)-(count+step-(length-1));
				} else if (dir < 0 && count+dir*step < 0) {
					dir = 1;
					count = step - count;
				} else {
					count += dir*step;
				}
			} else if (flip) {
				if (dir > 0 && count+dir*step >= length) {
					dir = -1;
					count = (length-1)-(count+step-(length-1)) + step;
				} else if (dir < 0 && count+dir*step < 0) {
					dir = 1;
					count = step - count - step;
				} else {
					count += dir*step;
				}			
			} else if (constrain) {
				if (dir > 0 && count+dir*step >= length) count = length-1;
				else if (dir < 0 && count+dir*step < 0) count = 0;
				else count += dir*step;
			} else {
				count += dir*step;
			}
			lastVal = val;			
			if (zim.isPick(val)) {	
				// adjusted in ZIM NFT to make literal version of series recursive
				// tricky - literal versus Pick.choose() was reporting wrong noPick results from series
				if (val.noPick && fromPick) return val;			
				return zim.Pick.choose(val);
			}
			return val;
        };
		var original = f.original = zim.copy(array);
        f.array = array;
		f.type = "series";
		Object.defineProperty(f, 'index', {
			get: function() {
				var length = array.length;
				return (length*10+count)%length;
			},
			set: function(value) {
				count = value;
				everyCount = 0;
			}
		});		
		Object.defineProperty(f, 'length', {
			get: function() {
				return array.length
			},
			set: function() {				
			}
		});
		f.jump = function(value) {
			count = value;
			return f;
		};
		f.reverse = function(value) {
			if (zot(value)) value = true;
			if (value) dir = -1;
			else dir = 1;
			if (count==0) count = array.length-1;
			return f;
		};
		f.bounce = function(value) {
			// normalize count
			if (zot(value)) value = true;
			var length = array.length;
			count = (length*10+count)%length;
			bounce = value;
			return f;
		};
		f.flip = function(value) {
			// normalize count
			if (zot(value)) value = true;
			var length = array.length;
			count = (length*10+count)%length;
			flip = value;
			return f;
		};
		f.step = function(value) {
			if (zot(value)) value = 1;
			step = Math.floor(value);
			return f;
		};
		f.every = function(value) {
			if (zot(value)) value = 1;
			every = Math.abs(value);
			everyCount = 0;
			return f;
		};
		f.constrain = function(value) {
			if (zot(value)) value = true;
			constrain = value;
			return f;
		};
		f.random = function(value) {
			if (zot(value)) value = true;
			if (!value) array = original;
			randomize = value==true;
			return f;
		};
		f.mix = function(value) {
			if (zot(value)) value = true;
			if (!value) array = original;
			mix = value==true;
			return f;
		};
		f.shuffle = function(value) {
			if (zot(value)) value = true;
			if (value) zim.shuffle(array);
			else array = original;
			return f;
		};
        return f;
	};//-13.61

/*--
zim.makeSeries = function(array)
	depreciated - use series()
--*///+13.6
	zim.makeSeries = function(array) {
		z_d("13.6");
        if (zot(array)) return function(){};
        var count = 0;
        var f = function() {
            return array[(count++)%array.length];
        };
        f.array = array;
        return f;
	};//-13.6

/*--
zim.loop = function(obj, call, reverse, interval, step, start, end, immediate, complete, completeParams)

loop
zim function

DESCRIPTION
1. If you pass in a Number for obj then loop() does function call that many times
and passes function call the currentIndex, totalLoops, startIndex, endIndex, obj.
By default, the index starts at 0 and counts up to one less than the number.
So this is like: for (let i=0; i<obj; i++) {}
There are step, start and end index parameters - start cannot be negative

2. If you pass in an Array then loop() loops through the array
and passes the function call the element in the array, currentIndex, totalLoops, startIndex, endIndex and the array.
So this is like: for (let i=0; i<obj; i++) {element = array[i];}

3. If you pass in an Object literal or ZIM Dictionary then loop() loops through the object
and passes the function call the property name, value, currentIndex, totalLoops, startIndex, endIndex, obj
So this is like: for (let i in obj) {property = i; value = obj[i];}
Note: a Dictionary uses a copy of its objects and values to provide name and value
this is because setting Dictionary values while looping will change the order of the arrays while looping

4. If you pass in an String then loop() loops through the letters
and passes the function call the letter, currentIndex, totalLoops, startIndex, endIndex, obj.
So this is like: for (let i=0; i<obj.length; i++) {letter = obj[i];}

5. If you pass an HTML NodeList or HTMLCollection then loop() loops and gives each tag in the NodeList or HTMLCollection
see ZIM zet() for an example of getting a NodeList (like the $() in JQuery)

6. If you pass in a Container then loop() loops through all the children of the container
and does the function for each one passing the child, currentIndex, totalLoops, startIndex, endIndex, obj.
So this is like for(let i=0; i<obj; i++) {let child = obj.getChildAt(i);} 
or for (let i in container.children) {let child = container.children[i];}

** the ZIM loop method can also be used for looping through a Container as follows:
container.loop(item=>{}); // see loop under the Methods Module.

NOTE: If you pass in true for reverse, the loop is run backwards counting to 0 (by default)
NOTE: use return to act like a continue in a loop and go to the next loop
NOTE: use return NEXT when in interval mode to go immediately to the next interval - as opposed to return which goes to next but after another interval
NOTE: return a value to return out of the loop completely like a break (and return a result if desired)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const container = new Container().alp(.1).addTo();
loop(1000, i=>{ // gets passed an index i, totalLoops 1000, startIndex 0, endIndex 999, obj 1000
	// make 1000 rectangles
	new Rectangle().loc(rand(W-100), rand(H-100), container);
});

// to continue or break from loop have the function return the string "continue" or "break"
loop(10, i=>{
	if (i%2==0) return; // skip even
	if (i>6) return "break"; // quit loop when > 6
	zog(i);
});

loop(10, i=>{
	zog(i); // 9-0 in console
}, true);

loop(10, i=>{
	zog(i); // 5-9
}, null, 1, 5)

// the start parameter cannot be less than 0
// to get negative values for i subtract a desired value inside the loop

const colors = [green, yellow, pink];
loop(colors, (color, index, start, end, array)=>{ // do not have to collect all these
	zog(color); // each color
});

const array = [0,0,0,1,0,0,0];
const pass = loop(array, val=>{
	if (val!=0) return false;
});
// below will log failed
if (pass) zog("passed"); // by default loop returns true (as of ZIM 10.6.1)
else zog("failed"); // false inside loop gets assigned to pass

const person = {name:"Dan Zen", occupation:"Inventor", location:"Dundas"}
const result = loop(person, (prop, val, index, total, start, end, object)=>{ // do not have to collect all these
	zog(prop, val); // each key value pair
	if (val == "criminal") return "criminal"; // this would return out of the loop to the containing function
});
if (result == "criminal") alert("oh no!");

const tags = zet(".heading").tags; // get an NodeList of tags styled with heading class
loop(tags, (tag, i)=>{
	tag.innerHTML = i + ". " + tag.innerHTML; // add an index number in front
});
END EXAMPLE 

EXAMPLE
// LOOP THROUGH A CONTAINER 

// LOOP FUNCTION
loop(container, child => { // gets passed the child, index, total, start, end and obj
	child.alp(rand(.2, .9)); // set each child to a random alpha
}); 

// LOOP METHOD
container.loop(child => { // gets passed the child, index, total, start, end and obj
	child.alp(rand(.2, .9)); // set each child to a random alpha
}); 

// backwards through a Container when removing
container.loop(child => { 
	if (odds(20)) child.removeFrom();
}, true); // true would reverse - important if removing children in loop
END EXAMPLE

EXAMPLE 
// looping with the interval setting 

// loop through an array every 1 second 
loop(10, i=>{zog(i);}, null, 1);

// loop through a Container every .01 seconds 
const tile = new Tile(new Rectangle(26,26,[green, blue, pink]), 10, 10, -1, -1)
	.reg(CENTER)
	.pos(0,100,CENTER,BOTTOM)
	.loop(item=>{
		item.color = darker;
		S.update();
	}, null, .01);
END EXAMPLE 

PARAMETERS supports DUO - parameters or single object with properties below
obj - a Number of times to loop or an Array or Object, String, NodeList or Container to loop through
	for looping through a Container also note the loop method: container.loop((child)=>{});
call - the function to call
	the function will receive (as its final parameters) the index, total, start, end, obj, intervalObj (if interval is set)
		where the index is the current index, total is how many times the loop will run
		start is the start index, end is the end index and obj is the object passed to the loop
	the starting parameters vary depending on the type of obj:
	if the obj is a number then the first parameter is the index (no extra starting parameters given)
	if the obj is an array then the first parameter is the element at the current index
	if the obj is an object literal then the first and second parameters are the property name and property value at the current index
	if the obj is an string then the first parameter is the letter
	if the obj is an HTMLCollection then the first parameter is the tag
	if the obj is a Container then the first paramter is the child
reverse - (default false) set to true to run the loop backwards to 0
interval - (default 0) set to a number of seconds between each loop
	use return NEXT to go immediately to the next interval 
	use return to just leave current interval then wait another interval to continue
	return a value (other than NEXT) to exit the loop and clear the inverval 
	the interval object is provided at the end of the loop function parameters - but will probably not be needed
step - (default 1) each step will increase by this amount (positive whole number - use reverse to go backwards)
start - (default 0 or length-1 for reverse) index to start
end - (default length-1 or 0 for reverse) index to end
immediate - (default true) set to false to not start the loop right away, but rather wait for a first interval
complete (default null) - a callback function to call when complete
completeParams (default null) - paramater to pass complete callback

RETURNS any value returned from the loop - or true if no value is returned from a loop
--*///+9.5
	zim.loop = function(obj, call, reverse, interval, step, start, end, immediate, complete, completeParams) {		
		var sig = "obj, call, reverse, interval, step, start, end, immediate, complete, completeParams";
		var duo; if (duo = zob(zim.loop, arguments, sig)) return duo;
		z_d("9.5");
		if (zot(obj) || zot(call)) return undefined;
		if (zot(reverse)) reverse = false;
		if (zot(interval)) interval = 0;
		if (zot(step) || step <= 0) step = 1;
		if (zot(immediate)) immediate = true;
		if (obj.constructor === Number) obj = Number(obj);
		if (obj.constructor === String) obj = String(obj);

		var comp = interval==0 && complete && typeof complete=="function";
				
		var type = typeof obj=="number"?"number":(obj.constructor === Array?"array":(obj.constructor === {}.constructor?"object":(typeof obj == "string"?"string":(obj instanceof NodeList?"nodelist":(obj instanceof HTMLCollection?"htmlcollection":(obj.type&&obj.type=="Dictionary"?"Dictionary":"invalid"))))));

		if (type == "invalid") {
			return undefined;
		}
		var length;
		var total;
		var i;
		var r;
		if (type == "number" || type == "string" || type == "array" || type == "nodelist" || type == "htmlcollection" || type == "Dictionary") {
			if (type == "Dictionary") {
				var vals = zim.copy(obj.values);
				obj = zim.copy(obj.objects);
			}
			length = type=="number"?obj:obj.length;
			total = getTotal(length-1);
			if (total == 0) return;
			if (reverse) {
				if (interval === 0) {
					for(i=start; i>=end; i-=step) {
						if (type=="number") {
							r = call(i, total, start, end, obj);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist
							r = call(obj.item(i), i, total, start, end, obj);
						}
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count;
						if (!immediate) i--;
						if (step) i *= step;
						i = start-i;
						
						if (type=="number") {
							r = call(i, total, start, end, obj);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist
							r = call(obj.item(i), i, total, start, end, obj);
						}					
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			} else {
				if (interval === 0) {
					for(i=start; i<=end; i+=step) {
						if (type=="number") {
							r = call(i, total, start, end, obj);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist // htmlcollection
							r = call(obj.item(i), i, total, start, end, obj);
						}
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count + start;
						if (!immediate) i--;
						if (step != 1) i = -start + i*step;
						
						if (type=="number") {
							r = call(i, total, start, end, obj, io);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj, io);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist or htmlcollection
							r = call(obj.item(i), i, total, start, end, obj, io);
						}
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			}
			if (comp) complete(completeParams);
			return true;
		} else if (type == "object") {
			length = 0;
			var props = [];
			for (i in obj) {
				length++;
				props.push(i);
			}
			total = getTotal(length-1);
			if (total == 0) return;
			if (reverse) {
				if (interval === 0) {
					for(i=start; i>=end; i-=step) {
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						if (typeof r != 'undefined') return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count;
						if (!immediate) i--;
						if (step) i *= step;
						i = start-i;
						
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			} else {
				if (interval === 0) {
					for(i=start; i<=end; i+=step) {
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						if (typeof r != 'undefined') return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count + start;
						if (!immediate) i--;
						if (step != 1) i = -start + i*step;
						
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			}
			if (comp) complete(completeParams);
			return true;
		}
		function getTotal(max) {
			if (zot(start)) start = reverse?max:0;
			if (zot(end)) end = reverse?0:max;
			if ((reverse && end > start) || (!reverse && start > end)) return 0;
			if ((start < 0 && end) <0 || (start > max && end > max)) return 0;
			start = Math.max(0, Math.min(start, max));
			end = Math.max(0, Math.min(end, max));
			return Math.floor((reverse?(start-end):(end-start)) / step) + 1;
		}		
	};//-9.5

/*--
getTIME = function(time, timeType, minWarning, maxWarning, noWarning)

getTIME
global function

Checks for TIME and timeUnit
Used internally by interval, timeout, animate and others
returns the time unit as "s" or "m"

~~~~~~~~~~~~~~
checkTIME = function(time, timeChar, minWarning, maxWarning)

checkTIME
globalFunction

Tests to see if time is in expected units - timeChar is "s" or "m" for seconds or milliseconds
logs a warning if ((timeChar="s" && time>minWarning) || (timeChar=="m" && time<maxWarning))
Set TIMECHECK = false to turn off check if desired - for instance if getting false positives
--*///+9.99
	function getTIME(time, timeUnit, minWarning, maxWarning, noWarning) {
		if (!zim.timeCheck) {z_d("9.99"); zim.timeCheck=true;}
		var timeType = zot(WW.TIME) ? zot(zim.TIME) ? "seconds" : zim.TIME : WW.TIME;
		if (timeType && timeType.toLowerCase) timeType = timeType.toLowerCase();
		if (timeType != "milliseconds" && timeType != "ms") timeType = "seconds";
		if (timeUnit && timeUnit.toLowerCase) timeUnit = timeUnit.toLowerCase();
		if (timeUnit=="ms" || timeUnit=="milliseconds" || timeUnit=="seconds" || timeUnit=="s") timeType = timeUnit;
		if (zot(time)) return timeType.charAt(0);
		if (timeType=="ms") timeType = "milliseconds";
		if (timeType=="s") timeType = "seconds";
		timeType = timeType.charAt(0);
		if (!noWarning) checkTIME(time, timeType, minWarning, maxWarning);
		return timeType;
	}
	function checkTIME(time, timeChar, minWarning, maxWarning) {
		if (zot(minWarning)) minWarning = 10;
		if (zot(maxWarning)) maxWarning = 9;
		if (!zim.TIMECHECK && !WW.TIMECHECK) return;
		if ((timeChar!="m" && time>minWarning) || (timeChar=="m" && time<maxWarning)) {
			if (zon) zogy("TIME - warning: time is in "+(timeChar=="m"?"milliseconds":"seconds")+ " ("+time+")");
		}
	}
	//-9.99

/*--
zim.timeout = function(time, call, pauseOnBlur, timeUnit)

timeout
zim function

DESCRIPTION
Calls a function after the time delay - like window.setTimeout()
This calls ZIM interval() with a total of 1.

NOTE: as of ZIM Cat time is in seconds not milliseconds.
Set TIME = "milliseconds"; to set all ZIM time to milliseconds
or pass in "milliseconds" to the timeUnit parameter for a specific override.

NOTE: setTimeout has the time parameter last, timeout has it first
so that it is consistent with loop() and the CreateJS on() method

NOTE: to clear a timeout you use returnID.clear() - different than window.clearTimeout(returnID)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
timeout(1, ()=>{
	circle.x += 100;
	S.update();
});
// moves the circle 100 pixels after one second

// GAME to press button within one second:
const id = timeout(1, ()=>{
	zog("you lose!");
	button.enabled = false;
});
const button = new Button().center();
button.on("click", ()=>{
	zog("you win!");
	id.clear();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
time - |ZIM VEE| seconds to wait until function is called
	see TIME global constant (defaults to "seconds") can also override with timeUnit parameter set to "milliseconds"
call - function to call when the time passes - will receive the id object as a single parameter
pauseOnBlur - (default false) set to true to pause timeout when window is reduced or another tab gains focus
timeUnit - (default TIME) set to "milliseconds" for traditional JavaScript milliseconds
	also see TIME constant which defaults to "seconds"
	timeUnit will override the TIME constant

RETURNS a ZIM timeoutObject to pause and clear the timeout with the following methods and properties:

METHODS - of ZIM timeoutObject
pause(state, immediate, reset) - (default true) will pause the timeout - set to false to unpause the timeout at the time remaining
	immediate (default false) set to true to make the timeout function run right away when unpausing (no effect when pausing)
	reset (default false) set to true to set the timeout back to 0 time passed when unpausing (no effect when pausing)
clear() - will clear the timeout

PROPERTIES - of ZIM timeoutObject
time - the time that has lapsed (in the timeUnit)
paused - the paused state of the timeout
done - true if finished
timeUnit - get the timeUnit used at start
--*///+9.7
	zim.timeout = function(time, call, pauseOnBlur, timeUnit) {
		var sig = "time, call, pauseOnBlur, timeUnit";
		var duo; if (duo = zob(zim.timeout, arguments, sig, this)) return duo;
		z_d("9.7");
		if (zot(call)) return;
		if (typeof call != 'function') return;
		var o = zim.interval(time, call, 1, false, pauseOnBlur, timeUnit);
		o.type = "timeoutObj";
		return o;
	};//-9.7

/*--
zim.interval = function(time, call, total, immediate, pauseOnBlur, timeUnit, complete, completeParams)

interval
zim function

DESCRIPTION
Calls a function after each time delay - like window.setInterval().
Can pass in an Array of two times to set random time delays each interval.
Can pass in how many times you want to run the function and whether it runs right away.

NOTE: as of ZIM Cat time is in seconds not milliseconds.
Set TIME = "milliseconds"; to set all ZIM time to milliseconds
or pass in "milliseconds" to the timeUnit parameter for a specific override.

NOTE: setInterval has the time parameter last, interval has it first
so that it is consistent with loop() and the CreateJS on() method

NOTE: to clear a interval you use intervalObj.clear() - different than window.clearInterval(returnID)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
interval(1, ()=>{
	circle.x += 100;
	S.update();
});
// every second the circle will move 100 pixels
// if you want smooth movement, use:

Ticker.add(()=>{
	circle.x += 100; // no need for S.update()
});

interval(1, obj=>{
	zog("counting " + obj.count); // starts counting at 1
	if (obj.count == 10) obj.clear(); // will now log 1 to 10
});
// OR better:
interval(1, obj=>{
	zog("counting " + obj.count); // starts counting at 1
}, 10); // now will log 1 - 10 with total parameter set to 10

// IMMEDIATE:
interval(1, obj=>{
	zog("counting " + obj.count); // starts counting at 0
}, 10, true); // now will log 0 - 9 with immediate parameter set to true

// EXTERNAL control:
const inter = interval(1, ()=>{
	zog("counting " + inter.count); // starts counting at 1
});
const button = new Button({label:"STOP", toggle:"START"}).center();
button.on("click", ()=>{inter.pause(button.toggled);});

// RANDOM intervals with ZIM Pick() literals
interval({min:.2, max:.8}, dropBombs); // bombs will fall at different rates between 200ms and 800ms
interval([1, 2], dropBombs); // bombs will fall at either 1 or 2 s
let count = 1;
function increase() {return ++count}
interval(increase, dropBombs); // bombs will fall at 1 second, then again after 2 more seconds and 3 seconds more after that, etc.
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
time - |ZIM VEE| (default 1) seconds for the interval (delay until the function runs - again and again)
	see TIME global constant (defaults to "seconds") can also override with timeUnit parameter set to "milliseconds"
call - function to call when the interval passes
	Will be passed a ZIM intervalObject as a single parameter
	This is the same as the return object from animate()
	See the Returns section below for methods and properties of the intervalObject
total - (default null - infinite) the number of times the function is called
	note: the count property counts intervals but the total property is based on function calls.
	The total will be equal to the end count with the immediate parameter set to false (default)
	but the total will be one less than the count if the immediate parameter is true (like an Array index and length)
immediate - (default false) set to true to call the function right away (and then still call every interval)
	This will not increase the count in the intervalObject because count counts intervals not function calls
	Use the provided parameter of the call function to access the intervalObject inside the call function
pauseOnBlur - (default false) set to true to pause interval when window is reduced or another tab gains focus
timeUnit - (default seconds) set to "milliseconds" for traditional JavaScript milliseconds
	also see TIME constant which defaults to "seconds"
	timeUnit will override the TIME constant
complete (default null) - a callback function to call when complete if total is set
completeParams (default null) - paramater to pass complete callback

RETURNS a ZIM intervalObject to pause and clear the interval with the following methods and properties:

METHODS - of ZIM intervalObject
pause(state, immediate, reset) - (default true) will pause the interval - set to false to unpause the interval with time left
	immediate (default false) set to true to make the interval function run right away when unpausing (no effect when pausing)
	reset (default false) set to true to set the interval back to 0 time passed when unpausing (no effect when pausing)
next() - calls the interval again immediately, count goes up
clear() - will clear the interval but the count stays as it was

PROPERTIES - of ZIM intervalObject
time - |ZIM VEE| get or set the time for the interval (see time parameter)
count - get or set the number of times the interval has run (if immediate is true, the first count is 0)
total - get or set the number of times the interval will run if the total parameter is set - otherwise -1 for infinite
paused - get the paused state of the interval (see pause() method)
pauseTimeLeft - if paused, get how much time is left once unpaused
--*///+9.8
	zim.interval = function(time, call, total, immediate, pauseOnBlur, timeUnit, complete, completeParams) {
		var sig = "time, call, total, immediate, pauseOnBlur, timeUnit, complete, completeParams";
		var duo; if (duo = zob(zim.interval, arguments, sig, this)) return duo;
		z_d("9.8");
		if (zot(call)) return;
		if (typeof call != 'function') return;

		var timeType = getTIME(time, timeUnit);
		if (zot(time)) time = timeType=="s"?1:1000;

		if (zot(immediate)) immediate = false;
		if (!zot(total) && (isNaN(total) || total<=0)) return;
		if (zot(total)) total = -1;
		var obj = {count:0, total:total, paused:false, time:time, active:true, timeUnit:timeUnit};

		if (pauseOnBlur) {
			if (zot(zim.blurCheck)) zim.setBlurDetect();
			zim.pauseOnBlur.push(obj);
		}
		function interval() {
			obj.startTime = Date.now();
			obj.interval = zim.Pick.choose(obj.time);
			obj.id = setTimeout(function() {
				if (obj.paused) return;
				if (!obj.active) return;
				// obj.rid = requestAnimationFrame(interval);
				obj.count++;
				(call)(obj);
				interval();
				checkTotal();
			}, obj.interval*(timeType=="s"?1000:1));
		}
		if (immediate) {
			setTimeout(function() {
				(call)(obj);
				checkTotal();
			}, 10);
		}
		function checkTotal() {
			if (total == -1) return;
			if (obj.count >= (immediate?obj.total-1:obj.total)) {
				if (complete && typeof complete=="function") complete(completeParams);
				obj.clear();
			}
		}
		var pausedTimeout;
		obj.type = "intervalObject";
		obj.pause = function(state, immediate, reset) {
			if (zot(state)) state = true;
			if (state) { // pausing
				clearTimeout(pausedTimeout);
				clearTimeout(obj.id);
				cancelAnimationFrame(obj.rid);
				obj.pauseTimeLeft = obj.interval-(Date.now()-obj.startTime)/(timeType=="s"?1000:1);
			} else { // unpausing
				if (!obj.paused) obj.pause(true);
				pausedTimeout = setTimeout(function() {
					obj.count++;
					(call)(obj);
					interval();
					checkTotal();
				}, immediate?0:(reset?obj.interval:obj.pauseTimeLeft)*(timeType=="s"?1000:1));
				obj.pauseTimeLeft = null;
			}
			obj.paused = state;
		};
		obj.next = function() {
			obj.count++;
			(call)(obj);
			checkTotal();
		};
		obj.clear = function() {
			obj.active = false;
			clearTimeout(pausedTimeout);
			cancelAnimationFrame(obj.rid);
			clearTimeout(obj.id);
			var count = obj.count;
			for (var i in obj) {
				delete obj[i];
			}
			obj.active = false;
			obj.count = count;
			obj.pause = function() {};
			obj.clear = function() {};
		};
		interval();
		return obj;
	};//-9.8

/*--
zim.async = function(url, callback, callbackString, maxTime, maxCancel)

async
zim function

DESCRIPTION
A way to send data back and forth to a server script without reloading the HTML page.
(like AJAX but without the bother)
Uses a dynamic script call with an optional callback (cross domain calls are okay)
also known as JSON-P pattern but JSON is unnecessary - note, no JSON in two of the examples below.
Pass a url to the server script (ie. php or node page)
and an optional callback function that you define in your code (cannot be an anonymous function).
async will automatically add a random number to the end of your script call to defeat cache.

NOTE: async uses GET so data is limited to GET length (as of ZIM 10 - this is 2K to 8K depending on Browser)
If more data is required, use an AJAX library

NOTE: async uses an r CGI key to send a random number to defeat cache.
Do not send an r property

SEE: https://codepen.io/danzen/pen/gNKQYY for a full example

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// existing JSONp service:
// assuming that we have a callback function called test as shown below
async("https://ip-api.com/json?callback=async.test",test);
function test(data) {zog(data.country);}
// note that the callback we pass the service is async.test not just test
// this allows zim to handle scope issues and garbage collect the dynamic script when done
END EXAMPLE

EXAMPLE
// existing JSON service:
// if the service just returns JSON - then pass through a JSONp wrapper:
const api = "https://zimjs.com/codepen/ranker.php"; // not JSONp - just JSON
async("https://zimjs.org/cdn/jsonp.php?api="+api+"&callback=async.getData", getData);
function getData(data) {
	zog(data); // data will be the JSON parsed object
}
// Here is the jsonp.php code if you would like to host:

<?php
$api = $_GET["api"];
if (!preg_match('/^http/i', $api)) exit;
$callback = $_GET["callback"];
header('Content-Type: application/javascript');
$data = file_get_contents($api);
echo $callback."(".$data.")";
?>
END EXAMPLE

EXAMPLE
// CLIENT - your own server script:
// assuming we have a callback function called myFunction as shown below
async("https://yourserver.com/script.php?id=72&name=dan", myFunction);
function myFunction(data){
	zog(data.test); // wow - assuming you have the PHP file below (JSON is automatically parsed)
	zog(data.score[1]); // 2	
}

// SERVER - your script must output the following format as a string:
// "async.myFunction(somedata)"

// in the php file we would use the following to return JSON:
<?php
header('Content-type: text/javascript');
$data = [test=>"wow", score=>[1,2,3]];
echo "async.myFunction(".JSON_encode($data).")";
?>

// or to just echo a string:
<?php
header('Content-type: text/javascript');
echo "async.myFunction('success')"; // your data parameter in myFunction would be "success"
?>

// to return an object literal with nodejs express for example, you would use:
res.send('async.myFunction({list:[1,2,3], name:"whatever"})');
// the data parameter in the myFunction function defined earlier would be an object literal
// we could then do zog(data.list[0]) to log the value 1, etc.
END EXAMPLE

PARAMETERS
url - url to the server script (ie. php or node page)
	Note: async uses an r CGI key to send a random number to defeat cache - do not send an r property
callback - (default null) callback function that you define in your code (cannot be an anonymous function)
callbackString - (default null) a string name matching the function in case the file is minified
maxTime - (default 2 seconds) how long to wait for server response before triggering an error
	may still trigger callback if callback comes later unless maxCancel is set to true
	see also ZIM TIME constant
	If maxTime is up without calling back the function
	async will return two arguments to the callback function:
	"asyncError" and either "timeout" or "cancelled"
maxCancel - (default false) set to true to have maxTime cancel a late callback response

calling the return function on async does two things:
1. it handles scope issues so we can find your callback function
2. it handles garbage collection to remove the dynamic script tag that was used
if you do not specify a callback function then just send "" back from your server script
NOTE: we have experienced duplicate script calls if nothing is sent back
NOTE: if more than one async() with the same named call function is run at the same time
	then a queue of callbacks is created
	if the data comes back in a different order, the wrong call could be called
	if there is danger of this happening (rare) then use ZIM Ajax

RETURNS undefined
--*///+29
	zim.async = function (url, callback, callbackString, maxTime, maxCancel) {
		z_d("29");
		if (zot(url)) return;
		var tag = document.createElement("script");

		var timeType = getTIME(maxTime);
		if (zot(maxTime)) maxTime = timeType=="s"?2:2000;

		var n;
		if (callback) {

			if (callbackString) n = callbackString;
			else n = callback.toString().split(/\n/,1)[0].match(/^function\s?([^\s(]*)/)[1];

			// create a queue if more than one async() to same callback function name
			// if data is not returned in same order made, the wrong callbacks may be called
			if (!zim.asyncList) zim.asyncList = {};
			if (!zim.asyncList[n]) zim.asyncList[n] = [];
			zim.asyncList[n].push(callback);

			// create callback bridge on async function object
			zim.async[n] = function() { // closure to access tag on callback bridge
				var t = tag;
//				var name = n;
				var cancelMe = false;
				var errorID = setTimeout(function(){
					cancelMe = maxCancel;
					if (typeof callback == "function") callback("asyncError", maxCancel?"cancelled":"timeout");
				}, maxTime*(timeType=="s"?1000:1));
				return function(d){
					clearTimeout(errorID);
					if (zim.asyncList[n]) callback = zim.asyncList[n].shift();
					if (typeof callback == "function" && !cancelMe) callback(d);
					// remove the script tag
					if (t) t.parentNode.removeChild(t); t = null;
				};
			}();
		} else {
			if (zim.async.z_s && zim.async.z_s.parentNode) zim.async.z_s.parentNode.removeChild(zim.async.z_s); // keep overwriting same script tag if no callback
			zim.async.z_s = tag;
		}
		if (!url.match(/\?/)) url += "?";
		tag.setAttribute("src", url + "&r="+Math.random());
		document.getElementsByTagName("head")[0].appendChild(tag);
	};//-29

//
/*--
zim.couple = function(json)

couple
zim function

DESCRIPTION
Turns a nested JSON object into a single layer JSON object
The object will have _ between the id and the property name
eg. {"circle":{"x":"10", "y":"20"},"count":{"currentValue":"0"}}
is: {"circle_x":"10", "circle_y":"20", "count_currentValue":"0"}
This allows data to be JSON decoded on the server
and put more directly into table fields of the database

See also ZIM decouple()

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// note the two levels of nesting - this is the format of ZIM Bind data for instance
const test = JSON.stringify({circle:{x:10, y:20},count:{currentValue:0}});
zog(couple(test)); // {"circle_x":"10", "circle_y":"20", "count_currentValue":"0"}
END EXAMPLE

PARAMETERS
json - a JSON string in the nested form of:
{"obj1":{"prop1":"val", "prop2":"val"},"obj2":{"prop3":"val"}}

RETURNS a JSON string with one less level of objects in form of:
{"obj1_prop1":"val", "obj1_prop2":"val", "obj2_prop3":"val"}
--*///+29.2
	zim.couple = function (json) {
		z_d("29.2");
		if (!zim.isJSON(json)) return json;
		var obj = JSON.parse(json);
		var obj2 = {};
		for (var i in obj) {
			var o = obj[i];
			for (var j in o) {
				obj2[i+"_"+j] = o[j];
			}
		}
		return JSON.stringify(obj2);
	};//-29.2

/*--
zim.decouple = function(json)

decouple
zim function

DESCRIPTION
Turns a flat coupled JSON object into a nested layer JSON object
The object will remove _ from between the id and the property name
eg. {"circle_x":"10", "circle_y":"20", "count_currentValue":"0"}
is: {"circle":{"x":"10", "y":"20"},"count":{"currentValue":"0"}}
This allows data from table fields of the database
to be more easily dealt with as objects with their own properties

See also ZIM couple()

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// note the two levels of nesting - this is the format of ZIM Bind data for instance
const test = {circle:{x:10, y:20},count:{currentValue:0}};
const test2 = JSON.stringify(test);
const test3 = couple(test);
// {"circle_x":"10", "circle_y":"20", "count_currentValue":"0"}
// send this to server to store in fields

// receive back similar coupled data from fields
// decouple the data:
const test4 = decouple(test3);
// {"circle":{"x":"10", "y":"20"},"count":{"currentValue":"0"}}
const test5 = JSON.parse(test4); // similar object to test!
// {circle:{x:10, y:20},count:{currentValue:0}};
END EXAMPLE

PARAMETERS
json - a JSON string in the coupled form of
{"obj1_prop1":"val", "obj1_prop2":"val", "obj2_prop3":"val"}

RETURNS a JSON string with one less level of objects in the form of:
{"obj1":{"prop1":"val", "prop2":"val"},"obj2":{"prop3":"val"}}
the original JSON string will be returned if the initial JSON string is not coupled
--*///+29.3
	zim.decouple = function (json) {
		z_d("29.3");
		if (!zim.isJSON(json)) return json;
		var obj = JSON.parse(json);
		var obj2 = {};
		for (var i in obj) {
			var n = i.split("_", 2);
			if (n.length != 2) return json;
			if (!obj2[n[0]]) obj2[n[0]] = {};
			obj2[n[0]][n[1]] = obj[i];
		}
		return JSON.stringify(obj2);
	};//-29.3

/*--
zim.convertColor = function(color, toColorType, alpha)

convertColor
zim function

DESCRIPTION
Converts color to HEX - for example: "#333333"
Converts color to HEX NUMBER - for example: 0x333333
Or converts color to HTML string - for example: "red"
Or converts color to RGB - for example: "rgb(0,0,0)"
Or converts color to RGBA - for example: "rgba(0,0,0,.5)"
Or converts color to hsl array - for example: [degrees, percent, percent]

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
let color;
color = convertColor("red"); // result is "#ff0000"
color = convertColor("rgb(255,0,0)")); // result is "#ff0000"
color = convertColor("rgb(0,0,255)", "string"); // result is "blue"
color = convertColor("rgb(0,0,20)", "string"); // result is "#000014" - no matching string color
color = convertColor("#ff0000", "string"); // result is "red"
color = convertColor("f00", "string"); // result is "red" - note missing # okay and can use three digits
color = convertColor(blue, "rgba", .5); // result is "rgba(80,196,183,0.5)"
color = convertColor("rgb(256,256,0)", "rgba", .3); // result is "rgba(256,256,0,.3)"
color = convertColor("rgba(0,0,0,.2)", "rgba", .5); // result is "rgba(0,0,0,.5)"
color = convertColor("rgba(0,0,0,.2)", "hex", .5); // result adds alpha to hex "#00000080"
color = convertColor("red", "hexNumber"); // result is 0xff0000
color = convertColor("rgba(0,0,0,.2)", "array"); // result is [0,0,0,.2]
color = convertColor(blue, "hsl"); // result is [173.28,49.57,54.12] // first is angle then two percentages
color = convertColor(0x00FF00); // result is "#00FF00";
END EXAMPLE

PARAMETERS
color - (default black) the HTML string or HEX color (case insensitive) or HEX number starting with 0x
	HEX can be a # followed by 6, 3, 8 or 4 characters (3 or 4 characters will be duplicated to 6 or 8)
toColorType - (default "hex") or use "string", "rgb", "rgba", "array", "hsl" (different than "hsv") "zim", "hexNumber"
	if "string" and color does not match existing HTML string color
	then will return HEX number as string
	zim will convert zim rgb to zim string like "blue"
	hexNumber is the color.parseInt(16) - similar to 0x format
	array will give [r,g,b,a] as array
	hsl will give [degree, percent, percent] - note, hsv and hsl are similar but only the hue is the same
alpha - (default 1) the alpha used for the "rgba" and "hex" toColorType
	for hex color type, the hex number is an 8 character result (after the #)

RETURNS a String with the converted color
--*///+27.5
	zim.convertColor = function(color, toColorType, alpha) {
		if (!zim.convertColorCheck) {z_d("27.5"); zim.convertColorCheck=true;}
		if (zot(toColorType)) toColorType = "hex";
		color = zik(color);
        if (typeof color == "number") color = "#" + color.toString(16);
		if (zot(color) || !color.toLowerCase) return;        
		color = color.toLowerCase();
		toColorType = toColorType.toLowerCase();
		var colors = ['black','aliceblue','antiquewhite','aqua','aquamarine','azure','beige','bisque','blanchedalmond','blue','blueviolet','brown','burlywood','cadetblue','chartreuse','chocolate','coral','cornflowerblue','cornsilk','crimson','cyan','darkblue','darkcyan','darkgoldenrod','darkgray','darkgrey','darkgreen','darkkhaki','darkmagenta','darkolivegreen','darkorange','darkorchid','darkred','darksalmon','darkseagreen','darkslateblue','darkslategray','darkslategrey','darkturquoise','darkviolet','deeppink','deepskyblue','dimgray','dimgrey','dodgerblue','firebrick','floralwhite','forestgreen','fuchsia','gainsboro','ghostwhite','gold','goldenrod','gray','grey','green','greenyellow','honeydew','hotpink','indianred','indigo','ivory','khaki','lavender','lavenderblush','lawngreen','lemonchiffon','lightblue','lightcoral','lightcyan','lightgoldenrodyellow','lightgray','lightgrey','lightgreen','lightpink','lightsalmon','lightseagreen','lightskyblue','lightslategray','lightslategrey','lightsteelblue','lightyellow','lime','limegreen','linen','magenta','maroon','mediumaquamarine','mediumblue','mediumorchid','mediumpurple','mediumseagreen','mediumslateblue','mediumspringgreen','mediumturquoise','mediumvioletred','midnightblue','mintcream','mistyrose','moccasin','navajowhite','navy','oldlace','olive','olivedrab','orange','orangered','orchid','palegoldenrod','palegreen','paleturquoise','palevioletred','papayawhip','peachpuff','peru','pink','plum','powderblue','purple','rebeccapurple','red','rosybrown','royalblue','saddlebrown','salmon','sandybrown','seagreen','seashell','sienna','silver','skyblue','slateblue','slategray','slategrey','snow','springgreen','steelblue','tan','teal','thistle','tomato','turquoise','violet','wheat','white','whitesmoke','yellow','yellowgreen'];
		var hex = ['000000','f0f8ff','faebd7','00ffff','7fffd4','f0ffff','f5f5dc','ffe4c4','ffebcd','0000ff','8a2be2','a52a2a','deb887','5f9ea0','7fff00','d2691e','ff7f50','6495ed','fff8dc','dc143c','00ffff','00008b','008b8b','b8860b','a9a9a9','a9a9a9','006400','bdb76b','8b008b','556b2f','ff8c00','9932cc','8b0000','e9967a','8fbc8f','483d8b','2f4f4f','2f4f4f','00ced1','9400d3','ff1493','00bfff','696969','696969','1e90ff','b22222','fffaf0','228b22','ff00ff','dcdcdc','f8f8ff','ffd700','daa520','808080','808080','008000','adff2f','f0fff0','ff69b4','cd5c5c','4b0082','fffff0','f0e68c','e6e6fa','fff0f5','7cfc00','fffacd','add8e6','f08080','e0ffff','fafad2','d3d3d3','d3d3d3','90ee90','ffb6c1','ffa07a','20b2aa','87cefa','778899','778899','b0c4de','ffffe0','00ff00','32cd32','faf0e6','ff00ff','800000','66cdaa','0000cd','ba55d3','9370db','3cb371','7b68ee','00fa9a','48d1cc','c71585','191970','f5fffa','ffe4e1','ffe4b5','ffdead','000080','fdf5e6','808000','6b8e23','ffa500','ff4500','da70d6','eee8aa','98fb98','afeeee','db7093','ffefd5','ffdab9','cd853f','ffc0cb','dda0dd','b0e0e6','800080','663399','ff0000','bc8f8f','4169e1','8b4513','fa8072','f4a460','2e8b57','fff5ee','a0522d','c0c0c0','87ceeb','6a5acd','708090','708090','fffafa','00ff7f','4682b4','d2b48c','008080','d8bfd8','ff6347','40e0d0','ee82ee','f5deb3','ffffff','f5f5f5','ffff00','9acd32'];

		if (toColorType == "zim") {
			var i = zim.colorsHex.indexOf(color);
			if (i<0) return color;
			return zim.colors[zim.colorsHex.indexOf(color)];
		}		
		if (toColorType == "hsv") toColorType == "hsl";
				
		var answer;
		var c;
		if (answer = color.match(/rgba\((.*)\)/)) {	
			c = answer[1].split(",");
			var a = c.pop(); // take off alpha
			if (zot(alpha)) alpha = a; // use alpha otherwise parameter overrides
			if (toColorType=="array") {
				c.push(a);
				return c;
			}				
			color = "rgb("+c.join(",")+")";			
			if (toColorType=="rgb") return color;	
			if (toColorType == "hsl") {
				return rgbToHsl(c[0], c[1], c[2]);
			}	
		}
		
			
		function rgbToHex(rgb) {
			var hex = Number(rgb).toString(16);
			if (hex.length < 2) {
				hex = "0" + hex;
			}
			return hex;
		}
		
		// https://gist.github.com/mjackson/5311256 comment by gntlechaos
		function mapMinMax(value,oldMin,oldMax,newMin, newMax) {
			return  (newMax-newMin)*(value-oldMin)/(oldMax-oldMin)+newMin;
		}		
		function rgbToHsl(r, g, b) {
			r /= 255;
			g /= 255;
			b /= 255;
			const l = Math.max(r, g, b);
			const s = l - Math.min(r, g, b);
			const h = s
				? l === r
				? (g - b) / s
				: l === g
				? 2 + (b - r) / s
				: 4 + (r - g) / s
				: 0;
			return [
				60 * h < 0 ? 60 * h + 360 : 60 * h,
				100 * (s ? (l <= 0.5 ? s / (2 * l - s) : s / (2 - (2 * l - s))) : 0),
				(100 * (2 * l - s)) / 2
			];
		}

		function getRGB(string) {
			var c = string.split(",");
			var red = rgbToHex(c[0]);
			var green = rgbToHex(c[1]);
			var blue = rgbToHex(c[2]);
			var alpha = zot(alpha)?"":rgbToHex(Math.round(Number(c[3])*255));
			return [red, green, blue, alpha];
		}	

		if (zot(alpha)) alpha = 1;
		var added;
		var co;
		var index;
		if (answer = color.match(/rgb\((.*)\)/)) {
			if (toColorType == "rgba") {
				return "rgba("+answer[1]+","+alpha+")";
			} else if (toColorType == "hex") {	
				added = alpha != 1?","+alpha:"";
				co = getRGB(answer[1]+added);
				return "#" + co[0] + co[1] + co[2] + co[3];
			} else if (toColorType == "hexnumber") {
				added = alpha != 1?","+alpha:0;
				co = getRGB(answer[1]+added);
				return parseInt(co[0]+""+co[1]+""+co[2], 16);
			} else if (toColorType == "string") {
				color = getRGB(answer[1]).join("").toLowerCase();
				index = hex.indexOf(color);
				if (index == -1) return "#" + color;
				else return colors[index];
			} else if (toColorType == "array") {
				added = alpha != 1?","+alpha:0;
				return getRGB(answer[1]+added);
			} else if (toColorType == "hsl") {
				c = answer[1].split(",");
				return rgbToHsl(c[0], c[1], c[2]);
			} else return color;
		}

		function hexToRgbA(hex){ // kennebec on StackOverflow
			var c;
			if(/^#([A-Fa-f0-9]{3}){1,2}$/.test(hex)){
				c= hex.substring(1).split('');
				if(c.length== 3){
					c= [c[0], c[0], c[1], c[1], c[2], c[2]];
				}
				c= '0x'+c.join('');
				if (toColorType == "rgb") {
					return 'rgb('+[(c>>16)&255, (c>>8)&255, c&255]+')';
				} else {
					if (toColorType=="array") return [(c>>16)&255, (c>>8)&255, c&255, alpha];
					return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')';
				}
				
			} else if(/^#([A-Fa-f0-9]{4}){1,2}$/.test(hex)){ // 8 or 4 digit hex color
				c= hex.substring(1).split('');
				if (c.length==8) {
					alpha = c.slice(-2).join("");					
					c = c.slice(0,6);
				}
				if(c.length== 4){
					alpha = c[3]+""+c[3];
					c= [c[0], c[0], c[1], c[1], c[2], c[2]];
				}
				alpha = parseInt(alpha,16)/255;	
				
				c= '0x'+c.join('');
				if (toColorType == "rgb") {
					return 'rgb('+[(c>>16)&255, (c>>8)&255, c&255]+')';
				} else {
					return 'rgba('+[(c>>16)&255, (c>>8)&255, c&255].join(',')+','+alpha+')';
				}
			} else {
				if (toColorType == "rgb") {
					return "rgb(0,0,0)";
				} else {
					return "rgba(0,0,0,1)";
				}
			}
		}	
		
		if (toColorType == "hsl") {
			return zim.convertColor(zim.convertColor(color,"rgb"), "hsl");
		}
		
		if (toColorType== "array" || toColorType == "rgb" || toColorType == "rgba") {						
			if (color.charAt(0)=="#") {
				return hexToRgbA(color);
			} else {
				return hexToRgbA(zim.convertColor(color));
			}
		} else if (toColorType == "hex") {
			if (color.charAt(0)=="#") {
				if (alpha!=1) {
					added = rgbToHex(Math.round(alpha*255));
					if (color.length==4 || color.length==5) {
						var vals = color.split("");
						vals[1]=vals[1]+""+vals[1];
						vals[2]=vals[2]+""+vals[2];
						vals[3]=vals[3]+""+vals[3];
						vals[4]=added;
						return vals.join("");
					} else {
						if (color.length==9) {
							return color.substring(0,colors.length-2)+added;
						} else return color + added;
					}					
				} else return color; // already hex
			}
		} else if (toColorType == "hexnumber") {
			if (color.charAt(0)=="#") {
				return parseInt(color.replace(/^#/, ''), 16);
			}	
		} else {
			if (color.charAt(0)=="#") {
				color = color.replace("#","");
				if (color.length == 3) {
					color = color.charAt(0)+color.charAt(0)+color.charAt(1)+color.charAt(1)+color.charAt(2)+color.charAt(2);
				}
			}
		}
		if (toColorType == "string") {
			index = hex.indexOf(color);
		if (index == -1) return "#" + color;
			else return colors[index];
		} else if (toColorType == "hexnumber") {
			return parseInt(hex[colors.indexOf(color.toLowerCase())!=-1?colors.indexOf(color):0], 16);
		} else {	
			added = (alpha!=1)?rgbToHex(Math.round(alpha*255)):"";
			return "#"+hex[colors.indexOf(color.toLowerCase())!=-1?colors.indexOf(color):0]+added;
		}
	};//-27.5

/*--
zim.colorRange = function(color1, color2, ratio)

colorRange
zim function

DESCRIPTION
Gets the color in a range between two colors based on a ratio from 0-1
Used internally by setColorRange() method and colorRange property of ZIM shapes
including animating color from current color to a new color

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
zog(colorRange(green, blue, .5)); // #7ecb7c
const rect = new Rectangle(100,100,red).center().setColorRange(purple);
rect.colorRange = .1; // will change color to #f1455e (closer to red than purple)
rect.animate({color:purple}, 1); // will animate color to purple in one second
rect.wiggle("colorRange", .5, .2, .5, 1, 5); // wiggles the color in the range
END EXAMPLE

PARAMETERS
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
	Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
color1 - |ZIM VEE| (default null) the first color as an HTML string or hex color (case insensitive)
color2 - |ZIM VEE| (default black) the second color as an HTML string or hex color (case insensitive)
ratio - (default .5) the ratio where 0 is the first color and 1 the second color

RETURNS a hex color string
--*///+27.6
	zim.colorRange = function(color1, color2, ratio) {
		if (!zim.colorRangeCheck) {z_d("27.6"); zim.colorRangeCheck=true;}
		// thanks Chris Dolphin - StackOverflow
		// modified by Dan Zen to use hex input and output
		// possibly converting and converting back - but not quite...
		if (zot(ratio)) ratio = .5;
		ratio = Math.max(0, Math.min(1, ratio));
		if (zot(color1)) color1 = "white";
		if (zot(color2)) color2 = "black";
		color1 = zik(color1);
		color2 = zik(color2);
		var color1O = color1;
		var color2O = color2;
		var c1 = zim.convertColor(color1, "rgb");
		var c2 = zim.convertColor(color2, "rgb");		
		color1 = c1.substring(4, c1.length - 1).split(',');
		color2 = c2.substring(4, c2.length - 1).split(',');
		var difference;
		var newColor = "#";
		var c;
		if (ratio==0) {
			newColor = color1O;
		} else if (ratio==1) {
			newColor = color2O;
		} else {
			for (var i=0; i<color1.length; i++) {
				difference = color2[i] - color1[i];
				c = Math.floor(parseInt(color1[i], 10) + difference * ratio).toString(16);
				if (c.length < 2) c = "0"+c;
				newColor += c;
			}
		}
		return newColor;
	};//-27.6

/*--
zim.lighten = function(color, ratio)

lighten
zim function

DESCRIPTION
Lightens the color by a ratio from 0 to 1
A shortcut for ZIM colorRange(color, white, ratio);
A shortcut method is also added to the JavaScript String
for instance:
	red.lighten(.2); // lightens ZIM red color
	"red".lighten(.2); // lightens HTML red color
	"#cc0000".lighten(.2); // lightens HTML Hex color

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a slightly lighter than ZIM blue circle
new Circle(100, lighten(blue, .2)).center();

// or use the String method directly
new Circle(100, blue.lighten(.2)).center();
END EXAMPLE

PARAMETERS
color - the color as an HTML string or hex color (case insensitive)
	can be ZIM colors as they are just references to hex colors
	not used with color String method
ratio - (default .5) the ratio where 0 is the color and 1 white

RETURNS a hex color string
--*///+27.65
	zim.lighten = function(color, ratio) {
		if (!zim.lightenCheck) {z_d("27.65"); zim.lightenCheck=true;}
		if (zot(ratio)) ratio = .5;
		if (ratio >= 0) return zim.colorRange(String(color), "#FFFFFF", ratio);
		else return zim.colorRange(String(color), "#000000", -ratio);
	};//-27.65


/*--
zim.darken = function(color, ratio)

darken
zim function

DESCRIPTION
Darkens the color by a ratio from 0 to 1
A shortcut for ZIM colorRange(color, black, ratio);
A shortcut method is also added to the JavaScript String
for instance:
	red.darken(.2); // darkens ZIM red color
	"red".darken(.2); // darkens HTML red color
	"#cc0000".darken(.2); // darkens HTML Hex color

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a slightly darker than ZIM blue circle
new Circle(100, darken(blue, .2)).center();

// or use the String method directly
new Circle(100, blue.darken(.2)).center();
END EXAMPLE

PARAMETERS
color - the color as an HTML string or hex color (case insensitive)
	can be ZIM colors as they are just references to hex colors
	not used with color String method
ratio - (default .5) the ratio where 0 is the color and 1 black

RETURNS a hex color string
--*///+27.66
	zim.darken = function(color, ratio) {
		if (zot(ratio)) ratio = .5;
		if (!zim.darkenCheck) {z_d("27.66"); zim.darkenCheck=true;}
		if (ratio >= 0) return zim.colorRange(String(color), "#000000", ratio);
		else return zim.colorRange(String(color), "#ffffff", -ratio);
	};//-27.66

/*--
zim.toColor = function(color, targetColor, ratio)

toColor
zim function

DESCRIPTION
toColor the color by a ratio from 0 to 1
A shortcut for ZIM colorRange(color, white, ratio);
A shortcut method is also added to the JavaScript String
for instance:
	red.toColor(blue, .2); // moves ZIM red color towards ZIM blue color
	"red".toColor("blue", .2); // moves HTML red color towards HTML blue color
	"#cc0000".toColor("#0000cc", .2); // moves HTML Hex red color towards HTML Hex blue color

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a ZIM blue circle be partway to ZIM pink
new Circle(100, toColor(blue, pink, .2)).center();

// or use the String method directly
new Circle(100, blue.toColor(pink, .2)).center();
END EXAMPLE

PARAMETERS
color - the color as an HTML string or hex color (case insensitive)
	can be ZIM colors as they are just references to hex colors
	not used with toColor String method
targetColor - the target color as an HTML string or hex color (case insensitive)
	can be ZIM colors as they are just references to hex colors
ratio - (default .5) the ratio where 0 is the color and 1 targetColor

RETURNS a hex color string
--*///+27.67
	zim.toColor = function(color, targetColor, ratio) {
		if (!zim.toColorCheck) {z_d("27.67"); zim.toColorCheck=true;}
		if (zot(ratio)) ratio = .5;
		return zim.colorRange(String(color), targetColor, ratio);
	};//-27.67

/*--
zim.toAlpha = function(color, alpha)

toAlpha
zim function

DESCRIPTION
Set the alpha of a the color by a ratio from 0 to 1
A shortcut for ZIM convertColor(color, "rgba", ratio);
A shortcut method is also added to the JavaScript String
for instance:
	red.toAlpha(.2); // sets ZIM red color to .2 alpha
	"red".toAlpha(.2); // sets HTML red color to .2 alpha
	"#cc0000".toAlpha(.2); // sets HTML Hex red color to .2 alpha

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a ZIM blue circle be partway to ZIM pink
new Label({text:"HELLO", backgroundColor:blue.toAlpha(.5)}).pos(0,50,CENTER,BOTTOM);
END EXAMPLE

PARAMETERS
color - the color as an HTML string or hex color (case insensitive)
	can be ZIM colors as they are just references to hex colors
	not used with toAlpha String method
ratio - (default .5) the ratio where 0 is the color and 1 targetColor

RETURNS a hex color string
--*///+27.68
	zim.toAlpha = function(color, ratio) {
		if (!zim.toAlphaCheck) {z_d("27.68"); zim.toAlphaCheck=true;}
		if (zot(ratio)) ratio = .5;
		return zim.convertColor(String(color), "rgba", ratio);
	};//-27.68
	
/*--
zim.toBW = function(hex)

toBW
zim function

DESCRIPTION
Returns either black or white depending on which will have better contrast on the provided hex color 
If the color is not hex then use ZIM convertColor() first.
Thanks - Mark Ransom on GitHub

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const invertedColor = invertColor(red);
const swatch = new Rectangle(300, 200, invertedColor).center();
new Label(invertedColor, 50, null, toBW(invertedColor)).center(swatch);
// the toBW() chooses black or white which ever will have highest contrast on color
END EXAMPLE

PARAMETERS
color - a hex color - use ZIM convertColor() if not a hex color

RETURNS either "#000000" or "#ffffff" depending on which has more contrast against the provided color 
--*///+27.84
	zim.toBW = function(hex) {
		if (hex.indexOf('#') === 0) {
			hex = hex.slice(1);
		}
		// convert 3-digit hex to 6-digits.
		if (hex.length === 3) {
			hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
		}
		if (hex.length !== 6) {
			zogy("ZIM toBW() - needs hex input")
			return hex;	
		}
		var r = parseInt(hex.slice(0, 2), 16),
		g = parseInt(hex.slice(2, 4), 16),
		b = parseInt(hex.slice(4, 6), 16);
		
		return (r * 0.299 + g * 0.587 + b * 0.114) > 186
		? '#000000'
		: '#FFFFFF';
	};//-27.84
	
/*--
zim.invertColor = function(hex)

invertColor
zim function

DESCRIPTION
Inverts a color (converts to RGB and subtracts the color from black)
Used in ZIM "invert" theme.
Thanks - Onur Yildirim on GitHub

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const invertedColor = invertColor(red);
const swatch = new Rectangle(300, 200, invertedColor).center();
new Label(invertedColor, 50, null, toBW(invertedColor)).center(swatch);
// the toBW() chooses black or white which ever will have highest contrast on color
END EXAMPLE

PARAMETERS
color - a hex color - use ZIM convertColor() if not a hex color

RETURNS a hex color string of inverted color
--*///+27.86
	zim.invertColor = function(hex) {
		if (!zim.invertColorCheck) {z_d("27.86"); zim.invertColorCheck=true;}
		if (hex.indexOf('#') === 0) {
			hex = hex.slice(1);
		}
		// convert 3-digit hex to 6-digits.
		if (hex.length === 3) {
			hex = hex[0] + hex[0] + hex[1] + hex[1] + hex[2] + hex[2];
		}
		if (hex.length !== 6) {
			zogy("ZIM invertColor() - needs hex input")
			return hex;	
		}	
		var r = parseInt(hex.slice(0, 2), 16),
		g = parseInt(hex.slice(2, 4), 16),
		b = parseInt(hex.slice(4, 6), 16);
		// invert color components
		r = (255 - r).toString(16);
		g = (255 - g).toString(16);
		b = (255 - b).toString(16);
		// pad each with zeros and return
		function padZero(str, len) {
			len = len || 2;
			var zeros = new Array(len).join('0');
			return (zeros + str).slice(-len);
		}
		return "#" + padZero(r) + padZero(g) + padZero(b);
	};//-27.86
	
/*--
zim.zimEase = function(points, polynomials, convert, reverse, lockEnds)

zimEase
zim function

DESCRIPTION
Easing is used in animation usually to slow down or speed up as the animation starts or ends.
ZIM animate() has built in eases that handle the common types of easing - so look there first!
https://zimjs.com/docs.html?item=animate under the ease parameter.

The zimEase() function provides for custom easing beyond the built in eases and
returns an easing function to pass in to ZIM animate() - or CreateJS TweenJS 
The points to pass in to zimEase() can be created at https://zimjs.com/ease
At the top of the app there are default easing functions 
but just use the built in easing function for most of these such as "quadOut", etc.

SEE: https://zimjs.com/ease for the zimEase tool 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// go to https://zimjs.com/ease use the sliders and TEST the motion 
// then press SAVE and copy the zimEase() code into ZIM animate()
// this example makes very big forward, back, forward motion
new Circle().loc(200,200).animate({
	props:{x:400},
	ease:zimEase([2.5,-0.5,-1,1]),
	time:1.5
});
END EXAMPLE

EXAMPLE
// passing an array of two arrays will play the first for the first half 
// and the second for the second half 
// so here we pass an array of two arrays for a snapInOut effect
// this is cool so it is now a set of eases: "snapIn", "snapOut", "snapInOut" - cheers GreenSock!
new Circle().loc(200,200).animate({
	props:{x:400},
	ease:zimEase([[1.45,-0.57,0.67,0.55], [0.34,0.44,1.43,-0.31]]),
	// ease:"snapInOut", // or use the new ZIM ease
	time:2
});
END EXAMPLE

PARAMETERS
points - (default [.2,.4,.6,.8]) an array of 4 points to feed the equation - or an array of two arrays
	use the tool at https://zimjs.com/ease and press SAVE to get these
	the two ends are anchored at 0 and 1 and are the input to the quintic Bezier formula
	If an array of two arrays is provided the first array is used for the first half of the tween (In) 
	and the second array is used for the second half of the tween (Out)
polynomials - (default null) an array of 5 points that are the results of the quintic Bezier formula 
	linear would be [0,0,0,0,1] - use this if you are given the polynomials - who knows! 
	otherwise see points.
mirror - (default false) will duplicate the ease equation and reverse the second copy all within the provided time
reverse - (default false) reverses the ease equation (does not work with mirror)
lockEnds - (default true) this snaps the start and end to the real values - set to false to draw curve based on data, for instance.

PROPERTIES  
** The function result is an object that holds the easing equation in a noPick property 
** this allows it to bypass the dynamic setting of ZIM VEE ease parameter.
** Also in this object are the additional properties 
points - the array of points or the array of arrays of points 
polynomials - the array of final values or an array of arrays of final values

RETURNS an easing function for ZIM animate() or CreateJS TweenJS 
--*///+27.69
	zim.zimEase = function(points, polynomials, mirror, reverse, lockEnds) {
		z_d("27.69");
		// with thanks to Timothée Groleau and all before
		// https://www.timotheegroleau.com/Flash/experiments/easing_function_generator.htm
		var two = false;
		if (zot(lockEnds)) lockEnds=true;
		
		var c0,c1,c2,c3,c4,c5,e,d,c,b,a;
		var t,di,ts,tc,rF,obj;  
		
		var points2;
		if (points) {
			if (Array.isArray(points[1])) {
				two = true;
				points2 = points[1];
				points = points[0];
				var c0z = 0;
				var c1z = points2[0];
				var c2z = points2[1];
				var c3z = points2[2];
				var c4z = points2[3]; 
				var c5z = 1; 
				var ez = 5*(c1z - c0z);
				var dz = 10*(c2z - c0z) - 4*ez;
				var cz = 10*(c3z - c0z) + 30*(c1z - c2z);
				var bz = 5*(c4z + c0z) - 20*(c3z + c1z) + 30*c2z;
				var az = c5z - c0z - bz - cz - dz - ez; 
			}
			c0 = 0;
			c1 = points[0];
			c2 = points[1];
			c3 = points[2];
			c4 = points[3]; 
			c5 = 1;	
			e = 5*(c1 - c0);
			d = 10*(c2 - c0) - 4*e;
			c = 10*(c3 - c0) + 30*(c1 - c2);
			b = 5*(c4 + c0) - 20*(c3 + c1) + 30*c2;
			a = c5 - c0 - b - c - d - e;  
		} else if (polynomials) {
			a = polynomials[0];
			b = polynomials[1];
			c = polynomials[2];
			d = polynomials[3];
			e = polynomials[4];            
			// calculate points - for consistent points property
			c1 = e / 5;
			c2 = (d+4*e)/10;
			c3 = (c + 6*e + 3*d)/10;
			c4 = (b + 4*e + 3*d + 2*c)/5;			
		} else {
			a = 0;
			b = 0;
			c = 0;
			d = 0;
			e = 1;
		}     
		// return CreateJS ratio format with variables in enclosure
		// looks like a lot of code but the tween code is just the function in noPick 
		// so we are putting the conditionals outside this during the single assignment 
		// this keeps the tween function fast as that runs at the framerate
		
		if (mirror) {
			rF = function(){
				return zim.zimEase(null,[a,b,c,d,e],true) // mirror would be the same
			};
			obj = {
				reverse:rF,
				points:[c1,c2,c3,c4], 
				polynomials:[a,b,c,d,e]
			}
			obj.noPick = function(k) {				
				if (lockEnds) {	
					if (k<.025) return 0;
					if (k>.975) return 1;		
				}			
				if (k<.5) {	
					k*=2; // k needs to be 0-1 to get full tween			
					t = k*100;
					di = 100;
					ts=(t/=di)*t;
					tc=ts*t;        
					// the completeness is divided by 2 	
					return (a*tc*ts + b*ts*ts + c*tc + d*ts + e*t)/2;
				} else {
					k=1-(k-.5)*2; // we use the second half of k but spread it out from 0 to 1 for complete formula (reversed for mirror)
					t = k*100;
					di = 100;
					ts=(t/=di)*t;
					tc=ts*t;   
					// the completeness is added to the second half and still divided by 2 (1 - for mirror)     
					return 1-(a*tc*ts + b*ts*ts + c*tc + d*ts + e*t)/2;
				}			
			}					
		} else if (two) { 
			rF = function(){
				if (zon) zogy("zimEase - multi array points cannot be reversed");
				return zim.zimEase(null,[a,b,c,d,e]) 
			};
			obj = {
				reverse:rF,
				points:[[c1,c2,c3,c4],[c1z,c2z,c3z,c4z]], 
				polynomials:[[a,b,c,d,e],[az,bz,cz,dz,ez]]
			}
			obj.noPick = function(k) {	
				if (lockEnds) {	
					if (k<.025) return 0;
					if (k>.975) return 1;		
				}				
				if (k<.5) {	
					k*=2; // k needs to be 0-1 to get full tween			
					t = k*100;
					di = 100;
					ts=(t/=di)*t;
					tc=ts*t;        
					// the completeness is divided by 2      
					return (a*tc*ts + b*ts*ts + c*tc + d*ts + e*t)/2;
				} else {
					k=(k-.5)*2; // we use the second half of k but spread it out from 0 to 1 for complete formula
					t = k*100;
					di = 100;
					ts=(t/=di)*t;
					tc=ts*t;        
					// the completeness is added to the second half and still divided by 2      
					return .5+(az*tc*ts + bz*ts*ts + cz*tc + dz*ts + ez*t)/2;
				}
			}				 				
		} else {
			rF = function(){
				return zim.zimEase(null,[a,b,c,d,e],null,true)
			};			
			obj = {
				reverse:rF,
				points:[c1,c2,c3,c4], 
				polynomials:[a,b,c,d,e]
			}
			if (reverse) {			
				obj.noPick = function(k) {	
					if (lockEnds) {	
						if (k<.025) return 0;
						if (k>.975) return 1;		
					}				
					t = 100-k*100; // reverse the time
					di = 100;
					ts=(t/=di)*t;
					tc=ts*t;					   
					return 1-(a*tc*ts + b*ts*ts + c*tc + d*ts + e*t); // reverse the percent done			    
				} 	
			} else {
				obj.noPick = function(k) {
					if (lockEnds) {	
						if (k<.025) return 0;
						if (k>.975) return 1;		
					}	
					t = k*100;
					di = 100;
					ts=(t/=di)*t;
					tc=ts*t;					   
					return (a*tc*ts + b*ts*ts + c*tc + d*ts + e*t);				    
				} 	
			}
		}
		obj.noPick.reverse = rF; // for once it is picked...
		return obj;
		
	}//-27.69
	
/*--
zim.spline = function(points, tension, close, shape, removeLast)

spline
zim function

DESCRIPTION
Makes a curve along given points.
Pass in a ZIM Shape and spline will draw the curve. 
Or pass return value into a ZIM Squiggle or Blob as the points parameter 
for an interactive curve or path for animation.
For a Blob, set the close parameter to true.
Thanks https://github.com/georgedoescode

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const shape = new Shape().addTo().s(red).ss(3);
spline([[10,10],[50,20],[30,200],[230,100]], 1, true, shape);
END EXAMPLE

EXAMPLE
const points = spline([[10,10],[50,20],[30,200],[230,100]], 1, true);
new Blob({
	borderColor:purple, 
	borderWidth:2, 
	controlType:"mirror", // otherwise default is free 
	points:points
}).center();
END EXAMPLE

PARAMETERS
points - an array of {x,y} or [x,y] points to draw a curve through
tension - (default 1) the smoothness of the curve with 0 being angulars
close - (default false) set to true to close the curve
shape - (default null) pass in an optional shape to draw the curve in 
	must set the s(), ss() or f() before passing in the shape
removeLast - (default close) for ZIM Blob and Squiggle 
	this removes the duplicate last point 
	only for the return values - will not affect a shape version

RETURNS an SVG path that can be passed into Squiggle or Blob
--*///+27.695
zim.spline = function(points, tension, close, shape, removeLast) {
	z_d("27.695");
	if (zot(points)) points = [];
	if (zot(tension)) tension = 1;
	if (zot(close)) close = false;
	if (zot(removeLast)) removeLast = close;
	
	var i; 
	// Thanks https://github.com/georgedoescode
	function formatPoints(points, close) {		
		if (!Array.isArray(points[0])) {
			for (i=0; i<points.length; i++) {
				points[i] = [points[i].x, points[i].y];
			} 
		}    
		if (close) {
			var lastPoint = points[points.length - 1];
			var secondToLastPoint = points[points.length - 2];    
			var firstPoint = points[0];
			var secondPoint = points[1];    
			points.unshift(lastPoint);
			points.unshift(secondToLastPoint);    
			points.push(firstPoint);
			points.push(secondPoint);
		}    
		var p = [];
		for (i=0; i<points.length; i++) {
			p.push(points[i][0], points[i][1]);
		}       
		return p;
	}
	
	points = formatPoints(points, close);       

	var size = points.length;
	var last = size - 4;
	var startPointX = close ? points[2] : points[0];
	var startPointY = close ? points[3] : points[1];
	var path = "M" + [startPointX, startPointY];        
	if (shape) shape.mt(startPointX, startPointY);
	var startIteration = close ? 2 : 0;
	var maxIteration = close ? size - 4 : size - 2;
	var inc = 2;
	
	for (i = startIteration; i < maxIteration; i += inc) {
		var x0 = i ? points[i - 2] : points[0];
		var y0 = i ? points[i - 1] : points[1];
		var x1 = points[i + 0];
		var y1 = points[i + 1];
		var x2 = points[i + 2];
		var y2 = points[i + 3];
		var x3 = i !== last ? points[i + 4] : x2;
		var y3 = i !== last ? points[i + 5] : y2;
		var cp1x = x1 + ((x2 - x0) / 6) * tension;
		var cp1y = y1 + ((y2 - y0) / 6) * tension;
		var cp2x = x2 - ((x3 - x1) / 6) * tension;
		var cp2y = y2 - ((y3 - y1) / 6) * tension;
		path += "C" + [cp1x, cp1y, cp2x, cp2y, x2, y2];            
		if (shape) shape.bt(cp1x, cp1y, cp2x, cp2y, x2, y2);
	}
	
	if (removeLast) {
		var pp = path.split("C");
		pp.pop();
		path = pp.join("C");
	}

	return path;
};//-27.695


/*--
zim.getPointAtPercent = function(x1, y1, x2, y2, percent)

getPointAtPercent
zim function

DESCRIPTION
Gets a new Point along the straight line from x1,y1 to x2,y2 at a percentage of the length

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// A ZIM line() is not needed but here we place a circle 30% along the length of the line
const line = new Line(500).rot(45).center();
new Circle(20,red).loc(getPointAtPercent(line.startX, line.startY, line.endX, line.endY, 30));
END EXAMPLE

PARAMETERS
x1 - (default 0) - the start x of the line
y1 - (default 0) - the start y of the line
x2 - (default 0) - the end x of the line
y2 - (default 0) - the end y of the line
percent - (default 50) - the percentage along the line straight for the return point

RETURNS an ZIM Point() with x an y at the percentage along the straight line
--*///+27.697
zim.getPointAtPercent = function(x1, y1, x2, y2, percent) {
	z_d("27.697");
	if (zot(x1)) x1 = 0;
	if (zot(y1)) y1 = 0;
	if (zot(x2)) x2 = 0;
	if (zot(y2)) y2 = 0;
	if (zot(percent)) percent = 50;
	
	var d = dist(x1,y1,x2,y2)*percent/100;
	var a = angle(x1,y1,x2,y2);
	return new zim.Point(x1+d*Math.cos(a*zim.RAD), y1+d*Math.sin(a*zim.RAD));
};//-27.697


/*--
zim.pointAlongCurve = function(points, ratio, getAngle)

pointAlongCurve
zim function

DESCRIPTION
Finds a point along a cubic Bezier curve - such as that used in Blob and Squiggle
as well as the Shape.graphics.bezierCurveTo() or tiny api bt()
Used internally for animating along Blob and Bezier curves

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// point1, control1, control2, point2
const points = [{x:100,y:100}, {x:200,y:100}, {x:200,y:100}, {x:200,y:200}]
const shape = new Shape().addTo();
shape.graphics
	.s("black").ss(2)
	.mt(points[0].x,points[0].y)
	.bt(points[1].x,points[1].y, points[2].x,points[2].y, points[3].x,points[3].y);
new Circle(10,red).loc(pointAlongCurve(points, .2));
END EXAMPLE

PARAMETERS
points - an array of point objects (or objects with an x and y property)
	for a cubic Bezier - point1, control1, control2, point2
ratio - (default .5) the ratio where 0 is at the first point and 1 is at the second point
getAngle - (default false) request a calculated angle of tangent at point
even - (default false) use modified cubic equation for even spacing for percentages
	even is used by Beads but not by placing a point along a path

RETURNS a point object with x and y properties on the curve at the ratio
	as well as an angle property for the tangent if getAngle is true
--*///+27.7
zim.pointAlongCurve = function(points, ratio, getAngle, even) {
	z_d("27.7");
	if (!points || !points[0] || !points[1] || !points[2] || !points[3]) return;

	if (zot(even)) even = false;
	var cubic = new zim.Bezier(points[0],points[1],points[2],points[3]);
	var x,y,x0,y0,x2,y2;
	if (even) {
		x=cubic.mx(ratio);
		y=cubic.my(ratio);
	} else {
		x=cubic.x(ratio);
		y=cubic.y(ratio);
	}
	if (getAngle) {
		var lastRatio = ratio-.05;
		var nextRatio = ratio+.05;
		if (lastRatio < 0) lastRatio = 0;
		if (nextRatio > 1) nextRatio = 1;
		if (even) {
			x0=cubic.mx(lastRatio);
			y0=cubic.my(lastRatio);
			x2=cubic.mx(nextRatio);
			y2=cubic.my(nextRatio);
		} else {
			x0=cubic.x(lastRatio);
			y0=cubic.y(lastRatio);
			x2=cubic.x(nextRatio);
			y2=cubic.y(nextRatio);
		}
		var angle = zim.angle(x0, y0, x2, y2);
		return({x:x,y:y,angle:angle});
	}
	return({x:x,y:y});
};//-27.7

/*--
zim.distanceAlongCurve = function(points)

distanceAlongCurve
zim function

DESCRIPTION
Finds approximate distance along a cubic Bezier curve - such as that used in Blob and Squiggle
as well as the Shape.graphics.bezierCurveTo() or tiny api bt()
Used internally for animating along Blob and Bezier curves

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// point1, control1, control2, point2
const points = [{x:100,y:100}, {x:200,y:100}, {x:200,y:100}, {x:200,y:200}]
const shape = new Shape();
shape.graphics
	.s("black").ss(2)
	.mt(points[0].x,points[0].y)
	.bt(points[1].x,points[1].y, points[2].x,points[2].y, points[3].x,points[3].y);
zog(distanceAlongCurve(points)); // 170.7
END EXAMPLE

PARAMETERS
points - an array of point objects (or objects with an x and y property)
	for a cubic Bezier - point1, control1, control2, point2

RETURNS an approximate distance along the curve
--*///+27.8
	zim.distanceAlongCurve = function(points) {
		z_d("27.8");
		// Thanks David F. Knight in OpenGl.org forumn
		// points are [startPt, controlPt1, controlPt2, endPt]
		var chord = zim.dist(points[0], points[3]);
		var controlDist = zim.dist(points[0], points[1]) + zim.dist(points[1], points[2]) + zim.dist(points[2], points[3]);
		return (chord + controlDist)/2;
	};//-27.8

/*--
zim.closestPointAlongCurve = function(point, segmentPoints, num, interpolate, percentage)

closestPointAlongCurve
zim function

DESCRIPTION
Finds the closest point along a cubic Bezier curve before the given point.
Blob and Squiggle use cubic Bezier as does the Shape.graphics.bezierCurveTo() or tiny api bt()
Used internally for adding points to a Blob and Bezier curves

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const blob = new Blob().center();
const points = blob.segmentPoints;
S.on("stagemousedown", ()=>{
	const point = blob.globalToLocal(F.mouseX, F.mouseY)
	zog(closestPointAlongCurve({x:point.x, y:point.y}, points))
	// gives index of point on curve before mouse location
});
END EXAMPLE

PARAMETERS
point - an object with an x and y property
	this could be {x:100, y:140} or circle, etc.
	the results tell which segment to add the point to
	the segment starting with the returned index
segmentPoints - an array of cubic Bezier point data
	each being an array of points for a cubic Bezier
	in the format of [point1, control1, control2, point2]
	Note, this is not the same as Blob or Squiggle points
	but rather use the segmentPoints property of Blob and Squiggle
num - (default 10) the number of points per segment used to calculate answer
interpolate - (default false) will return closest test point - not index of closest existing point
percentage - (default false) will return percent (0-100) the nearest point is on the path (overrides interpolate)
RETURNS the index of the closest point in segmentPoints before the given point
	or if interpolate is true, will return the closest testPoint (use higher num for better result)
	or if percentage is true, will return percent (0-100) the nearest point is on the path (overrides interpolate)
--*///+27.9
	zim.closestPointAlongCurve = function(point, segmentPoints, num, interpolate, percentage) {
		z_d("27.9");
		var closest = 10000000;
		var closestTestPoint;
		var index = 0;
		var secondaryIndex = 0;
		if (zot(num)) num = 10;
		var totalD = 0;
		var totals = [];
		var lastDist=0;
		zim.loop(segmentPoints, function(points, i) {
			// add num more points to estimate closest
			var dist = zim.distanceAlongCurve(points);
			totalD += dist;	
			var cubic = new zim.Bezier(points[0],points[1],points[2],points[3]);
			zim.loop(num, function (j, total) {
				// var d = zim.dist(point, zim.pointAlongCurve(segmentPoints(that.points[i], that.points[i<t-1?i+1:0]), j/10));
				// var testPoint = zim.pointAlongCurve(points, j/total);
				// var d = zim.dist(point, testPoint);
				totals.push(lastDist+dist*j/total);
				// if (even) var testPoint = {x:cubic.mx(j/total), y:cubic.my(j/total)};
				var testPoint = {x:cubic.x(j/total), y:cubic.y(j/total)};				
				var d = zim.dist(point, testPoint);
				if (d < closest) {
					closest = d;
					closestTestPoint = testPoint;
					index = i;
					secondaryIndex = j;
				}
			});
			lastDist = totalD;
		});
		if (percentage) {
			return (totals[index*num+secondaryIndex]||0)/totalD*100;
			// return (index*num+secondaryIndex)/(segmentPoints.length*num)*100;
		} else if (interpolate) {
			return closestTestPoint;
		}
		return index;

	};//-27.9

/*--
zim.transformPoints = function(points, transformType, amount, x, y)

transformPoints
zim function

DESCRIPTION
Scales, rotates, or moves points about provided x and y - or 0, 0 if x and y are not provided
Used internally by Squiggle and Blob transformPoints method

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// from https://zimjs.com/paths/
const points = [[0,75,0,0,-150,150,150,-150],[300,75,0,0,0,0,0,0,"none"]];
const newPoints = transformPoints(points, "scale", 2);
// [[0,150,0,0,-300,300,300,-300],[600,150,0,0,0,0,0,0,"none"]]
END EXAMPLE

EXAMPLE
// or used with Squiggle:
const points = [[0,75,0,0,-150,150,150,-150],[300,75,0,0,0,0,0,0,"none"]];
const squiggle = new Squiggle({points:points}).transformPoints("scale", 2).center();
// a squiggle with points twice as big as before
END EXAMPLE

PARAMETERS
points - an array of points in the Squiggle and Blob format (controlType is left as is)
	[[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType], [etc]]
transformType - String any of: "scale", "scaleX", "scaleY", "rotation", "x", "y"
amount - the amount to transform
x, y - (default 0, 0) the x and y position to transform about

RETURNS an array of points with numbers transformed
--*///+27.95
	zim.transformPoints = function(points, transformType, amount, x, y) {
		z_d("27.95");
		if (zot(points) || !Array.isArray(points)) return;
		if (zot(x)) x = 0;
		if (zot(y)) y = 0;
		points = zim.copy(points);
		var xStart = x;
		var yStart = y;
		if (transformType == "rotation") {
			if (x != 0) points = zim.transformPoints(points, "x", -xStart);
			if (y != 0) points = zim.transformPoints(points, "y", -yStart);
		}
		var point;
		for (var i=0; i<points.length; i++) {
			point = points[i];
			if (!Array.isArray(point)) continue;
			// [[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType], [etc]]
			if (transformType == "x") {
				point[0] += amount;
			} else if (transformType == "y") {
				point[1] += amount;
			} else if (transformType == "scaleX") {
				point[0] = (point[0]-x)*amount+x;
				point[4] = (point[4])*amount;
				point[6] = (point[6])*amount;
			} else if (transformType == "scaleY") {
				point[1] = (point[1]-y)*amount+y;
				point[5] = (point[5])*amount;
				point[7] = (point[7])*amount;
			} else if (transformType == "scale") {
				point[0] = (point[0]-x)*amount+x;
				point[4] = (point[4])*amount;
				point[6] = (point[6])*amount;
				point[1] = (point[1]-y)*amount+y;
				point[5] = (point[5])*amount;
				point[7] = (point[7])*amount;
			} else if (transformType == "rotation") {
				var a = amount*Math.PI/180;
				var x1 = point[0];
				var y1 = point[1];
				point[0] = x1*Math.cos(a) - y1*Math.sin(a);
				point[1] = y1*Math.cos(a) + x1*Math.sin(a);

				x1 = point[4];
				y1 = point[5];
				point[4] = x1*Math.cos(a) - y1*Math.sin(a);
				point[5] = y1*Math.cos(a) + x1*Math.sin(a);

				x1 = point[6];
				y1 = point[7];
				point[6] = x1*Math.cos(a) - y1*Math.sin(a);
				point[7] = y1*Math.cos(a) + x1*Math.sin(a);
			}
		}
		if (transformType == "rotation") {
			if (x != 0) points = zim.transformPoints(points, "x", xStart);
			if (y != 0) points = zim.transformPoints(points, "y", yStart);
		}
		return points;
	};//-27.95
	
/*--
zim.trimEndPoints = function(points)

trimEndPoints
zim function

DESCRIPTION
Take outside Bezier rectangles off end points of Squiggle 
Modifies the points but then will have to make Squiggle from modified points  
Used internally, but might want to create a Squiggle from half the points or every other point
this function would make sure ends are clean.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const s = new Squiggle();
const p = copy(s.points).slice(1); // take off the first point
s.points = trimEndPoints(p);
s.center(); // a Squiggle with the first point gone
END EXAMPLE

PARAMETERS
points - an array of points in the Squiggle format

RETURNS an array of points with with the first point having no left control and the last point having no right control
--*///+27.97
	zim.trimPointEnds = function(points) {
		z_d("27.97");	
		points[0][4] = 0; // x
		points[0][5] = 0; // y
		points[0][8] = "free";                    
		points[points.length-1][6] = 0; // x
		points[points.length-1][7] = 0; // y
		points[points.length-1][8] = "free"; 
	};//-27.97

/*--
zim.reversePoints = function(points)

reversePoints
zim function

DESCRIPTION
Reverses Squiggle formatted points 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const s = new Squiggle();
const p = reversePoints(s.points);
const path = new Squiggle({points:p, interactive:false}).center();
new Circle(20,red).addTo().animate({path:path}, 10); // will go right to left
// also see reversePoints() on Squiggle and Blob
END EXAMPLE

PARAMETERS
points - an array of points in the Squiggle format to reverse

RETURNS an array of points that is in reverse order to the input points
--*///+27.975
	zim.reversePoints = function(points) {
		z_d("27.975");	
		points.reverse();
		zim.loop(points, function(p) {
			var p6 = p[6];					
			p[6] = p[4];
			p[4] = p6;
			var p7 = p[7];
			p[7] = p[5];
			p[5] = p7;
			// [point[6], point[7], point[4], point[5]] = [point[4], point[5], point[6], point[7]];                        
		});			
		return points;
	};//-27.975

/*--
zim.appendPoints = function(original, points, controlType)

appendPoints
zim function

DESCRIPTION
Adds a set of Squiggle points to after an original set of Squiggle points
The joining point is merged with the provided optional controlType
** appendPoints() expects the first point on points (the second parameter) 
to be at the last point of the original (the first parameter)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const s = new Squiggle(); // not added
// appendPoints expects the first point on points (the second parameter) 
// to be at the last point of the original (the first parameter)
const s2 = appendPoints(s.points, [s.points[s.points.length-1], [350,50]]); 
// an array with an extra points added at the end - the joining point is merged
new Squiggle({points:s2}).center();
END EXAMPLE

PARAMETERS
original - an array of points in the Squiggle format
points - an array of points in the Squiggle format to add to the end of the original
controlType - (default "straight") one of four String values as follows:
   none - there are no control rectangles (they are actually set at 0,0).  This makes a corner at the circle point.
   mirror - the control rectangles reflect one another about the point circle - lengths are kept even
   straight - the control rectangles keep a straight line through the point circle but length is independent
   free - the control rectangle moves independently from the other control rectangle

RETURNS the original array of points with the points added to the end
--*///+27.98
	zim.appendPoints = function(original, points, controlType) {		
		z_d("27.98");
		if (zot(original) && zot(points)) return [];
		if (zot(original)) return points;
		if (zot(points)) return original;
		original[original.length-1][6] = points[0][6];
		original[original.length-1][7] = points[0][7];
		if (controlType) original[original.length-1][8] = controlType;
		points.shift(); // remove the first point             
		original = original.concat(points);
		return original;		
	};//-27.98

/*--
zim.prependPoints = function(original, points, controlType)

prependPoints
zim function

DESCRIPTION
Adds a set of Squiggle points to before an original set of Squiggle points
The joining point is merged with the provided optional controlType
** prependPoints() expects the last point on points (the second parameter) 
to be at the first point of the original (the first parameter)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const s = new Squiggle(); // not added
// prependPoints expects the last point on points (the second parameter) 
// to be at the first point of the original (the first parameter)
const s2 = prependPoints(s.points, [[-50,50], s.points[0]]); 
// an array with an extra points added to the start - the joining point is merged
new Squiggle({points:s2}).center();
END EXAMPLE

PARAMETERS
original - an array of points in the Squiggle format
points - an array of points in the Squiggle format to add to the start of the original
controlType - (default "straight") one of four String values as follows:
   none - there are no control rectangles (they are actually set at 0,0).  This makes a corner at the circle point.
   mirror - the control rectangles reflect one another about the point circle - lengths are kept even
   straight - the control rectangles keep a straight line through the point circle but length is independent
   free - the control rectangle moves independently from the other control rectangle

RETURNS the original array of points with the points added to the beginning
--*///+27.985
	zim.prependPoints = function(original, points, controlType) {
		z_d("27.985");	
		if (zot(original) && zot(points)) return [];
		if (zot(original)) return points;
		if (zot(points)) return original;
		points[points.length-1][6] = original[0][6];
		points[points.length-1][7] = original[0][7];
		if (controlType) original[original.length-1][8] = controlType;
		original.shift(); // remove the old first point   
		original = points.concat(original);
		return original;
	};//-27.985

/*--
zim.splitPoints = function(points, index, trimEnds)

splitPoints
zim function

DESCRIPTION
Splits Squiggle points into two sets of Squiggle points 
Also used by Squiggle splitPoints() and Blob makeSquiggle()

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const s = new Squiggle();
const split = splitPoints(s.points, 2); // two arrays of three points each
// also see Squiggle.splitPoints(2) // which splits squiggle into two squiggles
END EXAMPLE

PARAMETERS
points - an array of points in the Squiggle format
index - (default floor of half points length) the index at which to split the points into two sets
	the first set gets the index 
trimEnds - (default false) take ending Bezier sticks off split ends

RETURNS an array if the first and second set of points
--*///+27.99
	zim.splitPoints = function(points, index, trimEnds) {
		z_d("27.99");	
		if (zot(points)) return;
		if (zot(index)) index = Math.floor(points.length/2);
		if (index < 0 || index > points.length-1) return;
		if (zot(trimEnds)) trimEnds = true;
		var first = zim.copy(points.slice(0,index+1));
		var second = zim.copy(points.slice(index));
		if (trimEnds) {
			zim.trimPointEnds(first);
			zim.trimPointEnds(second);
		}
		return [first, second];	
	};//-27.99	

/*--
zim.makeID = function(type, length, letterCase)

makeID
zim function

DESCRIPTION
makes a random letter, number or mixed id of specified length

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const id1 = makeID(); // five random letters and numbers (starts with letter)
const id2 = makeID("strings"); // five random uppercase letters
const id3 = makeID("numbers", 10); // ten random numbers
const id4 = makeID(["Z", "I", "M", 1, 2, 3, 4, 5, "-"], 5); // random five characters from array (possibly repeating)
END EXAMPLE

PARAMETERS
type - (default "mixed") set to "letters" or "numbers" as well
	note: no O, 0, 1, I or L due to identification problems
	pass in an array of characters to make an id from only those characters
length - (default 5) the length of the id
letterCase - (default uppercase) - set to "lowercase" or "mixed" as well

RETURNS a String id (even if type is number)
--*///+13.5
	zim.makeID = function(type, length, letterCase) {
		z_d("13.5");
		if (zot(type)) type = "mixed";
		if (zot(length)) length = 5;
		if (zot(letterCase)) letterCase = "uppercase";
		var choices;
		var nums = [2,3,4,5,6,7,8,9];
		var lets = "abcdefghjkmnpqrstuvwxyz".split("");
		if (type.constructor === Array) {
			choices = type;
		} else if (type == "numbers") {
			choices = nums;
		} else if (type == "letters") {
			choices = lets;
		} else {
			choices = nums.concat(lets);
		}
		var id = "";
		var c; // character - note, char is a reserved word for compressor!
		var rand;
		for (var i=0; i<length; i++) {
			c = choices[Math.floor(Math.random()*choices.length)];
			rand = Math.random();
			if (letterCase == "uppercase" || (letterCase == "mixed" && rand > .5)) {
				if (c.toUpperCase) c = c.toUpperCase();
			} else {
				if (c.toLowerCase) c = c.toLowerCase();
			}
			id += String(c);
		}
		return id;
	};//-13.5
	
/*--
zim.makeSyllable = function(length, firstVowel)

makeSyllable
zim function

DESCRIPTION
makes a syllable from random consonants and vowels in alternating order.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
zog(makeSyllable()); // "aru" or "bal", etc.  
END EXAMPLE

EXAMPLE
let word = "";
loop(3, ()=>{
	word += makeSyllable();
});
zog(word); // a three syllable word
END EXAMPLE

PARAMETERS
length - (default 3) the length of letters in the syllable
firstVowel - (default true 30%) set to true for the first letter being a vowel 
	set to consonant for a consonant - null will choose a vowel 30% of the time

RETURNS a String syllable of the length
--*///+13.55
	zim.makeSyllable = function(length, firstVowel) {
		z_d("13.55");
        var consonants = "bcdfghjklmnprstvwxz";
        var vowels = "aeiouaeiouaeiouy";
        if (zot(length)) length = 3;
        if (zot(firstVowel)) firstVowel = zim.rand()<.3;
        function getLetter(type) {
            var i = zim.rand(type.length-1);
            var letter = type.substring(i, i+1);
            return letter;            
        }
        var syllable = "";
        var currentType = firstVowel?vowels:consonants;
        zim.loop(length, function() {
            syllable += getLetter(currentType);
            currentType = currentType==vowels?consonants:vowels;
        });
        return syllable;       
	};//-13.55
	
/*--
zim.makePrimitive = function(obj)

makePrimitive
zim function

DESCRIPTION
Convert any new String(), new Number(), new Boolean() values to string, number and boolean primitives.
Recursively handles arrays and object literals.  All other objects left the same. 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
let o = new String("Dan Zen");
o = makePrimitive(o); // o is now "Dan Zen"
// this is the same as o = String(o);
END EXAMPLE

EXAMPLE
let o = {age:new Number(7), name:new String("Dan Zen")};
o = makePrimitive(s); // o is now {age:7, name:"Dan Zen"}
END EXAMPLE

EXAMPLE
let o = [new Number(7), new String("Dan Zen")];
o = makePrimitive(s); // o is now [7, "Dan Zen"];
// also works with combinations of arrays and object literals
END EXAMPLE

PARAMETERS
obj - the object to convert

RETURNS the object with String, Number and Boolean objects converted to primitives
--*///+13.56
	zim.makePrimitive = function(obj) {
		z_d("13.56");
		
		// recursively adjust String, Number and Boolean to primitives
		function adjust(o) {
			if (Array.isArray(o)) {
				zim.loop(o, function(item){item=adjust(item)});
				return o;
			} else if (o.constructor === {}.constructor) {
				zim.loop(o, function(key, val){o[key]=adjust(val)});
				return o;
			}
			if (o instanceof String) return String(o);
			if (o instanceof Number) return Number(o);
			if (o instanceof Boolean) return Boolean(o);
			return o;
		}
		return adjust(obj);		
		
	};//-13.56
	
//
/*--
zim.makeMath = function()

makeMath
zim function

DESCRIPTION
Adds all Math static methods to window as global variables
There are not as many as we might think... 43 at the time of writing this

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
makeMath();
zog(sin(20*RAD));
END EXAMPLE
--*///+13.565
	zim.makeMath = function() {
		z_d("13.565");
				
		var names = Object.getOwnPropertyNames(Math);
		for(var i=0; i<names.length; i++) {
			WW[names[i]] = Math[names[i]];
		}
		
	};//-13.565

/*--
zim.swapProperties = function(property, objA, objB)

swapProperties
zim function

DESCRIPTION
Pass in a property as a string and two object references
and this function will swap the property values.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// exchanges the x position of two ZIM circles
swapProperties("x", circle1, circle2); S.update();
END EXAMPLE

PARAMETERS
property - a String of the property to swap values eg. "alpha"
objA, objB - the objects on which to swap properties

RETURNS Boolean indicating success
--*///+17.1
	zim.swapProperties = function(property, objA, objB) {
		z_d("17.1");
		if (zot(objA) || zot(objB) || zot(objA[property]) || zot(objB[property])) return false;
		var temp = objB[property];
		objB[property] = objA[property];
		objA[property] = temp;
		return true;
	};//-17.1

/*--
zim.setProps = function(obj, props)

setProps
zim function

DESCRIPTION
Sets the props of an object literal {} on the provided object or array
Each value can be a ZIM VEE value - see docs for ZIM Pick()
Thanks Pettis Brandon and Joseph Diefenbach for the thoughts on this

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const c = new Circle().addTo();
setProps(c, {x:100, y:200});  // can also use CreateJS set() method for this

// Set props for each object in array
const a = [new Circle().loc(100,100), new Rectangle().loc(300,100)];
setProps(a, {color:red, borderColor:blue}); // cannot use CreateJS set() method for this

// Use the setProps() method of a Tile - just calls the setProps() function 
// The method is available on Tile, Wrapper, LabelLetters, LabelWords, LabelOnPath, LabelOnArc, etc.
new Tile().center().setProps(color:[red, orange, yellow])
END EXAMPLE

PARAMETERS
obj - an object or an array of objects
props - an object literal {} of properties and values to set on the object or objects in an array 
	the value can be ZIM VEE values - see docs for ZIM Pick()

--*///+17.15
zim.setProps = function(obj, props) {
	z_d("17.15");
	if (zot(obj)) return;
	if (!Array.isArray(obj)) obj = [obj];
	zim.loop(obj, function (item) {
		zim.loop(props, function(name, val) {
			item[name] = zik(val);
		});
	});
};//-17.15


/*--
zim.mobile = function(orientation)

mobile
zim function

NOTE: for making mobile apps - see https://zimjs.com/mobile.html
and the PWA entry in Docs https://zimjs.com/docs.html?item=PWA

NOTE: as of ZIM version ZIM 01, a global variable M is provided if the Frame is run
that just stores the result of mobile().  mobile() was needed for each Button... so made it global

DESCRIPTION
Detects if app is on a mobile device - if so, returns the mobile device type:
android, ios, blackberry, windows, other (all which evaluate to true) else returns false.
orientation defaults to true and if there is window.orientation then it assumes mobile
BUT this may return true for some desktop and laptop touch screens
so you can turn the orientation check off by setting orientation to false.
If orientation is set to false the check may miss non-mainstream devices
The check looks at the navigator.userAgent for the following regular expression:
/ip(hone|od|ad)|android|blackberry|nokia|opera mini|mobile|phone|nexus|webos/i
Microsoft mobile gets detected by nokia, mobile or phone.

NOTE: See also the ZIM MOBILE constant - this can be set to true or false to override mobile() (but not the M global)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
if (mobile()) {
	const pane = new Pane("Desktop Only");
	pane.show();
}

// alternatively, for ZIM version ZIM 01 and on:
if (M) {
	const pane = new Pane("Desktop Only");
	pane.show();
}
END EXAMPLE

PARAMETERS
orientation - (default true) uses window.orientation property to determine mobile
	this may call certain touch screens mobile
	but setting to false uses a test on mobile names which could be incomplete

RETURNS a String or false
--*///+28
	zim.mobile = function(orientation) {
		z_d("28");
		if (!zot(WW.MOBILE) && WW.MOBILE!="default") return WW.MOBILE;
		if (!zot(zim.MOBILE) && zim.MOBILE!="default") return zim.MOBILE;
		if (zot(orientation)) orientation = true;
		if (/ip(hone|od|ad)/i.test(navigator.userAgent)) return "ios";
		if (/android|nexus/i.test(navigator.userAgent)) return "android";
		if (/blackberry/i.test(navigator.userAgent)) return "blackberry";
		if (/nokia|phone|mobile/i.test(navigator.userAgent)) return "windows";
		if (/opera mini|webos/i.test(navigator.userAgent)) return "other";
		if (orientation && WW.orientation !== undefined) {
			if (/safari/i.test(navigator.userAgent)) return "ios";
			return true;
		}
		return false;
	};//-28

//
/*--
zim.vee = function(obj)

vee
zim function

DESCRIPTION
Determines if obj is a ZIM Pick() object or a Pick Literal - used by ZIM VEE parameters
Pick Literal format is [], {min:a, max:b}, function(){}, {noPick:x} or a function(){}
See https://zimjs.com/docs.html?type=Pick
ZIM Pick is a way to pass in dynamic parameters or style properties
This is very handy to pass in a series() function or an array for random pickings, etc.
Used to create dynamic particles with the Emitter or tile specific items in order, etc.
Pick.choose() accepts any value and if not in ZIM Pick format, will just return the object

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const color = [red, green, blue];
// ternary operator - if in Pick format, add "random" else ""
new Label((vee(color)?"random ":"") + "colors").center();
END EXAMPLE

PARAMETERS
obj - an object to pass in to test whether it is in ZIM VEE (Pick) format

RETURNS a Boolean true if Pick format or false if not (such as just a number, string, new Circle, etc.)
--*///+28.5
	zim.vee = function(obj) {
		z_d("28.5");
		return !zot(obj) && (obj.type == "Pick" || Array.isArray(obj) || (obj.constructor == {}.constructor && (!zot(obj.max) || !zot(obj.noPick))) || typeof obj == "function");
	};//-28.5

/*--
zim.extend = function(subclass, superclass, override, prefix, prototype)

extend
zim function - modified CreateJS extend and promote utility methods

DESCRIPTION
For ES5 - place after a sub class to extend a super class.
Extending a super class means that the sub class receives all the properties and methods of the super class.
For example, a ZIM Container() extends a CreateJS Container and then adds more methods and properties
but all the CreateJS Container methods and properties are still there too like x, y, addChild(), etc.

For ES6 - do not use zim.extend() but rather use the built in ES6 structures as follows:

EXAMPLE
// ES6 - do NOT use zim.extend()
class Person() {
	constructor () {
		zog("I am a person");
	}
}
class Woman extends Person { // use JS6 extends keyword
	constructor () {
		super(); // use JS6 super() to call the Person constructor - will do the zog()
		// Woman code
	}
}

// ES6 to extend a zim Container for example (do NOT use zim.extend() in ES6)
class ChineseCoin extends Container { // use JS6 extends keyword
	constructor () {
		super(); // must call the zim Container before using keyword this
		new Circle(100, "gold").addTo(this); // this will be the zim Container
		new Rectangle(100, 100, "brown").center(this);
	}
}
var coin = new ChineseCoin().center(); // coin is a zim Container with Circle and Rectangle inside
END EXAMPLE

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// ES5 examples using functions to make classes
// ES5 has no extends keyword and no super keyword so we use zim.extends()
function Person() {
	this.talk = function() {
		zog("I am a person");
	}
}
function Woman() {
	this.super_constructor(); // part of the zim.extend() system
}
extend(Woman, Person); // here is the zim.extend() for ES5
var woman = new Woman();
woman.talk();
END EXAMPLE

NOTE: CreateJS display objects require their constructor to be called otherwise it is like quantum entanglement (seriously)
extend() adds access to the super class constructor so it can be called in the subclass as follows:
this.super_constructor();
It also provides access to super class methods that are overridden

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// ES5 example - see the ES6 set of examples for ES6 ;-)
// make a Collection class that will extend a Container
// the Collection class will call the Container constructor
// and override the the ZIM Container center method in the class body
// and override the CreateJS Container addChild method in the prototype
// either method would work in either place - it is often a matter of preference
// but you might need to use a method in the class body to access local variables
// The ZIM extend() method parameter values need to change depending on where you override
// see the comments inline for the instructions

var Collection = function() {
	// for CreateJS the super constructor must be run
	this.super_constructor();

	// override the zim center() method
	// methods in the function call that override must be passed in as an array of strings
	// to the override parameter of extend() to be able to access the super_method
	this.center = function(where) {
		this.super_center(where);
		this.y -= 50;
	}
}
// override the super class addChild() that comes from the CreateJS Container
// methods on the prototype that override are automatically provided a super_method
// unless the prototype parameter of extend() is set to false (default is true)
Collection.prototype.addChild = function(c) {
	this.super_addChild(c); // call the super class addChild
	zog("added a child to Collection");
}

// make the Collection extend a Container()
// it will receive all the properties and methods of the Container plus its own
extend(Collection, Container, CENTER); // or pass an array of overridden methods

// use the Collection
var c = new Collection();
c.addChild(new Rectangle(100, 100, green)); // zogs "added a child to Collection"
c.center(); // centers the collection but then offsets it 50 pixels up
END EXAMPLE

NOTE: the superclass constructor is always available as this.prefix_constructor() no matter the override or prototype settings
NOTE: this.prefix_constructor(); should be called at the top of the subclass to avoid problems when multiple copies of object
NOTE: to extend a class that already extends a ZIM class then change the prefix to a unique name:

EXAMPLE
// if we already had the Collection example above and we want to extend that
// then we must use a new prefix when using extend()

var Records = function() {
	this.Collection_constructor();
}
extend(Records, Collection, null, "Collection");

// you will still have this.super_center(), this.super_addChild() if needed
// plus any newly overridden methods available as this.Collection_methodName() etc.
var r = new Records();
r.addChild(new Circle(20, pink));
r.super_center(); // call the original center (without vertical shift)

// to extend again, use yet another prefix - for example: "Records"
var Jazz = function() {
	this.Records_constructor();
}
extend(Jazz, Records, null, "Records");
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
NOTE: do NOT use zim.extend() with ES6 - see ES6 examples at top instead
subclass - the class to extend
superclass - the class to extend from (an existing class)
override - (default null) an Array of methods (as Strings) to override.
	You can override any function by just defining that function in the subclass
	the override parameter gives you access to the overridden function in the superclass prototype
	only methods on the superclass prototype can be accessed once overridden - not methods in the superclass body
	if there is only one method being overridden then a single string is fine ("test" or ["test"] is fine)
	any methods passed to this parameter will be given prefix_methodName() access on the sub class (this.prefix_methodName())
	where the prefix is below (note, the prototype setting has no bearing on these manual overrides)
	this list is only needed for methods in the subclass body
	methods assigned to the prototype of the subclass that override are automatically given prefixes
prefix - (default "super") a prefix that will be followed by "_" and then the overridden method name
	by default this.super_constructor() would call the super class constructor
	if prefix is set to "Person" then this.Person_constructor() would call the super class constructor
	the same system is used to call overridden files in override or prototype
prototype - (default true) will search the subclass prototype for overriding methods
	the overridden methods are then available as this.prefix_methodName()
	set to false to avoid searching the super class for methods overridden by the sub class prototype
	just quickens the code minutely if there is no need

NOTE: extend() is included in Distill if DISPLAY, METHODS or FRAME Module classes are used (otherwise NOT included)

RETURNS the subclass
--*///+50.35
	zim.extend = function(subclass, superclass, override, prefix, prototype) {
		var sig = "subclass, superclass, override, prefix, prototype";
		var duo; if (duo = zob(zim.extend, arguments, sig)) return duo;
		if (zot(subclass) || zot(superclass)) {
			if (zon && subclass!=zim.StageGL) zogy("zim.extend() - please supply a class and its superclass");
			return;
		}
		// zogr("start")		
		if (zot(prefix)) prefix = "super";
		if (zot(override)) override = [];
		if (!Array.isArray(override)) override = [override];
		if (zot(prototype)) prototype = true;
		// modified CreateJS extend() to include any prototype members already added
		// see https://www.createjs.com/docs/easeljs/classes/Utility%20Methods.html
		var existingP = {};
		for (var f in subclass.prototype) Object.defineProperty(existingP,f,Object.getOwnPropertyDescriptor(subclass.prototype, f));
		function o() {this.constructor = subclass;}
		o.prototype = superclass.prototype;
		subclass.prototype = new o();
		for (f in existingP) {
			Object.defineProperty(subclass.prototype,f,Object.getOwnPropertyDescriptor(existingP,f));
		}

		// modified CreateJS promote() to promote methods other than constructor only if methods is true
		// zim does not override with prototypes so it is uneccessary to loop through the super class methods
		// added checking an array of string values of methods defined in class (not prototype) that are being overridden
		var subP = subclass.prototype;
		var supP = (Object.getPrototypeOf&&Object.getPrototypeOf(subP))||subP.__proto__;
		if (supP) {
			subP[(prefix+="_") + "constructor"] = supP.constructor; // constructor is not always innumerable
			var n;
			for (var i=0; i<override.length; i++) {				
				n = override[i];
				if (typeof supP[n] == "function") {
					subP[prefix + n] = supP[n];
				}
			}
			if (prototype) {
				for (n in supP) {
					if (Object.prototype.hasOwnProperty.call(subP, n) && (typeof supP[n] == "function")) {subP[prefix + n] = supP[n];}
				}
			}
		}
		return subclass;
	};
	//-50.35

// SUBSECTION BASICS

/*--
zim.copy = function(obj, clone, cloneContainers)

copy
zim function

DESCRIPTION
Copies arrays and basic objects:
modified https://stackoverflow.com/users/35881/a-levy
If you have var obj = {prop:"val"};
and then try and copy obj to obj2 like so: obj2 = obj;
then obj2 and obj refer to the same object.
This means that after obj.prop = "new"; both obj.prop and obj2.prop would be "new".
copy(obj) returns a new object so both will work independently
and after obj.prop = "new"; obj2.prop would still be "val".

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const obj = {hair:blue, cars:["audi", "honda"]};
const cop = copy(obj);
cop.hair = "green";
zog(obj.hair, obj.cop); // blue, green
obj.cars.push("vw");
zog(obj.cars.length, cop.cars.length); // 3, 2

// copy with clone for cloneable objects
// without the second parameter as true these obj2[0] and obj3[0] would be the same
// and when we do the second addTo it would just move the circle to the second position
const obj2 = [
	new Circle(20,green),
	new Rectangle(30,30,green),
	new Triangle(40,40,40,green)
];
const obj3 = copy(obj, true); // copy and clone
obj2[0].addTo(stage).pos(100, 200);
obj3[0].addTo(stage).pos(300, 400);
END EXAMPLE

PARAMETERS
obj - the object to copy
clone - (default false) set to true to clone any cloneable object while copying
cloneContainers - (default true if clone true) set to false to not copy objects with type="Container"

RETURNS a new Object
--*///+10
	zim.copy = function(obj, clone, cloneContainer) {
		if (!zim.copyCheck) {z_d("10"); zim.copyCheck = true;}
		if (zot(clone)) clone = false;
		if (zot(cloneContainer)) cloneContainer = true;
		if (obj==null || !(obj instanceof Array || obj.constructor == {}.constructor)) return clone&&obj!=null?(obj.clone?(obj.type&&((obj.type!="Container"&&obj.type!="Stage"&&obj.type!="StageGL")||cloneContainer)?obj.clone():obj):obj):obj;
		if (obj instanceof Array) {
			var array = [];
			for (var i=0; i<obj.length; i++) {
				array[i] = zim.copy(obj[i], clone, cloneContainer);
			}
			return array;
		}
		if (obj.constructor == {}.constructor) {
			var copy = {};
			for (var attr in obj) {
				var answer = zim.copy(obj[attr], clone, cloneContainer);
				if (Object.prototype.hasOwnProperty.call(obj, attr)) copy[attr] = answer;
			}
			return copy;
		}
	};//-10

/*--
zim.merge = function(objects)

merge
zim function

DESCRIPTION
Merges any number of objects {} you pass in as parameters.
Overwrites properties if they have the same name.
Returns a merged object with original objects kept intact.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const one = {food:"chocolate"};
const two = {drink:"milk"};
const tri = merge(one, two);
zog(tri.food, tri.drink); // chocolate, milk
END EXAMPLE

PARAMETERS
objects - a list of objects (any number) to merge together

RETURNS a new Object
--*///+12
	zim.merge = function() {
		if (!zim.mergeCheck) {z_d("12"); zim.mergeCheck = true;}
		var obj = {}; var i; var j;
		for (i=0; i<arguments.length; i++) {
			for (j in arguments[i]) {
				if (Object.prototype.hasOwnProperty.call(arguments[i], j)) {
					obj[j] = arguments[i][j];
				}
			}
		}
		return obj;
	};//-12

/*--
zim.sortObject = function(obj, property, reverse)

sortObject
zim function

DESCRIPTION
Sorts an Object with inner objects by a property of the inner object

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const sortData = {
	Z_JJK34:{
		date:"2023-06-29",
		prefix:"Bits",
		title:"Basic Physics" // etc.
	},
	Z_92KL1:{
		date:"2023-06-28",
		prefix:"CodePen",
		title:"Art Puzzle with Scrambler"
	}
}
	
const sorted = sortObject(sortData, "date"); 
loop(sorted, (key, val)=>{
	zog(key + " : " + val.date); // sorted by date
});
END EXAMPLE

PARAMETERS
obj - an object with inner objects all having similar property names 
property - the property (as a string) of the inner object on which to sort
reverse - (default false) set to true to reverse the sort 

RETURNS a new Object with sorted properties - the original object is left as is
--*///+12.1

zim.sortObject = function(obj,property,reverse) {
	z_d("12.1");
	var valSelector = function(val) {return val[property]}
	var sortedEntries = Object.entries(obj)
		.sort(function(a, b) {
			return reverse?
			(valSelector(a[1]) < valSelector(b[1]) ? 1 : valSelector(a[1]) > valSelector(b[1]) ? -1 : 0)
			:
			(valSelector(a[1]) > valSelector(b[1]) ? 1 : valSelector(a[1]) < valSelector(b[1]) ? -1 : 0)
	});
	var map = new Map(sortedEntries);
	var sorted = {}; 
	map.forEach(function(v,k) {sorted[k] = v});
	return sorted;
};//-12.1

/*--
zim.arraysEqual = function(a, b, strict)

arraysEqual
zim function

DESCRIPTION
Finds out if arrays are same (including nested arrays).
Works for arrays with strings and numbers (not necessarily other objects).
(Slightly modified Evan Steinkerchnerv & Tomas Zato)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const one = [1,2,"wow",[3,4]];
const two = [1,2,"wow",[3,4]];
zog(arraysEqual(one, two)); // true
one[3][1] = 5;
zog(arraysEqual(one, two)); // false
END EXAMPLE

PARAMETERS
a, b - the arrays to check to see if they are equal
strict - (default true) set to false so order in arrays does not matter

RETURNS a Boolean
--*///+11
	zim.arraysEqual = function(a, b, strict) {
		z_d("11");
		if (zot(a) || zot(b)) return false;
		if (zot(strict)) strict = true; // must be the same order
		if (a.length != b.length) return false;

		for (var i = 0; i < a.length; i++) {
			if (a[i] instanceof Array && b[i] instanceof Array) {
				if (!zim.arraysEqual(a[i], b[i], strict))	return false;
			}
			else if (strict && a[i] != b[i]) {
				return false;
			}
			else if (!strict) {
				return zim.arraysEqual(a.sort(), b.sort(), true);
			}
		}
		return true;
	};//-11
	
/*--
zim.arrayMinMax = function(arr)

arrayMinMax
zim function

DESCRIPTION
Returns an object with {min, max} for min and max values of an array.
Or null for value if not a number.
(Thanks Lior Elrom from StackOverflow)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
zog(arrayMinMax([1,22,2,10]).max); // 22
END EXAMPLE

PARAMETERS
arr - a linear array with numbers

RETURNS an object with min and max properties
--*///+11.2
	zim.arrayMinMax = function(arr) {
		z_d("11.2");
		if (!Array.isArray(arr)) return {min:null, max:null};
		var min = arr[0];
		var max = arr[0];
		var i = arr.length;
		while (i--) {
			min = arr[i] < min ? arr[i] : min;
			max = arr[i] > max ? arr[i] : max;
		}
		min = isNaN(min)?null:min;
		max = isNaN(max)?null:max;
		return {min:min, max:max};
	};//-11.2	

/*--
zim.isEmpty = function(obj)

isEmpty
zim function

DESCRIPTION
returns whether an object literal is empty

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const o = {};
zog( isEmpty(o) ); // true
o.test = 9;
zog( isEmpty(o) ); // false
END EXAMPLE

PARAMETERS
obj - the object literal to test

RETURNS a Boolean
--*///+11.5
	zim.isEmpty = function(obj) {
		if (!zim.zimEmptyCheck) {z_d("11.5"); zim.zimEmptyCheck = true;}
		if (zot(obj)) return;
		var count = 0;
		for (var o in obj) {
			count++; break;
		}
		return (count == 0);
	};//-11.5

/*--
zim.isPick = function(obj)

isPick
zim function

DESCRIPTION
Returns whether an object is a SPECIAL Pick literal
of type [], {min:val, max:val}, {noPick:val} or function that returns a value
If any other object is passed to Pick, it just gets passed through
So in theory, all objects are in Pick literal format
but isPick() returns true if object operated on, not just passed through

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
zog(isPick(1)); // false
zog(isPick([1,2,3])); // true
zog(isPick({age:10})); // false
zog(isPick({min:10,max:20})); // true
zog(isPick({noPick:[1,2,3]})); // strange but true
zog(isPick(function(){})); // false
zog(isPick(function(){return 20;})); // true
const s = series(1,2,3);
zog(isPick(s)); // true
// important that the isPick() does not run the series to test if ZIM VEE
// so it checks the array property of series rather than checking for a function return value
zog(s()); // 1
END EXAMPLE

PARAMETERS
obj - the string to test

RETURNS a Boolean as to whether obj is SPECIAL ZIM Pick literal
--*///+11.7
	zim.isPick = function(obj) {
		if (!zim.zimPickCheck) {z_d("11.7"); zim.zimPickCheck = true;}
		if(zot(obj)) return;
		return (Array.isArray(obj)||(obj.constructor=={}.constructor && ((obj.min!=null && obj.max!=null) || obj.noPick))||(obj.constructor === Function && (obj.array!=null || obj()!=null))); // obj.array is a series
	};//-11.7

/*--
zim.isJSON = function(str)

isJSON
zim function

DESCRIPTION
returns whether a string is a JSON string

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const s = '{"age":7,"name":"Dan Zen"}';
zog( isJSON(s) ); // true
const b = "hello";
zog( isJSON(b) ); // false
END EXAMPLE

PARAMETERS
str - the string to test

RETURNS a Boolean
--*///+11.6
	zim.isJSON = function(str) {
		z_d("11.6");
		if (typeof str != "string") {
			return false;
		}
		try {
			JSON.parse(str);
			return true;
		}
		catch (error) {
			return false;
		}
	};//-11.6

/*--
zim.parseJSON = function(str)

parseJSON
zim function

DESCRIPTION
receives a JSON string or a "close-to" JSON string and returns the parsed object

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const badJSON = `{
	"inner":{
		// comments can be added
		prop:"note prop and prop2 are missing quotes",
		// another comment
		prop2:"note the comma on the end will be ok",
	}
}`;
// zog(JSON.parse(badJSON)); // would cause error
zog(parseJSON(badJSON)); // will log a valid object
END EXAMPLE

PARAMETERS
str - the JSON or "close-to" JSON string
	this can be missing the "" around the property names 
	and can have comments between lines 
	and trailing commas will not cause a problem

RETURNS an object
--*///+11.65
	zim.parseJSON = function(str) {
		z_d("11.65");
		function jst(str) {
            str = str.trim();
            try {
                return (new Function("return " + str))();
            } catch (err) {
                zogy("JSON did not parse");
                return null;
            }
        }        
        var jobj;
        try {
            jobj = JSON.parse(str);
        } catch (err) {            
            jobj = jst(str);
        }
        return jobj;
	};//-11.65

/*--
zim.decimals = function(num, places, addZeros, addZerosBefore, includeZero, time)

decimals
zim function

DESCRIPTION
Rounds number to the number of decimal places specified by places.
Negative number places round to tens, hundreds, etc.
If addZeros is set to a number it adds 0 in empty spaces up to that many places after the decimal
If addZerosBefore is set to a number it adds 0 in empty spaces up to that many places before the decimal

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const score = 1.234;
score = decimals(score);
zog(score); // 1.2
zog(decimals(1.8345, 2)); // 1.83
zog(decimals(123,-1)); // 120
zog(decimals(2.3,null,2)); // 2.30
zog(decimals(3,null,null,2)); // 03
zog(decimals(.12,2,2,1,null,true)); // 0:12
END EXAMPLE

PARAMETERS
num - the Number to operate on
places - (default 1) how many decimals to include (negative for left of decimal place)
addZeros - (default 0) set to number of places to fill in zeros after decimal (and return String)
addZerosBefore - (default 1) set to number of places to fill in zeros before decimal (and return String)
includeZero - (default true) set to false to always have zero just be 0 without any extra zeros
time - (default false) a swap of : for . to handle minutes and seconds (not hours)

RETURNS a rounded Number or a String if addZeros, addZerosBefore or time is true
--*///+13
	zim.zut = function(e) {
		if (zot(e) || typeof e == "object") return true;
	};
	zim.decimals = function(num, places, addZeros, addZerosBefore, includeZero, time, evt) {
		if (!zim.zimDecimalCheck) {z_d("13"); zim.zimDecimalCheck = true;}
		if (zot(num)) return 0;
		if (zot(places)) places = 1;
		if (zot(addZeros)) addZeros = 0;
		if (zot(addZerosBefore)) addZerosBefore = 1;
		if (zot(includeZero)) includeZero = true;
		if (zot(time)) time = false;
		// if (addZeros && places < 0) {
		// 	var place = String(num).indexOf(".");
		// 	var length = String(num).length;
		// 	var left = (place < 0) ? length : place;
		// 	for (var i=0; i<-places-left; i++) {num = "0" + num;}
		// 	return num;
		// }
		var answer = Math.round(num*Math.pow(10, places))/Math.pow(10, places);		
		if (time) {
			var secs = answer - Math.floor(answer);
			answer = zim.decimals(Math.floor(answer) + secs*60/100, 2);
		}
	
		// if (addZeros && places > 0 && answer != 0) {
		// 	var place = String(answer).indexOf(".");
		// 	var length = String(answer).length;
		// 	if (place < 0) {place = length++; answer+=".";}
		// 	for (var i=0; i<places-(length-place-1); i++) {answer += "0";}
		// }
		var sign = zim.sign(answer);
		var place,length,i;
		if (addZeros > 0) {
			place = String(answer).indexOf(".");
			length = String(answer).length;
			if (place < 0) {place = length++; answer+=".";}
			for (i=0; i<addZeros-(length-place-1); i++) {answer += "0";}
		}
		if (addZerosBefore > 1) {
			// fix this - Dan Zen - negative decimal number problem
			if (sign == -1) answer = answer.substr(1,answer.length-1);
			place = String(answer).indexOf(".");
			length = String(answer).length;
			var left = (place < 0) ? length : place;
			for (i=0; i<addZerosBefore-left; i++) {answer = "0" + answer;}
			if (sign == -1) answer = "-" + answer;
		}
		if (addZerosBefore == 0) answer = answer.toString().replace(/^0\./,".");
		if ((addZeros + addZerosBefore > 0) && !includeZero && Number(answer) == 0) answer = 0;
		if (time) answer = String(answer).replace(".", ":");
		
		return zim.zut(evt) ? answer : null;
	};//-13

/*--
zim.countDecimals = function(num)

countDecimals
zim function

DESCRIPTION
Counts the number of decimals in a number
Provided by Matthew Layton, A. Wolff - Stack Overflow

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const num1 = countDecimals(1.234); // num1 is 3
const num2 = countDecimals(22); // num2 is 0
END EXAMPLE

PARAMETERS
num - the Number for which to count decimals

RETURNS the number of decimal places
--*///+13.05
	zim.countDecimals = function(num) {
		if (!zim.zimCountDecimalsCheck) {z_d("13.05"); zim.zimCountDecimalsCheck = true;}
		return num % 1?num.toString().split(".")[1].length:0;
	};//-13.05
	

/*--
zim.sign = function(num)

sign
zim function

DESCRIPTION
returns -1, 0 or 1 depending on whether the number is less than, equal to or greater than 0

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
let speed;
speed = 20;
zog(sign(speed)); // 1

speed = 0;
zog(sign(speed)); // 0

speed = -20;
zog(sSign(speed)); // -1
END EXAMPLE

PARAMETERS
num - the Number to operate on

RETURNS -1, 0 or 1
--*///+13.1
	zim.sign = function(num) {
		if (!zim.zimSignCheck) {z_d("13.1"); zim.zimSignCheck=true;}
		return num?num<0?-1:1:0;
	};//-13.1


/*--
zim.constrain = function(num, min, max, negative)

constrain
zim function

DESCRIPTION
returns a number constrained to min and max

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const cirle.x = constrain(circle.x, circle.radius, W-circle.radius);
// circle.x will not be smaller than the radius or bigger than W-radius

const speed = constrain(speed, minSpeed, maxSpeed, true);
// will confine the speed between minSpeed and maxSpeed if speed is positive
// and confine the speed between -maxSpeed and -minSpeed if the speed is negative
END EXAMPLE

PARAMETERS
num - the number to be constrained
min - (default 0) the minimum value of the return number
max - (default Number.MAX_VALUE) the maximum value of the return number
negative - (default false) allow the negative range of min and max when num is negative

RETURNS num if between min and max otherwise returns min if less or max if greater (inclusive)
RETURNS num between -max and -min if num is negative and negative parameter is set to true
--*///+13.2
	zim.constrain = function(num, min, max, negative) {
		z_d("13.2");
		if (zot(num)) return;
		if (zot(min)) min = 0;
		if (zot(max)) max = Number.MAX_VALUE;
		if (max < min) {var max2 = min; max = min; min = max2;} // ES6 Fix to come
		if (zot(negative)) negative = false;
		if (negative && num < 0) {
			return Math.max(-max, Math.min(num, -min));
		} else {
			return Math.max(min, Math.min(num, max));
		}
	};//-13.2

/*--
zim.dist = function(a, b, c, d)

dist
zim function

DESCRIPTION
Calculates the distance between two points.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// using point values for each
const p1 = new Point(100, 100); // or {x:100, y:100}
const p2 = new Point(200, 200);
zog(dist(p1, p2)); // 141.42...
END EXAMPLE

EXAMPLE
// using x and y values for each
const distance = dist(W/2, H/2, F.mouseX, F.mouseY);
// distance of mouse from center of stage
END EXAMPLE

PARAMETERS
a - first Point - any object with x and y values - eg. a zim Container or zim Point or {x:10, y:30}
	or if four parameter values, an x value of the first point
b - second Point - any object with x and y values
	or if four parameter values, a y value of the first point
c - (default null) an x value of a second point - if using x and y values
d - (default null) a y value of a second point - if using x and y values

RETURNS a positive Number that is the distance (could be on an angle)
--*///+13.3
	zim.dist = function(a, b, c, d) {
		if (!zim.zimDistCheck) {z_d("13.3"); zim.zimDistCheck=true;}
		if (zot(a) || zot(b)) return;
		if (!zot(a.x) && !zot(b.x)) {
			d = b.y;
			c = b.x;
			b = a.y;
			a = a.x;
		} else {
			if (zot(c)) c = 0;
			if (zot(d)) d = 0;
		}
		return Math.sqrt((Math.pow(c-a, 2) + Math.pow(d-b, 2)));
	};//-13.3

/*--
zim.rectIntersect = function(a, b, margin)

rectIntersect
zim function

DESCRIPTION
Returns true if two rectangles are intersecting - this is a very fast but exact calculation

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// using point values for each
const r1 = {x:100, y:100, width:300, height:200}
const r2 = new Boundary(50,200,100,100);
zog(rectIntersect(r1, r2)); // true
END EXAMPLE

PARAMETERS
a - first rectangle with x, y, width and height properties - such as a bounds or Boundary
	make sure that these are in the same coordinate systems - use ZIM boundsToGlobal for instance
b - second rectangle with x, y, width and height properties
margin - (default 0) positive value adds margin (more likely to intersect) and negative subtracts (less likely to intersect)

RETURNS a Boolean as to whether rectangles are intersecting
--*///+13.32
	zim.rectIntersect = function(a, b, margin) {
		if (!zim.zimRectIntersectCheck) {z_d("13.32"); zim.zimRectIntersectCheck=true;}
		if (zot(margin)) margin = 0;
		if (a.x >= b.x + b.width + margin || a.x + a.width + margin <= b.x ||
			a.y >= b.y + b.height + margin || a.y + a.height + margin <= b.y ) {
			return false;
		} else {
			return true;
		}
	};//-13.32
	
/*--
zim.boundsAroundPoints = function(points)

boundsAroundPoints
zim function

DESCRIPTION
Returns a rectangle {x,y,width,height} around an array of points {x,y}

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const blob = new Blob();
const points = blob.interpolate();
zog(boundsAroundPoints(points)); // {x:-100, y:-100, width:200, height:200}
// could call this after resizing the blob to get the rough bounds of the blob (or squiggle)
// interpolate defaults to 1 so setting 5 would be even more precise, etc.
END EXAMPLE

PARAMETERS
points - an array of points with x and y properties.

RETURNS an object with x, y, width and height properties
representing the rectangle around the points provided
--*///+13.34
	zim.boundsAroundPoints = function(points) {
		if (!zim.zimBoundsAroundPointsCheck) {z_d("13.34"); zim.zimBoundsAroundPointsCheck=true;}
		var tX = 10000;
		var tY = 10000;
		var bX = -10000;
		var bY = -10000;
		for (var i=0; i<points.length; i++) {
			var p = points[i];
			if (p.x < tX) tX = p.x;
			if (p.x > bX) bX = p.x;
			if (p.y < tY) tY = p.y;
			if (p.y > bY) bY = p.y;
		}
		return {x:tX, y:tY, width:bX-tX, height:bY-tY};
	};//-13.34

/*--
zim.angle = function(x1, y1, x2, y2)

angle
zim function

DESCRIPTION
Calculates the angle between two points relative to the positive x axis

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const angle = angle(W/2, H/2, W/2+100, H/2+100); // 45
// angle from center of stage to 100, 100 to the right and down from the center of the stage

const angle2 = angle(W/2, H/2, W/2-100, H/2+100); // 135

const angle3 = angle(W/2, H/2, W/2+100, H/2-100); // 315
END EXAMPLE

PARAMETERS
x1, y1 - first point x and y
	unless no second point in which case x1, y1 will be second point and first point will be 0, 0
x2, y2 - second point x and y

RETURNS a positive Number that is the angle between first and second point relative to positive x axis
--*///+13.4
	zim.angle = function(x1, y1, x2, y2) {
		if (!zim.angleCheck) {z_d("13.4"); zim.angleCheck = true;}
		if (zot(x1) || zot(y1)) return;
		if (zot(x2)) {x2 = x1; x1 = 0;}
		if (zot(y2)) {y2 = y1; y1 = 0;}
		return (Math.atan2(y2-y1, x2-x1)*180/Math.PI+360)%360;
	};//-13.4


/*--
TAU, DEG, RAD, PHI

TAU, DEG, RAD, PHI
zim constants

DESCRIPTION
ZIM degrees and radian constants
If working in radians, TAU is equal to 2 radians (360).
This allows easy visualization of angles - TAU/2 is 180, TAU/4 is 90, etc.
DEG is 180/Math.PI so you multiply a radian value by DEG to get degrees.
RAD is Math.PI/180 so you multiply a degree value by RAD to get radians.
PHI is the golden ratio or Math.pow(5,.5)*.5+.5 or 1.6180339887…
NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
Math.sin(TAU/4); // sin of 90 degrees (1)
// is same as
Math.sin(90*RAD);
// is same as
Math.sin(90*Math.PI/180);
// and
Math.asin(1)*DEG; // is 90
END EXAMPLE
	--*///+83.6
	zim.TAU = Math.PI * 2;
	zim.DEG = 180/Math.PI;
	zim.RAD = Math.PI/180;
	zim.PHI = Math.pow(5,.5)*.5+.5;
	//-83.6

/*--
zim.smoothStep = function(num, min, max)

smoothStep
zim function

DESCRIPTION
smoothStep takes an input value and outputs a value between 0 and 1
that represents a transition between the min and max with easing at both ends.
If you want the easing to be more pronounced, then reduce difference between min and max.
If the value falls outside the min or max then it is set to the min or max.
Remember the return value is between 0 and 1 so you can multiply by max-min and add it to min
to get a value at the original scale.
Used to make blobs with Noise(): https://zimjs.com/noise/blobs.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// here we use smoothStep to make a gradient between black and white
// not an even one right across but a gradient across a transition zone of 40-100

// create an empty Bitmap size 200, 200 and center it on the stage
const bmp = new Bitmap(null, 200, 200).center();

// we need to loop and get a value for each pixel
// normally we loop across the rows and then do each column
// but here we are making a horizontal gradient
// so we will loop across the x and get the desired value
// then when we loop across the y in the inner loop, we just use that same value
for (let x = 0; x < bmp.width; x++) {
	// making gradient in x only so calculate smoothStep here
	// x will be from 0 to the width of 200
	// we pass in a min of 40 and a max of 100
	// the result of smoothStep is between 0 and 1
	// so from 0 to 40 the return of smoothStep will be 0
	// and from 100 to 200 the return of smoothStep will be 1
	// In between, the return value starts off close to 0, then speeds up
	// and then slows down to 1 in a curve that is somewhat like the letter f
	// When we multiply by 255 and apply that result to each color,
	// we get black and then a range of greys and then white
	const value = smoothStep(x, 40, 100)*255;

	// now we loop down the column for the x position
	for (let y = 0; y < bmp.height; y++) {
		// imageData is four values per pixel
		// the red, green, blue and alpha
		// in one big long array - each value will be constrained to between 0 and 255
		// this i value will increase by 4 each time
		// then we write the same value for red, green, blue to get a shade of grey
		let i = (x + y * bmp.width) * 4;
		bmp.imageData.data[i] = value; // red (0-255)
		bmp.imageData.data[i + 1] = value; // green (0-255)
		bmp.imageData.data[i + 2] = value; // blue (0-255)
		bmp.imageData.data[i + 3] = 255; // alpha (0-255)
	}
}
bmp.drawImageData(); // draw the imageData to the Bitmap
END EXAMPLE

PARAMETERS
num - the input value with respect to min and max
min - the lower edge for smoothStep (often termed edge0) - anything smaller will be set to min
max - the upper edge for smoothStep (often termed edge1) - anything bigger will be set to max

RETURNS a number between 0 and 1 that represents a transition factor
--*///+13.7
	zim.smoothStep = function(num, min, max) {
		z_d("13.7");
		var x = zim.constrain((num - min)/(max - min), 0, 1);
		return x*x*x*(x*(x*6 - 15) + 10); // Perlin
	};//-13.7
	
/*--
zim.unicodeToUTF = function(val)

unicodeToUTF
zim function

DESCRIPTION
unicodeToUTF() converts unicode to UTF format.  
This is used internally by ZIM Emoji and EmojiPicker.
Unicode can be pasted into text but can cause problems in scripts 
when writing to databases - like ZIM Zap and ZIM Kids Slate. 
There is a converter here: https://zimjs.com/emoji 
if the MORE button is pressed.  This is the code that handles that conversion.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
zog(unicodeToUTF("Paste unicode Slightly Smiling Face U+1F642 here")); // \ud83d\ude42
END EXAMPLE

PARAMETERS
val - the unicode emoji/character (not the unicode)

RETURNS a UTF string matching the unicode
--*///+13.75
	zim.unicodeToUTF = function(val) {
		z_d("13.75");
		if (!val) return;
		if (val != " ") val = val.replace(/^\s+/g, "");    	
		var s, m = "", n = "";
		s = val.charCodeAt(0);   
		m = s;
		n = val.charCodeAt(1);      		
		if ((n >= 0xDC00) && (n <= 0xDFFF)) s = ((m - 0xD800) * 0x400) + (n - 0xDC00) + 0x10000;
		m = m.toString(16);
		n = n.toString(16);    
		s = s.toString(16); 
		return "\\u" + m + "\\u" + n;
	};//-13.75

/*--
zim.capitalizeFirst = function(string)

capitalizeFirst
zim function

DESCRIPTION
Capitalize the first letter of a String.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
let name = "roger";
name = capitalizeFirst(name); // remember to assign back to string
zog(name); // Roger 
END EXAMPLE

PARAMETERS 
string - the string to capitalize the first letter

RETURNS the string with the first letter capitalized
--*///+13.78
	zim.capitalizeFirst = function(string) {
		z_d("13.78");
		return string.charAt(0).toUpperCase() + string.slice(1);
	};//-13.78
	

// SUBSECTION CLASSES

/*--
zim.Ajax = function(master, couple, lock, unique)

Ajax
zim class

DESCRIPTION
An AJAX class to send data back and forth to a server without reloading the page

NOTE: also see ZIM async() to send data back and forth as JSONp
using async can avoid various security issues with cross domain access

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// GET - note: GET is limited to approximately 2048 characters
const ajax = new Ajax();
new Button().center().tap(()=>{
	ajax.get("https://yourserver/ajax.php?record=pressed");
});
<?php
 	$record = isset($_GET["record"]) ? $_GET["record"] : "";
	// $record would now hold the string "pressed"
?>
END EXAMPLE

EXAMPLE
// GET with user input and server response
const query = new TextArea(300,90).center();
new Button({label:"SUBMIT", corner:5}).sca(.7).pos(0,100,CENTER,CENTER)
	.tap(()=>{
		new Ajax().get("https://yourserver/ajax.php?query="+encodeURI(query.text), callback);
	});
function callback(data) {
	query.text = "Date: " + data.date + "\nAnswer: " + data.answer;
}
<?php
 	$query = isset($_GET["query"]) ? $_GET["query"] : "";
	// probably get info from database
	$array = [];
	$array["date"] = "March 10, 2020";
	$array["answer"] = "yes, of course!";
	echo json_decode($array);
?>
END EXAMPLE

EXAMPLE
// POST - virtually unlimited size
const ajax = new Ajax();
new Button().center().tap(()=>{
	var data = {name:"Dr Abstract", occupatio:"creator"};
	// data will automatically have JSON.stringify() applied
	var id = "AB234";
	ajax.post("https://yourserver/ajax.php", data, "add", id, callback);
});
function callback(data) {
	zog(data.name); // "Dr Abstract"
}
<?php
	// ZIM Ajax POST the data is received as a data property:
 	$data = isset($_POST["data"]) ? $_POST["data"] : "";
	// a command can be sent for add, select, update, delete, etc.
	$command = isset($_POST["command"]) ? $_POST["command"] : "";
	// extra information can be collected such as an id, etc.
	$extra = isset($_POST["extra"]) ? $_POST["extra"] : "";
	// add $data to database as JSON string for the id in the $extra
	if ($command == "add") {}
	// The data can be decoded too
	$array = json_decode($data, true);

	// here we "round-trip" to show it can be done
	// send back encoded info from Database
	echo json_encode($array);
?>
END EXAMPLE

EXAMPLE
	// put - sends data in body of content
	// same as POST but no command and receive in PHP as follows:
<?php
	// ZIM Ajax put receive as follows:
	$array = json_decode(file_get_contents('php://input'), true);
?>
END EXAMPLE

PARAMETERS
master - data to be sent with every get() or post() (not put())
	this can be collected in php, for example, as $GET_["master"] or $POST_["master"]
couple - (default false) - set to true to turn nested JSON into a single layer
	** for POST only - use ZIM couple() and decouple() manually with GET and PUT
 	see ZIM couple() and decouple() for more information
	data for POST will be coupled when sent and uncoupled when received
lock - (defualt null) send an optional lock id - would need to be processed on the server
unique - (defualt null) send an optional unique=true - would need to be processed on the server

METHODS
get(url, call) - send and receive based on GET (approximate limit 2048 characters)
	the url will have parameters in cgi format to send information
	for example: "server.php?name="+encodeURI("Dr Abstract")+"&occupation=creator";
	in PHP access these with $_GET["name"], $_GET["occupation"], etc.
	call is the function to call and will receive (data, error) as parameters
	the data will automatically have JSON.parse() applied if in JSON format
post(url, data, command, extra, call) - send and receive based on POST
	** accepts the ZIM DUO technique of regular parameters or a configuration object with properties matching parameters
	url is the url to a server script such as php or node
		the url will not need parameters but rather use the data, command and extra
	data will automatically have JSON.stringify() applied
		in PHP access this with $data = $_POST["data"];
		often, we might store this directly as JSON in the database
		but it can be split up and put in fields as follows
		$assoc = json_decode($data, true); // true for assoc array if desired
	command is what to do with the data and will be encodeURI sent as variable command
		so for instance receive $command = $_POST["command"];
		this could have a value of "select", "add", "update", "delete", etc.
	extra is any extra filter information and will be encodeURI sent as variable extra
		so for instance receive $extra = $_POST["extra"];
		this could be an id or a search term
	call is the function to call and will receive (data, error) as parameters
		the data will automatically have JSON.parse() applied if in JSON format
put(url, data, call) - send and receive based on PUT
	put sends data in the body of the file
	the url will not have parameters but rather use the data
	the data will automatically have JSON.stringify() applied
	in PHP access this with: $array = json_decode(file_get_contents('php://input'), true);
	call is the function to call and will receive (data, error) as parameters
	the data will automatically have JSON.parse() applied if in JSON format

PROPERTIES
master - get or set the master data being sent with each get() or post() (not put())
couple - get or set whether the POST data is coupled when sent and uncoupled when received (not get() and put())
lock - get or set the lock data being sent with each get() or post() (not put())
--*///+13.8
	zim.Ajax = function(master, couple, lock, unique) {
		z_d("13.8");
		var http = new XMLHttpRequest();

		this.master = master;
		this.couple = couple;
		this.lock = lock;
		this.unique = unique;
		var that = this;

		this.get = function(url, callback) {
			// add here in case property is changed
			var addMaster = !zot(that.master)?"&master="+encodeURI(master):"";
			var addLock = !zot(that.lock)?"&lock="+encodeURI(lock):"";
			var addUnique = that.unique?"&unique=true":"";
			http.open('GET', url+addMaster+addLock+addUnique, true);
			http.onload = function() {
				if (http.status==200) {
					if (callback) callback(zim.isJSON(http.responseText)?JSON.parse(http.responseText):http.responseText);
				} else {
					if (callback) callback(null, 'Error: '+http.status);
				}
			};
			http.send();
		};

		this.post = function(url, data, command, extra, callback) {
			var sig = "url, data, command, extra, callback";
			var duo; if (duo = zob(that.post, arguments, sig)) return duo;
			if (zot(url)) return;
			http.open('POST', url, true);
			http.setRequestHeader('Content-type', "application/x-www-form-urlencoded");
			http.onload = function() {
				var r = http.responseText;
				if (zim.isJSON(r)) {
					if (that.couple) r = zim.decouple(r);
					r = JSON.parse(r);
				}
				if (callback) callback(r);
				// callback(isJSON(http.responseText)?JSON.parse(http.responseText):http.responseText);
			};
			if (!zim.isJSON(data)) data = JSON.stringify(data);
			if (that.couple) data = zim.couple(data);
			var addMaster = !zot(that.master)?"&master="+encodeURIComponent(that.master):"";
			var addLock = !zot(that.lock)?"&lock="+encodeURIComponent(that.lock):"";
			var addUnique = that.unique?"&unique=true":"";
			var addCommand = !zot(command)?"&command="+encodeURIComponent(command):"";
			var addExtra = !zot(extra)?"&extra="+encodeURIComponent(extra):"";
			http.send("data="+encodeURIComponent(data)+addMaster+addLock+addCommand+addExtra+addUnique);
		};

		this.put = function(url, data, callback) {
			http.open('PUT', url, true);
			http.setRequestHeader('Content-type', 'application/json');
			http.onload = function() {
				if (callback) callback(zim.isJSON(http.responseText)?JSON.parse(http.responseText):that.http.responseText);
			};
			http.send(JSON.stringify(data));
		};
	};//-13.8

/*--
zim.Noise = function(seed)

Noise
zim class

DESCRIPTION
Noise creates OpenSimplex Noise: https://en.wikipedia.org/wiki/OpenSimplex_noise
Converted from https://www.npmjs.com/package/open-simplex-noise
See examples at https://zimjs.com/noise/
In general, this is special noise where the pixels relate to one another in a complex way.
This connection, lets us do things like create terrains or blobs, etc. that look organic.
There is 1D, 2D, 3D, and 4D noise where we pass in one value, two values, three values and four values.
We always get back a number between -1 and 1 and this result relates to the results around it.

1D - we can plot 1D by drawing line segments across the stage (x) and setting the y value to the result of simplex1D(x)
This makes a 2D mountain-like terrain across the stage

2D - if we keep the plot from the 1D but use 2D and change the second parameter, we can animate the line.
We just need to adjust the second parameter by a very small amount each time such as .005.
Or we can plot put the return value of simplex2D onto its x,y matching location in a Bitmap
mapping it to a greyscale to make a traditional noise pattern.
We can adjust the "size" of the noise by dividing the x and y values (frequency).
If we use the ZIM smoothStep() function we can smoothen these to make blobs.
We can also use the return value as height for 3D terrain.

3D - if we keep the traditional noise/blob pattern from the 2D but use simplex3D and animate the third parameter,
we can animate the 2D noise in time which looks great when we animate blobs!
This plotting is thousands of computations and will bog the computer if too big.

4D - will allow us to animate 3D values, etc.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// 1D Noise to make a jagged line across the stage
const noise = new Noise();
const shape = new Shape(W, H)
	.addTo().s("black").ss(2).mt(0, H/2);
loop(W/50, i=>{
	shape.lt((i+1)*50, H/2 + noise.simplex1D(i)*200);
});
// the above can be animated by using simplex2D and animating the second number by small amounts
END EXAMPLE

EXAMPLE
// 2D noise
// create a Noise object:
const noise = new Noise();

// create an empty Bitmap size 200, 200 into which to draw the noise
const bmp = new Bitmap(null, 200, 200).center();

// we fill the bitmap starting from top left going across in the inner loop,
// then down, then across, etc. until we get to bottom right.
for (let y = 0; y < bmp.height; y++) {
	for (let x = 0; x < bmp.width; x++) {
		// the noise methods return a number from -1 to 1
		// by adding 1 we get a number between 0 and 2 and we divide by 2 to get 0-1
		// and we multiply this by 255 to get a number between 0 and 255
		let value = (noise.simplex2D(x,y)+1)/2 * 255;
		// imageData is one big array with four values per pixel
		// the red, green, blue and alpha
		// each value will constrained to between 0 and 255
		// the i value is how many on the current row plus the columns from the previous rows
		// and we set it to increase by 4 each time giving us a place for each color and alpha
		// We write the same value for red, green, blue to get a shade of grey
		let i = (x + y * bmp.width) * 4;
		bmp.imageData.data[i] = value; // red (0-255)
		bmp.imageData.data[i + 1] = value; // green (0-255)
		bmp.imageData.data[i + 2] = value; // blue (0-255)
		bmp.imageData.data[i + 3] = 255; // alpha (0-255)
	}
}
bmp.drawImageData(); // this draws the imageData to the Bitmap

// Here is the same example to get blobs using smoothStep:

const f = 25; // try changing this number around
for (let y = 0; y < bmp.height; y++) {
	for (let x = 0; x < bmp.width; x++) {
		let value = (noise.simplex2D(x/f, y/f)+1)/2; // 0-1
		// smoothStep sets less than .3 to 0 and greater than .35 to 1
		// and transitions between using an easing formula in the shape of an f
		value = smoothStep(value, .3, .35) * 255;
		let i = (x + y * bmp.width) * 4;
		bmp.imageData.data[i] = value; // red (0-255)
		bmp.imageData.data[i + 1] = value; // green (0-255)
		bmp.imageData.data[i + 2] = value; // blue (0-255)
		bmp.imageData.data[i + 3] = 255; // alpha (0-255)
	}
}
bmp.drawImageData();
END EXAMPLE

PARAMETERS
seed - (default Math.random()*1000000) keeping the same seed can remake a pattern the same

METHODS
simplex1D(x) - returns a noise value between -1 and 1
	In each method, the noise value relates to its neighbor rather than a completely random value
simplex2D(x,y) - returns a noise value between -1 and 1
simplex3D(x,y,z) - returns a noise value between -1 and 1
simplex4D(x,y,z,w) - returns a noise value between -1 and 1

PROPERTIES
seed - read only - the seed that was used for the Noise object
--*///+13.9
	zim.Noise = function(seed) {
		"use strict";
		z_d("13.9");

		if (zot(seed)) seed = Math.random()*1000000;
		var clientSeed = seed;
		this.seed = seed;

		var that = this;

		var con = {}; // holds the constants
		con.NORM_2D = 1.0 / 47.0;
		con.NORM_3D = 1.0 / 103.0;
		con.NORM_4D = 1.0 / 30.0;
		con.SQUISH_2D = (Math.sqrt(2 + 1) - 1) / 2;
		con.SQUISH_3D = (Math.sqrt(3 + 1) - 1) / 3;
		con.SQUISH_4D = (Math.sqrt(4 + 1) - 1) / 4;
		con.STRETCH_2D = (1 / Math.sqrt(2 + 1) - 1) / 2;
		con.STRETCH_3D = (1 / Math.sqrt(3 + 1) - 1) / 3;
		con.STRETCH_4D = (1 / Math.sqrt(4 + 1) - 1) / 4;
		con.base2D = [
			[1, 1, 0, 1, 0, 1, 0, 0, 0],
			[1, 1, 0, 1, 0, 1, 2, 1, 1]
		];
		con.base3D = [
			[0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1],
			[2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1, 3, 1, 1, 1],
			[1, 1, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 2, 1, 1, 0, 2, 1, 0, 1, 2, 0, 1, 1]
		];
		con.base4D = [
			[0, 0, 0, 0, 0, 1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1],
			[3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 4, 1, 1, 1, 1],
			[
				1, 1, 0, 0, 0, 1, 0, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 1, 2, 1, 1, 0, 0, 2, 1, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 1,
				0, 2, 0, 1, 0, 1, 2, 0, 0, 1, 1
			],
			[
				3, 1, 1, 1, 0, 3, 1, 1, 0, 1, 3, 1, 0, 1, 1, 3, 0, 1, 1, 1, 2, 1, 1, 0, 0, 2, 1, 0, 1, 0, 2, 1, 0, 0, 1, 2, 0, 1, 1,
				0, 2, 0, 1, 0, 1, 2, 0, 0, 1, 1
			]
		];
		con.gradients2D = [5, 2, 2, 5, -5, 2, -2, 5, 5, -2, 2, -5, -5, -2, -2, -5];
		con.gradients3D = [
			-11, 4, 4, -4, 11, 4, -4, 4, 11,
			11, 4, 4, 4, 11, 4, 4, 4, 11,
			-11, -4, 4, -4, -11, 4, -4, -4, 11,
			11, -4, 4, 4, -11, 4, 4, -4, 11,
			-11, 4, -4, -4, 11, -4, -4, 4, -11,
			11, 4, -4, 4, 11, -4, 4, 4, -11,
			-11, -4, -4, -4, -11, -4, -4, -4, -11,
			11, -4, -4, 4, -11, -4, 4, -4, -11
		];
		con.gradients4D = [
			3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 3, 1, 1, 1, 1, 3,
			-3, 1, 1, 1, -1, 3, 1, 1, -1, 1, 3, 1, -1, 1, 1, 3,
			3, -1, 1, 1, 1, -3, 1, 1, 1, -1, 3, 1, 1, -1, 1, 3,
			-3, -1, 1, 1, -1, -3, 1, 1, -1, -1, 3, 1, -1, -1, 1, 3,
			3, 1, -1, 1, 1, 3, -1, 1, 1, 1, -3, 1, 1, 1, -1, 3,
			-3, 1, -1, 1, -1, 3, -1, 1, -1, 1, -3, 1, -1, 1, -1, 3,
			3, -1, -1, 1, 1, -3, -1, 1, 1, -1, -3, 1, 1, -1, -1, 3,
			-3, -1, -1, 1, -1, -3, -1, 1, -1, -1, -3, 1, -1, -1, -1, 3,
			3, 1, 1, -1, 1, 3, 1, -1, 1, 1, 3, -1, 1, 1, 1, -3,
			-3, 1, 1, -1, -1, 3, 1, -1, -1, 1, 3, -1, -1, 1, 1, -3,
			3, -1, 1, -1, 1, -3, 1, -1, 1, -1, 3, -1, 1, -1, 1, -3,
			-3, -1, 1, -1, -1, -3, 1, -1, -1, -1, 3, -1, -1, -1, 1, -3,
			3, 1, -1, -1, 1, 3, -1, -1, 1, 1, -3, -1, 1, 1, -1, -3,
			-3, 1, -1, -1, -1, 3, -1, -1, -1, 1, -3, -1, -1, 1, -1, -3,
			3, -1, -1, -1, 1, -3, -1, -1, 1, -1, -3, -1, 1, -1, -1, -3,
			-3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -3, -1, -1, -1, -1, -3
		];
		con.lookupPairs2D = [0, 1, 1, 0, 4, 1, 17, 0, 20, 2, 21, 2, 22, 5, 23, 5, 26, 4, 39, 3, 42, 4, 43, 3];
		con.lookupPairs3D = [
			0, 2, 1, 1, 2, 2, 5, 1, 6, 0, 7, 0, 32, 2, 34, 2, 129, 1, 133, 1, 160, 5, 161, 5, 518, 0, 519, 0, 546, 4, 550, 4, 645,
			3, 647, 3, 672, 5, 673, 5, 674, 4, 677, 3, 678, 4, 679, 3, 680, 13, 681, 13, 682, 12, 685, 14, 686, 12, 687, 14, 712,
			20, 714, 18, 809, 21, 813, 23, 840, 20, 841, 21, 1198, 19, 1199, 22, 1226, 18, 1230, 19, 1325, 23, 1327, 22, 1352, 15,
			1353, 17, 1354, 15, 1357, 17, 1358, 16, 1359, 16, 1360, 11, 1361, 10, 1362, 11, 1365, 10, 1366, 9, 1367, 9, 1392, 11,
			1394, 11, 1489, 10, 1493, 10, 1520, 8, 1521, 8, 1878, 9, 1879, 9, 1906, 7, 1910, 7, 2005, 6, 2007, 6, 2032, 8, 2033,
			8, 2034, 7, 2037, 6, 2038, 7, 2039, 6
		];
		con.lookupPairs4D = [
			0, 3, 1, 2, 2, 3, 5, 2, 6, 1, 7, 1, 8, 3, 9, 2, 10, 3, 13, 2, 16, 3, 18, 3, 22, 1, 23, 1, 24, 3, 26, 3, 33, 2, 37, 2,
			38, 1, 39, 1, 41, 2, 45, 2, 54, 1, 55, 1, 56, 0, 57, 0, 58, 0, 59, 0, 60, 0, 61, 0, 62, 0, 63, 0, 256, 3, 258, 3, 264,
			3, 266, 3, 272, 3, 274, 3, 280, 3, 282, 3, 2049, 2, 2053, 2, 2057, 2, 2061, 2, 2081, 2, 2085, 2, 2089, 2, 2093, 2,
			2304, 9, 2305, 9, 2312, 9, 2313, 9, 16390, 1, 16391, 1, 16406, 1, 16407, 1, 16422, 1, 16423, 1, 16438, 1, 16439, 1,
			16642, 8, 16646, 8, 16658, 8, 16662, 8, 18437, 6, 18439, 6, 18469, 6, 18471, 6, 18688, 9, 18689, 9, 18690, 8, 18693,
			6, 18694, 8, 18695, 6, 18696, 9, 18697, 9, 18706, 8, 18710, 8, 18725, 6, 18727, 6, 131128, 0, 131129, 0, 131130, 0,
			131131, 0, 131132, 0, 131133, 0, 131134, 0, 131135, 0, 131352, 7, 131354, 7, 131384, 7, 131386, 7, 133161, 5, 133165,
			5, 133177, 5, 133181, 5, 133376, 9, 133377, 9, 133384, 9, 133385, 9, 133400, 7, 133402, 7, 133417, 5, 133421, 5,
			133432, 7, 133433, 5, 133434, 7, 133437, 5, 147510, 4, 147511, 4, 147518, 4, 147519, 4, 147714, 8, 147718, 8, 147730,
			8, 147734, 8, 147736, 7, 147738, 7, 147766, 4, 147767, 4, 147768, 7, 147770, 7, 147774, 4, 147775, 4, 149509, 6,
			149511, 6, 149541, 6, 149543, 6, 149545, 5, 149549, 5, 149558, 4, 149559, 4, 149561, 5, 149565, 5, 149566, 4, 149567,
			4, 149760, 9, 149761, 9, 149762, 8, 149765, 6, 149766, 8, 149767, 6, 149768, 9, 149769, 9, 149778, 8, 149782, 8,
			149784, 7, 149786, 7, 149797, 6, 149799, 6, 149801, 5, 149805, 5, 149814, 4, 149815, 4, 149816, 7, 149817, 5, 149818,
			7, 149821, 5, 149822, 4, 149823, 4, 149824, 37, 149825, 37, 149826, 36, 149829, 34, 149830, 36, 149831, 34, 149832,
			37, 149833, 37, 149842, 36, 149846, 36, 149848, 35, 149850, 35, 149861, 34, 149863, 34, 149865, 33, 149869, 33,
			149878, 32, 149879, 32, 149880, 35, 149881, 33, 149882, 35, 149885, 33, 149886, 32, 149887, 32, 150080, 49, 150082,
			48, 150088, 49, 150098, 48, 150104, 47, 150106, 47, 151873, 46, 151877, 45, 151881, 46, 151909, 45, 151913, 44,
			151917, 44, 152128, 49, 152129, 46, 152136, 49, 152137, 46, 166214, 43, 166215, 42, 166230, 43, 166247, 42, 166262,
			41, 166263, 41, 166466, 48, 166470, 43, 166482, 48, 166486, 43, 168261, 45, 168263, 42, 168293, 45, 168295, 42,
			168512, 31, 168513, 28, 168514, 31, 168517, 28, 168518, 25, 168519, 25, 280952, 40, 280953, 39, 280954, 40, 280957,
			39, 280958, 38, 280959, 38, 281176, 47, 281178, 47, 281208, 40, 281210, 40, 282985, 44, 282989, 44, 283001, 39,
			283005, 39, 283208, 30, 283209, 27, 283224, 30, 283241, 27, 283256, 22, 283257, 22, 297334, 41, 297335, 41, 297342,
			38, 297343, 38, 297554, 29, 297558, 24, 297562, 29, 297590, 24, 297594, 21, 297598, 21, 299365, 26, 299367, 23,
			299373, 26, 299383, 23, 299389, 20, 299391, 20, 299584, 31, 299585, 28, 299586, 31, 299589, 28, 299590, 25, 299591,
			25, 299592, 30, 299593, 27, 299602, 29, 299606, 24, 299608, 30, 299610, 29, 299621, 26, 299623, 23, 299625, 27,
			299629, 26, 299638, 24, 299639, 23, 299640, 22, 299641, 22, 299642, 21, 299645, 20, 299646, 21, 299647, 20, 299648,
			61, 299649, 60, 299650, 61, 299653, 60, 299654, 59, 299655, 59, 299656, 58, 299657, 57, 299666, 55, 299670, 54,
			299672, 58, 299674, 55, 299685, 52, 299687, 51, 299689, 57, 299693, 52, 299702, 54, 299703, 51, 299704, 56, 299705,
			56, 299706, 53, 299709, 50, 299710, 53, 299711, 50, 299904, 61, 299906, 61, 299912, 58, 299922, 55, 299928, 58,
			299930, 55, 301697, 60, 301701, 60, 301705, 57, 301733, 52, 301737, 57, 301741, 52, 301952, 79, 301953, 79, 301960,
			76, 301961, 76, 316038, 59, 316039, 59, 316054, 54, 316071, 51, 316086, 54, 316087, 51, 316290, 78, 316294, 78,
			316306, 73, 316310, 73, 318085, 77, 318087, 77, 318117, 70, 318119, 70, 318336, 79, 318337, 79, 318338, 78, 318341,
			77, 318342, 78, 318343, 77, 430776, 56, 430777, 56, 430778, 53, 430781, 50, 430782, 53, 430783, 50, 431000, 75,
			431002, 72, 431032, 75, 431034, 72, 432809, 74, 432813, 69, 432825, 74, 432829, 69, 433032, 76, 433033, 76, 433048,
			75, 433065, 74, 433080, 75, 433081, 74, 447158, 71, 447159, 68, 447166, 71, 447167, 68, 447378, 73, 447382, 73,
			447386, 72, 447414, 71, 447418, 72, 447422, 71, 449189, 70, 449191, 70, 449197, 69, 449207, 68, 449213, 69, 449215,
			68, 449408, 67, 449409, 67, 449410, 66, 449413, 64, 449414, 66, 449415, 64, 449416, 67, 449417, 67, 449426, 66,
			449430, 66, 449432, 65, 449434, 65, 449445, 64, 449447, 64, 449449, 63, 449453, 63, 449462, 62, 449463, 62, 449464,
			65, 449465, 63, 449466, 65, 449469, 63, 449470, 62, 449471, 62, 449472, 19, 449473, 19, 449474, 18, 449477, 16,
			449478, 18, 449479, 16, 449480, 19, 449481, 19, 449490, 18, 449494, 18, 449496, 17, 449498, 17, 449509, 16, 449511,
			16, 449513, 15, 449517, 15, 449526, 14, 449527, 14, 449528, 17, 449529, 15, 449530, 17, 449533, 15, 449534, 14,
			449535, 14, 449728, 19, 449729, 19, 449730, 18, 449734, 18, 449736, 19, 449737, 19, 449746, 18, 449750, 18, 449752,
			17, 449754, 17, 449784, 17, 449786, 17, 451520, 19, 451521, 19, 451525, 16, 451527, 16, 451528, 19, 451529, 19,
			451557, 16, 451559, 16, 451561, 15, 451565, 15, 451577, 15, 451581, 15, 451776, 19, 451777, 19, 451784, 19, 451785,
			19, 465858, 18, 465861, 16, 465862, 18, 465863, 16, 465874, 18, 465878, 18, 465893, 16, 465895, 16, 465910, 14,
			465911, 14, 465918, 14, 465919, 14, 466114, 18, 466118, 18, 466130, 18, 466134, 18, 467909, 16, 467911, 16, 467941,
			16, 467943, 16, 468160, 13, 468161, 13, 468162, 13, 468163, 13, 468164, 13, 468165, 13, 468166, 13, 468167, 13,
			580568, 17, 580570, 17, 580585, 15, 580589, 15, 580598, 14, 580599, 14, 580600, 17, 580601, 15, 580602, 17, 580605,
			15, 580606, 14, 580607, 14, 580824, 17, 580826, 17, 580856, 17, 580858, 17, 582633, 15, 582637, 15, 582649, 15,
			582653, 15, 582856, 12, 582857, 12, 582872, 12, 582873, 12, 582888, 12, 582889, 12, 582904, 12, 582905, 12, 596982,
			14, 596983, 14, 596990, 14, 596991, 14, 597202, 11, 597206, 11, 597210, 11, 597214, 11, 597234, 11, 597238, 11,
			597242, 11, 597246, 11, 599013, 10, 599015, 10, 599021, 10, 599023, 10, 599029, 10, 599031, 10, 599037, 10, 599039,
			10, 599232, 13, 599233, 13, 599234, 13, 599235, 13, 599236, 13, 599237, 13, 599238, 13, 599239, 13, 599240, 12,
			599241, 12, 599250, 11, 599254, 11, 599256, 12, 599257, 12, 599258, 11, 599262, 11, 599269, 10, 599271, 10, 599272,
			12, 599273, 12, 599277, 10, 599279, 10, 599282, 11, 599285, 10, 599286, 11, 599287, 10, 599288, 12, 599289, 12,
			599290, 11, 599293, 10, 599294, 11, 599295, 10
		];
		con.p2D = [0, 0, 1, -1, 0, 0, -1, 1, 0, 2, 1, 1, 1, 2, 2, 0, 1, 2, 0, 2, 1, 0, 0, 0];
		con.p3D = [
			0, 0, 1, -1, 0, 0, 1, 0, -1, 0, 0, -1, 1, 0, 0, 0, 1, -1, 0, 0, -1, 0, 1, 0, 0, -1, 1, 0, 2, 1, 1, 0, 1, 1, 1, -1, 0,
			2, 1, 0, 1, 1, 1, -1, 1, 0, 2, 0, 1, 1, 1, -1, 1, 1, 1, 3, 2, 1, 0, 3, 1, 2, 0, 1, 3, 2, 0, 1, 3, 1, 0, 2, 1, 3, 0, 2,
			1, 3, 0, 1, 2, 1, 1, 1, 0, 0, 2, 2, 0, 0, 1, 1, 0, 1, 0, 2, 0, 2, 0, 1, 1, 0, 0, 1, 2, 0, 0, 2, 2, 0, 0, 0, 0, 1, 1,
			-1, 1, 2, 0, 0, 0, 0, 1, -1, 1, 1, 2, 0, 0, 0, 0, 1, 1, 1, -1, 2, 3, 1, 1, 1, 2, 0, 0, 2, 2, 3, 1, 1, 1, 2, 2, 0, 0,
			2, 3, 1, 1, 1, 2, 0, 2, 0, 2, 1, 1, -1, 1, 2, 0, 0, 2, 2, 1, 1, -1, 1, 2, 2, 0, 0, 2, 1, -1, 1, 1, 2, 0, 0, 2, 2, 1,
			-1, 1, 1, 2, 0, 2, 0, 2, 1, 1, 1, -1, 2, 2, 0, 0, 2, 1, 1, 1, -1, 2, 0, 2, 0
		];
		con.p4D = [
			0, 0, 1, -1, 0, 0, 0, 1, 0, -1, 0, 0, 1, 0, 0, -1, 0, 0, -1, 1, 0, 0, 0, 0, 1, -1, 0, 0, 0, 1, 0, -1, 0, 0, -1, 0, 1,
			0, 0, 0, -1, 1, 0, 0, 0, 0, 1, -1, 0, 0, -1, 0, 0, 1, 0, 0, -1, 0, 1, 0, 0, 0, -1, 1, 0, 2, 1, 1, 0, 0, 1, 1, 1, -1,
			0, 1, 1, 1, 0, -1, 0, 2, 1, 0, 1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 0, 2, 0, 1, 1, 0, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1,
			0, 2, 1, 0, 0, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 0, 2, 0, 1, 0, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 0, 2, 0, 0, 1, 1,
			1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 1, 4, 2, 1, 1, 0, 4, 1, 2, 1, 0, 4, 1, 1, 2, 0, 1, 4, 2, 1, 0, 1, 4, 1, 2, 0, 1, 4, 1,
			1, 0, 2, 1, 4, 2, 0, 1, 1, 4, 1, 0, 2, 1, 4, 1, 0, 1, 2, 1, 4, 0, 2, 1, 1, 4, 0, 1, 2, 1, 4, 0, 1, 1, 2, 1, 2, 1, 1,
			0, 0, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 1, 2, 1, 0, 1, 0, 3, 2, 0, 1, 0, 3, 1, 0, 2, 0, 1, 2, 0, 1, 1, 0, 3, 0, 2, 1, 0,
			3, 0, 1, 2, 0, 1, 2, 1, 0, 0, 1, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 1, 2, 0, 1, 0, 1, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 1, 2,
			0, 0, 1, 1, 3, 0, 0, 2, 1, 3, 0, 0, 1, 2, 2, 3, 1, 1, 1, 0, 2, 1, 1, 1, -1, 2, 2, 0, 0, 0, 2, 3, 1, 1, 0, 1, 2, 1, 1,
			-1, 1, 2, 2, 0, 0, 0, 2, 3, 1, 0, 1, 1, 2, 1, -1, 1, 1, 2, 2, 0, 0, 0, 2, 3, 1, 1, 1, 0, 2, 1, 1, 1, -1, 2, 0, 2, 0,
			0, 2, 3, 1, 1, 0, 1, 2, 1, 1, -1, 1, 2, 0, 2, 0, 0, 2, 3, 0, 1, 1, 1, 2, -1, 1, 1, 1, 2, 0, 2, 0, 0, 2, 3, 1, 1, 1, 0,
			2, 1, 1, 1, -1, 2, 0, 0, 2, 0, 2, 3, 1, 0, 1, 1, 2, 1, -1, 1, 1, 2, 0, 0, 2, 0, 2, 3, 0, 1, 1, 1, 2, -1, 1, 1, 1, 2,
			0, 0, 2, 0, 2, 3, 1, 1, 0, 1, 2, 1, 1, -1, 1, 2, 0, 0, 0, 2, 2, 3, 1, 0, 1, 1, 2, 1, -1, 1, 1, 2, 0, 0, 0, 2, 2, 3, 0,
			1, 1, 1, 2, -1, 1, 1, 1, 2, 0, 0, 0, 2, 2, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 0, 0, 0, 0, 0, 2, 1, 1, -1, 1, 0, 1, 1, 0,
			1, -1, 0, 0, 0, 0, 0, 2, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1, 0, 0, 0, 0, 0, 2, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 0, 0, 0, 0,
			0, 2, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 0, 0, 0, 0, 0, 2, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 0, 0, 0, 0, 0, 2, 1, 1, 1, -1,
			0, 1, 1, 1, 0, -1, 2, 2, 0, 0, 0, 2, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 2, 2, 0, 0, 0, 2, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1,
			2, 2, 0, 0, 0, 2, 1, 1, 1, -1, 0, 1, 1, 1, 0, -1, 2, 0, 2, 0, 0, 2, 1, -1, 1, 1, 0, 1, 0, 1, 1, -1, 2, 0, 2, 0, 0, 2,
			1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 2, 0, 2, 0, 0, 2, 1, 1, -1, 1, 0, 1, 1, 0, 1, -1, 2, 0, 0, 2, 0, 2, 1, -1, 1, 1, 0, 1,
			0, 1, 1, -1, 2, 0, 0, 2, 0, 2, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 2, 0, 0, 2, 0, 2, 1, 1, -1, 0, 1, 1, 1, 0, -1, 1, 2, 0,
			0, 0, 2, 2, 1, -1, 1, 0, 1, 1, 0, 1, -1, 1, 2, 0, 0, 0, 2, 2, 1, -1, 0, 1, 1, 1, 0, -1, 1, 1, 2, 0, 0, 0, 2, 3, 1, 1,
			0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 1, 1, -1, 3, 1, 0, 1, 0, 0, 2, 0, 2, 0, 0, 2, 1, 1, 1, -1, 3, 1, 0, 0, 1, 0, 2, 0, 0, 2,
			0, 2, 1, 1, 1, -1, 3, 1, 1, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, 1, -1, 1, 3, 1, 0, 1, 0, 0, 2, 0, 2, 0, 0, 2, 1, 1, -1, 1,
			3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 2, 1, 1, -1, 1, 3, 1, 1, 0, 0, 0, 2, 2, 0, 0, 0, 2, 1, -1, 1, 1, 3, 1, 0, 0, 1, 0, 2,
			0, 0, 2, 0, 2, 1, -1, 1, 1, 3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 2, 1, -1, 1, 1, 3, 1, 0, 1, 0, 0, 2, 0, 2, 0, 0, 2, -1,
			1, 1, 1, 3, 1, 0, 0, 1, 0, 2, 0, 0, 2, 0, 2, -1, 1, 1, 1, 3, 1, 0, 0, 0, 1, 2, 0, 0, 0, 2, 2, -1, 1, 1, 1, 3, 3, 2, 1,
			0, 0, 3, 1, 2, 0, 0, 4, 1, 1, 1, 1, 3, 3, 2, 0, 1, 0, 3, 1, 0, 2, 0, 4, 1, 1, 1, 1, 3, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0,
			4, 1, 1, 1, 1, 3, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 4, 1, 1, 1, 1, 3, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 4, 1, 1, 1, 1, 3, 3,
			0, 0, 2, 1, 3, 0, 0, 1, 2, 4, 1, 1, 1, 1, 3, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 2, 1, 1, 1, -1, 3, 3, 2, 0, 1, 0, 3, 1, 0,
			2, 0, 2, 1, 1, 1, -1, 3, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0, 2, 1, 1, 1, -1, 3, 3, 2, 1, 0, 0, 3, 1, 2, 0, 0, 2, 1, 1, -1,
			1, 3, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 2, 1, 1, -1, 1, 3, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 2, 1, 1, -1, 1, 3, 3, 2, 0, 1, 0,
			3, 1, 0, 2, 0, 2, 1, -1, 1, 1, 3, 3, 2, 0, 0, 1, 3, 1, 0, 0, 2, 2, 1, -1, 1, 1, 3, 3, 0, 0, 2, 1, 3, 0, 0, 1, 2, 2,
			1, -1, 1, 1, 3, 3, 0, 2, 1, 0, 3, 0, 1, 2, 0, 2, -1, 1, 1, 1, 3, 3, 0, 2, 0, 1, 3, 0, 1, 0, 2, 2, -1, 1, 1, 1, 3, 3,
			0, 0, 2, 1, 3, 0, 0, 1, 2, 2, -1, 1, 1, 1
		];

		// helper classes

		function shuffleSeed(seed) {
			var newSeed = new Uint32Array(1);
			newSeed[0] = seed[0] * 1664525 + 1013904223;
			return newSeed;
		}

		function Contribution2(multiplier, xsb, ysb) {
			this.dx = -xsb - multiplier * con.SQUISH_2D;
			this.dy = -ysb - multiplier * con.SQUISH_2D;
			this.xsb = xsb;
			this.ysb = ysb;
		}

		function Contribution3(multiplier, xsb, ysb, zsb) {
			this.dx = -xsb - multiplier * con.SQUISH_3D;
			this.dy = -ysb - multiplier * con.SQUISH_3D;
			this.dz = -zsb - multiplier * con.SQUISH_3D;
			this.xsb = xsb;
			this.ysb = ysb;
			this.zsb = zsb;
		}

		function Contribution4(multiplier, xsb, ysb, zsb, wsb) {
			this.dx = -xsb - multiplier * con.SQUISH_4D;
			this.dy = -ysb - multiplier * con.SQUISH_4D;
			this.dz = -zsb - multiplier * con.SQUISH_4D;
			this.dw = -wsb - multiplier * con.SQUISH_4D;
			this.xsb = xsb;
			this.ysb = ysb;
			this.zsb = zsb;
			this.wsb = wsb;
		}

		// initialize

		var contributions2D = [];
		var i,k,r,baseSet,previous,current;
		for (i = 0; i < con.p2D.length; i += 4) {
			baseSet = con.base2D[con.p2D[i]];
			previous = null;
			current = null;
			for (k = 0; k < baseSet.length; k += 3) {
				current = new Contribution2(baseSet[k], baseSet[k + 1], baseSet[k + 2]);
				if (previous === null)
					contributions2D[i / 4] = current;
				else
					previous.next = current;
				previous = current;
			}
			current.next = new Contribution2(con.p2D[i + 1], con.p2D[i + 2], con.p2D[i + 3]);
		}
		this.lookup2D = [];
		for (i = 0; i < con.lookupPairs2D.length; i += 2) {
			this.lookup2D[con.lookupPairs2D[i]] = contributions2D[con.lookupPairs2D[i + 1]];
		}
		var contributions3D = [];
		for (i = 0; i < con.p3D.length; i += 9) {
			baseSet = con.base3D[con.p3D[i]];
			previous = null;
			current = null;
			for (k = 0; k < baseSet.length; k += 4) {
				current = new Contribution3(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3]);
				if (previous === null)
					contributions3D[i / 9] = current;
				else
					previous.next = current;
				previous = current;
			}
			current.next = new Contribution3(con.p3D[i + 1], con.p3D[i + 2], con.p3D[i + 3], con.p3D[i + 4]);
			current.next.next = new Contribution3(con.p3D[i + 5], con.p3D[i + 6], con.p3D[i + 7], con.p3D[i + 8]);
		}
		this.lookup3D = [];
		for (i = 0; i < con.lookupPairs3D.length; i += 2) {
			this.lookup3D[con.lookupPairs3D[i]] = contributions3D[con.lookupPairs3D[i + 1]];
		}
		var contributions4D = [];
		for (i = 0; i < con.p4D.length; i += 16) {
			baseSet = con.base4D[con.p4D[i]];
			previous = null;
			current = null;
			for (k = 0; k < baseSet.length; k += 5) {
				current = new Contribution4(baseSet[k], baseSet[k + 1], baseSet[k + 2], baseSet[k + 3], baseSet[k + 4]);
				if (previous === null)
					contributions4D[i / 16] = current;
				else
					previous.next = current;
				previous = current;
			}
			current.next = new Contribution4(con.p4D[i + 1], con.p4D[i + 2], con.p4D[i + 3], con.p4D[i + 4], con.p4D[i + 5]);
			current.next.next = new Contribution4(con.p4D[i + 6], con.p4D[i + 7], con.p4D[i + 8], con.p4D[i + 9], con.p4D[i + 10]);
			current.next.next.next = new Contribution4(con.p4D[i + 11], con.p4D[i + 12], con.p4D[i + 13], con.p4D[i + 14], con.p4D[i + 15]);
		}
		this.lookup4D = [];
		for (i = 0; i < con.lookupPairs4D.length; i += 2) {
			this.lookup4D[con.lookupPairs4D[i]] = contributions4D[con.lookupPairs4D[i + 1]];
		}

		// end initialize

		this.perm = new Uint8Array(256);
		this.perm2D = new Uint8Array(256);
		this.perm3D = new Uint8Array(256);
		this.perm4D = new Uint8Array(256);
		var source = new Uint8Array(256);
		for (i = 0; i < 256; i++) {
			source[i] = i;
		}
		seed = new Uint32Array(1);
		seed[0] = clientSeed;
		seed = shuffleSeed(shuffleSeed(shuffleSeed(seed)));
		for (i = 255; i >= 0; i--) {
			seed = shuffleSeed(seed);
			r = new Uint32Array(1);
			r[0] = (seed[0] + 31) % (i + 1);
			if (r[0] < 0)
				r[0] += (i + 1);
			this.perm[i] = source[r[0]];
			this.perm2D[i] = this.perm[i] & 0x0E;
			this.perm3D[i] = (this.perm[i] % 24) * 3;
			this.perm4D[i] = this.perm[i] & 0xFC;
			source[r[0]] = source[i];
		}

		this.simplex1D = function(x) {
			return that.simplex2D(x, 1);
		};

		this.simplex2D = function (x, y) {
			var stretchOffset = (x + y) * con.STRETCH_2D;
			var _a = [x + stretchOffset, y + stretchOffset], xs = _a[0], ys = _a[1];
			var _b = [Math.floor(xs), Math.floor(ys)], xsb = _b[0], ysb = _b[1];
			var squishOffset = (xsb + ysb) * con.SQUISH_2D;
			var _c = [x - (xsb + squishOffset), y - (ysb + squishOffset)], dx0 = _c[0], dy0 = _c[1];
			var _d = [xs - xsb, ys - ysb], xins = _d[0], yins = _d[1];
			var inSum = xins + yins;
			var hashVals = new Uint32Array(4);
			hashVals[0] = xins - yins + 1;
			hashVals[1] = inSum;
			hashVals[2] = inSum + yins;
			hashVals[3] = inSum + xins;
			var hash = hashVals[0] | (hashVals[1] << 1) | (hashVals[2] << 2) | (hashVals[3] << 4);
			var c = that.lookup2D[hash];
			var value = 0.0;
			while (typeof c !== 'undefined') {
				var _e = [dx0 + c.dx, dy0 + c.dy], dx = _e[0], dy = _e[1];
				var attn = 2 - dx * dx - dy * dy;
				if (attn > 0) {
					var _f = [xsb + c.xsb, ysb + c.ysb], px = _f[0], py = _f[1];
					var i = that.perm2D[(that.perm[px & 0xFF] + py) & 0xFF];
					var valuePart = con.gradients2D[i] * dx + con.gradients2D[i + 1] * dy;
					attn *= attn;
					value += attn * attn * valuePart;
				}
				c = c.next;
			}
			return value * con.NORM_2D;
		};

		this.simplex3D = function (x, y, z) {
			var stretchOffset = (x + y + z) * con.STRETCH_3D;
			var _a = [x + stretchOffset, y + stretchOffset, z + stretchOffset], xs = _a[0], ys = _a[1], zs = _a[2];
			var _b = [Math.floor(xs), Math.floor(ys), Math.floor(zs)], xsb = _b[0], ysb = _b[1], zsb = _b[2];
			var squishOffset = (xsb + ysb + zsb) * con.SQUISH_3D;
			var _c = [x - (xsb + squishOffset), y - (ysb + squishOffset), z - (zsb + squishOffset)], dx0 = _c[0], dy0 = _c[1], dz0 = _c[2];
			var _d = [xs - xsb, ys - ysb, zs - zsb], xins = _d[0], yins = _d[1], zins = _d[2];
			var inSum = xins + yins + zins;
			var hashVals = new Uint32Array(7);
			hashVals[0] = yins - zins + 1;
			hashVals[1] = xins - yins + 1;
			hashVals[2] = xins - zins + 1;
			hashVals[3] = inSum;
			hashVals[4] = inSum + zins;
			hashVals[5] = inSum + yins;
			hashVals[6] = inSum + xins;
			var hash = hashVals[0] | hashVals[1] << 1 | hashVals[2] << 2 | hashVals[3] << 3 | hashVals[4] << 5 |
				hashVals[5] << 7 | hashVals[6] << 9;
			var c = that.lookup3D[hash];
			var value = 0.0;
			while (typeof c !== 'undefined') {
				var _e = [dx0 + c.dx, dy0 + c.dy, dz0 + c.dz], dx = _e[0], dy = _e[1], dz = _e[2];
				var attn = 2 - dx * dx - dy * dy - dz * dz;
				if (attn > 0) {
					var _f = [xsb + c.xsb, ysb + c.ysb, zsb + c.zsb], px = _f[0], py = _f[1], pz = _f[2];
					var i = that.perm3D[(that.perm[(that.perm[px & 0xFF] + py) & 0xFF] + pz) & 0xFF];
					var valuePart = con.gradients3D[i] * dx + con.gradients3D[i + 1] * dy + con.gradients3D[i + 2] * dz;
					attn *= attn;
					value += attn * attn * valuePart;
				}
				c = c.next;
			}
			return value * con.NORM_3D;
		};

		this.simplex4D = function (x, y, z, w) {
			var stretchOffset = (x + y + z + w) * con.STRETCH_4D;
			var _a = [x + stretchOffset, y + stretchOffset, z + stretchOffset, w + stretchOffset], xs = _a[0], ys = _a[1], zs = _a[2], ws = _a[3];
			var _b = [Math.floor(xs), Math.floor(ys), Math.floor(zs), Math.floor(ws)], xsb = _b[0], ysb = _b[1], zsb = _b[2], wsb = _b[3];
			var squishOffset = (xsb + ysb + zsb + wsb) * con.SQUISH_4D;
			var dx0 = x - (xsb + squishOffset);
			var dy0 = y - (ysb + squishOffset);
			var dz0 = z - (zsb + squishOffset);
			var dw0 = w - (wsb + squishOffset);
			var _c = [xs - xsb, ys - ysb, zs - zsb, ws - wsb], xins = _c[0], yins = _c[1], zins = _c[2], wins = _c[3];
			var inSum = xins + yins + zins + wins;
			var hashVals = new Uint32Array(11);
			hashVals[0] = zins - wins + 1;
			hashVals[1] = yins - zins + 1;
			hashVals[2] = yins - wins + 1;
			hashVals[3] = xins - yins + 1;
			hashVals[4] = xins - zins + 1;
			hashVals[5] = xins - wins + 1;
			hashVals[6] = inSum << 6;
			hashVals[7] = inSum + wins;
			hashVals[8] = inSum + zins;
			hashVals[9] = inSum + yins;
			hashVals[10] = inSum + xins;
			var hash = hashVals[0] | hashVals[1] << 1 | hashVals[2] << 2 | hashVals[3] << 3 | hashVals[4] << 4 | hashVals[5] << 5 |
				hashVals[6] << 6 | hashVals[7] << 8 | hashVals[8] << 11 | hashVals[9] << 14 | hashVals[10] << 17;
			var c = that.lookup4D[hash];
			var value = 0.0;
			while (typeof c !== 'undefined') {
				var _d = [dx0 + c.dx, dy0 + c.dy, dz0 + c.dz, dw0 + c.dw], dx = _d[0], dy = _d[1], dz = _d[2], dw = _d[3];
				var attn = 2 - dx * dx - dy * dy - dz * dz - dw * dw;
				if (attn > 0) {
					var _e = [xsb + c.xsb, ysb + c.ysb, zsb + c.zsb, wsb + c.wsb], px = _e[0], py = _e[1], pz = _e[2], pw = _e[3];
					var i = that.perm4D[(that.perm[(that.perm[(that.perm[px & 0xFF] + py) & 0xFF] + pz) & 0xFF] + pw) & 0xFF];
					var valuePart = con.gradients4D[i] * dx + con.gradients4D[i + 1] * dy + con.gradients4D[i + 2] * dz + con.gradients4D[i + 3] * dw;
					attn *= attn;
					value += attn * attn * valuePart;
				}
				c = c.next;
			}
			return value * con.NORM_4D;
		};

	};//-13.9

/*--
zim.Point = function(x, y, z, q, r, s, t, u, v, w)

Point
zim class extends a createjs.Point

DESCRIPTION
Stores x, y, z, q, r, s, t, u, v, w properties.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const point = new Point(100, 100);
zog(point.x, point.y); // 100, 100
END EXAMPLE

PARAMETERS
x - (default 0) the x value of the point
y - (default 0) the y value of the point
z - (default 0) the z value of the point - probably not used
q - (default 0) the q value of the point - very probably not used
r - (default 0) the r value of the point - very probably not used
s - (default 0) the s value of the point - very probably not used
t - (default 0) the t value of the point - very probably not used
u - (default 0) the u value of the point - very probably not used
v - (default 0) the v value of the point - very probably not used
w - (default 0) the w value of the point - very probably not used

METHODS - thanks nycjoseph
** only when using the ZIM version of CreateJS
subtract(point) - subtracts the provided point from original point
	returns the resulting point
add(point) - adds the provided point to original point
	 returns the resulting point
angle(point) - gets an angle to the provided point
	returns the angle in degrees
length() - gets the length from 0,0 to the point	
	returns the length from 0,0 to the point
distance(point) - gets the distance to the provided point
	returns the resulting distance
project(angle, length) gets a point at an angle (degrees) and distance
	returns the resulting point
interpolate(point, number) gets a point at a ratio to the provided point
 	returns the resulting point
average(point) - gets a point half way to the provided point
	returns the resulting point

** these have been added to ZIM's CreateJS but in Radians 
also see CreateJS docs for setValues, copy and clone

PROPERTIES
x - the x value of the point
y - the y value of the point
z - the z value of the point - probably not used
q - the q value of the point - very probably not used
r - the r value of the point - very probably not used
s - the s value of the point - very probably not used
t - the t value of the point - very probably not used
u - the u value of the point - very probably not used
v - the v value of the point - very probably not used
w - the w value of the point - very probably not used
--*///+13.45
	if (typeof createjs != "undefined") {
		zim.Point = function(x, y, z, q, r, s, t, u, v, w) {
			z_d("13.45");
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(z)) z = 0;
			if (zot(q)) q = 0;
			if (zot(r)) r = 0;
			if (zot(s)) s = 0;
			if (zot(t)) t = 0;
			if (zot(u)) u = 0;
			if (zot(v)) v = 0;
			if (zot(w)) w = 0;
			this.createjsPoint_constructor(x,y);
			this.type = "Point";
			this.x = x;
			this.y = y;
			this.z = z;
			this.q = q;
			this.r = r;
			this.s = s;
			this.t = t;
			this.u = u;
			this.v = v;
			this.w = w;
			this.angle = function(point) {
				return this.createjsPoint_angle(point)*180/Math.PI;
			}
			this.project = function(angle, length) {
				return this.createjsPoint_project(angle*Math.PI/180, length);
			}
		};
		zim.extend(zim.Point, createjs.Point, ["angle","project"], "createjsPoint");
	}
	//-13.45
	
/*--
zim.Bezier = function(a, b, c, d)

Bezier
zim class

DESCRIPTION
Creates data for a Cubic Bezier to give x and y at a ratio of the curve
Also gives mx and my for a modified x and y that is more evenly spaced
Thanks Ivo Wetzel - StackExchange
Used internally by zim.getCurvePoint() used by Squiggle, Blob, Beads, and animate() in path

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const a = {x:100, y:100}; // start point
const b = {x:400, y:100}; // control point for start point
const c = {x:100, y:300}; // control point for end point
const d = {x:300, y:300}; // end point
const bezier = new Bezier(a,b,c,d);
new Shape().s(black).mt(a.x,a.y).bt(b.x,b.y, c.x,c.y, d.x,d.y).addTo();
loop(10, i=>{
	// original spacing
	// new Circle(5).loc(bezier.x(i/10), bezier.y(i/10));

	// modified spacing to be more even
	new Circle(5).loc(bezier.mx(i/10), bezier.my(i/10));
});
END EXAMPLE

PARAMETERS
// all parameters are points with x and y properties {x:val, y:val}
a - start point of Bezier curve
b - control point for the start point
c - control point for the end point
d - end point

METHODS
x(r) - the x position of a point at ratio r (0-1) on the curve
y(r) - the y position of a point at ratio r (0-1) on the curve
mx(r) - the evenly-spaced x position of a point at ratio r (0-1) on the curve
my(r) - the evenly-spaced y position of a point at ratio r (0-1) on the curve

PROPERTIES
a, b, c, d - the points passed in - each having x and y properties

--*///+13.47
	zim.Bezier = function Bezier(a, b, c, d) {
		z_d("13.47");
        this.a = a;
        this.b = b;
        this.c = c;
        this.d = d;

        this.len = 100;
        this.arcLengths = new Array(this.len + 1);
        this.arcLengths[0] = 0;

        var ox = this.x(0), oy = this.y(0), clen = 0;
        for(var i = 1; i <= this.len; i += 1) {
            var x = this.x(i * 0.01), y = this.y(i * 0.01);
            var dx = ox - x, dy = oy - y;
            clen += Math.sqrt(dx * dx + dy * dy);
            this.arcLengths[i] = clen;
            ox = x, oy = y;
        }
        this.length = clen;
    };

    zim.Bezier.prototype = {
        map: function(u) {
            var targetLength = u * this.arcLengths[this.len];
            var low = 0, high = this.len, index = 0;
            while (low < high) {
                index = low + (((high - low) / 2) | 0);
                if (this.arcLengths[index] < targetLength) {
                    low = index + 1;

                } else {
                    high = index;
                }
            }
            if (this.arcLengths[index] > targetLength) {
                index--;
            }

            var lengthBefore = this.arcLengths[index];
            if (lengthBefore === targetLength) {
                return index / this.len;

            } else {
                return (index + (targetLength - lengthBefore) / (this.arcLengths[index + 1] - lengthBefore)) / this.len;
            }
        },

        mx: function (u) {
            return this.x(this.map(u));
        },

        my: function (u) {
            return this.y(this.map(u));
        },

        x: function (t) {
            return ((1 - t) * (1 - t) * (1 - t)) * this.a.x
                   + 3 * ((1 - t) * (1 - t)) * t * this.b.x
                   + 3 * (1 - t) * (t * t) * this.c.x
                   + (t * t * t) * this.d.x;
        },

        y: function (t) {
            return ((1 - t) * (1 - t) * (1 - t)) * this.a.y
                   + 3 * ((1 - t) * (1 - t)) * t * this.b.y
                   + 3 * (1 - t) * (t * t) * this.c.y
                   + (t * t * t) * this.d.y;
        }
    };//-13.47

/*--
zim.Boundary = function(x|bounds, y, width, height)

Boundary
zim class

DESCRIPTION
Stores the data for a rectangle with x, y, width and height.
Can be used with ZIM drag(), gesture() for boundaries
and the Physics module for world boundary.

NOTE: A createjs.Rectangle or an object {} with x, y, width and height properties can also be used
Boundary was introduced to reduce confusion over having a ZIM Rectangle (Shape) and a CreateJS Rectangle (data)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Circle(100, blue)
	.center()
	.drag(new Boundary(0,0,W,H));
// note: drag and gesture used to have rect parameters
// these have now been depreciated and replaced with boundary parameters

// CONTRACT
// the drag() boundary contains the registration point
// note: the gesture() boundary contains the whole shape of the object
// here, we keep the circle inside the stage by contracting the Boundary by the radius
var radius = 100;
new Circle(radius, red)
	.center()
	.drag(new Boundary(0,0,W,H).contract(radius));
END EXAMPLE

PARAMETERS
x|bounds - the x position of the Boundary
	or pass in an object with {x,y,width,height} - such as obj.getBounds()
	this allows manipulation with contract if desired
	at which point, the other parameters are ignored
y - the y position of the Boundary
width - the width of the Boundary
height - the height of the Boundary

PROPERTIES
x - the x position of the Boundary
y - the y position of the Boundary
width - the width of the Boundary
height - the height of the Boundary

METHODS
contract(number|x, y, width, height) - number of pixels to make the Boundary smaller
	passing in a single number will contract this on all sides
	passing in two numbers will contract from horizontal and vertical accordingly
	passing in four numbers will contract from the sides accordingly (left, top, right, bottom)
	note: to expand pass in a negative number
	returns object for chaining
--*///+13.46
	zim.Boundary = function(x, y, width, height) {
		z_d("13.46");
		if (!zot(x.x)) { // a rectangle or getBounds() is provided
			height = x.height;
			width = x.width;
			y = x.y;
			x = x.x;
		}
		if (zot(x) || zot(y) || zot(width) || zot(height)) return;
		this.x = x;
		this.y = y;
		this.width = width;
		this.height = height;

		this.contract = function(a,b,c,d) {
			if (zot(a)) return this;
			if (zot(b)) b = a;
			if (zot(c)) {
				c = a*2;
			} else {
				c = c+a;
			}
			if (zot(d)) {
				d = b*2;
			} else {
				d = d+b;
			}
			this.x += a;
			this.y += b;
			this.width -= c;
			this.height -= d;
			return this;
		};
	};//-13.46

/*--
zim.GradientColor = function(colors, ratios|angle, x0, y0, x1, y1)

GradientColor
zim class

DESCRIPTION
Creates data for a Linear Gradient that can be used to color ZIM Shapes
like Circle, Rectangle, Triangle, Squiggle, Blob, Flare
and therefore all ZIM component background colors, etc.
Also see ZIM RadialColor and BitmapColor classes

NOTE: the base ZIM Shape class will need gradients applied as usual

NOTE: The chainable methods for linearGradient() and radialGradient() are depricated

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// linear gradient from pink to purple across whole gradient
// with the start at 0,0 and end at 0,500 - so from top to bottom
new Rectangle(1000, 500, new GradientColor([pink,purple], [0,1], 0,0, 0,500)).addTo();

// alternatively, a short version is provided
// this makes the gradient across the object at 90 degrees - so pointing down as 0 points to the right
new Rectangle(1000, 500, new GradientColor([pink,purple],90)).addTo();
END EXAMPLE 

EXAMPLE
// linear gradient with 30% pink transitioning to green at half way then to 30% pure pink
// along a horizontal path from 0 to 1000 in width
// could also go diagonal for instance 0,0,1000,500
new Rectangle(1000, 500, new GradientColor([pink,green,purple], [.3,.5,.7], 0,0, 1000,0)).addTo();

// alternatively, a short version is provided
// this makes the gradient across the object at the default 0 degrees - so pointing right
// so the angle can be provided instead of the the ratios as in the previous example 
// or the angle can be provided after the ratios to replace the x and y values 
new Rectangle(1000, 500, new GradientColor([pink,green,purple], [.3,.5,.7], 0).addTo();
// or better yet as the default angle is 0:
new Rectangle(1000, 500, new GradientColor([pink,green,purple], [.3,.5,.7]).addTo();
END EXAMPLE

PARAMETERS
colors - an Array of colors for the gradient, can be more than two
ratios|angle - an Array of 0-1 numbers reprenting the start position of transitions for the colors above
	or an angle with 0 (default) goes from left to the right
		20 would angle down slightly from left to right
		-20 would angle up slightly from left to right
		90 would point straight down 
		180 would go from right to left
		270 or -90 would go from the bottom to the top
	if an angle is provided then x0,x1,y0,y1 is ignored
	and the size of the object's bounds is used to scale the gradient
	if no value or an angle is provided the ratios will be divided evenly across the colors 
x0|angle - the x position to start the gradient
	if no further parameter values are provided then this will be the angle 
	see the ratios|angle parameter for information on angle
y0 - the y position to start the gradient
x1 - the x position to end the gradient
y1 - the y position to end the gradient

PROPERTIES
type - the type of color as a String
** the above parameters are all available as properties
** but will not change objects with their color already set
--*///+13.465
	zim.GradientColor = function(colors,ratios, x0,y0, x1,y1) {
		z_d("13.465");
		this.type = "GradientColor";
		this.colors = zot(colors)?["black","white"]:colors;
		if (!Array.isArray(this.colors)) this.colors = [this.colors, this.colors];
		if (this.colors.length==1) this.colors.push(this.colors[0]); // at least two colors
		this.ratios = zot(ratios)?0:ratios;
		if (!Array.isArray(this.ratios)) {
			this.angle = this.ratios;
			this.ratios = [];
			for (var i=0; i<this.colors.length; i++) {
				this.ratios.push(i/(this.colors.length-1))
			}
		}
		if (!zot(x0) && (zot(y0) || zot(x1) || zot(y1))) {
			this.angle = x0;
			x0 = null;
		} else if (zot(this.angle) && zot(x0) && zot(y0) && zot(x1) && zot(y1)) {
			this.angle = 0;
		} else {
			this.x0 = zot(x0)?0:x0;
			this.y0 = zot(y0)?0:y0;
			this.x1 = zot(x1)?0:x1;
			this.y1 = zot(y1)?100:y1;			
		}
	};//-13.465

/*--
zim.RadialColor = function(colors, ratios, x0, y0, r0, x1, y1, r1)

RadialColor
zim class

DESCRIPTION
Creates data for a Radial Gradient that can be used to color ZIM Shapes
like Circle, Rectangle, Triangle, Squiggle, Blob, Flare
and therefore all ZIM component background colors, etc.
Also see ZIM GradientColor and BitmapColor classes

NOTE: the base ZIM Shape class will need gradients applied as usual

NOTE: The chainable methods for linearGradient() and radialGradient() are depricated

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// radial gradient from pink in center to purple at edge
// with the start at 0,0,0 and end at 0,0,200 - so from radius to center
new Circle(200, new RadialColor([pink,purple], [0,1], 0,0,0, 0,0,200)).center();

// or a shortened version is provided:
new Circle(200, new RadialColor([pink,purple])).center();

// this shortened version also works
new Circle(200, new RadialColor([pink,green,purple], [0,.2,1])).center();

// this shortened version will apply the gradient out to the corners of the rectangle 
new Rectangle(200, 400, new RadialColor([pink,purple])).center();
END EXAMPLE 

EXAMPLE
// radial gradient from dark to light with alpha reduced
// start fading the light right away to 30% the gradient then use the dark
// move the center of the dark right and up and bigger than radius
// move the center of the light right and up and at 0
// this makes a moon with the dark shade at the bottom left
new Circle(100, new RadialColor(
	["rgba(0,0,0,.2)","rgba(255,255,255,.2)"],[0,.3], 50,-30,120, 40,-40,0)
).center()
END EXAMPLE

PARAMETERS
colors - an Array of colors for the gradient, can be more than two
ratios - an Array of 0-1 numbers reprenting the start position of transitions for the colors above
	if not provided, the ratio will be divided evenly across the provided colors
** the below parameters are optional and will be the center to the edge of the object if not provided
x0 - the x position to start the gradient
y0 - the y position to start the gradient
r0 - the radius at the start of the gradient
x1 - the x position to end the gradient
y1 - the y position to end the gradient
r1 - the radius at the end of the gradient

PROPERTIES
type - the type of color as a String
** the above parameters are all available as properties
** but will not change objects with their color already set
--*///+13.466
	zim.RadialColor = function(colors,ratios, x0,y0,r0, x1,y1,r1) {
		z_d("13.466");
		this.type = "RadialColor";
		this.colors = zot(colors)?["black","white"]:colors;
		if (!Array.isArray(this.colors)) this.colors = [this.colors, this.colors];
		if (this.colors.length==1) this.colors.push(this.colors[0]); // at least two colors
		this.ratios = ratios;
		if (!Array.isArray(this.ratios)) {
			this.ratios = [];
			for (var i=0; i<this.colors.length; i++) {
				this.ratios.push(i/(this.colors.length-1))
			}
		}
		this.x0 = x0;
		this.y0 = y0;
		this.r0 = r0;
		this.x1 = x1;
		this.y1 = y1;
		this.r1 = r1;
	};//-13.466

/*--
zim.BitmapColor = function(image, repetition, matrix)

BitmapColor
zim class

DESCRIPTION
Creates data for a Bitmap fill from a loaded asset
that can be used to color ZIM Shapes
like Circle, Rectangle, Triangle, Squiggle, Blob, Flare
and therefore all ZIM component background colors, etc.
Also see ZIM GradientColor and RadialColor classes

See: https://youtu.be/xgXVRSVVJTw?t=861

NOTE: the base ZIM Shape class will need a bitmap fill applied as usual

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const assets = "flecks.jpg";
const path = "https://zimjs.org/assets/";
new Frame(scaling, width, height, color, outerColor, ready, assets, path);
function ready() {
	new Rectangle(W, H, new BitmapColor("flecks.jpg")).addTo();
	// or use new Pic("flecks.jpg") instead of string "flecks.jpg" - but ZIM will figure it out
}
END EXAMPLE

PARAMETERS
image - a ZIM Bitmap() such as available with Pic() or asset()
	when asset is loaded with ZIM Frame or F.loadAssets()
	also accepts the string name of an asset that would go in the new Pic() or asset()
	may accept url to html image but image needs to be loaded first
	so would recommend usual ZIM asset loading
repetition - (default "repeat") the repeat of the Bitmap fill
	also "repeat-x", "repeat-y" or "no-repeat"
matrix - a transformation matrix to apply to the Bitmap

PROPERTIES
type - the type of color as a String
** the above parameters are all available as properties
** but will not change objects with their color already set
--*///+13.467
	zim.BitmapColor = function(image, repetition, matrix) {
		z_d("13.467");
		this.type = "BitmapColor";
		if (typeof image == "string" && WW.asset) image = WW.asset(image);
		if (image.type != "Bitmap" && image.bitmap) image = image.bitmap;
		this.image = image.type=="Bitmap"?image.image:image;
		this.repetition = repetition;
		this.matrix = matrix;
	};//-13.467

/*--
zim.Damp = function(startValue, damp)

Damp
zim class

DESCRIPTION
Damping emulates things slowing down due to friction.
The movement heads towards the right value and looks organic.
This is similar if not the same as easing out when tweening.
Create your Damp object outside an interval or Ticker
then inside an interval or ticker call the convert method.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const d = new Damp(parameters);
setInterval(()=>{
	dampedValue = d.convert(desiredValue);
}, 100);
END EXAMPLE

you would then apply that desired value to a property such as x or y or scale
if you want to do both x and y then you need two Damp objects
and two convert calls (you can do both in one interval or ticker)

EXAMPLE
const circle = new Circle();
circle.center();
const dampX = new Damp(circle.x);
const dampY = new Damp(circle.y);
// start moving once mouse enters stage
// this event will only run once (the last parameter is true)
S.on("stagemousemove", start, null, true);
function start() {
	Ticker.add(()=>{
		circle.x = dampX.convert(F.mouseX);
		circle.y = dampY.convert(F.mouseY);
	});
}
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
startValue - (default 0) start object at this value and then start damping
damp - (default .1) the damp value with 1 being no damping and 0 being no movement

METHODS
convert(value) - converts a value into a damped value
immediate(value) - immediately goes to value and returns the Damp object

PROPERTIES
damp - can dynamically change the damping (usually just pass it in as a parameter to start)
lastValue - setting this would go immediately to this value (would not normally use)
--*///+14
	zim.Damp = function(startValue, damp) {
		z_d("14");
		var sig = "startValue, damp";
		var duo; if (duo = zob(zim.Damp, arguments, sig, this)) return duo;
		this.lastValue = (zot(startValue)) ? 0 : startValue;
		this.damp = (zot(damp)) ? .1 : damp;
	};
	zim.Damp.prototype.convert = function(desiredValue) {
		return this.lastValue = this.lastValue + (desiredValue - this.lastValue) * this.damp;
	};
	zim.Damp.prototype.immediate = function(desiredValue) {
		this.lastValue = desiredValue;
		return this;
	};//-14

/*--
zim.Proportion = function(baseMin, baseMax, targetMin, targetMax, factor, targetRound, clamp)

Proportion
zim class

DESCRIPTION
Proportion converts an input value to an output value on a different scale.
(sometimes called a map() function)
For instance, like a slider controlling the scale of an object or sound volume.
Make a Proportion object and then in an interval, ticker or event,
convert the base value to the target value using the convert method.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
F.loadAssets("mySound.mp3");
F.on("complete", ()=>{
	// must have also interacted with app before playing sound
	const sound = new Aud("mySound.mp3").play();
	const p = new Proportion(0, 10, 0, 1);
	const dial = new Dial(); // default range of 0 to 10
	dial.currentValue = 10;
	dial.on("change", ()=>{
		sound.volume = p.convert(dial.currentValue);
	}); // end of dial change
}); // end sound loaded
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
baseMin - min for the input scale (say x value)
baseMax - max for the input scale (say x value)
targetMin - (default 0) min for the output scale (say volume)
targetMax - (default 1) max for the output scale (say volume)
factor - (default 1) is going the same direction and -1 is going in opposite direction
targetRound - (default false) set to true to round the converted number
clamp - (default true) set to false to let results go outside min and max range

METHODS
convert(input) - will return the output property (for instance, a volume)

NOTE: the object always starts by assuming baseMin as baseValue
just call the convert method right away if you want it to start at a different baseValue
for instance, if your slider went from 100 to 500 and you want to start at half way
make the object and call p.convert(300); on the next line
--*///+15
	zim.Proportion = function(baseMin, baseMax, targetMin, targetMax, factor, targetRound, clamp) {
		var sig = "baseMin, baseMax, targetMin, targetMax, factor, targetRound, clamp";
		var duo; if (duo = zob(zim.Proportion, arguments, sig, this)) return duo;
		z_d("15");
		// factor - set to 1 for increasing and -1 for decreasing
		// round - true to round results to whole number
		if (zot(targetMin)) targetMin = 0;
		if (zot(targetMax)) targetMax = 1;
		if (zot(factor)) factor = 1;
		if (zot(targetRound)) targetRound = false;
		if (zot(clamp)) clamp = true;

		// proportion
		var proportion;
		var targetAmount;

		this.convert = function(baseAmount) {
			if (zot(baseAmount)) baseAmount = baseMin; // just start at the min otherwise call immediate(baseValue);
			if (isNaN(baseAmount) || (baseMax-baseMin==0)) {return;}
			if (clamp) {
				baseAmount = Math.max(baseAmount, baseMin);
				baseAmount = Math.min(baseAmount, baseMax);
			}
			proportion = (baseAmount - baseMin) / (baseMax - baseMin);
			if (factor > 0) {
				targetAmount = targetMin + (targetMax-targetMin) * proportion;
			} else {
				targetAmount = targetMax - (targetMax-targetMin) * proportion;
			}
			if (targetRound) {targetAmount = Math.round(targetAmount);}
			return targetAmount;
		};
	};//-15

/*--
zim.ProportionDamp = function(baseMin, baseMax, targetMin, targetMax, damp, factor, targetRound, clamp)

ProportionDamp
zim class

DESCRIPTION
ProportionDamp converts an input value to an output value on a different scale with damping.
Works like Proportion Class but with a damping parameter.
Damping needs constant calculating so do not put in mousemove event.
The below example scales the circle based on the mouse height.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circle = new Circle(50, red);
circle.center(); // center method added in ZIM 4TH
const pd = new ProportionDamp(0, H, 0, 5, .2);
Ticker.add(()=>{
	circle.sca(pd.convert(S.mouseV)); // scale method added in ZIM 4TH
}, stage);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
baseMin - min for the input scale (say x value)
baseMax - max for the input scale (say x value)
targetMin - (default 0) min for the output scale (say volume)
targetMax - (default 1) max for the output scale (say volume)
damp - (default .1) the damp value with 1 being no damping and 0 being no movement
factor - (default 1) is going the same direction and -1 is going in opposite direction
targetRound - (default false) set to true to round the converted number
clamp - (default true) set to false to let results go outside min and max range

METHODS
convert(input) - converts a base value to a target value
immediate(input) - immediately uses the input to set the target value (no damping) and returns the ProportionDamp object
immediateValue(input) - immediately sets the target value (no damping) and returns the ProportionDamp object
dispose() - clears interval

PROPERTIES
damp - can adjust this dynamically (usually just pass it in as a parameter to start)

NOTE: the object always starts by assuming baseMin as baseValue
if you want to start or go to an immediate value without easing then
call the pd.immediate(baseValue) method with your desired baseValue (not targetValue)
--*///+16
	zim.ProportionDamp = function(baseMin, baseMax, targetMin, targetMax, damp, factor, targetRound, clamp) {
		var sig = "baseMin, baseMax, targetMin, targetMax, damp, factor, targetRound, clamp";
		var duo; if (duo = zob(zim.ProportionDamp, arguments, sig, this)) return duo;
		z_d("16");
		// damp - can be changed via damp get/set method property
		// factor - set to 1 for increasing and -1 for decreasing
		// round - true to round results to whole number
		// zot() is found in danzen.js (the z version of not)
		if (zot(targetMin)) targetMin = 0;
		if (zot(targetMax)) targetMax = 1;
		if (zot(damp)) damp = .1;
		if (zot(factor)) factor = 1;
		if (zot(targetRound)) targetRound = false;
		if (zot(clamp)) clamp = true;

		this.damp = damp; // want to expose as a property we can change
		var that = this;

		// proportion
		var baseAmount;
		var proportion;
		var targetDifference;
		var targetAmount;

		// damping
		var differenceAmount;
		var desiredAmount=0;
		var lastAmount = 0;

		baseAmount = baseMin; // just start at the min otherwise call immediate(baseValue);
		lastAmount = targetMin;

		var interval = setInterval(calculate, 20);

		function calculate() {
			if (isNaN(baseAmount) || (baseMax-baseMin==0)) {return;}

			if (clamp) {
				baseAmount = Math.max(baseAmount, baseMin);
				baseAmount = Math.min(baseAmount, baseMax);
			}

			proportion = (baseAmount - baseMin) / (baseMax - baseMin);
			targetDifference = targetMax - targetMin;

			if (factor > 0) {
				targetAmount = targetMin + targetDifference * proportion;
			} else {
				targetAmount = targetMax - targetDifference * proportion;
			}

			desiredAmount = targetAmount;
			differenceAmount = desiredAmount - lastAmount;
			lastAmount += differenceAmount*that.damp;
		}

		this.immediate = function(n) {
			that.convert(n);
			calculate();
			lastAmount = targetAmount;
			if (targetRound) {lastAmount = Math.round(lastAmount);}
			return that;
		};
		
		this.immediateValue = function(n) {
			desiredAmount = lastAmount = n;		
			return that;
		};

		this.convert = function(n) {
			baseAmount = n;
			if (targetRound) {
				return Math.round(lastAmount);
			} else {
				return lastAmount;
			}
		};

		this.dispose = function() {
			clearInterval(interval);
			return true;
		};
	};//-16

/*--
zim.Dictionary = function(unique)

Dictionary
zim class

DESCRIPTION
An object that uses objects as keys to give values.
Similar to an object literal with properties except the property names are objects instead of strings.
JavaScript currently does not have a dictionary, but other languages do.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const o = {test:"test"};
const f = function(w) {zog(w)};
const c = new Circle();
const d = new Dictionary();
d.add(o, 1); d.add(f, 2); d.add(c, f);
zog(d.at(o)); // 1
zog(d.at(f)); // 2
d.at(c)("hello"); // hello
d.remove(o); // to clear o
zog(d.length); // 2
END EXAMPLE

EXAMPLE
const d = new Dictionary();
d.add(circle, "one");
d.add(circle, "two");
zog(d.at(circle)); // two - just the latest but "one" is still there
for (let i=0; i<d.length; i++) {
	if (d.objects[i] == circle) zog(d.values[i]); // one then two
}
// note, loop backwards to clear values at a key
END EXAMPLE

EXAMPLE
// with unique property add(key, val) removes the last val at that key
const d = new Dictionary(true);
d.add(circle, "one");
d.add(circle, "two");
zog(d.at(circle)); // two - and now only two is there
for (let i=0; i<d.length; i++) {
	if (d.objects[i] == circle) zog(d.values[i]); // two
}
// note, now d.remove(key) removes that unique entry for the key
END EXAMPLE

PARAMETERS
unique (default false) - set to true to only accept a single entry (the last added) for a key

METHODS
add(object, value) - adds a value that can be retrieved by an object reference
	if unique is false, this will not overwrite previous entries at the object key
	if unique is true, this will overwrite previous entries at the object key
	value is optional and will default to true
at(object) - retrieves the last value stored at the object (or returns null if not there)
remove(object) - removes the last value at the object from the Dictionary returns boolean success
clear() - removes all objects from Dictionary - returns object for chaining
dispose() - deletes Dictionary object

PROPERTIES
type - the type of the object as a string
length - the number of items in the Dictionary
unique - whether the dictionary will overwrite values (going from false to true will not delete previous values)
objects - array of keys
values - array of values synched to keys
--*///+17
	zim.Dictionary = function(unique) {
		z_d("17");
		this.length = 0;
		this.unique = unique;
		var objects = this.objects = []; // store objects and values in synched arrays
		var values = this.values = [];
		this.type = "Dictionary";

		this.add = function(o,v) {
			if (zot(o)) return;
			if (zot(v)) v = true;
			if (this.unique) this.remove(o);
			objects.push(o);
			values.push(v);
			this.length++;
		};

		this.at = function(o) {
			if (zot(o)) return;
			var i = objects.indexOf(o);
			if (i > -1) return values[i];
			return null;
		};

		this.remove = function(o) {
			if (zot(o)) return false;
			var i = objects.indexOf(o);
			if (i > -1) {
				objects.splice(i,1);
				values.splice(i,1);
				this.length--;
				return true;
			} else {
				return false;
			}
		};

		this.clear = function() {
			objects = this.objects = []; // store objects and values in synched arrays
			values = this.values = [];
			this.length = null;
			return this;
		};

		this.dispose = function() {
			objects = null;
			values = null;
			this.length = null;
			return true;
		};
	};//-17

/*--
zim.Hierarchy = function(input)

Hierarchy
zim class

DESCRIPTION
A hierarchy is a nested structure for organized data (like XML).
For instance, Hierarchy manages the accordion feature of ZIM List()
where the list can be expanded and collapsed to show nested sections.

HOW IT WORKS
There are two formats that can be used as input.
Each will create a data property in final hierarchy format.

A. The SIMPLE input is an easier format to write but
has a limitation in that identifiers must be strings.
The Hierarchy replaces the identifiers with sequential ids
and stores the original identifiers as an obj property.

B. The COMPLEX input starts off like the final hierarchy data
which has the advantage of storing any type of object in the hierarchy.
The disadvantage is the ids must be hand coded and it is longer.
The Hierarchy will add level, open and opened properties
and create the data property in final hierarchy format.

STRATEGY
The complex format is tricky.
One way to deal with it is to pass in a SIMPLE string version.
Then replace the strings with final objects in the data property.
The Hierarchy class is used internally by ZIM so may not be needed.
However, it will help for custom tree menus, mindmaps, etc.

As of ZIM 014 Hiearchy data can be edited 
using insertBefore(), insertAfter(), replaceItem() and removeItem()
If used for a List, then the List can be recreated with the new data
See: https://zimjs.com/014/hierachy.html 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE - SIMPLE INPUT
let simple;

// 1. Here is linear input as an array - a boring tree - more like grass!
simple = [1,2,3,4]; // so we would probably not use Hierarchy for this.

// 2. To hold nested data we use an object literal.
// The properties can hold linear arrays as values
// but if any of the values need to hold more values then use an object literal:
simple = {
	"linear":[1,2,3,4], // an array is okay as all items are leaf nodes (end nodes)
	"nested":{ // an object literal is required as one or more items hold other items
		"A":[], // this holds nothing (a leaf node) but still needs an empty array
		"B":["one", "two", "three"], // this holds a linear list - all leaf nodes
		"C":{ // this holds another nested list where at least one item holds more
		"LEAF":[],
		"LINEAR":[1,2,3,4],
		"LEAF":[]
		}
	}
}

// If EXTRA info is desired this can be handled like so:
// Set the values as a list property of an object and add any extra properties desired
// The extra property does not have to be called extra and there can be multiple extra properties
// Avoid calling the properties list, obj, level, open or opened.
// The extra properties will be added to the complex data objects (see below)

simple = {
	"linear":{list:[1,2,3,4], extra:"val"},
	"nested":{list:{ // an object literal is required as one or more items hold other items
		"A":[], // this holds nothing (a leaf node) but still needs an empty array
		"B":["one", "two", "three"], // this holds a linear list - all leaf nodes
		"C":{ // this holds another nested list where at least one item holds more
		"LEAF":[],
		"LINEAR":[1,2,3,4],
		"LEAF":[]
		}
	}, extra:"val"}
}


// pass the object into the input parameter:
const hierarchy = new Hierarchy(simple);
const data = hierarchy.data;

// data will be the following - note it is a more complex format
// but also a form that could hold any type of data as a value
// note the level matches the indent and all values have an id
data = {
	id0:{obj:"linear", level:0, open:false, opened:false, list:{
		id1:{obj:1, level:1},
		id2:{obj:2, level:1},
		id3:{obj:3, level:1},
		id4:{obj:4, level:1}
	}, extra:"val"},
	id5:{obj:"nested", level:0, open:false, opened:false, list:{
		id6:{obj:"A", level:1},
		id7:{obj:"B", level:1, open:false, opened:false, list:{
			id8:{obj:"one", level:2},
			id9:{obj:"two", level:2},
			id10:{obj:"three", level:2}
		}},
		id11:{obj:"C", level:1, open:false, opened:false, list:{
			id12:{obj:"LEAF", level:2},
			id13:{obj:"LINEAR", level:2, open:false, opened:false, list:{
				id14:{obj:1, level:3},
				id15:{obj:2, level:3},
				id16:{obj:3, level:3},
				id17:{obj:4, level:3}
			}},
			id18:{obj:"LEAF", level:2}
		}}
	}, extra:"val"}
}
END EXAMPLE

EXAMPLE - COMPLEX INPUT
// Here is a sample of passing in the more complex format.
// level, open, opened properties are not required
// they will be added by the Hierarchy.
// Note that there are no arrays in this data format so that each item has an id.
// This could be passed in to the data property of List
// to show an expandable hierarchy of objects rather than strings converted to buttons
const complex = {
	id0:{obj:new Rectangle(), list:{
		id1:{obj:new Triangle()},
		id2:{obj:new Triangle()},
		id3:{obj:new Triangle()}
	}},
	id4:{obj:new Circle(), list:{
		id5:{obj:new Button()},
		id6:{obj:new Button(), list:{
			id7:{obj:new CheckBox()},
			id8:{obj:new CheckBox()},
		}},
		id9:{obj:new Button(), list:{
			id10:{obj:new Label("Leaf")},
			id11:{obj:new Label("Nest"), list:{
				id12:{obj:1},
				id13:{obj:2},
				id14:{obj:3},
				id15:{obj:4},
			}},
			id16:{obj:new Label("Leaf")}
		}}
	}}
};
const hierarchy = new Hierarchy(complex);
const list = new List({list:hierarchy.data, align:CENTER}).center();
END EXAMPLE

PARAMETERS
input (default null) - a simple formated input - see the examples
	this will be turned in to a more complex object literal available as the data property
	OR input a complex formated input - similar to the data property output
	but only ids, obj and list properties are required.
	The main purpose of Hierarchy is to create the complex data object
	but passing in a complex format allows objects other than strings to be used.

METHODS
processSimple(input) - enter simple input - returns a Hierarchy data object literal
	this is what the Hierarchy does when a simple input is provided to make its data property
	the input must be in the simple format as described in the SIMPLE example.
processComplex(input) - enter complex input - returns a Hierarchy data object literal
	this is what the Hierarchy does when complex data is provided to make its data property
	processComplex will add level, open, and opened properties to the data
	otherwise data must be in the same format as the final data property - see COMPLEX example
getLinearList(list) - enter final list from the data format, to get a linear list of top level objects
	and all open list objects within according to the open property
getLinearIds(list) - enter final list from the data format, to get a linear list of top level ids
	and all open lists ids within according to the open property
getData(id) - find the final data format for a given Hierarchy ID - eg. id0, id12, etc.
	pass the data.list to the getLinearList() and getLinearIDs() methods
getNextSibling(id) - gets the id of the next sibling - skipping ids of any children
	will find parents next sibling if last child in parent
	or undefined if last child in hierarchy
getPrevSibling(id) - gets the id of the previous sibling - skipping ids of any children
	will find the parent if first child in parent
	or undefined if first child in hierarchy
getParent(id) - gets the parent object of the item at the id or null if no parent
insertBefore(items, id, innerItems) - insert item or an array of items before an id with optional children
	this will insert at the same level as the id - also see insertAfter()
	can pass in an array for items such as ["TEST", "TEST2"]
	can pass in a third parameter for children of a single item
	The third parameter can also be an array but if there is a third parameter 
	and if the first parameter is a list then it only uses the first item in the list
	as the parent for the third parameter.
insertAfter(items, id, innerItems) - insert item or an array of items after an id with optional children
	this will insert at the same level as the id - also see insertBefore()
	can pass in an array for items such as ["TEST", "TEST2"]
	can pass in a third parameter for children of a single item
	The third parameter can also be an array but if there is a third parameter 
	and if the first parameter is a list then it only uses the first item in the list
	as the parent for the third parameter.
replaceItem(item, id) - replace the current item at the id with the provided item
removeItem(id) - remove the item at the id

PROPERTIES
data - a hierarchy formated object literal with ids that hold object literals
	ids are in the format of id0, id1, id2, etc. numbered in order of creation (top to bottom)
	the object literals have obj, level, open, opened and list properties
	leaf nodes (end nodes) will have {} as its list property value
length - read only total length of all nodes
--*///+17.5
	zim.Hierarchy = function(input, open) {
		z_d("17.5");
		var that = this;
        if (zot(input)) return;
		if (zot(open)) open = false;
		var _length;
        that.processSimple = function(list) {
            var count = 0;
            var m = {};
            function makeLevel(list2, obj, level, last) {
				if (!zot(list2)) list = list2;
                if (list.constructor == {}.constructor) {
					var originalList;
					if (list.list) { // in extra format
						originalList = list;
						list = list.list;
					}
					if (last && originalList) {
						zim.loop(originalList, function (k,v) {
							if (k=="list") return; // like a for loop continue
							last[k] = v;
						});
					}
                    zim.loop(list, function (key, val) {
                        var newList = {};
						var current = obj["id"+count] = {obj:key, level:level, open:open, opened:false, list:newList};
						count++;
						makeLevel(val, newList, level+1, current);
					});
                } else if (Array.isArray(list)) {
                    zim.loop(list, function (val) {
                        obj["id"+count] = {obj:val};
                        count++;
                    });
                }
            }
            makeLevel(input, m, 0);
			_length = count;
            return m;
        };
		that.processComplex = function(input) {
			var count = 0;
			function innerFunction(inp, level) {
				zim.loop(inp, function (key, val) {
					val.level = level;
					if (zot(val.open)) val.open = open;
					if (zot(val.opened)) val.opened = false;
					if (val.list) innerFunction(val.list, level+1);
					count++;
				});
			}
			innerFunction(input, 0);
			_length = count;
			return input;
		};

		if (zot(input.id0)) {
			that.data = that.processSimple(input);
		} else {
			that.data = that.processComplex(input);
		}

        that.getLinearList = function(data) {
			if (zot(data)) data = that.data;
            return getLinear(data)[0];
        };
        that.getLinearIDs = function(data) {
			if (zot(data)) data = that.data;
            return getLinear(data)[1];
        };

        function getLinear(data) {
            var linear = [];
            var ids = [];
            function getLevel(data, level) {
                zim.loop(data, function (item, list) {
                    linear.push(list.obj);
                    ids.push(item);
                    if (list.open) getLevel(list.list, level+1);
                });
            }
            getLevel(data, 0);
            return [linear, ids];
        }

        that.getData = function(id) {
            // recursively find the data for id
            var answer;
            function find(obj) {
                zim.loop(obj, function (key, val) {
                    if (key == id) {
                        answer = val;
                        return answer;
                    }
                    find(val.list);
                });
            }
            find(that.data);
            return answer;
        };

        that.getNextSibling = function(id) {
            var current;
            var answer;
            function find(obj) {
                zim.loop(obj, function (key, val) {
                    if (!answer && current) {
                        answer = key;
                        return answer;
                    }
                    if (key == id) {
                        current = val;
                    } else {
                        find(val.list);
                    }
                });
            }
            find(that.data);
            return answer;
        };

		that.getPrevSibling = function(id) {
			var lasts = [];
			var answer;
            function find(obj, lev) {
                zim.loop(obj, function (key, val) {
                    if (key == id) {
						answer = lasts[lev] || lasts[lev-1];
						return answer;
                    } else {
						lasts[lev] = key;
                        find(val.list, lev+1);
                    }
                });
            }
            find(that.data, 0);
            return answer;
        };

		// hierarchy edits added ZIM 014

		that.insertBefore = function(items, id, innerItems) { 
			return doRecursive("insertBefore", items, id, innerItems);
		}
	
		that.insertAfter = function(items, id, innerItems) { 
			return doRecursive("insertAfter", items, id, innerItems);
		}
	
		that.removeItem = function(id) {
			return doRecursive("removeItem", null, id);
		}
	
		that.replaceItem = function(newItem, id) {        
			var data = that.getData(id);
			data.obj = newItem;
			return doRecursive("replaceItem");
		}
	
		function doRecursive(type, items, id, innerItems) {
		   
			var count = 0;
			var m = {}; 
			var input = that.data;
			function makeLevel(list, obj, level, last) {
				zim.loop(list, function (key, val) {
	
					if (type == "removeItem") {
						if (key==id) return;
					}
	
					var newList;
					var lastList;
					var current;    
					
					if (type == "insertBefore") {
						if (key==id) count = doInsert(obj, count, level, items, innerItems);
					}
	
					newList = {};
					lastList = val.list;
					val.list = newList;
					val.opened = false;
					val.open = false;
					current = obj["id"+count] = val;
					if (current.obj.type && current.obj.type=="TabsButton") current.obj = current.obj.text; 
					count++;
					makeLevel(lastList, newList, level+1);
	
					if (type == "insertAfter") {
						if (key==id) count = doInsert(obj, count, level, items, innerItems);
					}
	
				});            
			}
			makeLevel(input, m, 0);
			_length = count;
			return m;       
	
		}
	
		function doInsert(obj, count, level, items, innerItems) {
			if (innerItems) {
				var added = {}
				if (Array.isArray(items)) items = items[0];
				obj["id"+count] = {obj:items, level:level, open:false, opened:false, list:added};
				count++;
				if (!Array.isArray(innerItems)) innerItems = [innerItems];
				zim.loop(innerItems, function(item) {
					added["id"+count] = {obj:item, level:level+1, open:false, opened:false, list:{}};
					count++;
				});           
			} else {
				if (!Array.isArray(items)) items = [items];
				zim.loop(items, function(item) {
					obj["id"+count] = {obj:item, level:level, open:false, opened:false, list:{}};
					count++;
				});                        
			}    
			return count;    
		}
	
		that.getParent = function(id) {
			var input = that.data; 
			function checkLevel(list, parent) {
				var answer = zim.loop(list, function (key, val) {
					if (key==id) {
						_length-=1;
						return parent;
					}
					if (val.list && !zim.isEmpty(val.list)) {
						return checkLevel(val.list, key);    
					}            
				});  
				if (answer!==true) return answer;          
			}        
			return checkLevel(input);
		}


		Object.defineProperty(that, 'length', {
			get: function() {
				return _length;
			},
			set: function() {
				if (zon) zogy("Hierarchy() - length is read only");
			}
		});

	};//-17.5

/*--
zim.Pick = function(choices)

Pick
zim class

HISTORY
Pick was originally zik() and ZIM VEE (introduced in ZIM 5) throughout the ZIM documentation
It was so handy that a general (non ZIM centric) name has been given to a class
that can be used by other libraries and languages.
See https://github.com/danzen/Pick for the complete general code and description

DESCRIPTION
Pick() provides a system to handle dynamic parameters.
It does so by providing formats for options and a choose() method to pick from the options.

For example, a particle emitter has an obj parameter to receive what type of particle to emit.
If a particle were randomly chosen from a rectangle, circle or triangle and passed into obj
then the emitter would only emit the randomly chosen particle - say, a bunch of triangles.
What is desired is that the emitter emit rectangles, circles and triangles randomly.
Pick() provides a way to pass in all three shapes and have the emitter choose each time it emits.

FORMATS
The Pick() formats handle:
	1. a random selection: [blue, green, yellow] - array format
	2. a random range: {min:10, max:30} - range object format (plus integer and negative) 
	3. a series: series(10,20,30) - series format also Pick.series()
	4. a function result: function(){return new Date().minutes} - function format
	5. a normal value: 7 or "hello" - single-value format
	6. a noPick object: {noPick:["real", "array"]} - escape format
	7. a combination: [{min:10, max:20}, 30, 40] - combination format (recursive)

NOTE: the range format gets passed to ZIM rand() directly so see docs there
there are also integer and negative parameters both defaulting to false

PICK LITERAL
Formats are passed in to a Pick() object and the Pick object can be passed to a class or function parameter
In ZIM, the formats may be passed directly into the class or function parameter (as a Pick literal)
	new Circle(new Pick([10,20]), red); // Pick()
	new Circle([10,20], red); // Pick Literal
** The literal can run into conflicts such as for a ZIM corner parameter which accepts an array []
This would be avoided with a system always using Pick() and never the literal.
But... ZIM started off without the formalized Pick - and the literal is shorter ;-)
The conflict can be resolved by using {noPick:[]} and then the array is not picked from.

NOTE: Pick is used internally by by zim.interval, zim.animate, zim.Emitter, zim.Pen, etc.
as well as ZIM STYLE and ZIM Shape basic parameters handy for cloning with Tile, Emitter, etc.

EXAMPLE
let loopCount, choice;

loopCount = new Pick([1,2,3]);
choice = Pick.choose(loopCount); // 1, 2, or 3

loopCount = [1,2,3]; // Pick literal
choice = Pick.choose(loopCount); // 1, 2, or 3

choice = Pick.choose([1,2,3]); // 1, 2, or 3

const rotation = {min:10, max:20, integer:false, negative:true};
// an example of a Range object - this will give values between -20 and -10 or 10 and 20
// rotation now holds an object as to how to pick its value
// this can be passed into a zim.Emitter() for instance
// which will make multiple copies and rotate them based on Pick.choose()
// or this can be passed into an animation object
// and then into zim.Emitter() for the animate parameter

const emitter = new Emitter({
	obj:new Rectangle(),
	random:{rotation:rotation} // the emitter will use Pick.choose() to pick a rotation for each particle
}).center();

function age() {
	// assuming user.age is some input value that exists
	if (user.age >= 18) return ["a", "b", ["c","d"]];
	else return ["e", "f"];
}
// below will be a, b, c or d if user is 18+ with a and b having more of a chance
// or e or f if not over 18
const show = Pick.choose(age);

// below we randomize the tile colors in the first example
// and make them in color order for the second example
new Tile(new Rectangle(10,10,[blue, red]), 10, 10).center(); // would randomize colors
new Tile(new Rectangle(10,10,series(blue, red)), 10, 10).center(); // would alternate colors

// here we pass an array through without processing the array:
Pick.choose({noPick:[1,2,3,4,5]}); // result is [1,2,3,4,5]

// a range between one and three seconds - repeating after 3 choices
const pick = new Pick({min:1, max:3}).num(3);
interval(pick, function () {console.log("calling");}); // eg. 2.5s, 2.7s, 1.2s, 2.5s, 2.7s, 1.2s, etc.
END EXAMPLE

PARAMETERS
choices - any of the ZIM Pick formats:
	1. an array of choices to choose from randomly
	2. a range object with min and max (integer and negative) properties
	3. a zim.series() or Pick.series() to pick objects in order
	4. a function that returns a result
	5. a single not one of the above that passes through
	6. an escape object with a noPick property
	7. any combination of the above to pick recursively

METHODS
num(number) - a chainable method to limit the number of options until Pick.choose() will repeat like a series
loop(number, call(value, index, total)) - a way to loop through options
 	number is the number of times to loop
	call is a callback function that gets called each loop
	the callback will recieve a value (the choice), the index of the loop and the total (the number parameter)
	inside the function a return is like a continue and a return of any value is like a break in traditional for loops.

STATIC METHODS
Pick.choose(Pick Object or Pick Literal) - gets a value from the Pick object or Pick Literal
	so chooses from a random array, or range, or gets the next in the series, etc.
Pick.rand(a, b, integer, negative) - gets a random number - same as zim.rand()
	a - the first Number for the range
		if a and b are not provided, rand() acts like Math.random()
		if parameter b is not provided, rand will use range 0 to and including a
	b - (default 0) second Number for the range
		it does not matter if a>b or a<b
	integer - (default true) set to false to include decimals in results
		if false, range will include decimals up to but not including the highest number
		if a or b have decimals this is set to false
	negative - (default false) includes the negative range as well as the positive
Pick.series(array|item1, item2, item3, etc.) - same as zim.series()
	returns a function that can be called many times each time returning the next value in the series (eventually looping)
	array|item1 - the first item - or an array of results that will be called in order as the resulting function is called
	item2 - the second item if the first is not an array
	item3 - the third item, etc. to as many items as needed
Pick.getMinMax(ZIM VEE value) - returns a {min:val, max:val} object 
 	with the min and max values the ZIM VEE value can return 
	or null, null if not numbers or the ZIM VEE is a function 
	This will work for a range object {min, max}, an array of number [] or a series() of numbers

PROPERTIES
type - the type of object as a String
choices - a reference to the choices object provided as the Pick(choices) parameter
--*///+17.6
	zim.Pick = function(choices) {
		if (!zim.pickCheck) {z_d("17.6"); zim.pickCheck=true;}
        this.choices = choices;
        this.num = function(num) {
            var s = [];
            for (var i=0; i<num; i++) {s.push(zim.Pick.choose(this));}
            this.choices = zim.Pick.series(s);
            return this;
        };
        var that = this;
        this.loop = function(num, call) {
            var r;
            for (var i=0; i<num; i++) {
                r = call(zim.Pick.choose(that), i, num);
                if (typeof r != 'undefined') return r;
            }
         };
    };
    zim.Pick.prototype.type = "Pick";
    zim.Pick.series = function() {
		// see https://github.com/danzen/Pick for all inclusive class to use in other libraries / languages, etc.
		if (!zim.pickCheck) {z_d("17.6"); zim.pickCheck=true;}
		return zim.series.apply(null, arguments);
    };
    zim.Pick.rand = function(a, b, integer, negative) {
		// see https://github.com/danzen/Pick for all inclusive class to use in other libraries / languages, etc.
		if (!zim.pickCheck) {z_d("17.6"); zim.pickCheck=true;}
		return zim.rand(a, b, integer, negative);
    };
    zim.Pick.choose = function(obj, literal, target) {
		if (!zim.pickCheck) {z_d("17.6"); zim.pickCheck=true;}
        if (literal == null) literal = true;
		if (obj==null) return obj;
        if (obj.type=="Pick" || literal) {
            var c = obj.choices || obj;
			var val;
            if (Array.isArray(c)) {
                val = c[Math.floor(Math.random()*(c.length))];
                return zim.Pick.choose(val); // recursive
            } else if (c.constructor === {}.constructor) {
                if (!zot(c.noPick)) return c.noPick; // a passthrough for arrays and functions
                if (zot(c.max)) return c;
                if (zot(c.integer)) c.integer = false;
                val = zim.Pick.rand(c.min, c.max, c.integer, c.negative);
                return val; // this is just a number in a range - no need for recursive
            } else if (c instanceof Function) {
				if (c.count==null) c.count=0;
				else c.count++;
                return zim.Pick.choose((c)(target, true)); // recursive
            }	
            return obj;
        } else {	
            return obj;
        }		
	};
	zim.Pick.getMinMax = function(vee) {
		if (!zot(vee.min) && !zot(vee.max)) return vee;				
		if (Array.isArray(vee)) {
			return zim.arrayMinMax(vee);
		}
		if (vee.type == "series") {
			return zim.arrayMinMax(vee.array);
		}
		else return {min:null, max:null}
	};//-17.6

	// DOM CODE

// SUBSECTION HTML FUNCTIONS

/*--
zim.scrollX = function(num, time)

scrollX
zim function

DESCRIPTION
This function gets or sets how many pixels from the left the browser window has been scrolled.
If num is provided then the function scrolls the window to this x position.
If num and time are provided it animates the window to the x position in time milliseconds.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// hide the logo if the page is scrolled left more than 200 pixels
if (scrollX < -200) zss("logo").display = "none";
END EXAMPLE

PARAMETERS
num - (default null) optional scroll position to go to (probably negative)
time - (default 0) time in seconds to take to go to the num position (also see ZIM TIME constant)

RETURNS a Number
--*///+18
	zim.scrollX = function(num, time) {
		z_d("18");
		return zim.abstractScroll("X", "Left", num, time);
	};//-18


/*--
zim.scrollY = function(num, time)

scrollY
zim function

DESCRIPTION
This function gets or sets how many pixels from the top the browser window has been scrolled.
If num is provided then the function scrolls the window to this y position.
If num and time are provided it animates the window to the y position in time milliseconds.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// animate the scroll position down 100 pixels in half a second
scrollY(scrollY()-100, .5);
END EXAMPLE

PARAMETERS
num - (default null) optional scroll position to go to (probably negative)
time - (default 0) time in seconds to take to go to the num position (also see ZIM TIME constant)

RETURNS a Number
--*///+19
	zim.scrollY = function(num, time) {
		z_d("19");
		return zim.abstractScroll("Y", "Top", num, time);
	};//-19

	//+20
	zim.abstractScroll = function(dir, side, num, time) {
		z_d("20");
		var timeType = getTIME(time);
		var perpend = (dir == "X") ? "Y" : "X"; // perpendicular direction
		if (zot(num)) {			
			return (document.documentElement && document.documentElement["scroll"+side]) || document.body["scroll"+side];
		} else if (zot(time)) {
			WW.scrollTo(zim["scroll"+perpend](), num);
		} else {
			var interval = 50;
			var t = time*(timeType=="s"?1000:1);
			if (t < interval) t = interval;
			var steps = t/interval;
			var current = zim["scroll"+dir]();
			var amount = num - current;
			var diff = amount/steps;
			var count = 0;
			var scrollInterval = setInterval(function() {
				count++;
				current+=diff;
				WW.scrollTo(zim["scroll"+perpend](), current);
				if (count >= steps) {
					WW.scrollTo(zim["scroll"+perpend](), num);
					clearInterval(scrollInterval);
				}
			}, interval);
		}
		return num;
	};//-20

/*--
zim.windowWidth = function()

windowWidth
zim function

DESCRIPTION
Returns the width of a window.
(window.clientWidth or window.innerWidth)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
if (windowWidth() < 500) zss("related").display = "none";
END EXAMPLE

RETURNS a Number
--*///+21
	zim.windowWidth = function() {
		z_d("21");
		var w = isNaN(WW.innerWidth) ? WW.clientWidth : WW.innerWidth;
		var h = isNaN(WW.innerHeight) ? WW.clientHeight : WW.innerHeight;
		if (zim.mobile() && !zot(WW.orientation) && !WW.parent) {
			if ((w > h && Math.abs(WW.orientation) != 90) || h > w && Math.abs(WW.orientation) == 90) {
				var oldW = w;
				w = h;
				h = oldW;
			}
		}
		// 6. part of TEN PATCH
		// pay attention to swapRotation from Frame
		return (WW.zdf && WW.zdf.swapRotation)?h:w;
	};//-21

/*--
zim.windowHeight = function()

windowHeight
zim function

DESCRIPTION
Returns the height of a window.
(window.clientHeight or window.innerHeight)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
if (windowHeight() > 1000) zgo("big.html");
END EXAMPLE

RETURNS a Number
--*///+22
	zim.windowHeight = function() {
		z_d("22");
		var w = isNaN(WW.innerWidth) ? WW.clientWidth : WW.innerWidth;
		var h = isNaN(WW.innerHeight) ? WW.clientHeight : WW.innerHeight;
		if (zim.mobile() && !zot(WW.orientation) && !WW.parent) {
			if ((w > h && Math.abs(WW.orientation) != 90) || h > w && Math.abs(WW.orientation) == 90) {
				var oldW = w;
				w = h;
				h = oldW;
			}
		}
		// 7. part of TEN PATCH
		// pay attention to swapRotation from Frame
		return (WW.zdf && WW.zdf.swapRotation)?w:h;
	};//-22
	
/*--
zim.browserZoom = function()

browserZoom
zim function

DESCRIPTION
Returns the browser zoom relative to starting zoom.
For example, will return 2 if zoomed twice as big as starting zoom
and will return .5 is zoomed half as big as starting zoom.
Note: this always returns 1 at the start regardless of the starting browser zoom.

This is changed by CTRL+, CTRL-, CTRL scroll wheel or the zoom menu, etc.
It is really just comparing the difference of the devicePixelRatio.
The function is used internally by ZIM Tag(), TextArea() and Loader().

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
Ticker.add(()=>{
	zog(browserZoom()); // 1 at start then changes depending on browser zoom
});
END EXAMPLE

RETURNS a Number
--*///+22.2
	zim.browserZoom = function() {			
		if (!zim.zimBZ) {
			z_d("22.2"); 
			zim.zimBZ=true;
			if (typeof frame == "undefined") {
				if (WW.zdf) {
					var frame = WW.zdf;
				} else {
					zim.zimBZA = 1;
					return 1;
				}
			}
			if (frame.retina) zim.zimBZ1 = WW.devicePixelRatio || 1;
			else {
				zim.zimBZA = 1;
				return 1;
			}
		} else {
			if (!zot(zim.zimBZA)) return zim.zimBZA;
			return zim.decimals((WW.devicePixelRatio||1)/zim.zimBZ1,2);
		}
	};//-22.2

/*--
zim.getQueryString = function(string)

getQueryString
zim function

DESCRIPTION
Turns the HTML query string into a object.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// currentHTML page myPage.html?party=true&toys=many
const details = getQueryString();
zog(details.party); // "true"
zog(details.toys); // "many"
loop(details, (key, val, i)=>{
	zog(key, val, i);
});
// outputs:
// party true 0
// toys many 1
END EXAMPLE

EXAMPLE
// an array of values is created if a query string has multiple properties with the same name:
const collection = getQueryString("type=dog&age=10&age=20&age=30");
zog(collection.age); // [10,20,30]
END EXAMPLE

PARAMETERS
string - (default null) null will get string from end of HTML page after ?
	set the key value pairs (without question mark) to parse a custom string
	eg. party=true&toys=many

RETURNS an object literal with properties matching the keys and values matching the values (or undefined if no query string)
--*///+22.5
	zim.getQueryString = function(s) {
		z_d("22.5");
		if (zot(s)) s = location.search.replace("?","");
		if (s == "") return {};
		var vars = s.split("&");
		var obj = {};
		for (var i=0; i<vars.length; i++) {
			var pair = vars[i].split("=");
			if (typeof obj[pair[0]] == "undefined") {
				obj[pair[0]] = decodeURIComponent((pair[1] + '').replace(/\+/g, '%20'));
			} else if (typeof obj[pair[0]] == "string") {
				obj[pair[0]] = [obj[pair[0]], decodeURIComponent((pair[1] + '').replace(/\+/g, '%20'))];
			} else {
				obj[pair[0]].push(decodeURIComponent((pair[1] + '').replace(/\+/g, '%20')));
			}
		}
		return obj;
	};//-22.5

/*--
zim.swapHTML = function(idA, idB)

swapHTML
zim function

DESCRIPTION
Pass in two tag ids as strings and this function will swap their innerHTML content.
The content (including nested tags) will be swapped.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// exchanges the content of two divs called question and answer
swapHTML("question","answer");
END EXAMPLE

PARAMETERS
idA, idB - String names of the tag id with which to swap innerHTML values

RETURNS Boolean indicating success
--*///+17.2
	zim.swapHTML = function(idA, idB) {
		z_d("17.2");
		return zim.swapProperties("innerHTML", zid(idA), zid(idB));
	};//-17.2

/*--
zim.urlEncode = function(string)

urlEncode
zim function

DESCRIPTION
Matches PHP urlencode and urldecode functions
for passing data on end of URL.
NOTE: only encode values of key=value pairs (not keys and not both keys and values)
NOTE: JSON automatically encodes and decodes - except maybe &

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const motto = "good = life & life = now";
zgo("submit.php?motto="+urlEncode(motto));
END EXAMPLE

PARAMETERS
string - a value to URL encode (space to plus, etc.)

RETURNS a String
--*///+23
	zim.urlEncode = function(s) {
		z_d("23");
		s = (s + '').toString();
		return encodeURIComponent(s).replace(/!/g, '%21').replace(/'/g, '%27').replace(/\(/g, '%28').
		replace(/\)/g, '%29').replace(/\*/g, '%2A').replace(/%20/g, '+');
	};//-23

/*--
zim.urlDecode = function(string)

urlDecode
zim function

DESCRIPTION
Matches PHP urlencode and urldecode functions
for receiving raw data from a source that URLencodes.
NOTE: JSON automatically encodes and decodes

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const pairs = command.split("&");
const motto = urlDecode(pairs[0].split("=")[1]);
END EXAMPLE

PARAMETERS
string - a URLencoded String to decode

RETURNS a String
--*///+24
	zim.urlDecode = function(s) {
		z_d("24");
		return decodeURIComponent((s + '').replace(/\+/g, '%20'));
	};//-24

/*--
zim.setCookie = function(name, value, days)

setCookie
zim function

DESCRIPTION
Sets an HTML cookie to remember some user data your site has set over time.
If no days, it will be a session cookie (while browser is open).

NOTE: cookies may not work unless files are on a server

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const visits = getCookie("visits");
if (zot(visits)) visits = 0;
setCookie("visits", ++visits);
END EXAMPLE

PARAMETERS
name - a String name for your cookie
value - a String value that you want to store
days - (default 0) for how many days do you want to store the cookie

ALSO: see getCookie and deleteCookie

RETURNS a Boolean indicating success
--*///+25
	zim.setCookie = function(name, value, days) {
		z_d("25");
		if (zot(name) || zot(value)) return;
		var expires;
		if (days) {
			var date = new Date();
			date.setTime(date.getTime()+(days*24*60*60*1000));
			expires = "; expires="+date.toGMTString();
		} else {
			expires = "";
		}
		document.cookie = name+"="+escape(value)+expires+"; path=/";
		return true;
	};//-25

/*--
zim.getCookie = function(name)

getCookie
zim function

DESCRIPTION
Gets an HTML cookie that you have previously set.

NOTE: cookies may not work unless files are on a server

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const visits = getCookie("visits");
if (zot(visits)) visits = 0;
setCookie("visits", ++visits);
END EXAMPLE

PARAMETERS
name - the String name of your stored cookie

ALSO: see setCookie and deleteCookie

RETURNS a String or undefined if not found
--*///+26
	zim.getCookie = function(name) {
		z_d("26");
		var outer = document.cookie.split(/;\s*/);
		var cookies = new Array();
		var inner;
		for (var i=0; i<outer.length; i++) {
			inner = outer[i].split("=");
			cookies[inner[0]] = inner[1];
		}
		if (typeof cookies[name] == 'undefined') return undefined;
		return unescape(cookies[name]);
	};//-26

/*--
zim.deleteCookie = function(name)

deleteCookie
zim function

DESCRIPTION
Deletes an HTML cookie.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
deleteCookie("visits"); // clears the cookie
END EXAMPLE

PARAMETERS
name - the String name of your stored cookie to delete

ALSO: see setCookie and getCookie

RETURNS a Boolean indicating success
--*///+27
	zim.deleteCookie = function(name) {
		z_d("27");
		if (zot(zim.getCookie(name))) return false;
		zim.setCookie(name,"",-1);
		return true;
	};//-27

if (createjs == null) {if (zon) {zogr("ZIM >= 4.3.0 requires createjs namespace to be loaded (import createjs before zim)");} return zim;}



////////////////  ZIM DISPLAY  //////////////

// Zim Display (formerly Zim Build) adds common display classes for Zapps (apps, art, games and gadgets with ZIM)
// classes in this module require createjs namespace to exist and in particular easel.js
// available at https://createjs.com

// SUBSECTION BASE DISPLAY

/*--
zim.Coordinates = function(canvasID)

Helper functions for localToGlobal, globalToLocal and localToLocal

--*///+50.43
zim.localToGlobal = function localToGlobal(x,y,scope,func) {
	if (!zim.coordinatesCheck) {z_d("50.43"); zim.coordinatesCheck=true;}
	if (x==null || y==null) return;
	var point = func.call(scope,x,y);
	var stage = scope.stage;
	if (!WW.zdf) {
		if (!stage) return point;
		WW.zdf = {stage:stage, canvas:stage.canvas};
	}
	point.x /= zim.scaX;
	point.y /= zim.scaY;
	return point;
};
zim.globalToLocal = function globalToLocal(x,y,scope,func) {
	if (!zim.coordinatesCheck) {z_d("50.43"); zim.coordinatesCheck=true;}
	if (x==null || y==null) return;
	var stage = scope.stage;
	if (!WW.zdf) {
		if (!stage) return func.call(scope,x,y);
		WW.zdf = {stage:stage, canvas:stage.canvas};
	}
	x *= zim.scaX;
	y *= zim.scaY;
	var point = func.call(scope,x,y);
	return point;
};
zim.localToLocal = function localToLocal(x,y,target,scope) {
	if (!zim.coordinatesCheck) {z_d("50.43"); zim.coordinatesCheck=true;}
	if (x==null || y==null || target==null) return;
	var point = scope.localToGlobal(x,y);
	var stage = scope.stage;
	if (!WW.zdf) {
		if (!stage) return target.globalToLocal(point.x, point.y);
		WW.zdf = {stage:stage, canvas:stage.canvas};
	}
	if (!stage) stage = WW.zdf.stage;
	if (target == stage) return point;
	if (point) return target.globalToLocal(point.x, point.y);
};
//-50.43

/*--
zim.displayBase = function()

displayBase
zim function 

DESCRIPTION
Used internally by ZIM to set common properties on basic DisplayObjects 
Container, Shape, Bitmap, Sprite, MovieClip 
Also called by zimify() if object does not already have these (hueBatch used for test)
Turns off and on allowDefault if allowDefault is true as object is interacted with 
this prevents the page from scrolling on mobile when drag, gesture, transform, etc. are happening
Might have set these on CreateJS DisplayObject

--*///+50.432
	zim.displayBase = function(obj) {
		if (!zim.zimDBCheck) {z_d("50.432"); zim.zimDBCheck=true;}
		var that = obj;				
		Object.defineProperty(obj, 'width', {
			enumerable: true,
			get: function() {
				// that.setBounds(null);
				var b = this.getBounds();
				return (zot(b))?null:Math.abs(b.width*this.scaleX);
			},
			set: function(value) {
				if (obj.scaleDimensions!==false) {
					var b = this.getBounds();
					if (zot(b) || b.width==0) {
						if (zon) zogy("DisplayObject() - width needs bounds set with setBounds()");
						return;
					}
					var s = value/b.width;
					this.scaleX = this.scaleY = s;
				} else {
					var p = obj.width!=0?obj.height/obj.width:0;
					obj.setWidth(value);
					obj.setHeight(value*p);
					obj.drawShape();
				}		
			}
		});
		Object.defineProperty(obj, 'height', {
			enumerable: true,
			get: function() {
				// that.setBounds(null);
				var b = this.getBounds();
				return (zot(b))?null:Math.abs(b.height*this.scaleY);
			},
			set: function(value) {				
				if (obj.scaleDimensions!==false) {
					var b = this.getBounds();
					if (zot(b) || b.height==0) {
						if (zon) zogy("DisplayObject() - height needs bounds set with setBounds()");
						return;
					}
					var s = value/b.height;
					this.scaleX = this.scaleY = s;
				} else {
					var p = obj.height!=0?obj.width/obj.height:0;
					obj.setHeight(value);
					obj.setWidth(value*p);
					obj.drawShape();
				}	
				
			}
		});
		Object.defineProperty(obj, 'widthOnly', {
			enumerable: true,
			get: function() {
				// that.setBounds(null);
				var b = this.getBounds();
				return (zot(b))?null:Math.abs(b.width*this.scaleX);
			},
			set: function(value) {
				if (obj.scaleDimensions!==false) {
					var b = this.getBounds();
					if ((zot(b) || b.width==0) && zon) {zogy("DisplayObject() - widthOnly needs bounds set with setBounds()"); return;}
					var s = value/b.width;
					this.scaleX = s;					
				} else {
					obj.setWidth(value);
					obj.drawShape();
				}				
			}
		});
		Object.defineProperty(obj, 'heightOnly', {
			enumerable: true,
			get: function() {
				// that.setBounds(null);
				var b = this.getBounds();
				return (zot(b))?null:Math.abs(b.height*this.scaleY);
			},
			set: function(value) {
				if (obj.scaleDimensions!==false) {
					var b = this.getBounds();
					if ((zot(b) || b.height==0) && zon) {zogy("DisplayObject() - heightOnly needs bounds set with setBounds()"); return;}
					var s = value/b.height;
					this.scaleY = s;
				} else {
					obj.setHeight(value);
					obj.drawShape();
				}	
			}
		});
		Object.defineProperty(obj, 'level', {
			enumerable: true,
			get: function() {
				if (this.parent) return this.parent.getChildIndex(this); return null;
			},
			set: function(value) {
				if (this.parent) this.parent.setChildIndex(this, Math.max(0, Math.min(value, this.parent.numChildren-1)));
			}
		});
		Object.defineProperty(obj, 'depth', {
			enumerable: true,
			get: function() {
				return this._depth;
			},
			set: function(depth) {
				this._depth = depth;
				if (!zot(this.vrChannel)) {
					var parallaxShift = this.vrParallaxDistance ? depth*this.vrParallax*this.vrParallaxDistance : 0;
					if (this.vrChannel == "left") {
						this.x = this.vrStartX + depth + parallaxShift;
					} else if (this.vrChannel == "right") {
						this.x = this.vrStartX - depth + parallaxShift;
					}
				}
			}
		});
		Object.defineProperty(obj, 'blendMode', {
			enumerable: true,
			get: function() {
				return this.compositeOperation;
			},
			set: function(value) {
				this.compositeOperation = value;
			}
		});
			
		if (!that.name) {
			var _name;
			Object.defineProperty(that, 'name', {
				get: function() {
					return _name;
				},
				set: function(value) {
					_name = value;
					zim.zimObjectIDs[value] = that;
				}
			});
		}
		that._draggable;
		Object.defineProperty(that, 'draggable', {
			get: function() {
				return this._draggable;
			},
			set: function(value) {
				if (value == this._draggable) return;
				this._draggable = value;
				if (this._draggable) this.drag();
				else this.noDrag();
			}
		});
		
		var frame;
		var adCheck;
		that.on("mousedown", function (e) {
			if (e.target.stage) {
				frame = e.target.stage.frame;
				if (frame.allowDefault) {
					adCheck = true;
					frame.allowDefault = false;
				}
			}
		});
		that.on("pressup", function () {
			if (frame && adCheck) frame.allowDefault = true;
		});
		
		// EFFECTS
		// making 8 properties, 4 that update effect and 4 that do not 
		// so that regular properties can update effect - obj.hue=20 // updates
		// but animate and wiggle can bulk update effect - obj.hueBatch=20 // does not update
		var effects = ["hue", "saturation", "brightness", "contrast"];
		for (var i=0; i<effects.length; i++) {
			-function() { // closure to remember eff
				var eff = effects[i];
				for (var j=0; j<2; j++) {
					-function() { // closure to remember add
						var add = j==0?"":"Batch";
						Object.defineProperty(that, eff+add, {
							get: function() {											
								if (that.effects && that.effects.multi) return that.effects.multi[eff];	
								else return 0;		
							},
							set: function(value) {
								if (!that.effects || !that.effects.multi) that.effect(new zim.MultiEffect(eff=="hue"?value:0,eff=="saturation"?value:0,eff=="brightness"?value:0,eff=="contrast"?value:0));
								else that.effects.multi[eff] = value;
								if (add=="") that.updateEffects(); 
							}
						});
					}();				
				}			
			}();
		}	
	
	}		
	//-50.432

/*--
zim.gD = function()

gD
zim function 

DESCRIPTION
Used internally by ZIM to globally dispose common connections

--*///+50.435
	zim.gD = function(obj) {
		if (!zim.zimGDCheck) {z_d("50.435"); zim.zimGDCheck=true;}
		if (!obj) return;
		if (obj.z_bc) { // ZIM ZIM 01 patch to help out Safari - thanks Chris Spolton
			var c = obj.z_bc;
	        c.width = c.height = 1;
	        if (c.getContext) c.getContext("2d").clearRect(0,0,1,1);
			delete obj.z_bc;
		}
		if (zim.KEYFOCUS == obj) zim.KEYFOCUS = null;
		if (WW.KEYFOCUS == obj) WW.KEYFOCUS = null;		
		if (obj.veeObj) obj.veeObj = null;
		if (obj.draggable) obj.noDrag();
		if (obj.zimTweens) obj.stopAnimate();
		if (obj.zimWire) obj.noWire();
		if (obj.zimWired) obj.noWired();
		if (obj.zimClickHoldDownEvent) obj.noHold();
		if (obj.motionController) obj.motionController.dispose();
		if (obj.transformControls) obj.transformControls.dispose();
		if (obj.zimClickDownEvent) obj.zimClickDownEvent = null;
		if (obj.zimClickUpEvent) obj.zimClickUpEvent = null;
		if (obj.physics) obj.removePhysics();
		if (obj.name && zim.zimObjectIDs[obj.name] == obj) delete zim.zimObjectIDs[obj.name];
	}		
	//-50.435

/*--
zim.Stage = function(canvasID, touch, singleTouch)

Stage
zim class - extends a createjs.Stage which extends a createjs.Container

DESCRIPTION
An extension of a createjs.Stage that includes read only type, width and height properties, loop and hitTestGrid methods.
When using zim.Frame, there should be no reason to make a zim.Stage.
This was put in place to match the ZIM TypeScript typings for stage width and height.
Also see https://www.createjs.com/docs/easeljs/classes/Stage.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const stage = new Stage("canvasID");
END EXAMPLE

PARAMETERS
canvasID - (default null) string ID for canvas tag
touch - (default false) set to true for touch on mobile 
	will be multitouch unless singleTouch is set to true
singleTouch - (default false) set to true for single touch 
	will override touch setting and turn touch to true but with single touch

METHODS
loop(call, reverse, step, start, end) - see the ZIM Display Methods loop() for details
	 see the ZIM Display Methods loop() for details
hitTestGrid(width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type)
	see the ZIM Display Methods hitTestGrid() for details
disposeAllChildren() - remove and dispose all children
See the CreateJS Easel Docs for Stage methods, such as:
clear, update, toDataURL
And all the Container methods such as:
on, off, setBounds, getBounds, globalToLocal, etc.

PROPERTIES
frame - if made with ZIM Frame then frame points to the frame that made the stage
type - holds the class name as a String
width - read only width set by ZIM Frame
height - read only height set by ZIM Frame

ALSO: see the CreateJS Easel Docs for Stage properties, such as:
autoClear, canvas, nextStage, etc.
and all the Container properties, such as:
children, mouseChildren, filters, cacheCanvas, etc.

Note: also makes a partial zdf allowing circle.center() to work
but will be overwritten if an actual Frame is made

EVENTS
See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.44
zim.Stage = function(canvasID, touch, singleTouch) {
	z_d("50.44");
	if (zot(canvasID)) return;
	var tag = canvasID.tagName=="CANVAS"?canvasID:zid(canvasID);
	if (zot(tag)) return;
	this.cjsStage_constructor(canvasID);
	this.setBounds(0,0,tag.width,tag.height);
	this.type = "Stage";
	if (!WW.zdf) WW.zimDefaultFrame = WW.zdf = {stage:this};
	
	if (singleTouch) createjs.Touch.enable(this, true);
	else if (touch) createjs.Touch.enable(this, false);
				
	this.cache = function(a,b,c,d,scale,options) {
		if (zot(c)) {
			if (zot(a)) {
				var bounds = this.getBounds();
				if (!zot(bounds)) {
					var added = this.borderWidth > 0 ? this.borderWidth/2 : 0;
					a = bounds.x-added;
					b = bounds.y-added;
					c = bounds.width+added*2;
					d = bounds.height+added*2;
				}
			} else {
				c = a;
				d = b;
				a = 0;
				b = 0;
			}
		}
		this.cjsStage_cache(a,b,c,d,scale,options);
		this.z_bc = this.cacheCanvas;
		return this;
	};
	this.on("mousedown", function(e) {
		var e2 = e.clone();
		e2.type = "pressdown";
		e.target.dispatchEvent(e2);
	}, undefined, false, undefined, true);	
	this.loop = function(call, reverse, interval, step, start, end) {
		return zim.loop(this, call, reverse, interval, step, start, end);
	};
	this.hitTestGrid = function(width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type) {
		return zim.hitTestGrid(this, width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type);
	};
	this.disposeAllChildren = function() {
		for (var i=this.numChildren-1; i>=0; i--) {
			var child = this.getChildAt(i)
			if (child.dispose) child.dispose();
		}
		return this;
	};

	this.frame = WW.zdf;
	if (createjs && !createjs.stageTransformable && (WW.zdf.retina || typeof exportRoot != "undefined")) {
		Object.defineProperty(this, 'scale', {
			get: function () {
				return this.cjsStage_scale;
			},
			set: function (value) {
				this.cjsStage_scaleX = value;
				this.cjsStage_scaleY = value;
				zim.scaX = createjs.stageTransformable ? 1 : value;
				zim.scaY = createjs.stageTransformable ? 1 : value;
			}
		});

		Object.defineProperty(this, 'scaleX', {
			get: function () {
				return this.cjsStage_scaleX;
			},
			set: function (value) {
				this.cjsStage_scaleX = value;
				zim.scaX = createjs.stageTransformable ? 1 : value;
			}
		});

		Object.defineProperty(this, 'scaleY', {
			get: function () {
				return this.cjsStage_scaleY;
			},
			set: function (value) {
				this.cjsStage_scaleY = value;
				zim.scaY = createjs.stageTransformable ? 1 : value;
			}
		});
	
		this.localToGlobal = function (x, y) {
			return zim.localToGlobal(x, y, this, this.cjsStage_localToGlobal);
		};
		this.globalToLocal = function (x, y) {
			return zim.globalToLocal(x, y, this, this.cjsStage_globalToLocal);
		};
		this.localToLocal = function (x, y, target) {
			return zim.localToLocal(x, y, target, this);
		};
	}	
};
zim.extend(zim.Stage, createjs.Stage, ["cache","localToLocal","localToGlobal","globalToLocal"], "cjsStage", false);

//-50.44

/*--
zim.StageGL = function(canvasID, options, touch, singleTouch)

StageGL
zim class - extends a zim.Stage which extends a createjs.Stage

DESCRIPTION
An extension of a zim.Stage for WebGL support
See ZIM Stage and https://www.createjs.com/docs/easeljs/classes/StageGL.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const stage = new StageGL("canvasID", {preserveBuffer:true, antialias:true});
END EXAMPLE

PARAMETERS
canvasID - (default null) string ID for canvas tag
options - (default null) an object literal with the following properties
	FROM https://www.createjs.com/docs/easeljs/classes/StageGL.html
    preserveBuffer (default false)
    	If true, the canvas is NOT auto-cleared by WebGL (the spec discourages setting this to true). This is useful if you want persistent draw effects.
	antialias (default false)
		Specifies whether or not the browser's WebGL implementation should try to perform anti-aliasing. This will also enable linear pixel sampling on power-of-two textures (smoother images).
	transparent (default false)
		If true, the canvas is transparent. This is very expensive, and should be used with caution.
	premultiply (default false)
		Alters color handling. If true, this assumes the shader must account for pre-multiplied alpha. This can help avoid visual halo effects with some assets, but may also cause problems with other assets.
	autoPurge (default 1200)
	 	How often the system should automatically dump unused textures with purgeTextures(autoPurge) every autoPurge/2 draws. See purgeTextures for more information.
touch - (default false) set to true for touch on mobile 
	will be multitouch unless singleTouch is set to true
singleTouch - (default false) set to true for single touch 
	will override touch setting and turn touch to true but with single touch

METHODS
loop(call, reverse, step, start, end) - see the ZIM Display Methods loop() for details
	 see the ZIM Display Methods loop() for details
hitTestGrid(width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type)
	see the ZIM Display Methods hitTestGrid() for details
disposeAllChildren() - remove and dispose all children
See the CreateJS Easel Docs for StageGL methods:
https://www.createjs.com/docs/easeljs/classes/StageGL.html

PROPERTIES
frame - if made with ZIM Frame then frame points to the frame that made the stage
type - holds the class name as a String
width - read only width set by ZIM Frame
height - read only height set by ZIM Frame

See the CreateJS Easel Docs for Stage properties:
https://www.createjs.com/docs/easeljs/classes/StageGL.html

Note: also makes a partial zdf allowing circle.center() to work
but will be overwritten if an actual Frame is made

EVENTS
See the CreateJS Easel Docs for StageGL events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.45
zim.StageGL = function(canvasID, options, touch, singleTouch) {
		z_d("50.45");
		if (zot(canvasID)) return;
		var tag = canvasID.tagName=="CANVAS"?canvasID:zid(canvasID);
		if (zot(tag)) return;
		this.cjsStageGL_constructor(canvasID, options);
		this.setBounds(0,0,tag.width,tag.height);
		this.type = "StageGL";
		if (!WW.zdf) WW.zdf = {stage:this};
		if (singleTouch) createjs.Touch.enable(this, true);
		else if (touch) createjs.Touch.enable(this, false);
		this.cache = function(a,b,c,d,scale,options) {
			if (zot(c)) {
				if (zot(a)) {
					var bounds = this.getBounds();
					if (!zot(bounds)) {
						var added = this.borderWidth > 0 ? this.borderWidth/2 : 0;
						a = bounds.x-added;
						b = bounds.y-added;
						c = bounds.width+added*2;
						d = bounds.height+added*2;
					}
				} else {
					c = a;
					d = b;
					a = 0;
					b = 0;
				}
			}
			this.cjsStageGL_cache(a,b,c,d,scale,options);
			this.z_bc = this.cacheCanvas;
			return this;
		};
		this.on("mousedown", function(e) {
			var e2 = e.clone();
			e2.type = "pressdown";
			e.target.dispatchEvent(e2);
		}, undefined, false, undefined, true);	
		this.loop = function(call, reverse, interval, step, start, end) {
			return zim.loop(this, call, reverse, interval, step, start, end);
		};
		this.hitTestGrid = function(width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type) {
			return zim.hitTestGrid(this, width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type);
		};
		this.disposeAllChildren = function() {
			for (var i=this.numChildren-1; i>=0; i--) {
				var child = this.getChildAt(i)
				if (child.dispose) child.dispose();
			}
			return this;
		};
		
		this.frame = WW.zdf;
		if (createjs && !createjs.stageTransformable && (WW.zdf.retina || typeof exportRoot != "undefined")) {
			Object.defineProperty(this, 'scale', {
				get: function() {
					return this.cjsStage_scale;
				},
				set: function(value) {
					this.cjsStage_scaleX = value;
					this.cjsStage_scaleY = value;
					zim.scaX = createjs.stageTransformable ? 1 : value;
					zim.scaY = createjs.stageTransformable ? 1 : value;
				}
			});

			Object.defineProperty(this, 'scaleX', {
				get: function() {
					return this.cjsStage_scaleX;
				},
				set: function(value) {
					this.cjsStage_scaleX = value;
					zim.scaX = createjs.stageTransformable ? 1 : value;
				}
			});

			Object.defineProperty(this, 'scaleY', {
				get: function() {
					return this.cjsStage_scaleY;
				},
				set: function(value) {
					this.cjsStage_scaleY = value;
					zim.scaY = createjs.stageTransformable ? 1 : value;
				}
			});

			this.localToGlobal = function(x,y) {
				return zim.localToGlobal(x,y,this,this.cjsStageGL_localToGlobal);
			};
			this.globalToLocal = function(x,y) {
				return zim.globalToLocal(x,y,this,this.cjsStageGL_globalToLocal);
			};
			this.localToLocal = function(x,y,target) {
				return zim.localToLocal(x,y,target,this);
			};
		}
	};
	zim.extend(zim.StageGL, createjs.StageGL, ["cache","localToLocal","localToGlobal","globalToLocal"], "cjsStageGL", false);

	//-50.45

/*--
zim.Container = function(a, b, c, d, style, group, inherit)

Container
zim class - extends a createjs.Container

DESCRIPTION
A Container object is used to hold other display objects or other containers.
You can then move, rotate, scale and skew the container and all objects inside will transform accordingly.
You can apply an event on a container and use the target property of the event object
to access the object in the container that caused the event
or use the currentTarget property of the event object to access the container itself.
Containers do not have bounds unless some items in the container have bounds -
at which point the bounds are the combination of the bounds of the objects with bounds.
You can manually set the bounds with setBounds(x,y,w,h) - read the CreateJS docs.
Or pass in width and height, or boundsX, boundsY, width, height to have Container set bounds.
Manually set bounds will not update automatically unless you setBounds(null).

NOTE: All the ZIM shapes and components extend the Container.
This means all shapes and components inherit the methods and properties below
and indeed, the Container inherits all the createjs.Container methods and properties.
See the CreateJS documentation for x, y, alpha, rotation, on(), addChild(), etc.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE 
const container = new Container().loc(100,100);

// demonstration of adding drag() to a Container
const rect = new Rectangle(100, 100, blue)
   .addTo(container); // add rectangle to container
const circle = new Circle(40, red)
   .center(container) // add the circle to the container and center
container.drag(); // will drag either the rectangle or the circle
container.drag({all:true}); // will drag both the rectangle and the circle

// below will reduce the alpha of the object in the container that was clicked (target)
container.on("click", e => {e.target.alpha = .5; S.update();});

// below will reduce the alpha of all the objects in the container (currentTarget)
container.on("click", e => {e.currentTarget.alpha = .5; S.update();});
END EXAMPLE

EXAMPLE
// Here we apply the normalize() method of the Container to a Tile (which is a Container)
// and scale the children based on the resulting ratio
const tile = new Tile(new Rectangle(70,70,white,black).reg(CENTER), 9, 1, 20)
	.normalize("x", CENTER)
	.center();

// scale the items based on the distance from the center
// note, could set the strokeObj:{ignoreScale:true} param of Rectangle above too
tile.loop(item=>{
	zogy(decimals(item.ratio)); // 0, .3, .5, .8, 1, .8, .5, .3, 0
	item.sca(.5 + item.ratio*2);
});

// adjust the spacing by re-tiling the scaled items
const final = new Tile({
	obj:tile.items, 
	cols:tile.items.length,
	rows:1,
	spacingH:-10,
	unique:true, // make sure we do not pick (ZIM VEE) from the array
	valign:CENTER
}).center()

tile.dispose();

final.sortBy("ratio"); // make more central objects come to front
END EXAMPLE

EXAMPLE 
// In this case we animate the children based on the rate
// animate() the rate and use sequence:0 to apply different speed to each item
const tile = new Tile(new Rectangle(10, 10, series(green,blue,yellow)), 20, 20, 5, 5)
	.normalize("reg", CENTER)
	.center()
	.noMouse()
	.animate({
		props:{scale:2},
		time:2,
		ease:"elasticOut",
		rate:target=>{return 1 + target.ratio*4},
		sequence:0 // turn on per item animation
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** Container has a, b, c, d parameters to set x, y, width and height 
	There are two settings that are more common than providing all four parameters:
		1. provide no parameters to make a Container with bounds that grow with content. 
		2. provide a and b only to make a Container with a width and height (and bounds with x and y of 0)
	Here is what happens when you provide 1, 2 or all of the a,b,c,d parameters:
a - (default null) - width and height will be equal to parameter a (x and y will be 0)
	or provide a ZIM Boundary() object or createjs Rectangle() object with x, y, width and height properties 
a, b - (default null) - the width and height (x and y will be 0) 
	this is the normal way to make a container with a starting width and height
a, b, c, d - (default null) - the x, y, width and height of the bounds
	if parameter a is not set, then the Container will take bounds that grow with its content
	the bounds of the Container can be set at any time with setBounds(a, b, c, d)
	if the bounds are set, then the Container bounds will not change as content is added
	the bounds can be removed with setBounds(null) and the Container will get auto bounds
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
* This class has all the DISPLAY METHODS introduced in ZIM 4TH
* the methods are available to all ZIM Display objects that extend a ZIM Container
* such as ZIM Rectangle, Circle, Triangle, BLob
* as well as all components like: Label, Button, Slider, Dial, Tab, Pane, etc.
* as well as the ZIM display wrappers: Container, Shape, Sprite, MovieClip and Bitmap
cache(width||x, height||y, null||width, null||height, scale, options, margin, rtl, willReadFrequently) - overrides CreateJS cache() and returns object for chaining
	** Supports ZIM DUO
	If you do not provide the first four parameters, then the cache dimensions will be set to the bounds of the object
	width||x - (default getBounds().x) the width of the chache - or the x if first four parameters are provided
	height||y - (default getBounds().y) the height of the chache - or the y if first four parameters are provided
	width - (default getBounds().width) the width of the chache - or null if first two parameters are provided
	height - (default getBounds().height) the height of the chache - or null if first two parameters are provided
	scale - (default 1) set to 2 to cache with twice the fidelity if later scaling up
	options - (default null) additional parameters for cache logic - see CreateJS somewhere for details
		also added adjustBounds property for options - set to true to set new bounds and registration point 
		on cached objects with x,y,width,height different than the original
		this appears to NOT be the default with createjs cache() which keeps the original registration point and bounds
		automatically fixing this changes lots of things so use the adjustBounds option when needed 
		for instance when caching parts of a container and requiring hit tests or the part to be draggable, etc.
	margin - (default 0) add or subtract a margin from the bounds
		eg. margin:10 will make the cache size 10 pixels more on all sides
		this can be handy when caching objects with borders - that go half outside the natural bounds
	rtl - (default null) set to true to use right to left
	willReadFrequently - (default null) set to true if planning on using operations with getImageData() or toDataURL()
		if you get a warning in the console about willReadFrequently then set this to true
updateCache() - updates the cache if cache() is set 
uncache() - uncaches and returns object for chaining
setBounds(width||x||Boundary, height||y, null||width, null||height) - overrides CreateJS setBounds() and returns object for chaining
	If you do not provide any parameters, then the bounds will be reset to the calculated bounds
	width||x||Boundary - (default null) the width of the bounds - or the x if four parameters are provided
		or a ZIM Boundary Object {x,y,width,height} - same as CreateJS Rectangle - thanks Joseph Diefenbach
	height||y - (default width) the height of the bounds - or the y if four parameters are provided
	width - (default null) the width of the bounds - or null if only the first two parameters are provided
	height - (default null) the height of the bounds - or null if only the first two parameters are provided
getBounds(targetSpace) - overrides CreateJS getBounds() and returns a rectangle with x, y, width height of bounds (not including outside of border) 
	pass in a Container (including Stage) to map rectangle to that coordinate space 
childrenToBitmap() - turns content to a Bitmap and adds bitmap to container - removing all other children
sortBy(prop) - sorts the children of the container by a property - must be numeric
normalize(prop, from, from2, min, max, factor, clamp) - sets a ratio property (1 to 0) for each item in a Container.
	passing in no parameters will normalize to the last normalized parameters - also see normalized property
	** Supports ZIM DUO
	PARAMETERS: prop - the property (as a string) to normalize  
		from - where the ratio will start at 1, values can be START (highest number), END (lowest number), CENTER, LEFT, RIGHT
		from2 - used with "reg" with values of START, END, CENTER, TOP, BOTTOM - see the SPECIAL note down below.
		min and max - can be set to override the calculated min and max values for the items in container - min and max are ignored for "reg"
		factor - (default 1) is going the same direction and -1 is going in opposite direction
		targetRound - (default false) set to true to round the converted number
		clamp - (default true) set to false to let results go outside min and max range
	WORKINGS: the ratio is 1 when it is closest to the from parameter(s) and 0 when farthest
		For example, container.normalize("x") would provide a ratio property for each item in the container 
		with a default from START that would be 1-item.x/(largestX-smallestX)
		In other words, if the item is the least distance in the x then ratio is 1, if the item is the most distance in the x then the ratio is 0
		The from parameter will determine where the ratio is the largest.
		container.normalize("x", END) would be 0 for an x of 0 and 1 for an item on the right side 
		container.normalize("x", CENTER) would be 1 for an item in the middle and 0 for items at the start and end
		Set factor to -1 to reverse the direction of the ratio - eg. 0 in the middle and 1 at the start and end.
		Or set min and max values to override the calculated min and max
		The clamp, if true, will keep values between min and max or let them go outside these if false
		there is one ratio property per object but this can be set and used any number of times.
	NOTE: The ratio property is like a ZIM Proportion convert() but to each item in the container.
		A provided property is converted based on a min and max to a target of 1 to 0 (factor is inverted)
	SPECIAL: a property of "reg" will actually set the registration to the from value
		the still property of reg() is used to keep the item from shifting.
		An _orX and _orY will be provided on each item for original regX and regY.
		setting normalize("reg", CENTER) will do both horizontal and vertical to the container dimensions.
		If this is not desired, use container.loop(item=>{item.reg(item._orX, item._orY, true)}); 
		to set the registration point back but still keep the ratio property 
	USAGE: the ratio property can be used by animate() with sequenceRate to set the rate of an animation based on ratio 
		Or the ratio property can be used directly - for instance, to set a scale based on a distance from somewhere 
		Or as another example, set the alpha based on the rotation of a shape in the container    
specialColor(colorCommand, colorObject) - used internally by ZIM Shapes
	to set GradientColor, RadialColor and BitmapColor on a fill or stroke color command
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - clones the container, its properties and all its children
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if a Container holds a new Circle(20,[blue,green])
	then its clone might be blue or green
	If exact is set to true then the clone will be whatever color was picked for the original circle
disposeAllChildren() - removes and disposes all children but leaves the container (see also CreateJS removeAllChildren() which does not dispose them) 
dispose(disposing) - removes from parent, removes event listeners - must still set outside references to null for garbage collection
	if calling dispose() on the super class from a custom class then pass in true to indicate already started dispose (otherwise infinite loops)

ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES 
** common to all DisplayObjects that extend a Container such as ZIM Shapes and Components
type - holds the class name as a String
group - used when the object is made to add STYLE with the group selector (like a CSS class)
** bounds must be set first (or width and height parameters set) for these to work
** setting these adjusts scale not bounds and getting these uses the bounds dimension times the scale
width - gets or sets the width. Setting the width will scale the height to keep proportion (see widthOnly below)
height - gets or sets the height. Setting the height will scale the width to keep proportion (see heightOnly below)
widthOnly - gets or sets the width.  This sets only the width and may change the aspect ratio of the object
heightOnly - gets or sets the height.  This sets only the height and may change the aspect ratio of the object
ratio - get a ratio set by the Container normalize method() - or Tile itemRegX, itemRegY parameters
    this will probably be a value from 1 to 0 as to how close the property is the end specified in the from parameter of normalize()
    a value of 1 is the closest and a value of 0 is the farthest - see the normalize() method for details
normalized - get if the container has been normalized - see normalized parameter
draggable - set to true for a default drag() and false for a noDrag()
level - gets or sets the level of the object in its parent container (or the stage) - a property for parent.getChildIndex() and parent.setChildIndex()
depth - for ZIM VR - the depth used to shift left and right channel and for parallax in VR - also see dep() ZIM Display method
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
effects - an object that holds effects added such as blur, glow, shadow, color, multi and alpha - see effect() under ZIM Methods 
** the following are convenience Effects that run a ZIM MultiEffect()
** these can use a lot of processing when animating - see Docs for effects() 
** batch versions are available too as hueBatch, etc. these will not update the effect until updateEffects() is called on the object
hue - the tint of an object between -180 and 180 with 0 being no change 
	Also see the keyOut() method of Bitmap(), Pic() and SVG() that has a replacement color parameter
saturation - the amount of color of an object between -100 and 100 with 0 being no change 
brightness - the lightness or darkness of an object between -255 and 255 with 0 being no change 
contrast - the crispness of an object between -100 and 100 with 0 being no change 

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scale, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.5
	zim.Container = function(a, b, c, d, style, group, inherit) {
		var sig = "a, b, c, d, style, group, inherit";
		var duo; if (duo = zob(zim.Container, arguments, sig, this)) return duo;
		if (!zim.containerCheck) {
			z_d("50.5");
			z_d("50.435"); // global dispose too - may not catch dispose in DISTILL check
			zim.containerCheck=true;
		}
		this.cjsContainer_constructor();
		this.type = "Container";
		this.group = group;
		var that = this;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);		

		if (zot(a)) a = DS.a!=null?DS.a:null;
		if (zot(b)) b = DS.b!=null?DS.b:null;
		if (zot(c)) c = DS.c!=null?DS.c:null;
		if (zot(d)) d = DS.d!=null?DS.d:null;		

		var n = normalizeBounds(a, b, c, d);		
		function normalizeBounds(a, b, c, d) {
			var bounds = [];
			if (zot(a)) {
				bounds = [a,b,c,d];
			} else if (zot(b)) {
				if (a.x) bounds = [a.x, a.y, a.width, a.height]; 	
				else {
					bounds[0] = 0;
					bounds[1] = 0;
					bounds[2] = a;
					bounds[3] = a;
				}		
			} else if (!zot(c)) {
				bounds[0] = a;
				bounds[1] = b;
				bounds[2] = c;
				bounds[3] = d;
			} else {
				bounds[0] = 0;
				bounds[1] = 0;
				bounds[2] = a;
				bounds[3] = b;
			}
			if (zot(bounds[3])) bounds[3] = bounds[2];
			return bounds;
		}
		
		if (!zot(a)) this.setBounds(n[0],n[1],n[2],n[3]); // es6 to fix		

		this.cache = function(a,b,c,d,scale,options,margin,rtl,willReadFrequently) {			
			if (that.type=="AC"&&WW.zdf) {WW.zdf.ac("cache", arguments, that); return that;}
			var sig = "a,b,c,d,scale,options,margin,rtl,willReadFrequently";
			var duo; if (duo = zob(that.cache, arguments, sig)) return duo;
			var bounds = that.getBounds();
			if (zot(c)) {
				if (zot(a)) {
					if (!zot(bounds)) {
						var added = that.borderWidth > 0 ? that.borderWidth/2 : 0;
						a = bounds.x-added;
						b = bounds.y-added;
						c = bounds.width+added*2;
						d = bounds.height+added*2;
					}
				} else {
					c = a;
					d = b;
					a = 0;
					b = 0;
				}
			}			
			if (that.type == "Triangle") {
				a-=that.borderWidth?that.borderWidth:0;
				c+=that.borderWidth?that.borderWidth*2:0;
				b-=that.borderWidth?that.borderWidth:0;
				d+=that.borderWidth?that.borderWidth*2:0;
			}
			if (zot(margin)) margin = 0;

			that.cjsContainer_cache(a-margin,b-margin,c+margin*2,d+margin*2,scale,options,rtl,willReadFrequently);
			
			// if (bounds && options && options.adjustBounds && (a!=bounds.x || b!=bounds.y || c!=bounds.width || d!=bounds.height)) {  
			// 	zog("015")                  
            //     that.setBounds(a, b, c, d);
            //     that.reg(a,b);
            //     that.hitArea = new zim.Shape().f(black).dr(a-margin,b-margin,c+margin*2,d+margin*2);                
            // }		
		
			if (bounds && ((that.width == 0 && c > 0) || (options && options.adjustBounds))) {   
				var oW = that.width;
                that.setBounds(a, b, c, d);	
				if (oW != 0) {
					if (a!=bounds.x || b!=bounds.y || c!=bounds.width || d!=bounds.height) that.reg(a,b);
					that.hitArea = new zim.Shape().f(black).dr(a-margin,b-margin,c+margin*2,d+margin*2);        
				}        
            }			
			that.z_bc = that.canvas = that.cacheCanvas;
			return that;
		};
		this.uncache = function() {
			that.cjsContainer_uncache();
			return that;
		};
		this.childrenToBitmap = function () {
			var cached = this.cacheCanvas;
			var pic = new zim.Bitmap(this.cache().cacheCanvas);
			if (!cached) this.uncache();
			this.removeAllChildren();
			pic.addTo(this);
			return this;
		};

		this.sortBy = function(prop, inverse) {
			if (zot(prop)) return this;
			var sortFunction = function(obj1, obj2, options) {
				if (obj1[prop] > obj2[prop]) { return inverse?-1:1; }
				if (obj1[prop] < obj2[prop]) { return inverse?1:-1; }
				return 0;
			}
			this.sortChildren(sortFunction);
			return this;
		}
        
		this.normalize = function(prop, from, from2, min, max, factor, clamp) {

            // TODO - special hue, saturation, etc.

			var sig = "prop, from, from2, min, max, overflow, flip";
			var duo; if (duo = zob(that.normalize, arguments, sig)) return duo;

            if (this.z_norm) {
                if (zot(prop)) prop = this.z_norm.prop;
                if (zot(from)) from = this.z_norm.from;
                if (zot(from2)) from2 = this.z_norm.from2;
                if (zot(from2)) min = this.z_norm.min;
                if (zot(max)) max = this.z_norm.max;
                if (zot(factor)) factor = this.z_norm.factor;
                if (zot(clamp)) clamp = this.z_norm.clamp;
            }

			if (zot(from)) from = "start";
			else if (from == "left") from = "start";
			else if (from == "right") from = "end";
			else if (from == "middle") from = "center";
			else if (from != "start" && from != "center" && from != "end") from = "start";
			if (from=="center" && zot(from2)) from2 = "center";
			if (from2 == "top") from2 = "start";
			else if (from2 == "bottom") from2 = "end";
			else if (from2 == "middle") from2 = "center";
			else if (from2 != "start" && from2 != "center" && from2 != "end") from2 = "start";           

            this.z_norm = {prop:prop, from:from, from2:from2, min:min, max:max, factor:factor, clamp:clamp}; 

            this.normalized = true;
            that.saveOriginalReg = function() {
                that.loop(c=>{
                    c._orX = c.regX;
                    c._orY = c.regY;
                });
            }    
            that.resetOriginalReg = function() {
                that.loop(c=>{
                    c.reg(c._orX, c._orY, true);	
                });
            }   

			if (prop == "reg") {
				that.resetOriginalReg();
				that.saveOriginalReg(); 
			
				// loop items and shift reg with third param true 
				var maxX = -10000000;
				var maxY = -10000000;

				that.loop(c=>{		
					c._dx = c._dy = null;			
					if (from == "center") c._dx = that.width/2-c.x;
					else if (from == "end") c._dx = that.width-c.x;
					else if (from == "start") c._dx = 0-c.x;
					if (from2 == "center") c._dy = that.height/2-c.y;
					else if (from2 == "start") c._dy = 0-c.y;
					else if (from2 == "end") c._dy = that.height-c.y;
					c.reg(c._dx,c._dy,true);
					maxX = Math.max(maxX, Math.abs(c._orX-c._dx));
					maxY = Math.max(maxY, Math.abs(c._orY-c._dy));
				});
				that.loop(c=>{
					c.ratio = 1 - (Math.sqrt(Math.pow((c._orX-c._dx),2) + Math.pow((c._orY-c._dy),2)) / Math.sqrt(Math.pow(maxX,2) + Math.pow(maxY,2)));
					if (factor==-1) c.ratio = 1-c.ratio;
					if (clamp) c.ratio = zim.constrain(c.ratio, 0, 1);				
				});
				
			} else { // not reg
				if (zot(min) || zot(max)) setMM();
				var d;
				if (from == "start") d = [0,1,-1];
				else if (from == "end") d = [0,1,1];
				if (from == "center") d = [-1,1,-1];
				that.proportion = new zim.Proportion(min, max, d[0], d[1], d[2], false, clamp);				
				that.loop(function(c) {					
					c.ratio = Math.abs(that.proportion.convert(c[prop]));
					if (from == "center") c.ratio = 1-c.ratio;
				});
			}		

			function setMM() {
				var minC = 1000000000;
				var maxC = -1000000000;
				that.loop(c=>{	
					if (zot(min) && c[prop] < minC) minC = c[prop];
					if (zot(max) && c[prop] > maxC) maxC = c[prop];
				});
				if (zot(min)) min = minC;
				if (zot(max)) max = maxC;
			}			
            return this;
		}

        

		var frame = WW.zdf || 1;		
		if (createjs && !createjs.stageTransformable && frame.retina) {
			this.localToGlobal = function(x,y) {
				return zim.localToGlobal(x,y,this,this.cjsContainer_localToGlobal);
			};
			this.globalToLocal = function(x,y) {
				return zim.globalToLocal(x,y,this,this.cjsContainer_globalToLocal);
			};
			this.localToLocal = function(x,y,target) {
				return zim.localToLocal(x,y,target,this);
			};
		}
		this.setBounds = function(a,b,c,d) {
			var n = normalizeBounds(a, b, c, d);
			that.cjsContainer_setBounds(n[0],n[1],n[2],n[3]);
			return that;
		};
		this.getBounds = function(targetSpace) {
			if (targetSpace) {
				return that.boundsToGlobal(null,null,null,targetSpace);
			}
			return that.cjsContainer_getBounds();
		};
				
		this.disposeAllChildren = function() {
			for (var i=this.numChildren-1; i>=0; i--) {
				var child = this.getChildAt(i)
				if (child.dispose) child.dispose();
			}
			return this;
		};
			
		zim.displayBase(that);
		
		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
		this.clone = function(exact) {
			if (this.type=="AC"&&WW.zdf) {
				if (zon) {zogy("ZIM asset() - cannot clone lazy-loaded asset - use Frame() assets parameter or loadAssets() method")}
				WW.zdf.ac("clone", arguments, this); 
				return this;
			}
			var currentBounds = this.getBounds();
			if (zot(currentBounds)) currentBounds = {x:null, y:null, width:null, height:null};
			return this.cloneChildren(this.cloneProps(new zim.Container(currentBounds.x,currentBounds.y,currentBounds.width,currentBounds.height, style, this.group, inherit)), exact);
		};
		this.hasProp = function(prop) {
			return (!zot(this[prop]) || Object.prototype.hasOwnProperty.call(this,prop));
		};
	};
	zim.Container.prototype.dispose = function(disposing) {			
		recursiveDispose(this, disposing);
		return true;
	};
	zim.Container.prototype.specialColor = function(command, co, obj, bounds) {
		if (co.type=="GradientColor") {
			if (!zot(co.angle)) {
				if (!obj.width && zot(bounds)) {
					command.style = co.colors[0]; 
					return;
				} else {
					var b = bounds?bounds:obj.getBounds();
					co.angle += 360*100000;
					co.angle %= 360;	
					
					if (obj.type=="Circle") {
						var x = b.width/2*Math.cos(co.angle*RAD);
						var y = b.width/2*Math.sin(co.angle*RAD);
						co.x0 = -x;
						co.y0 = -y;
						co.x1 = x;
						co.y1 = y;
					} else {									
						var a = co.angle%90;
						var o = b.width*Math.sin(a*RAD);
						var x1 = o*Math.sin(a*RAD);
						var y1 = -o*Math.cos(a*RAD);										
						var o2 = b.height*Math.sin(a*RAD);
						var x2 = b.width+o2*Math.cos(a*RAD);
						var y2 = o2*Math.sin(a*RAD);					
						var o3 = b.height*Math.sin(a*RAD);
						var x3 = -o3*Math.cos(a*RAD);
						var y3 = b.height-o3*Math.sin(a*RAD);	
						
						if (co.angle>=0&&co.angle<90) {
							co.x0 = b.x+x1;
							co.y0 = b.y+y1;
							co.x1 = b.x+x2;
							co.y1 = b.y+y2;
						} else if (co.angle>=90&&co.angle<180) {
							co.x0 = b.x+x1;
							co.y0 = b.y+y1;
							co.x1 = b.x+x3;
							co.y1 = b.y+y3;
						} else if (co.angle>=180&&co.angle<270) {
							co.x0 = b.x+x2;
							co.y0 = b.y+y2;
							co.x1 = b.x+x1;
							co.y1 = b.y+y1;
						} else {
							co.x0 = b.x+x3;
							co.y0 = b.y+y3;
							co.x1 = b.x+x1;
							co.y1 = b.y+y1;
						}		
					}		
					// new Shape().s(red).ss(2).mt(co.x0,co.y0).lt(co.x1,co.y1).addTo(obj)
					// new Circle(10,red).loc(co.x0,co.y0,obj)
				}
			} 
			command.linearGradient(co.colors, co.ratios, co.x0, co.y0, co.x1, co.y1);
			
		} else if (co.type=="RadialColor") {
			
			if (zot(co.x0) && zot(bounds)) {
				if (!obj.width) {
					command.style = co.colors[0]; 
					return;
				} else {
					var b = bounds?bounds:obj.getBounds();
					co.r0 = 0;				
					if (obj.type=="Circle") {					
						co.x0 = 0;
						co.y0 = 0;			
						// note x1 and y1 are defined down below			
						co.r1 = b.width/2; // note r0 is defined above
					} else {									
						co.x0 = b.x+b.width/2;
						co.y0 = b.y+b.height/2;
						co.r1 = Math.sqrt(Math.pow(b.width/2,2)+Math.pow(b.height/2,2));
					}	
					co.x1 = co.x0;
					co.y1 = co.y0;	
					
					// new Shape().s(red).ss(2).mt(co.x0,co.y0).lt(co.x1,co.y1).addTo(obj)
					// new Circle(10,red).loc(co.x0,co.y0,obj)
				}
			} 
			command.radialGradient(co.colors, co.ratios, co.x0, co.y0, co.r0, co.x1, co.y1, co.r1);
		}
		else if (co.type == "BitmapColor") command.bitmap(co.image, co.repetition, co.matrix);
	};

	function recursiveDispose(obj, disposing) {	
		// zogr(obj.type)
		if (obj) zim.gD(obj); // globalDispose function for common elements
		// dispose was fixed in ZIM 10.7.0 in TWO ways:
		// ONE
		// Some classes have custom dispose - so may want to call these.
		// If disposing is true then we are coming from a custom dispose already
		// otherwise, call the custom dispose and pass true to say we are already disposing containers
		// otherwise the custom dispose will try and call the container dispose and we have an endless loop
		if (!disposing && obj && obj.dispose && obj.dispose !== zim.Container.prototype.dispose) {
			obj.dispose(null,null,true);
		}
		// TWO
		// dispose was only disposing type=="CONTAINER"
		// so should have been type=="Container" - but even that is too narrow
		// as would not include components parts or Tile parts, etc.
		// so fixed it to include all decendents of Container by testing for addChild
		// zog(obj.type)
		// if (obj.type == "Container") {
		if (obj && obj.addChild) {
			obj.dispatchEvent("removed");
			obj.removeAllEventListeners();
			if (obj.numChildren) {
				for (var i=obj.numChildren-1; i>=0; i--) {
					recursiveDispose(obj.getChildAt(i));
				}
			}
		}
		if (obj && obj.parent) obj.parent.removeChild(obj);
	}
	zim.extend(zim.Container, createjs.Container, ["cache","uncache","setBounds","getBounds","clone","localToLocal","localToGlobal","globalToLocal"], "cjsContainer", false);
	zimify(zim.Container.prototype);
	//-50.5
	
/*--
zim.Shape = function(a, b, c, d, graphics, optimize, style, group, inherit)

Shape
zim class - extends a createjs.Shape

DESCRIPTION
ZIM Shape lets you draw dynamic shapes beyond the ZIM provided shapes.
You make a new shape object and then draw in its graphics property
using similar commands to the HTML Canvas commands (and Flash Bitmap drawing).
See the CreateJS Easel Shapes and Graphics docs:
https://www.createjs.com/docs/easeljs/classes/Graphics.html

ALSO SEE: https://zimjs.com/docs.html?item=Generator for dynamically drawing into shapes like Processing (P5js)
ALSO SEE: https://zimjs.com/docs.html?item=Squiggle,Blob for odd shapes and user adjustable shapes 
ALSO SEE: https://zimjs.com/docs.html?item=Pen for dynamic drawing of lines
ALSO SEE: https://zimjs.com/docs.html?item=Connectors for dynamic connections
// these mean we rarely use Shape directly but all of above were made in ZIM with Shape

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

NOTE: as of ZIM 10.6.0 the tiny API is available right on the Shape (no need for graphics)

EXAMPLE
// NEWER CODE
// Uses the tiny API (see options down below) right on the ZIM Shape
// for example: f() is fill() and dr() is drawRect()
// s() is beginStroke(), ss() is setStrokeStyle(), mt() is moveTo(), lt() is lineTo()

// draw a red rectangle into a shape
new Shape().f(red).dr(0,0,200,100).addTo();
// but it would be easier to use
// new Rectangle(200, 100, red).addTo();

// we can draw lines, etc. (but also see the ZIM Line object)
new Shape().s(blue).ss(5).mt(200,200).lt(300,300).addTo();

// note - we can draw as much as we want in the same shape
END EXAMPLE 

EXAMPLE 
// OLDER CODE
// The first example uses a tiny API (see options below)
// The traditional full commands are available on the graphics object:
const shape = new Shape().addTo();
shape.graphics.beginFill(red).drawRect(0,0,200,100);

// or often we stored the graphics object in a variable g 
const g = shape.graphics; 
g.beginStroke(blue).moveTo(200,200).lineTo(300,300);
END EXAMPLE 

EXAMPLE
// to change a color or stroke after it has been made use command:
const shape = new Shape().addTo();
const strokeColor = shape.s(red).command;
shape.dr(50,50,100,100);
S.update();
timeout(1, ()=>{
	strokeColor.style = blue;
	S.update();
});
// This seems a little complex which is why ZIM provides many basic shapes 
// Rectangle, Circle, Triangle, Squiggle, Blob, Poly, Line, Flare
// that can be adjusted dynamically with properties
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** Shape supports three different sets of parameters as follows:
a - (default null) - width and height equal to parameter a (x and y will be 0)
a, b - (default null) - the width and height (x and y will be 0)
a, b, c, d - (default null) - the x, y, width and height of the bounds
graphics - (default null) a CreateJS Graphics instance (see CreateJS docs)
	or just use the graphics property of the shape object (like usual)
optimize - (default false) set to true to not store graphics methods directly on Shape
	this means the shapes graphics property will need to be used to access f(), s(), ss(), etc.
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
The following shortcuts to CreateJS graphics methods are provided (as long as optimize is false)
See https://www.createjs.com/docs/easeljs/classes/Graphics.html for definitions and parameters
mt()	moveTo
lt()	lineTo
a() 	arc
at()	arcTo
bt()	bezierCurveTo
ct()	curveTo
qt()	quadraticCurveTo (same as curveTo)
r() 	rect
cp()	closePath
c() 	clear
f() 	beginFill
lf()	beginLinearGradientFill
rf()	beginRadialGradientFill
bf()	beginBitmapFill
ef()	endFill
ss()	setStrokeStyle
sd()	setStrokeDash
s() 	beginStroke
ls()	beginLinearGradientStroke
rs()	beginRadialGradientStroke
bs()	beginBitmapStroke
es()	endStroke
dr()	drawRect
rr()	drawRoundRect
rc()	drawRoundRectComplex
dc()	drawCircle
de()	drawEllipse
dp()	drawPolyStar
pg()	polygon // added in ZIM CreateJS 1.3.3 (Diamond)
p() 	decodePath
cache(width||x, height||y, null||width, null||height, scale, options, margin, rtl, willReadFrequently) - overrides CreateJS cache() and returns object for chaining
	** Supports ZIM DUO
	If you do not provide the first four parameters, then the cache dimensions will be set to the bounds of the object
	width||x - (default getBounds().x) the width of the chache - or the x if first four parameters are provided
	height||y - (default getBounds().y) the height of the chache - or the y if first four parameters are provided
	width - (default getBounds().width) the width of the chache - or null if first two parameters are provided
	height - (default getBounds().height) the height of the chache - or null if first two parameters are provided
	scale - (default 1) set to 2 to cache with twice the fidelity if later scaling up
	options - (default null) additional parameters for cache logic - see CreateJS somewhere for details
		also added adjustBounds property for options - set to true to set new bounds and registration point 
		on cached objects with x,y,width,height different than the original
		this appears to NOT be the default with createjs cache() which keeps the original registration point and bounds
		automatically fixing this changes lots of things so use the adjustBounds option when needed 
		for instance when caching parts of a container and requiring hit tests or the part to be draggable, etc.
	margin - (default 0) add or subtract a margin from the bounds
		eg. margin:10 will make the cache size 10 pixels more on all sides
		this can be handy when caching objects with borders - that go half outside the natural bounds
	rtl - (default false) set to true to use right to left
	willReadFrequently - (default null) set to true if planning on using operations with getImageData() or toDataURL()
		if you get a warning in the console about willReadFrequently then set this to true
setBounds(width||x||Boundary, height||y, null||width, null||height) - overrides CreateJS setBounds() and returns object for chaining
	If you do not provide any parameters, then the bounds will be reset to the calculated bounds
	width||x||Boundary - (default null) the width of the bounds - or the x if four parameters are provided
		or a ZIM Boundary Object {x,y,width,height} - same as CreateJS Rectangle - thanks Joseph Diefenbach
	height||y - (default width) the height of the bounds - or the y if four parameters are provided
	width - (default null) the width of the bounds - or null if only the first two parameters are provided
	height - (default null) the height of the bounds - or null if only the first two parameters are provided
getBounds(targetSpace) - overrides CreateJS getBounds() and returns a rectangle with x, y, width height of bounds (not including outside of border) 
	pass in a Container (including Stage) to map rectangle to that coordinate space 
hasProp(property) - returns true if String property exists on object else returns false
clone(recursive) - makes a copy of the shape
	recursive defaults to true so copy will have own copy of graphics
	set recursive to false to have clone share graphic property
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), placeReg(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
command - save a previously chained operation as a command
	then can use the command to change the operation later (see example above)
group - used when the object is made to add STYLE with the group selector (like a CSS class)
** bounds must be set first (or width and height parameters set) for these to work
** setting these adjusts scale not bounds and getting these uses the bounds dimension times the scale
width - gets or sets the width. Setting the width will scale the height to keep proportion (see widthOnly below)
height - gets or sets the height. Setting the height will scale the width to keep proportion (see heightOnly below)
widthOnly - gets or sets the width.  This sets only the width and may change the aspect ratio of the object
heightOnly - gets or sets the height.  This sets only the height and may change the aspect ratio of the object
draggable - set to true for a default drag() and false for a noDrag()
level - gets or sets the level of the object in its parent container (or the stage) - a property for parent.getChildIndex() and parent.setChildIndex()
depth - for ZIM VR - the depth used to shift left and right channel and for parallax in VR - also see dep() ZIM Display method
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
effects - an object that holds effects added such as blur, glow, shadow, color, multi and alpha - see effect() under ZIM Methods 
** the following are convenience Effects that run a ZIM MultiEffect()
** these can use a lot of processing when animating - see Docs for effects() 
** batch versions are available too as hueBatch, etc. these will not update the effect until updateEffects() is called on the object
hue - the tint of an object between -180 and 180 with 0 being no change 
saturation - the amount of color of an object between -100 and 100 with 0 being no change 
brightness - the lightness or darkness of an object between -255 and 255 with 0 being no change 
contrast - the crispness of an object between -100 and 100 with 0 being no change 

ALSO: see the CreateJS Easel Docs for Shape properties, such as:
graphics, x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, mouseEnabled, etc.

EVENTS
See the CreateJS Easel Docs for Shape events, such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.6
	zim.Shape = function(a, b, c, d, graphics, optimize, style, group, inherit) {
		var sig = "a, b, c, d, graphics, optimize, style, group, inherit";
		var duo; if (duo = zob(zim.Shape, arguments, sig, this)) return duo;
		z_d("50.6");
		this.cjsShape_constructor(graphics);
		this.type = "Shape";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		var that = this;

		if (zot(a)) a = DS.a!=null?DS.a:null;
		if (zot(b)) b = DS.b!=null?DS.b:null;
		if (zot(c)) c = DS.c!=null?DS.c:null;
		if (zot(d)) d = DS.d!=null?DS.d:null;
		if (zot(graphics)) graphics = DS.graphics!=null?DS.graphics:null;
		if (zot(optimize)) optimize = DS.optimize!=null?DS.optimize:false;

		var n = normalizeBounds(a, b, c, d);
		function normalizeBounds(a, b, c, d) {
			var bounds = [];
			if (zot(a)) {
				bounds = [a,b,c,d];
			} else if (zot(b)) {
				if (a.x) bounds = [a.x, a.y, a.width, a.height]; 	
				else {
					bounds[0] = 0;
					bounds[1] = 0;
					bounds[2] = a;
					bounds[3] = a;
				}		
			} else if (!zot(c)) {
				bounds[0] = a;
				bounds[1] = b;
				bounds[2] = c;
				bounds[3] = d;
			} else {
				bounds[0] = 0;
				bounds[1] = 0;
				bounds[2] = a;
				bounds[3] = b;
			}
			if (zot(bounds[3])) bounds[3] = bounds[2];
			return bounds;
		}
		if (!zot(a)) this.setBounds(n[0],n[1],n[2],n[3]); // es6 to fix

		if (!optimize) {
			var shorts = ["mt","lt","a","at","bt","ct","qt","cp","c",
			"f","lf","rf","bf","ef","ss","sd","s",
			"ls","rs","bs","es","dr","rr","rc","dc","de","dp","pg","p"];
			for (var i=0; i<shorts.length; i++) {
				~function() { // store each in closure to maintain name
					var n = i;
					that[shorts[n]] = function(){
						if (shorts[n]=="ct") that.graphics.curveTo.apply(that.graphics, arguments);
						else that.graphics[shorts[n]].apply(that.graphics, arguments);
						return that;
					};
				}();
			}
		}
		Object.defineProperty(that, 'command', {
			get: function() {
				return that.graphics.command;
			},
			set: function() {
			}
		});

		this.cache = function(a,b,c,d,scale,options,margin,rtl,willReadFrequently) {
			var sig = "a,b,c,d,scale,options,margin,rtl,willReadFrequently";
			var duo; if (duo = zob(that.cache, arguments, sig)) return duo;
			var bounds = that.getBounds();
			if (zot(c)) {
				if (zot(a)) {
					if (!zot(bounds)) {
						var added = that.borderWidth > 0 ? that.borderWidth/2 : 0;
						a = bounds.x-added;
						b = bounds.y-added;
						c = bounds.width+added*2;
						d = bounds.height+added*2;
					}
				} else {
					c = a;
					d = b;
					a = 0;
					b = 0;
				}
			}
			if (zot(margin)) margin = 0;
			that.cjsShape_cache(a-margin,b-margin,c+margin*2,d+margin*2,scale,options,rtl,willReadFrequently);
			if (bounds && options && options.adjustBounds && (a!=bounds.x || b!=bounds.y || c!=bounds.width || d!=bounds.height)) {                    
                that.setBounds(a, b, c, d);
                that.reg(a,b);
                that.hitArea = new zim.Shape().f(black).dr(a-margin,b-margin,c+margin*2,d+margin*2);                
            }	
			that.z_bc = that.canvas = that.cacheCanvas;
			return that;
		};
		this.setBounds = function(a,b,c,d) {
			var n = normalizeBounds(a, b, c, d);
			this.cjsShape_setBounds(n[0],n[1],n[2],n[3]);
			return this;
		};
		this.getBounds = function(targetSpace) {
			if (targetSpace) {
				return that.boundsToGlobal(null,null,null,targetSpace);
			}
			return that.cjsShape_getBounds();
		};
		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
		this.clone = function(recursive) {
			if (zot(recursive)) recursive = true;
			var currentBounds = this.getBounds();
			if (zot(currentBounds)) currentBounds = {x:null, y:null, width:null, height:null};
			var c = that.cloneProps(new zim.Shape(currentBounds.x,currentBounds.y,currentBounds.width,currentBounds.height, graphics, style, group, inherit));
			if (recursive) c.graphics = that.graphics.clone();
			else c.graphics = that.graphics;
			return c;
		};
		var frame = WW.zdf || 1;
		if (createjs && !createjs.stageTransformable && frame.retina) {
			this.localToGlobal = function(x,y) {
				return zim.localToGlobal(x,y,this,this.cjsShape_localToGlobal);
			};
			this.globalToLocal = function(x,y) {
				return zim.globalToLocal(x,y,this,this.cjsShape_globalToLocal);
			};
			this.localToLocal = function(x,y,target) {
				return zim.localToLocal(x,y,target,this);
			};
		}
		this.hasProp = function(prop) {
			return (!zot(this[prop]) || Object.prototype.hasOwnProperty.call(this,prop));
		};
		// this.pg = function(points, close) {
		// 	if (!Array.isArray(points)) points = Array.from(arguments);
		// 	var type = 	points[0].x != null?"obj":points[0][0] != null?"arr":"par";	
		// 
		// 	var p, fp, sp;
		// 	if (type=="obj") p = points[0];
		// 	else if (type=="arr") p = {x:points[0][0], y:points[0][1]||0};
		// 	else p = {x:points[0], y:points[1]||0};
		// 	fp = {x:p.x, y:p.y};
		// 	this.mt(fp.x, fp.y);			
		// 	for (var i=1; i<points.length; i++) {
		// 		if (type=="obj") p = points[i];
		// 		else if (type=="arr") p = {x:points[i][0], y:points[i][1]||0};
		// 		else p = {x:points[i*2], y:points[i*2+1]||0};
		// 		if (i==1) sp = {x:p.x, y:p.y};
		// 		this.lt(p.x, p.y);								
		// 	}	
		// 	this.lt(fp.x, fp.y).lt(sp.x, sp.y); // go around to second point to get correct end bevel/miter
		// 	return this;
		// }
		
		zim.displayBase(that);	
		
		this.dispose = function() {
			zim.gD(this); // globalDispose function for common elements
			this.graphics.c();
			this.dispatchEvent("removed");
			this.removeAllEventListeners();
			if (this.parent) this.parent.removeChild(this);
		};
	};
	zim.extend(zim.Shape, createjs.Shape, ["cache","clone","setBounds","getBounds","localToLocal","localToGlobal","globalToLocal"], "cjsShape", false);
	zimify(zim.Shape.prototype);
	//-50.6

/*--
zim.Bitmap = function(image, width, height, left, top, scale, style, group, inherit)

Bitmap
zim class - extends a createjs.Bitmap

DESCRIPTION
Makes a Bitmap object from an image source (image, video or canvas).
It is best to use the assets and path parameters of ZIM Frame or the loadAssets() method of Frame
to preload the image and then use the asset() method to access the Bitmap.
See the ZIM Frame class and asset example on the ZIM Frame page of templates.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Frame({ready, assets:"logo.jpg"});
function ready() {
	const logo = new Pic("logo.jpg").center(); // logo is a Pic with a bitmap property that is a Bitmap	
	const logo2 = new Pic("logo.jpg").loc(100,100);
}
END EXAMPLE

EXAMPLE
// turn a container of circles into a Bitmap
const circles = new Container(W, H).addTo();
loop(10, ()=>{
	new Circle(rand(200), [pink,green,blue,yellow,purple], dark).center(circles).ble();
});
const pic = new Bitmap(circles).center().drag();
circles.removeFrom();

// previous to ZIM 10.8.0 we needed to use the cacheCanvas:
var pic = new Bitmap(circles.cache().cacheCanvas).center().drag();
END EXAMPLE

EXAMPLE
// fill a Bitmap with noise:
const noise = new Noise();
// empty Bitmap size 200, 200
const bmp = new Bitmap(null,200,200).center();
// we fill the bitmap starting from top left going across in the inner loop,
// then down, then across, etc. until we get to bottom right.
const f = 50; // used to make noise bigger or smaller - see the blob comment below
for (let y = 0; y < bmp.height; y++) {
	for (let x = 0; x < bmp.width; x++) {
		// the noise methods return a number from -1 to 1
		// by adding 1 we get a number between 0 and 2 then divide by 2
		// and we multiply this by 255 to get a number between 0 and 255
		let value = (noise.simplex2D(x, y)+1)/2 * 255;
		// or get blobs by smoothing and adjusting frequency:
		// var value = smoothStep((noise.simplex2D(x/f, y/f)+1)/2, .3,.35) * 255;
		// imageData is four values per pixel
		// the red, green, blue and alpha
		// in one big long array - each value will be constrained to between 0 and 255
		// this i value will increase by 4 each time
		// then we write the same value for red, green, blue to get a shade of grey
		let i = (x + y * bmp.width) * 4;
		bmp.imageData.data[i] = value; // red (0-255)
		bmp.imageData.data[i + 1] = value; // green (0-255)
		bmp.imageData.data[i + 2] = value; // blue (0-255)
		bmp.imageData.data[i + 3] = 255; // alpha (0-255)
	}
}
bmp.drawImageData();
END EXAMPLE

EXAMPLE
// applying filters
new Pic("statue.jpg").effect(new BlurEffect()).center();
END EXAMPLE

EXAMPLE
// getting the color at point(100, 100) on the Bitmap
const bitmap = new Pic("statue.jpg").cache();
const ctx = bitmap.cacheCanvas.getContext('2d');
const data = ctx.getImageData(100, 100, 1, 1).data;
const color = "rgba("+data.join(", ")+")";
END EXAMPLE

EXAMPLE
// a Base64 image - with a long list of characters:
const image = "data:image/png;base64,longlistofcharacters";
const logo;
Bitmap.fromData(image, bitmap=>{
	logo = bitmap.center();
	S.update();
});
END EXAMPLE

EXAMPLE
const thumbs = [];
const cols = 5;
const rows = 5;

const image = asset("yourimage.jpg");
const w = image.width/cols;
const h = image.height/cols;
loop(rows, r=>{
	loop(cols, c=>{
		// make Bitmap show a different part of the main image each time
		// note: width, height, left, top
		// NOT x, y, width, height like Container
		// left and top specifiy where in an image
		// to start the picture at 0,0 in the Bitmap
		thumbs.push(new Bitmap(image, w, h, c*w, r*h));
	});
});
const tile = new Tile(thumbs, cols, rows, 0, 0, true).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
image - an HTML image URL (may not load right away - see Frame loadAssets)
	or as of 10.8.0 a DisplayObject - this will be turned into a cacheCanvas
	and then the DisplayObject turned back to its previous cached setting
width - (default image width or 100) the width of the resulting Bitmap - will potentially crop an image
	see also height, left and top parameters
	which allow part of an image to be drawn into the Bitmap
	and is handy rather than masking to cut up an image into squares for instance
height - (default image height or 100) the height of the resulting Bitmap
left - (default 0) where on the source image to start the left of the image
top - (default 0) where on the source image to start the top of the image
scale - if making a Bitmap from a DisplayObject, this will scale the object before it is cached for better resolution
	the resulting bitmap will be the scaled size
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
keyOut(color, tolerance, replacement) - remove color from Bitmap and a tolerance between 0-1
	the default color is "#389b26" which is a medium dark green
	the default tolerance is .1 - the higher the tolerance the less sensitive the keying process - so more colors will be removed similar to the provided color
	color and tolerance can be an array of colors and tolerances (or just one tolerance if all are the same)
	replacement (default clear) a color to replace the keyed out color with or an optional array to match the colors array if an array is used
fromData(data, callback) - STATIC method so use the Bitmap class directly: Bitmap.fromData()
	The callback will receive a reference to the Bitmap after 50ms or 100ms.
	There is no event for making a Bitmap from base64 for instance - so this will have to do.
drawImageData(x, y, sourceX, sourceY, sourceWidth, sourceHeight) - draws the Bitmap's imageData data to the Bitmap
	NOTE: This is only used when dynamically drawing a Bitmap with data - not for your normal picture
	See the imageData property which should be set before using the drawImageData() method
	ZIM calls a putImageData method for the HTML Canvas and then transfers this to the Bitmap
	See also https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/putImageData - but let ZIM do the work...
	Usually just leave the parameters blank
	x - (default 0) where to start putting the drawing in the x
	y - (default 0) where to start putting the drawing in the y
	sourceX - (default 0) where in the imageData to start using the data in the x
	sourceY - (default 0) where in the imageData to start using the data in the y
	sourceWidth - (default the width of the imageData) how much width of the data to use
	sourceHeight - (default the height of the imageData) how much height of the data to use
setBounds(width||x||Boundary, height||y, null||width, null||height) - overrides CreateJS setBounds() and returns object for chaining
	If you do not provide any parameters, then the bounds will be reset to the calculated bounds
	width||x||Boundary - (default null) the width of the bounds - or the x if four parameters are provided
		or a ZIM Boundary Object {x,y,width,height} - same as CreateJS Rectangle - thanks Joseph Diefenbach
	height||y - (default width) the height of the bounds - or the y if four parameters are provided
	width - (default null) the width of the bounds - or null if only the first two parameters are provided
	height - (default null) the height of the bounds - or null if only the first two parameters are provided
getBounds(targetSpace) - overrides CreateJS getBounds() and returns a rectangle with x, y, width height of bounds (not including outside of border) 
	pass in a Container (including Stage) to map rectangle to that coordinate space 
cache(width||x, height||y, null||width, null||height, scale, options, rtl, willReadFrequently) - overrides CreateJS cache() and returns object for chaining
	** Supports ZIM DUO
	** Usually you do not want to cache a Bitmap as it is already a Bitmap ;-)
	** But for applying a filter or using a cacheCanvas to get a context, etc. then you might.
	If you do not provide the first four parameters, then the cache dimensions will be set to the bounds of the object
	width||x - (default getBounds().x) the width of the chache - or the x if first four parameters are provided
	height||y - (default getBounds().y) the height of the chache - or the y if first four parameters are provided
	width - (default getBounds().width) the width of the chache - or null if first two parameters are provided
	height - (default getBounds().height) the height of the chache - or null if first two parameters are provided
	scale - (default 1) set to 2 to cache with twice the fidelity if later scaling up
	options - (default null) additional parameters for cache logic - see CreateJS somewhere for details
		also added adjustBounds property for options - set to true to set new bounds and registration point 
		on cached objects with x,y,width,height different than the original
		this appears to NOT be the default with createjs cache() which keeps the original registration point and bounds
		automatically fixing this changes lots of things so use the adjustBounds option when needed 
		for instance when caching parts of a container and requiring hit tests or the part to be draggable, etc.
	rtl - (default null) set to true to use Right to Left.
	willReadFrequently - (default null) set to true if planning on using operations with getImageData() or toDataURL()
		if you get a warning in the console about willReadFrequently then set this to true
getColorAt(x,y,array) - returns the rgba() value at the x and y location - passes array of [r,g,b,a] if array parameter is true
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied - also copies file and src properties
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection
	if this is a cloned bitmap then the original asset("image.png") will still exist unless it is disposed.
	
ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Bitmap methods, such as:
on(), off(), dispatchEvent(), etc.

PROPERTIES
type - holds the class name as a String
file - if loaded as an asset this is the file name
imageData - data for the pixels stored in a data property of an ImageData object
	NOTE: This is only used when dynamically drawing a Bitmap with data - not for your normal picture
	The data property is an one dimensional Array with consecutive red, green, blue, alpha values (0-255) for each pixels
	eg. 0,0,0,255,255,255,255,255 is a black pixel with 1 alpha and a white pixel with 1 alpha
	You set this before calling the Bitmap drawImageData() method
 	See also https://developer.mozilla.org/en-US/docs/Web/API/ImageData - but let ZIM do the work
group - used when the object is made to add STYLE with the group selector (like a CSS class)
** bounds must be set first (or width and height parameters set) for these to work
** setting these adjusts scale not bounds and getting these uses the bounds dimension times the scale
width - gets or sets the width. Setting the width will scale the height to keep proportion (see widthOnly below)
height - gets or sets the height. Setting the height will scale the width to keep proportion (see heightOnly below)
widthOnly - gets or sets the width.  This sets only the width and may change the aspect ratio of the object
heightOnly - gets or sets the height.  This sets only the height and may change the aspect ratio of the object
draggable - set to true for a default drag() and false for a noDrag()
level - gets or sets the level of the object in its parent container (or the stage) - a property for parent.getChildIndex() and parent.setChildIndex()
depth - for ZIM VR - the depth used to shift left and right channel and for parallax in VR - also see dep() ZIM Display method
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
effects - an object that holds effects added such as blur, glow, shadow, color, multi and alpha - see effect() under ZIM Methods 
** the following are convenience Effects that run a ZIM MultiEffect()
** these can use a lot of processing when animating - see Docs for effects() 
** batch versions are available too as hueBatch, etc. these will not update the effect until updateEffects() is called on the object
hue - the tint of an object between -180 and 180 with 0 being no change 
saturation - the amount of color of an object between -100 and 100 with 0 being no change 
brightness - the lightness or darkness of an object between -255 and 255 with 0 being no change 
contrast - the crispness of an object between -100 and 100 with 0 being no change 

ALSO: see the CreateJS Easel Docs for Bitmap properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, mouseEnabled, etc.

EVENTS
See the CreateJS Easel Docs for Bitmap events, such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.7
zim.Bitmap = function(image, width, height, left, top, scale, style, group, inherit) {	
	var sig = "image, width, height, left, top, scale, style, group, inherit";
	var duo; if (duo = zob(zim.Bitmap, arguments, sig, this)) return duo;
	z_d("50.7");	

	this.group = group;
	var DS = style===false?{}:zim.getStyle("Bitmap", this.group, inherit);
	if (zot(scale)) scale = DS.scale!=null?DS.scale:1;
	if (zot(width)) width = DS.width!=null?DS.width:image?image.width:100;
	if (zot(height)) height = DS.height!=null?DS.height:image?image.height:100;
	if (zot(left)) left = DS.left!=null?DS.left:0;
	if (zot(top)) top = DS.top!=null?DS.top:0;
		
	var displayCheck = false;
	var imageOriginal = image;
	if (!zot(image)) {
		if (image.uncache) { // testing if it has a CreateJS uncache method
			displayCheck = true;
			var cached = image.cacheCanvas;
			var original = image;
			var bOriginal = original.getBounds();
			image.cache(left,top,width,height,scale); // do not chain on end as might be createjs image
			this.z_bc = image = image.cacheCanvas; // what we will pass to bitmap
		}		
	}	
	this.cjsBitmap_constructor(image);
	if (original && !cached) original.uncache();
	if (bOriginal) original.setBounds(bOriginal.x, bOriginal.y, bOriginal.width, bOriginal.height);
	
	var that = this;
	this.type = "Bitmap";	
	if (!zot(width) && !zot(height)) this.setBounds(0,0,width,height);
	
	this.drawImageData = function(x, y, sourceX, sourceY, sourceWidth, sourceHeight) {
		if (zot(x)) x = 0;
		if (zot(y)) y = 0;
		if (zot(sourceX)) sourceX = 0;
		if (zot(sourceY)) sourceY = 0;
		if (zot(sourceWidth)) sourceWidth = width;
		if (zot(sourceHeight)) sourceHeight = height;
		if (!that.proxyCanvas) {
			var c = that.proxyCanvas = document.createElement("canvas");
			c.setAttribute("width", width);
			c.setAttribute("height", height);
			that.proxyContext = c.getContext('2d');
			image = imageOriginal = that.image = c;
		}
		if (that.proxyContext) {
			that.proxyContext.putImageData(that.imageData, x, y, sourceX, sourceY, sourceWidth, sourceHeight);
		}
	}

	if (WW.zdf) {
		// not supported by IE - thanks Chris Spolton for the find and suggested fix
		if (WW.zdf.canvas.getContext("2d")) {
			this.imageData = WW.zdf.canvas.getContext("2d").createImageData(width, height);
		} else {
			this.imageData = document.createElement('canvas').getContext("2d").createImageData(width, height);
			// if (ImageData) this.imageData = new ImageData(width, height);
		}
		if (zot(image)) that.drawImageData();

		// handle delay when creating Bitmap from data
		if (image && image.match && image.match(/data:image/i)) setTimeout(function() {
			if (that.stage) that.stage.update();
			setTimeout(function() {
				if (that.stage) that.stage.update();
			}, 50);
		}, 50);
	}
	
	if (image && image.nodeName && image.nodeName.toLowerCase() != "video") {
		if (displayCheck) that.sourceRect = {x:0, y:0, width:width*scale, height:height*scale};
		else that.sourceRect = {x:left, y:top, width:width, height:height};
	}
	function normalizeBounds(a, b, c, d) {
		var bounds = [];
		if (zot(a)) {
			bounds = [a,b,c,d];
		} else if (zot(b)) {
			if (a.x) bounds = [a.x, a.y, a.width, a.height]; 	
			else {
				bounds[0] = 0;
				bounds[1] = 0;
				bounds[2] = a;
				bounds[3] = a;
			}		
		} else if (!zot(c)) {
			bounds[0] = a;
			bounds[1] = b;
			bounds[2] = c;
			bounds[3] = d;
		} else {
			bounds[0] = 0;
			bounds[1] = 0;
			bounds[2] = a;
			bounds[3] = b;
		}
		if (zot(bounds[3])) bounds[3] = bounds[2];
		return bounds;
	}
	this.setBounds = function(a,b,c,d) {
		var n = normalizeBounds(a, b, c, d);
		that.cjsBitmap_setBounds(n[0],n[1],n[2],n[3]);
		return that;
	};
	this.getBounds = function(targetSpace) {
		if (targetSpace) {
			return that.boundsToGlobal(null,null,null,targetSpace);
		}
		return that.cjsBitmap_getBounds();
	};

	
	this.cache = function(a,b,c,d,scale,options,rtl,willReadFrequently) {
		var sig = "a,b,c,d,scale,options,rtl,willReadFrequently";
		var duo; if (duo = zob(that.cache, arguments, sig)) return duo;
		var bounds;
		if (zot(c)) {
			if (zot(a)) {
				bounds = this.getBounds();
				if (!zot(bounds)) {
					var added = this.borderWidth > 0 ? this.borderWidth/2 : 0;
					a = bounds.x-added;
					b = bounds.y-added;
					c = bounds.width+added*2;
					d = bounds.height+added*2;
				}
			} else {
				c = a;
				d = b;
				a = 0;
				b = 0;
			}
		}
		bounds = that.getBounds();
		that.cjsBitmap_cache(a,b,c,d,scale,options,rtl,willReadFrequently);		
		if (bounds && options && options.adjustBounds && (a!=bounds.x || b!=bounds.y || c!=bounds.width || d!=bounds.height)) {                    
			that.setBounds(a, b, c, d);
			that.reg(a,b);
			that.hitArea = new zim.Shape().f(black).dr(a-margin,b-margin,c+margin*2,d+margin*2);                
		}	
		that.z_bc = that.canvas = that.cacheCanvas;
		return that;
	};
		
	this.clone = function() {		
		var c = this.cloneProps(new zim.Bitmap(imageOriginal, width, height, left, top, scale, style, this.group, inherit));
		c.cloned = true;
		c.src = that.src;
		c.file = that.file;
		c.image = that.image;
		c.svg = that.svg;
		c.item = that.item;
		return c;
	};
	var frame = WW.zdf || 1;
	if (createjs && !createjs.stageTransformable && frame.retina) {
		this.localToGlobal = function(x,y) {
			return zim.localToGlobal(x,y,this,this.cjsBitmap_localToGlobal);
		};
		this.globalToLocal = function(x,y) {
			return zim.globalToLocal(x,y,this,this.cjsBitmap_globalToLocal);
		};
		this.localToLocal = function(x,y,target) {
			return zim.localToLocal(x,y,target,this);
		};
	}
	this.hasProp = function(prop) {
		return (!zot(this[prop]) || Object.prototype.hasOwnProperty.call(this,prop));
	};
	var myContext;
	this.getColorAt = function(x,y,array) {
		if (!myContext) {
			that.cache(null,null,null,null,null,null,null,true);
			myContext = that.cacheCanvas.getContext('2d');			
			that.uncache();
		}	
		var d = myContext.getImageData(x, y, 1, 1).data;
		d[3] /= 255;
		if (array) return d;
		return "rgba("+d[0]+","+d[1]+","+d[2]+","+d[3]+")";
	};

	this.keyOut = function(color, tolerance, replacement) {
		if (zot(color)) color = "#389b26";
		if (zot(tolerance)) tolerance = .1;
		if (!Array.isArray(color)) color = [color];
		if (!Array.isArray(tolerance)) tolerance = [tolerance];
		if (!zot(replacement) && !Array.isArray(replacement)) replacement = [replacement];
		var i, j;
		var c = [];
		var t = []; 
		var rep = []; 
		for (i=0; i<color.length; i++) {
			c[i] = zim.convertColor(color[i], "array");
			if (tolerance[i]!=null) t[i] = tolerance[i] * 255;
			else t[i] = tolerance[0] * 255;
			if (replacement) {
				if (replacement[i]!=null) {
					rep[i] = zim.convertColor(replacement[i], "array");
					rep[i][3] *= 255;
				} else {
					rep[i] = zim.convertColor(replacement[0], "array");
					rep[i][3] *= 255;
				}
			}
		}	
		
		if (that.cacheCanvas) that.updateCache();
		if (!myContext) {
			that.cache(null,null,null,null,null,null,null,true);
			myContext = that.cacheCanvas.getContext('2d');
			// that.uncache();
		}
		var info = myContext.getImageData(left, top, width, height)
		var d = info.data;
		var l = d.length/4;
		if (replacement) {
			for (i=0; i<l; i++) {
				var r = d[i*4+0];
				var g = d[i*4+1];
				var b = d[i*4+2];
				for (j=0; j<color.length; j++) {
					if (r>c[j][0]-t[j]&&r<c[j][0]+t[j]&&g>c[j][1]-t[j]&&g<c[j][1]+t[j]&&b>c[j][2]-t[j]&&b<c[j][2]+t[j]) {												
						d[i*4+0]=rep[j][0]; 
						d[i*4+1]=rep[j][1]; 
						d[i*4+2]=rep[j][2]; 
						d[i*4+3]=rep[j][3]; 						
					}
				}
			}
		} else {
			for (i=0; i<l; i++) {
				var r = d[i*4+0];
				var g = d[i*4+1];
				var b = d[i*4+2];
				for (j=0; j<color.length; j++) {
					if (r>c[j][0]-t[j]&&r<c[j][0]+t[j]&&g>c[j][1]-t[j]&&g<c[j][1]+t[j]&&b>c[j][2]-t[j]&&b<c[j][2]+t[j]) {
						d[i*4+3]=0; // no alpha for color						
					}
				}
			}
		}		
		myContext.putImageData(info,top,left);
		// that.updateCache()
		return this;
	} 

	zim.displayBase(that);
	
	if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
	
	// this.dispose = function() {
	this.doDispose = function() {
		zim.gD(this); // globalDispose function for common elements
		this.dispatchEvent("removed");
		this.removeAllEventListeners();
		if (!this.cloned) {
			if (this.id) {
				if (this.stage && this.stage.frame) frame = this.stage.frame;
				else frame = WW.zdf;
				if (frame && frame.assets) {
					if (frame.assets[this.id]) delete frame.assets[this.id];
				}
				if (zim.assets[this.id]) delete zim.assets[this.id];
			}		
		}	
		if (this.parent) this.parent.removeChild(this);
	};
};
zim.Bitmap.fromData = function(data, callback) {
	var width = 100;
	var height = 100;	
	var img = new Image();
	img.onload = function() {
		width = img.naturalWidth;
		height = img.naturalHeight;
		if (zot(width)) width = img.width;
		if (zot(height)) height = img.height;
		var bitmap = new zim.Bitmap(data, width, height);
		setTimeout(function() {
			callback(bitmap);
		}, 50);
	}
	img.src = data;	
};
zim.extend(zim.Bitmap, createjs.Bitmap, ["cache","clone","dispose","setBounds","getBounds","localToLocal","localToGlobal","globalToLocal"], "cjsBitmap", false);
zim.Bitmap.prototype.dispose = function() {return this.doDispose();};
zimify(zim.Bitmap.prototype);
	//-50.7

/*--
zim.Sprite = function(image, cols, rows, count, offsetX, offsetY, spacingX, spacingY, width, height, animations, json, id, globalControl, spriteSheet, label, frame, style, group, inherit)

Sprite
zim class - extends a createjs.Sprite

DESCRIPTION
A Sprite plays an animation of a spritesheet
which is a set of images layed out in one file.
You play the Sprite with the run() method.
This animates the Sprite over a given time
with various features like playing a labelled animation,
playing animation series, wait, loop, rewind and call functions.
This actually runs a ZIM animation and animates the frames.

SEE: 
https://zimjs.com/interactiveanimation.html
https://zimjs.com/interactiveanimation/
https://zimjs.com/spritesheet/
https://zimjs.com/spritesheet/skateboard.html
https://codepen.io/danzen/pen/yEKbbR
https://codepen.io/danzen/pen/VdXzLV
https://zimjs.com/zide/
https://zimjs.com/explore/sidescroller.html (with keyboard)
https://zimjs.com/sprite/ (with Free TexturePacker)

NOTE: A ZIM Sprite handles both an evenly tiled spritesheet - use cols and rows
and an un-evenly tiled spritesheet - use the json parameter.
The json can come from TexturePacker for instance exported for EaselJS/CreateJS
CreateJS Easel Sprite and SpriteSheet docs:
https://www.createjs.com/docs/easeljs/classes/Sprite.html
https://www.createjs.com/docs/easeljs/classes/SpriteSheet.html
You can optionally pass in an existing createjs.SpriteSheet as a parameter.
When you do so, all other parameters are ignored.
** JSON hash and JSON array formats are now supported (Phaser formats)
** See https://www.codeandweb.com/free-sprite-sheet-packer

NOTE: You can use CreateJS gotoAndPlay(), play(), etc.
but we found the framerate could not be kept
with other animations or Ticker events running.
So we recommend using the ZIM Sprite run() method.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// boom.png is a sprite sheet found online
// It has 8 columns and 6 rows that we can visually count
// We can enter a total parameter if it does not end evenly in the grid
// A graphics editor (like Photoshop) could be used to see
// if there is an offset or spacing, etc. and enter those as parameters
// In this case, we do not need to do any of this - just enter the cols and rows

new Frame(FIT, 1024, 768, black, darker, ready, "boom.png", "https://zimjs.org/assets/");
function ready() {

	const animation = new Sprite({
		image:"boom.png",
		cols:8,
		rows:6,
		animations:{mid:[10,20], end:[30,40]} // optional animations with labels
		// see CreateJS SpriteSheet docs for the various animation format as there are a few different ones!
	})
		.center()
		.run(2); // plays the frames of the Sprite over 2 seconds (master time)

	// OR use the label to play the frames listed in animations parameter
	animation.run(1, "mid");

	// OR run a series of animations
	// by passing an array of label objects to the label parameter
	// these each have a time so the master time is ignored
	// they can also have any of the run() parameters
	// if you provide an array of labels, you cannot rewind the overall animation
	animation.run(null, [
		{label:"mid", time:1},
		{label:"end", time:.5, loop:true, loopCount:5, call:function(){zog("loops done");}},
		{startFrame:10, endFrame:20, time:1}
	]);

	// OR can call a function when done
	animation.run(1, "mid", function(){
		S.removeChild(animation);
		S.update();
	});

	// OR can loop the animation
	animation.run({time:2, loop:true}); // see run() parameters for more
}
END EXAMPLE

EXAMPLE
// using Sprite as a texture atlas - or spritesheet of different images
// see: https://zimjs.com/zapp/Z_FDJXA
// load in assets and path
new Frame({ready, assets:["fruit.png", "fruit.json"], path:"assets/"});
function ready() {
	new Sprite({json:"fruit.json", label:"apple"}).center();
}
END EXAMPLE

EXAMPLE
// Here is an example with CreateJS SpriteSheet data
// robot.png is a sprite sheet made by ZOE based on a Flash swf
// you can also make your own with Photoshop or Texture Packer

F.loadAssets("robot.png");
F.on("complete", ()=>{

	// using ZOE to export swf animation to spritesheet data
	// spritesheet data uses the image name, not the Bitmap itself
	const image = new Pic("robot.png").image;
	const spriteData = {
		"framerate":24,
		"images":[image],
		"frames":[[0, 0, 256, 256, 0, -54, -10], many more - etc.],
		"animations":{}
	};
	const animation = new Sprite({json:spriteData});
	animation.center();
	animation.run(2); // note, duration alternative to framerate
});

// OR
// load in data from external JSON
F.loadAssets(["robot.json", "robot.png"]);
// ... same as before
const animation = new Sprite({json:"robot.json"});
// ... same as before

// see CreateJS SpriteSheet docs for the format of the JSON file
// including various animation formats
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
image - the ZIM Pic() ir ZIM Bitmap() for the spritesheet
	or use a string filename to a preloaded image file (in Frame or loadAssets())
cols - (default 1) - the columns in the spritesheet
rows - (default 1) the rows in the spritesheet
count - (default cols*rows) how many total frames in the spritesheet
offsetX - (default 0) the pixels from the left edge to the frames
offsetY - (default 0) the pixels from the top edge to the frames
spacingX - (default 0) the horizontal spacing between the frames
spacingY - (default 0) the vertical spacing between the frames
width - (default image width) the width including offset and spacing for frames
height - (default image height) the height including offset and spacing for frames
animations - (default null) an object literal of labels holding frames to play
	{label:3, another:[4,10]}
	run(1, "label") would play frame 3 for a second
	run(1, "another") would play frames 4 to 10 for a second
	{unordered:{frames:[1,2,3,22,23,24,"anotherLabel",5,6], next:prevLabel}}
	There are also ways to set speeds - but would recommend dividing into simple labels
	and using the label series technique available with the run() method
json - (default null) a JSON string for a CreateJS SpriteSheet
	or use a string filename to a preloaded JSON file (in Frame or loadAssets())
	If you pass in a json parameter, all other parameters are ignored
	NOTE: remember that JSON needs quotes around the animation properties above:
	{"label":3, "another":[4,10]}
	JSON hash and JSON array formats from TexturePacker are supported as well as the createjs/easeljs format 
	See https://www.codeandweb.com/free-sprite-sheet-packer for instance
id - (default randomly assigned) an id you can use in other animations - available as sprite.id
	use this id in other animations for pauseRun and stopRun to act on these as well
globalControl - (default true) pauseRun and stopRun will control other animations with same id
spriteSheet - (default null) pass in a CreateJS SpriteSheet to build a Sprite from that
label - (default null) pass in a label to stop on initially - to play from a label use the run({label:val}) method
frame - (default zimDefaultFrame) specify a Frame other than the default frame
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
run(time, label, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startFrame, endFrame, tweek, id, globalControl)
	The run() method animates the Sprite over an amount of time
	Would recommend this method over the CreateJS play() and gotoAndPlay()
	methods because the framerate for these get overwritten by other S.update() calls
	With run() you get other nice ZIM animate features as well as follows:
	Returns the object for chaining
	Can be paused with pauseAnimate(true) or unpaused with pauseAnimate(false)
	Can be stopped with stopAnimate() on the Sprite
	supports DUO - parameters or single object with properties below
	time (default 1) - the time in seconds to run the animations (the master time)
	label (default null) - a label specified in the Sprite animations parameter
		if this is an array holding label objects for example:
		[{label:"run", time:1}, {label:"stand", time:2}]
		then the sprite will play the series with the times given and ignore the master time
		Note: if any of the series has a loop and loops forever (a loopCount of 0 or no loopCount)
		then this will be the last of the series to run
		rewind is not available on the outside series but is available on an inside series
	call - (default null) the function to call when the animation is done
	params - (default target) a single parameter for the call function (eg. use object literal or array)
	wait - (default 0) seconds to wait before doing animation
	waitedCall - (default null) call the function after a wait time if there is one
	waitedParams - (default null) parameters to pass to the waitedCall function
	loop - (default false) set to true to loop animation
	loopCount - (default 0) if loop is true how many times it will loop (0 is forever)
	loopWait - (default 0) seconds to wait before looping (post animation wait)
	loopCall - (default null) calls function after loop and loopWait (not including last loop)
	loopParams - (default target) parameters to send loopCall function
	loopWaitCall - (default null) calls function after at the start of loopWait
	loopWaitParams - (default target) parameters to send loopWaitCall function
	rewind - (default false) set to true to rewind (reverse) animation (doubles animation time) (not available on label series)
	rewindWait (default 0) seconds to wait in the middle of the rewind
	rewindCall (default null) calls function at middle of rewind after rewindWait
	rewindParams - (default target) parameters to send rewindCall function
	rewindWaitCall (default null) calls function at middle of rewind before rewindWait
	rewindWaitParams - (default target) parameters to send rewindCall function
	rewindTime - (default time) set to a time in seconds to adjust the time to rewind
	rewindEase - (default null) see ease parameter for options for rewind ease
		note - this goes backwards - so "bounceOut" would happen at the end of the rewind
	startFrame - (default null - or 0) the frame to start on - will be overridden by a label with frames
	endFrame - (default null - or totalFrames) the frame to end on - will be overridden by a label with frames
	tweek - (default 1) a factor for extra time on rewind and loops if needed
	id - (default randomly assigned) an id you can use in other animations - available as sprite.id
		use this id in other animations for pauseRun and stopRun to act on these as well
	globalControl - (default true) pauseRun and stopRun will control other animations with same id
	pauseOnBlur - (default true) pause the sprite when the window is not seen or set to false to keep playing the sprite
pauseRun(state) - pause or unpause the animation (including an animation series)
	state - (default true) when true the animation is paused - set to false to unpause
	returns object for chaining
stopRun() - stop the sprite from animating
setBounds(width||x||Boundary, height||y, null||width, null||height) - overrides CreateJS setBounds() and returns object for chaining
	If you do not provide any parameters, then the bounds will be reset to the calculated bounds
	width||x||Boundary - (default null) the width of the bounds - or the x if four parameters are provided
		or a ZIM Boundary Object {x,y,width,height} - same as CreateJS Rectangle - thanks Joseph Diefenbach
	height||y - (default width) the height of the bounds - or the y if four parameters are provided
	width - (default null) the width of the bounds - or null if only the first two parameters are provided
	height - (default null) the height of the bounds - or null if only the first two parameters are provided
getBounds(targetSpace) - overrides CreateJS getBounds() and returns a rectangle with x, y, width height of bounds (not including outside of border) 
	pass in a Container (including Stage) to map rectangle to that coordinate space 
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Sprite methods, such as:
play(), gotoAndPlay(), gotoAndStop(), stop(), advance(),
on(), off(), dispatchEvent(), etc.

PROPERTIES
type - holds the class name as a String
id - an id that you can use in other animations to also be controlled by pauseRun() and stopRun()
frame - get and set the current frame of the Sprite
normalizedFrame - if animations have CreateJS speeds applied, zim handles these by making extra frames
	for example, if a speed is given of .5 then two frames are made (min resulution is .1)
normalizedFrames - an array of total frames after being normalized - really for internal usage
totalFrames - get the total frames of the Sprite - read only
animations - the animations data with labels of frames to animate
running - is the sprite animation being run (includes both paused and unpaused) - read only
runPaused - is the sprite animation paused (also returns paused if not running) - read only
	note: this only syncs to pauseRun() and stopRun() not pauseAnimate() and stopAnimate()
	note: CreateJS has paused, etc. but use that only if running the CreateJS methods
	such as gotoAndPlay(), gotoAndStop(), play(), stop()
draggable - set to true for a default drag() and false for a noDrag()
group - used when the object is made to add STYLE with the group selector (like a CSS class)
** bounds must be set first (or width and height parameters set) for these to work
** setting these adjusts scale not bounds and getting these uses the bounds dimension times the scale
width - gets or sets the width. Setting the width will scale the height to keep proportion (see widthOnly below)
height - gets or sets the height. Setting the height will scale the width to keep proportion (see heightOnly below)
widthOnly - gets or sets the width.  This sets only the width and may change the aspect ratio of the object
heightOnly - gets or sets the height.  This sets only the height and may change the aspect ratio of the object
draggable - set to true for a default drag() and false for a noDrag()
level - gets or sets the level of the object in its parent container (or the stage) - a property for parent.getChildIndex() and parent.setChildIndex()
depth - for ZIM VR - the depth used to shift left and right channel and for parallax in VR - also see dep() ZIM Display method
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
effects - an object that holds effects added such as blur, glow, shadow, color, multi and alpha - see effect() under ZIM Methods 
** the following are convenience Effects that run a ZIM MultiEffect()
** these can use a lot of processing when animating - see Docs for effects() 
** batch versions are available too as hueBatch, etc. these will not update the effect until updateEffects() is called on the object
hue - the tint of an object between -180 and 180 with 0 being no change 
saturation - the amount of color of an object between -100 and 100 with 0 being no change 
brightness - the lightness or darkness of an object between -255 and 255 with 0 being no change 
contrast - the crispness of an object between -100 and 100 with 0 being no change 

ALSO: see the CreateJS Easel Docs for Sprite properties, such as:
currentFrame, framerate, paused, currentAnimation, currentAnimationFrame, spriteSheet,
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, mouseEnabled, etc.

EVENTS
See the CreateJS Easel Docs for Sprite events, such as:
animationend, change, added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.8
	zim.Sprite = function(image, cols, rows, count, offsetX, offsetY, spacingX, spacingY, width, height, animations, json, id, globalControl, spriteSheet, label, frame, style, group, inherit) {
		var sig = "image, cols, rows, count, offsetX, offsetY, spacingX, spacingY, width, height, animations, json, id, globalControl, spriteSheet, label, frame, style, group, inherit";
		var duo; if (duo = zob(zim.Sprite, arguments, sig, this)) return duo;
		z_d("50.8");
		this.type = "Sprite";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		var that = this;
		var sheet;
		if (zot(frame)) frame = DS.frame!=null?DS.frame:WW.zdf;
		if (image && typeof image == "string") image = frame.asset(image);
		if (zot(json) && !zot(image)) {
			if (zot(cols)) cols = DS.cols!=null?DS.cols:1;
			if (zot(rows)) rows = DS.rows!=null?DS.rows:1;
			if (zot(count)) count = DS.count!=null?DS.count:(cols*rows);
			if (zot(offsetX)) offsetX = DS.offsetX!=null?DS.offsetX:0;
			if (zot(offsetY)) offsetY = DS.offsetY!=null?DS.offsetY:0;
			if (zot(spacingX)) spacingX = DS.spacingX!=null?DS.spacingX:0;
			if (zot(spacingY)) spacingY = DS.spacingY!=null?DS.spacingY:0;
			if (zot(width)) width = DS.width!=null?DS.width:image.width;
			if (zot(height)) height = DS.height!=null?DS.height:image.height;
			if (image.bitmap) image = image.bitmap;

			var frameW = (width-offsetX+spacingX) / cols - spacingX;
			var frameH = (height-offsetY+spacingY) / rows - spacingY;
			var frames = [];
			var num = 0;
			outer:
			for (var j=0; j<rows; j++) {
				for (var i=0; i<cols; i++) {
					if (++num > count) break outer;
					frames.push([
						offsetX + i*(frameW+spacingX),
						offsetY + j*(frameH+spacingY),
						frameW,
						frameH
					]);
				}
			}
			makeSheet(image, frames, animations);
		} else if (spriteSheet) {
			sheet = spriteSheet;
			animations = sheet.animations;
		} else if (json) {
			
			var frame = that.stage ? that.stage.frame : WW.zdf;
			if (typeof json == "string") json = frame.asset(json);
			
			// CreateJS format for frames is [[],[]]
			// check for other formats used with Phaser, etc.
			
			var fr, f, ff;
			if (json.frames && !Array.isArray(json.frames)) {
				// json is in JSON hash format
				// {id:{},id:{}}
				fr = [];
				for (f in json.frames) {
					ff = json.frames[f].frame;
					fr.push([ff.x, ff.y, ff.w, ff.h]);
				}				
				json.frames = fr;						
			}
			
			if (json.frames && !Array.isArray(json.frames[0])) {
				// json is in JSON array format
				// [{},{}]
				fr = [];
				for (f=0; f<json.frames.length; f++) {
					var ff = json.frames[f].frame;
					fr.push([ff.x, ff.y, ff.w, ff.h]);
				}				
				json.frames = fr;
			}
			if (!json.images && json.meta && json.meta.image) {
				json.images = [json.meta.image];
			}	
			
			// even though data is in JSON, may want to create SpriteSheet from image
			// so that cors will work - so see if provided an image
			// or that the images in the JSON are available in frame.assets
			frames = json.frames;
			animations = json.animations;
			if (!zot(image)) {				
				makeSheet(image, frames, animations);
			} else {
				var im = json.images?json.images[0]:null;
				if (!im || !im.split) {
					sheet = new createjs.SpriteSheet(json);
				} else {
					var assets = [];
					zim.loop(json.images, function(im) {
						var imEnd = im.split("/").pop();
						if (frame.asset(imEnd) && frame.asset(imEnd).type != "EmptyAsset") {
							assets.push(frame.asset(imEnd));
						} else if (frame.asset(im) && frame.asset(im).type != "EmptyAsset") {
							assets.push(frame.asset(im));
						} else if (frame.asset(im).type != "EmptyAsset") {
							assets.push(frame.asset(im));
						} else {
							if (zon) zogy("Sprite() - please preload Sprite in Frame or with loadAssets");
						}
					});
					makeSheet(assets, frames, animations);					
				}
			}
		} else {
			return;
		}

		function makeSheet(image, frames, animations) {
			if (!Array.isArray(image)) image = [image];
			zim.loop(image, function(im, i) {
				image[i] = im.image;
			});
			var spriteData = {
				images:image, 
				frames:frames,
				animations:animations?animations:[]
			};
			sheet = new createjs.SpriteSheet(spriteData);
		}

		this.animations = animations;
		this.cjsSprite_constructor(sheet, label);
		if (!zot(label)) this.stop();

		if (zot(id)) id = zim.makeID();
		this.id = id;

		if (zot(globalControl)) globalControl = true;
		that.globalControl = globalControl;

		var _normalizedFrame = 0;
		var _normalizedFrames;
		this.parseFrames = function(label, startFrame, endFrame, fromDynamo) {
			var frames = [];
			var minSpeed = Number.MAX_VALUE;
			var maxSpeed = 0;
			if (zot(label)) {
				if (zot(startFrame)) startFrame = 0;
				if (zot(endFrame)) endFrame = that.totalFrames-1;
				addSequential(startFrame, endFrame);
			} else {
				if (zot(that.animations) || zot(that.animations[label])) return [];
				var a = that.animations[label];
				processAnimation(a);
			}
			function processAnimation(a) {
				if (Array.isArray(a)) {
					processArray(a);
				} else if (a.constructor == {}.constructor) {
					processObject(a);
				} else if (!isNaN(a)) {
					frames.push({f:Math.floor(a), s:1});
				}
			}
			function processArray(a) {
				addSequential(a[0], a[1], a[3]);
				if (a[2] && !zot(that.animations[a[2]])) processAnimation(that.animations[a[2]]);
			}
			function processObject(a) {
				if (zot(a.frames)) return;
				if (zot(a.speed)) a.speed = 1;
				for (var i=0; i<a.frames.length; i++) {
					if (a.speed < minSpeed) minSpeed = a.speed;
					if (a.speed > maxSpeed) maxSpeed = a.speed;
					frames.push({f:a.frames[i], s:a.speed});
				}
				if (a.next && !zot(that.animations[a.next])) processAnimation(that.animations[a.next]);
			}
			function addSequential(start, end, speed) {
				if (zot(speed)) speed = 1;
				var i;
				if (end > start) {
					for (i=start; i<=end; i++) {inner(i);}
				} else {
					for (i=end; i<=start; i++) {inner(start-(i-end));}
				}
				function inner(i) {
					if (speed < minSpeed) minSpeed = speed;
					if (speed > maxSpeed) maxSpeed = speed;
					frames.push({f:i, s:speed});
				}
			}
			if (fromDynamo) return frames;
			// run() uses an array of frame numbers (normalized to speed) where dynamo uses the speed

			// normalize up to 1/10 - as in if put at .1 then have to multiply all others speeds by 10
			minSpeed = zim.constrain(zim.decimals(minSpeed), .1);
			maxSpeed = zim.constrain(zim.decimals(maxSpeed), .1);

			// normalize speed:
			var framesNormalized = [];
			var normalize = (minSpeed != maxSpeed);
			var fr;
			for (var i=0; i<frames.length; i++) {
				fr = frames[i];
				if (normalize) {
					// if minSpeed less than 1 then divide all others by minSpeed otherwise use speed - and need to round to a number that is at least .1
					for (var j=0; j<zim.constrain(Math.round(minSpeed<1?fr.s/minSpeed:fr.s), .1); j++) {
						framesNormalized.push(fr.f);
					}
				} else {
					framesNormalized.push(fr.f);
				}
			}
			return framesNormalized;
		};

		this.run = function(time, label, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startFrame, endFrame, tweek, id, globalControl, pauseOnBlur) {
			var sig = "time, label, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startFrame, endFrame, tweek, id, globalControl, pauseOnBlur";
			var duo; if (duo = zob(that.run, arguments, sig)) return duo;

			var timeType = getTIME();

			var obj;
			if (zot(tweek)) tweek = 1;
			if (!zot(id)) that.id = id;
			if (!zot(globalControl)) that.globalControl = globalControl;

			var extraTime;
			if (Array.isArray(label)) {
				// check labels
				var innerLabel;
				var lastLabel;
				obj = [];
				extraTime = 0;
				var firstStartFrame;
				for (var i=0; i<label.length; i++) {
					innerLabel = label[i]; // {label:"first", time:1, etc}

					innerLabel.lookup = that.parseFrames(innerLabel.label, innerLabel.startFrame, innerLabel.endFrame);
					if (i==0) firstStartFrame = innerLabel.lookup[0];
					delete innerLabel.startFrame;
					delete innerLabel.endFrame;

					innerLabel.obj = zim.merge(innerLabel.obj, {normalizedFrame:innerLabel.lookup.length-1});
					innerLabel.set = zim.merge(innerLabel.set, {normalizedFrames:{noPick:innerLabel.lookup}, normalizedFrame:0});

					// based on previous frames
					if (zot(innerLabel.wait)) innerLabel.wait = extraTime*tweek;

					lastLabel = innerLabel.label;
					delete innerLabel.label;

					obj.push(innerLabel);

					// will get applied next set of frames
					extraTime = 0;
					var tt = zot(innerLabel.time)?time:innerLabel.time;
					if (endFrame-startFrame > 0) extraTime = tt / (endFrame-startFrame) / 2; // slight cludge - seems to look better?

					// if (i==0) firstStartFrame = startFrame;
				}
				//startFrame = firstStartFrame;
				if (obj.length == 0) return this;
				if (obj.length == 1) { // just one label in list ;-)
					time = obj[0].time;
					label = lastLabel;
					setSingle();
				} else {
					that.gotoAndStop(firstStartFrame);
				}
			} else { // single label
				setSingle();
			}

			function setSingle() {
				_normalizedFrames = that.parseFrames(label, startFrame, endFrame);
				_normalizedFrame = 0;
				that.gotoAndStop(_normalizedFrames[_normalizedFrame]);
				startFrame = endFrame = null;
				obj = {normalizedFrame:_normalizedFrames.length-1};
			}

			if (zot(time)) time = timeType=="s"?1:1000;
			// if already running the sprite then stop the last run
			if (that.running) that.stopAnimate(that.id);
			that.running = true;
			
			if (!Array.isArray(obj)) {
				extraTime = 0;
				if (endFrame-startFrame > 0) extraTime = time / Math.abs(endFrame-startFrame) / 2; // slight cludge - seems to look better?
				if (_normalizedFrames && _normalizedFrames.length>0) extraTime = time / _normalizedFrames.length / 2; // slight cludge - seems to look better?
				if (loop && zot(loopWait)) {loopWait = extraTime*tweek;}
				if (rewind && zot(rewindWait)) {rewindWait = extraTime*tweek;}
			}

			// locally override call to add running status after animation done
			var localCall = function() {
				that.running = false;
				that.stop();
				if (call && typeof call == 'function') call(params||that);				
			};
			zim.animate({
				target:that,
				obj:obj,
				time:time,
				ease:"linear",
				call:localCall,
				params:params,
				wait:wait, waitedCall:waitedCall, waitedParams:waitedParams,
				loop:loop,
				loopCount:loopCount,
				loopWait:loopWait,
				loopPick:loopPick,
				// animateCall:function() {zog(that.latestTween.percentComplete);},
				loopCall:loopCall, loopParams:loopParams,
				loopWaitCall:loopWaitCall, loopWaitParams:loopWaitParams,
				rewind:rewind, rewindWait:rewindWait, // rewind is ignored by animation series
				rewindCall:rewindCall, rewindParams:rewindParams,
				rewindWaitCall:rewindWaitCall, rewindWaitParams:rewindWaitParams,
				rewindTime:rewindTime, rewindEase:rewindEase,
				override:false,
				pauseOnBlur:pauseOnBlur,
				id:that.id
			});
			that.runPaused = false;
			that.pauseAnimate(false); // needed after 015 latestTween adjustments because Sprite starts with animating=false
			return that;
		};

		this.runPaused = true;
		this.pauseRun = function(paused) {
			if (zot(paused)) paused = true;
			that.runPaused = paused;
			if (that.globalControl) {
				zim.pauseAnimate(paused, that.id);
			} else {
				that.pauseAnimate(paused, that.id);
			}
			return that;
		};
		this.stopRun = function() {
			that.runPaused = true;
			that.running = false;
			if (that.globalControl) {
				zim.stopAnimate(that.id);
			} else {
				that.stopAnimate(that.id);
			}
			return that;
		};

		Object.defineProperty(this, 'frame', {
			get: function() {
				return this.currentFrame;
			},
			set: function(value) {
				value = Math.round(value);
				if (this.paused) {
					this.gotoAndStop(value);
				} else {
					this.gotoAndPlay(value);
				}
			}
		});

		Object.defineProperty(this, 'normalizedFrame', {
			get: function() {
				return _normalizedFrame;
			},
			set: function(value) {
				_normalizedFrame = Math.round(value);
				this.gotoAndStop(_normalizedFrames[_normalizedFrame]);
			}
		});

		Object.defineProperty(this, 'normalizedFrames', {
			get: function() {
				return _normalizedFrames;
			},
			set: function(value) {
				_normalizedFrames = value;
			}
		});

		Object.defineProperty(this, 'totalFrames', {
			get: function() {
				return sheet.getNumFrames();
			},
			set: function() {
				zogy("zim.Sprite - totalFrames is read only");
			}
		});

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
		this.clone = function() {
			var s = this.cloneProps(new zim.Sprite(image, cols, rows, count, offsetX, offsetY, spacingX, spacingY, width, height, animations, json, null, globalControl, spriteSheet, label, frame, style, this.group, inherit));
			
			// if it is 0 it will be 0 anyway and including 0 seems to make it so a clone can't set a frame
			if (that.frame > 0) s.run({startFrame:that.frame, endFrame:that.frame});
			
			return s;			
		};
		if (createjs && !createjs.stageTransformable && frame.retina) {
			this.localToGlobal = function(x,y) {
				return zim.localToGlobal(x,y,this,this.cjsSprite_localToGlobal);
			};
			this.globalToLocal = function(x,y) {
				return zim.globalToLocal(x,y,this,this.cjsSprite_globalToLocal);
			};
			this.localToLocal = function(x,y,target) {
				return zim.localToLocal(x,y,target,this);
			};
		}
		
		this.hasProp = function(prop) {
			return (!zot(this[prop]) || Object.prototype.hasOwnProperty.call(this,prop));
		};
		
		zim.displayBase(that);
		function normalizeBounds(a, b, c, d) {
			var bounds = [];
			if (zot(a)) {
				bounds = [a,b,c,d];
			} else if (zot(b)) {
				if (a.x) bounds = [a.x, a.y, a.width, a.height]; 	
				else {
					bounds[0] = 0;
					bounds[1] = 0;
					bounds[2] = a;
					bounds[3] = a;
				}		
			} else if (!zot(c)) {
				bounds[0] = a;
				bounds[1] = b;
				bounds[2] = c;
				bounds[3] = d;
			} else {
				bounds[0] = 0;
				bounds[1] = 0;
				bounds[2] = a;
				bounds[3] = b;
			}
			if (zot(bounds[3])) bounds[3] = bounds[2];
			return bounds;
		}
		this.setBounds = function(a,b,c,d) {
			var n = normalizeBounds(a, b, c, d);
			that.cjsSprite_setBounds(n[0],n[1],n[2],n[3]);
			return that;
		};
		this.getBounds = function(targetSpace) {
			if (targetSpace) {
				return that.boundsToGlobal(null,null,null,targetSpace);
			}
			return that.cjsSprite_getBounds();
		};
		this.dispose = function() {
			zim.gD(this); // globalDispose function for common elements
			this.dispatchEvent("removed");
			this.removeAllEventListeners();
			if (this.parent) this.parent.removeChild(this);
		};
	};
	zim.extend(zim.Sprite, createjs.Sprite, ["clone","setBounds","getBounds","localToLocal","localToGlobal","globalToLocal"], "cjsSprite", false);
	zimify(zim.Sprite.prototype);
	//-50.8

/*--
zim.MovieClip = function(mode, startPosition, loop, labels, style, group, inherit)

MovieClip
zim class - extends a createjs.MovieClip

DESCRIPTION
A MovieClip adds timelines to a Container.
The timelines are animate() zimTween properties.
The zimTween property returns a CreateJS Tween object.
Primarily made to support Adobe Animate MovieClip export.
*Consider this experimental for the moment...

NOTE: to use animate() on a MovieClip, add the MovieClip to a Container and animate() the Container
otherwise the animate() may advance the MovieClip.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const movieClip = new MovieClip();
const circle = new Circle(20, blue).animate({
	props:{scale:3}, time:.1, rewind:true, loop:true
});

// Time is in frames NOT in ms - so 100 frames at the Ticker.framerate 60 fps by default is almost 2 seconds
// To change the Ticker's framerate use setFPS(mobile, desktop) method
// If you use one number then both mobile and desktop are set to that fps.
// The defaults are 60 fps mobile (as of ZIM Cat 04) and 60 fps desktop

movieClip.timeline.addTween(circle.zimTween);
movieClip.play();
movieClip.center();
S.on("stagemousedown", ()=>{
   movieClip.paused = !movieClip.paused;
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
// from the CreateJS MovieClip docs: https://www.createjs.com/docs/easeljs/classes/MovieClip.html
mode - (default "independent") or single_frame (based on startPosition) or synched (syncs to parent)
startPosition - (default 0) the start position of the MovieClip (*could not get to work)
loop - (default true) set to false not to loop (*did not seem to loop so use loop:true in zim.animate())
labels - (default null) declare label property with position value
	eg. {explode:20} to use with gotoAndPlay("explode") rather than gotoAndPlay(20)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
setBounds(width||x||Boundary, height||y, null||width, null||height) - overrides CreateJS setBounds() and returns object for chaining
	If you do not provide any parameters, then the bounds will be reset to the calculated bounds
	width||x||Boundary - (default null) the width of the bounds - or the x if four parameters are provided
		or a ZIM Boundary Object {x,y,width,height} - same as CreateJS Rectangle - thanks Joseph Diefenbach
	height||y - (default width) the height of the bounds - or the y if four parameters are provided
	width - (default null) the width of the bounds - or null if only the first two parameters are provided
	height - (default null) the height of the bounds - or null if only the first two parameters are provided
getBounds(targetSpace) - overrides CreateJS getBounds() and returns a rectangle with x, y, width height of bounds (not including outside of border) 
	pass in a Container (including Stage) to map rectangle to that coordinate space 
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for MovieClip methods, such as:
play(), gotoAndPlay(), gotoAndStop(), stop(), advance(),
on(), off(), dispatchEvent(), etc.

PROPERTIES
type - holds the class name as a String
draggable - set to true for a default drag() and false for a noDrag()
group - used when the object is made to add STYLE with the group selector (like a CSS class)
** bounds must be set first (or width and height parameters set) for these to work
** setting these adjusts scale not bounds and getting these uses the bounds dimension times the scale
width - gets or sets the width. Setting the width will scale the height to keep proportion (see widthOnly below)
height - gets or sets the height. Setting the height will scale the width to keep proportion (see heightOnly below)
widthOnly - gets or sets the width.  This sets only the width and may change the aspect ratio of the object
heightOnly - gets or sets the height.  This sets only the height and may change the aspect ratio of the object
draggable - set to true for a default drag() and false for a noDrag()
level - gets or sets the level of the object in its parent container (or the stage) - a property for parent.getChildIndex() and parent.setChildIndex()
depth - for ZIM VR - the depth used to shift left and right channel and for parallax in VR - also see dep() ZIM Display method
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
effects - an object that holds effects added such as blur, glow, shadow, color, multi and alpha - see effect() under ZIM Methods 
** the following are convenience Effects that run a ZIM MultiEffect()
** these can use a lot of processing when animating - see Docs for effects() 
** batch versions are available too as hueBatch, etc. these will not update the effect until updateEffects() is called on the object
hue - the tint of an object between -180 and 180 with 0 being no change 
saturation - the amount of color of an object between -100 and 100 with 0 being no change 
brightness - the lightness or darkness of an object between -255 and 255 with 0 being no change 
contrast - the crispness of an object between -100 and 100 with 0 being no change 

ALSO: see the CreateJS Easel Docs for MovieClip properties, such as:
currentFrame, totalFrames, currentLabel, duration, framerate, labels, loop, mode, paused, startPosition, timeline,
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, mouseEnabled, parent, etc.

EVENTS
See the CreateJS Easel Docs for MovieClip events, such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.9
	zim.MovieClip = function(mode, startPosition, loop, labels, style, group, inherit) {
		var sig = "mode, startPosition, loop, labels, style, group, inherit";
		var duo; if (duo = zob(zim.MovieClip, arguments, sig, this)) return duo;
		z_d("50.9");
		this.type = "MovieClip";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(mode)) mode = DS.mode!=null?DS.mode:null;
		if (zot(startPosition)) startPosition = DS.startPosition!=null?DS.startPosition:null;
		if (zot(loop)) loop = DS.loop!=null?DS.loop:null;
		if (zot(labels)) labels = DS.labels!=null?DS.labels:null;

		this.cjsMovieClip_constructor(mode, startPosition, loop, labels);

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
		this.clone = function() {
			return this.cloneProps(new zim.MovieClip(mode, startPosition, loop, labels, style, this.group, inherit));
		};
		this.hasProp = function(prop) {
			return (!zot(this[prop]) || Object.prototype.hasOwnProperty.call(this,prop));
		};
		var frame = WW.zdf || 1;
		if (createjs && !createjs.stageTransformable && frame.retina) {
			this.localToGlobal = function(x,y) {
				return zim.localToGlobal(x,y,this,this.cjsMovieClip_localToGlobal);
			};
			this.globalToLocal = function(x,y) {
				return zim.globalToLocal(x,y,this,this.cjsMovieClip_globalToLocal);
			};
			this.localToLocal = function(x,y,target) {
				return zim.localToLocal(x,y,target,this);
			};
		}
		
		zim.displayBase(this);
		function normalizeBounds(a, b, c, d) {
			var bounds = [];
			if (zot(a)) {
				bounds = [a,b,c,d];
			} else if (zot(b)) {
				if (a.x) bounds = [a.x, a.y, a.width, a.height]; 	
				else {
					bounds[0] = 0;
					bounds[1] = 0;
					bounds[2] = a;
					bounds[3] = a;
				}		
			} else if (!zot(c)) {
				bounds[0] = a;
				bounds[1] = b;
				bounds[2] = c;
				bounds[3] = d;
			} else {
				bounds[0] = 0;
				bounds[1] = 0;
				bounds[2] = a;
				bounds[3] = b;
			}
			if (zot(bounds[3])) bounds[3] = bounds[2];
			return bounds;
		}
		this.setBounds = function(a,b,c,d) {
			var n = normalizeBounds(a, b, c, d);
			that.cjsMovieClip_setBounds(n[0],n[1],n[2],n[3]);
			return that;
		};
		this.getBounds = function(targetSpace) {
			if (targetSpace) {
				return that.boundsToGlobal(null,null,null,targetSpace);
			}
			return that.cjsMovieClip_getBounds();
		};
		
		this.dispose = function() {
			zim.gD(this); // globalDispose function for common elements
			this.dispatchEvent("removed");
			this.removeAllEventListeners();
			if (this.parent) this.parent.removeChild(this);
		};
	};
	zim.extend(zim.MovieClip, createjs.MovieClip, ["clone","setBounds","getBounds","localToLocal","localToGlobal","globalToLocal"], "cjsMovieClip", false);
	zimify(zim.MovieClip.prototype);
	//-50.9

/*--
zim.SVGContainer = function(svg, splitTypes, geometric, showControls, interactive, style, group, inherit)

SVGContainer
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Parses SVG and adds items to a ZIM Container.
Items are created as ZIM Shapes: Circle, Rectangle, Blob, Squiggle.
If geometric is true then Circle and Rectangle are used otherwise Blob is used.
Items can be accessed using svgcontainer.getChildAt(0), etc.
See: https://zimjs.com/svg/
See: https://zimjs.com/explore/svgcontainer.html

ALSO: see SVG() class under Frame module.

An SVG path string can be passed directly to a Squiggle or Blob points parameter
and so avoiding the SVGContainer - see ZIM Squiggle and Blob

WARNING: this should be considered experimental
The idea is that paths from SVG can be made editable in ZIM
or animation, dragging, or Label along paths can be accommodated
As such, not all SVG features will work - no CSS, Text, Gradients, DropShadows, etc.
It is possible that these will be added at some point
See also the ZIM svgToBitmap() function under META to get an exact image of the SVG
Thank you https://github.com/colinmeinke/svg-arc-to-cubic-bezier for the Arc conversion

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const svgContainer = new SVGContainer(asset("sample.svg")).addTo();

// OR

const svg = `<svg  width="150" height="200" xmlns="h t t p ://www.w3.org/2000/svg">
    <path id="lineAB" d="M 0 0 l 150 200" stroke="red" stroke-width="3" fill="none" />
</svg>`;
const svgContainer = new SVGContainer(svg).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
svg - an SVG file loaded into an asset() or SVG text
splitTypes - (default false) - set to true to split different types of paths into separate objects
geometric - (default true) - set to false to load Rectangle and Circle objects as Blob objects
showControls - (default true) set to false to start with controls not showing
interactive - (default true) set to false to turn off controls, move, toggle, select, edit - leaving just the shapes
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
processPath(path) - path is an SVG path string - returns a ZIM Blob or Squiggle points array
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
svg - a reference to the SVG text
type - holds the class name as a String

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.95

	zim.SVGContainer = function(svg, splitTypes, geometric, showControls, interactive, style, group, inherit) {
		var sig = "svg, splitTypes, geometric, showControls, interactive, style, group, inherit";
		var duo; if (duo = zob(zim.SVGContainer, arguments, sig, this)) return duo;
		z_d("50.95");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("SVGContainer", this.group, inherit);

		if (svg && svg.type == "Bitmap") svg = svg.svg; // svg is now loaded into a Bitmap automatically in Frame

		var that = this;
		var startPosition = new zim.Point(0,0); // the x,y of the last shape
		var arcToBezier;
		function makeArcCode() {
			// ~~~~~~~~~~~~~~~~~~~~~~~~		
			// ES5 Babel port from ES6 https://github.com/colinmeinke/svg-arc-to-cubic-bezier

			function _sa(arr, i) { return _ah(arr) || _il(arr, i) || _ua(arr, i) || _ni(); }
			function _ni() { throw new TypeError("Invalid"); }
			function _ua(o, minLen) { if (!o) return; if (typeof o === "string") return _ala(o, minLen); var n = Object.prototype.toString.call(o).slice(8, -1); if (n === "Object" && o.constructor) n = o.constructor.name; if (n === "Map" || n === "Set") return Array.from(o); if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _ala(o, minLen); }
			function _ala(arr, len) { if (len == null || len > arr.length) len = arr.length; for (var i = 0, arr2 = new Array(len); i < len; i++) { arr2[i] = arr[i]; } return arr2; }
			function _il(arr, i) { if (typeof Symbol === "undefined" || !(Symbol.iterator in Object(arr))) return; var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i["return"] != null) _i["return"](); } finally { if (_d) throw _e; } } return _arr; }
			function _ah(arr) { if (Array.isArray(arr)) return arr; }
			
			var TAU = Math.PI * 2;			
			var me = function me(_ref, rx, ry, cosphi, sinphi, centerx, centery) {
				var x = _ref.x, y = _ref.y;
				x *= rx;
				y *= ry;
				var xp = cosphi * x - sinphi * y;
				var yp = sinphi * x + cosphi * y;
				return {
					x: xp + centerx,
					y: yp + centery
				};
			};	
			
			var approxUnitArc = function approxUnitArc(ang1, ang2) {
				// If 90 degree circular arc, use a constant
				// as derived from https://spencermortensen.com/articles/bezier-circle
				var a = ang2 === 1.5707963267948966 ? 0.551915024494 : ang2 === -1.5707963267948966 ? -0.551915024494 : 4 / 3 * Math.tan(ang2 / 4);
				var x1 = Math.cos(ang1);
				var y1 = Math.sin(ang1);
				var x2 = Math.cos(ang1 + ang2);
				var y2 = Math.sin(ang1 + ang2);
				return [{
					x: x1 - y1 * a,
					y: y1 + x1 * a
					}, {
					x: x2 + y2 * a,
					y: y2 - x2 * a
					}, {
					x: x2,
					y: y2
				}];
			};
			var vectorAngle = function vectorAngle(ux, uy, vx, vy) {
				var sign = ux * vy - uy * vx < 0 ? -1 : 1;
				var dot = ux * vx + uy * vy;
				if (dot > 1) {
					dot = 1;
				}
				if (dot < -1) {
					dot = -1;
				}
				return sign * Math.acos(dot);
			};
		
			var getArcCenter = function getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp) {
				var rxsq = Math.pow(rx, 2);
				var rysq = Math.pow(ry, 2);
				var pxpsq = Math.pow(pxp, 2);
				var pypsq = Math.pow(pyp, 2);
				var radicant = rxsq * rysq - rxsq * pypsq - rysq * pxpsq;

				if (radicant < 0) {
					radicant = 0;
				}
				radicant /= rxsq * pypsq + rysq * pxpsq;
				radicant = Math.sqrt(radicant) * (largeArcFlag === sweepFlag ? -1 : 1);
				var centerxp = radicant * rx / ry * pyp;
				var centeryp = radicant * -ry / rx * pxp;
				var centerx = cosphi * centerxp - sinphi * centeryp + (px + cx) / 2;
				var centery = sinphi * centerxp + cosphi * centeryp + (py + cy) / 2;
				var vx1 = (pxp - centerxp) / rx;
				var vy1 = (pyp - centeryp) / ry;
				var vx2 = (-pxp - centerxp) / rx;
				var vy2 = (-pyp - centeryp) / ry;
				var ang1 = vectorAngle(1, 0, vx1, vy1);
				var ang2 = vectorAngle(vx1, vy1, vx2, vy2);

				if (sweepFlag === 0 && ang2 > 0) {
					ang2 -= TAU;
				}
				if (sweepFlag === 1 && ang2 < 0) {
					ang2 += TAU;
				}

				return [centerx, centery, ang1, ang2];
			};
			return function arcToBezier(_ref2) {
				var px = _ref2.px,
				py = _ref2.py,
				cx = _ref2.cx,
				cy = _ref2.cy,
				rx = _ref2.rx,
				ry = _ref2.ry,
				_ref2$xAxisRotation = _ref2.xAxisRotation,
				xAxisRotation = _ref2$xAxisRotation === void 0 ? 0 : _ref2$xAxisRotation,
				_ref2$largeArcFlag = _ref2.largeArcFlag,
				largeArcFlag = _ref2$largeArcFlag === void 0 ? 0 : _ref2$largeArcFlag,
				_ref2$sweepFlag = _ref2.sweepFlag,
				sweepFlag = _ref2$sweepFlag === void 0 ? 0 : _ref2$sweepFlag;
				var curves = [];

				if (rx === 0 || ry === 0) {
					return [];
				}

				var sinphi = Math.sin(xAxisRotation * TAU / 360);
				var cosphi = Math.cos(xAxisRotation * TAU / 360);
				var pxp = cosphi * (px - cx) / 2 + sinphi * (py - cy) / 2;
				var pyp = -sinphi * (px - cx) / 2 + cosphi * (py - cy) / 2;

				if (pxp === 0 && pyp === 0) {
					return [];
				}

				rx = Math.abs(rx);
				ry = Math.abs(ry);
				var lambda = Math.pow(pxp, 2) / Math.pow(rx, 2) + Math.pow(pyp, 2) / Math.pow(ry, 2);

				if (lambda > 1) {
					rx *= Math.sqrt(lambda);
					ry *= Math.sqrt(lambda);
				}

				var _getArcCenter = getArcCenter(px, py, cx, cy, rx, ry, largeArcFlag, sweepFlag, sinphi, cosphi, pxp, pyp),
					_getArcCenter2 = _sa(_getArcCenter, 4),
					centerx = _getArcCenter2[0],
					centery = _getArcCenter2[1],
					ang1 = _getArcCenter2[2],
					ang2 = _getArcCenter2[3];

				var ratio = Math.abs(ang2) / (TAU / 4);

				if (Math.abs(1.0 - ratio) < 0.0000001) {
					ratio = 1.0;
				}

				var segments = Math.max(Math.ceil(ratio), 1);
				ang2 /= segments;

				for (var i = 0; i < segments; i++) {
					curves.push(approxUnitArc(ang1, ang2));
					ang1 += ang2;
				}

				return curves.map(function (curve) {
					var _me = me(curve[0], rx, ry, cosphi, sinphi, centerx, centery),
					x1 = _me.x,
					y1 = _me.y;

					var _me2 = me(curve[1], rx, ry, cosphi, sinphi, centerx, centery),
					x2 = _me2.x,
					y2 = _me2.y;

					var _me3 = me(curve[2], rx, ry, cosphi, sinphi, centerx, centery),
					x = _me3.x,
					y = _me3.y;

					return {
						x1: x1,
						y1: y1,
						x2: x2,
						y2: y2,
						x: x,
						y: y
					};
				});
			};
			// ~~~~~~~~~~~~~~~~~~~~~~~~
		}	
		
		if (zot(splitTypes)) splitTypes = false;
		if (zot(geometric)) geometric = true;

		var parser, tag;
		
		function processTag(tag) {
			zim.loop(tag, function (t) {
				var tn = t.tagName.toLowerCase();
				if (tn == "path") processPath(t);
				if (tn == "circle") processShape("circle", t);
				if (tn == "rect") processShape("rect", t);
				if (tn == "ellipse") processShape("ellipse", t);
				if (tn == "line") processShape("line", t);
				if (tn == "polygon") processShape("polygon", t);
				if (tn == "polyline") processShape("polyline", t);
				if (tn == "g") {
					// styles can be overwritten by parameters in the general tag
					// so find styles first
					var style = t.getAttribute("style");
					var f,s,ss,a,aa;
					if (style) {
						var styles = processStyle(style);
						f = styles[0];
						s = styles[1];
						ss = styles[2];
						a = styles[3];
						aa = styles[4];
					}
					// then overwrite styles with any attribute values
					currentTransform = t.getAttribute("transform");
					generalFill = t.getAttribute("fill")?t.getAttribute("fill"):!zot(f)?f:defaultFill;
					generalStroke = t.getAttribute("stroke")?t.getAttribute("stroke"):!zot(s)?s:defaultStroke;
					generalStrokeSize = t.getAttribute("stroke-width")?t.getAttribute("stroke-width"):!zot(ss)?ss:defaultStrokeSize;
					generalAlpha = t.getAttribute("fill-opacity")?t.getAttribute("fill-opacity"):!zot(a)?a:defaultAlpha;
					generalStrokeAlpha = t.getAttribute("stroke-opacity")?t.getAttribute("stroke-opacity"):!zot(aa)?aa:defaultStrokeAlpha;
				}
				// general settings can wrap any number of tags - the tags are processed here:
				processTag(t.children);
				// after this nest of tags are processed, clear the general settings
				if (t.tagName.toLowerCase() == "g") {
					generalFill = defaultFill;
					generalStroke = defaultStroke;
					generalStrokeSize = defaultStrokeSize;
					generalAlpha = defaultAlpha;
					generalStrokeAlpha = defaultStrokeAlpha;
					currentTransform = null;
				}
			});
		}
		
		function processStyle(style) {
			var st = style.split(";");											//kv note: there si bug when style contains ; at the end of the string
			var f,s,ss,a,aa;
			zim.loop(st, function (sty) {
				sty = sty.replace(/,/g,"");
				var styl = sty.split(":");
				var prop = styl[0].trim().toLowerCase();
				var val = styl[1].trim().toLowerCase().replace("px", "");
				if (prop=="fill") f = val;
				if (prop=="stroke") s = val;
				if (prop=="stroke-width") ss = val;
				if (prop=="opacity") a = val, aa = val;
				if (prop=="fill-opacity") a = val;
				if (prop=="stroke-opacity") aa = val;
			});
			return [f,s,ss,a,aa];
		}

		function processShape(type, tag) {
			var shape;
			var g = processGeneral(tag); // want ES6
			var f = g[0], s = g[1], ss = g[2], x = g[5], y = g[6];
			// var a = g[3], aa = g[4];
			if (type == "circle") {
				var r = Number(tag.getAttribute("r").trim());
				var d = r*.5523;
				if (geometric) shape = new zim.Circle(Number(tag.getAttribute("r")), f, s, ss);
				else shape = new zim.Blob(f, s, ss, 4, r, d, "mirror", null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
			} else if (type == "rect") {
				if (geometric) shape = new zim.Rectangle(Number(tag.getAttribute("width")), Number(tag.getAttribute("height")), f, s, ss, Number(tag.getAttribute("rx")));
				else {
					var w = Number(tag.getAttribute("width"));
					var h = Number(tag.getAttribute("height"));
					var rx = Number(tag.getAttribute("rx"));
					var ry = Number(tag.getAttribute("ry"));
					if (rx && ry) {
						var dx = rx*.5523;
						var dy = ry*.5523;
						shape = new zim.Blob(f, s, ss, [
							[rx,0,0,0,-dx,0,0,0,"free"],[w-rx,0,0,0,0,0,dx,0,"free"],
							[w,ry,0,0,0,-dy,0,0,"free"],[w,h-ry,0,0,0,0,0,dy,"free"],
							[w-rx,h,0,0,dx,0,0,0,"free"],[rx,h,0,0,0,0,-dx,0,"free"],
							[0,h-ry,0,0,0,dy,0,0,"free"],[0,ry,0,0,0,0,0,-dy,"free"]], null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
					} else {
						shape = new zim.Blob(f, s, ss, [[0,0],[w,0],[w,h],[0,h]], null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
					}
				}
			} else if (type == "line") {
				shape = new zim.Squiggle(s, ss, [[Number(tag.getAttribute("x1")), Number(tag.getAttribute("y1"))],[Number(tag.getAttribute("x2")), Number(tag.getAttribute("y2"))]], null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
			} else if (type == "polygon" || type == "polyline") {
				var p = tag.getAttribute("points");
				p = p.replace(/-/g, " -");
				p = p.replace(/\s+/g, " ");
				var points = [];
				if (p.indexOf(",") != -1) {
					zim.loop(p.split(" "), function (point) {
						var pp = point.split(",");
						points.push([Number(pp[0].trim()), Number(pp[1].trim())]);
					});
				} else {
					var lastP;
					zim.loop(p.split(" "), function (point, i) {
						if ((i+1)%2==0) points.push([lastP, point.trim()]);
						lastP = point.trim();
					});
				}
				if (type=="polygon") shape = new Blob(f, s, ss, points);
				else shape = new zim.Squiggle(s, ss, points, null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
			} else if (type == "ellipse") {
				shape = new zim.Blob(f, s, ss, ellipse(0, 0, Number(tag.getAttribute("rx")), Number(tag.getAttribute("ry"))), null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
			}
			shape.loc(x,y,that);
			var transform = tag.getAttribute("transform");
			if (transform || currentTransform) processTransform(shape, transform || currentTransform);
			if (interactive && (shape.type == "Rectangle" || shape.type=="Circle")) shape.transform({showReg:false, visible:showControls});
		}

		function processTransform(shape, transform) {
			var tr = transform.split(")");
			// apply all transforms in the order given
			zim.loop(tr, function (tra) {
				if (tra=="") return;
				var tran = tra.trim().split("(");
				var prop = tran[0].trim().toLowerCase();
				var val = tran[1].trim().toLowerCase().replace("px", "").replace("deg", "");
				if (prop=="translate") {
					var m = val.split(",");
					shape.mov(Number(m[0].trim()), m[1]?Number(m[1].trim()):0);
				}
				if (prop=="scale"){
					var s = val.split(",");
					if (shape.type=="Blob" || shape.type=="Squiggle") {
						if (s.length == 1) shape.transformPoints("scale", Number(s[0].trim()));
						else if (s.length == 2) {
							shape.transformPoints("scaleX", Number(s[0].trim()));
							shape.transformPoints("scaleY", Number(s[1].trim()));
						}
					} else {
						if (s.length == 1) shape.sca(Number(s[0].trim()));
						else if (s.length == 2) {
							shape.sca(Number(s[0].trim()), Number(s[1].trim()));
						}
					}
				}
				if (prop=="rotate") {
					var r = val.split(",");
					// if (shape.type=="Blob" || shape.type=="Squiggle") {
						// rotation is a different way for SVG and transform() - too bad
						// it rotates around 0,0 unless a different point is chosen
						// so shape.transformPoints which is a registration point system
						// is unlikely to work - and too complex to add rotate around a given point
						// so we will use zim rot() to which we have added rotating around a different point
						// but this will rotate the little box handles
						// maybe look into keeping those parallel in the blob and squiggle - no matter what the rotation
						// if (r.length == 1) shape.transformPoints("rotation", Number(r[0].trim()))
					if (r.length == 1) r.push(0,0);
					else if (r.length == 2) r.push(0);
					shape.rot(Number(r[0].trim()), Number(r[1].trim()), Number(r[2].trim()));
				}

				if (prop=="skewX") shape.skewX = val;
				if (prop=="skewY") shape.skewY = val;
			});
		}

		// beatgammit on StackOverflow
		function ellipse(x, y, xDis, yDis) {
			var kappa = 0.5522848, // 4 * ((âˆš(2) - 1) / 3)
				ox = xDis * kappa,  // control point offset horizontal
				oy = yDis * kappa,  // control point offset vertical
				xe = x + xDis,      // x-end
				ye = y + yDis;      // y-end
			var points = [ // modified by Dan Zen to relative
				[x - xDis, y, 0, 0, x, ye+oy-yDis, x, y-oy, "mirror"],
				[x, y - yDis, 0, 0, x-ox, y, xe+ox-xDis, y, "mirror"],
				[xe, y, 0, 0, x, y-oy, x + ox-ox, ye+oy-yDis, "mirror"],
				[x, ye, 0, 0, xe-xDis+ox, y, x-ox, y, "mirror"]
			];
			return points;
		}
				
		if (!zot(svg)) {
			if (svg.replace) svg = svg.replace(/style\s?=[^"]*"[^"]*"/ig, ""); // 10.9.0 remove style parameters
					
			if (!zot(svg.draggable)) {
				parser = new DOMParser();
				svg = !svg.innerHTML?svg:parser.parseFromString(svg.innerHTML,"text/xml");
				var list = svg.getElementsByTagName("svg");
				tag = this.svg = list?svg.getElementsByTagName("svg")[0]:null;
			} else {
				if (!svg.getAttribute) {
					parser = new DOMParser();
					svg = parser.parseFromString(svg, "image/svg+xml").documentElement;
				}
				tag = this.svg = svg;
			}
			var w, h;
			if (!zot(tag)){
				w = tag.getAttribute("width");
				h = tag.getAttribute("height");
			}
			if (w) w = Number(w.trim());
			if (h) h = Number(h.trim());
			this.zimContainer_constructor(w, h);
			this.type = "SVGContainer";

			if (zot(tag)) return;

			var defaultFill = zim.black, generalFill = zim.black;
			var defaultStroke =zim. black, generalStroke = zim.black;
			var defaultStrokeSize = 2, generalStrokeSize = 2;
			var defaultAlpha = 1, generalAlpha = 1;
			var defaultStrokeAlpha = 1, generalStrokeAlpha = 1;
			var currentTransform;
			
			var process = svg.getElementsByTagName("svg");
			if (process.length == 0) process = [svg];

			processTag(process);

		}

		function processGeneral(tag) {
			// any styles on the tag overwrites general styles or attributes
			var f,s,ss,a,aa;
			var style = tag.getAttribute("style");
			if (style) {
				var styles = processStyle(style);
				f = styles[0];
				s = styles[1];
				ss = styles[2];
				a = styles[3];
				aa = styles[4];
			}
			// kv comments: need to apply string cleansing, application bugs when there is a semi colon character used in tags.
			// get rid of semi colon,
			// any attributes on the tag overwrites styles or general
			f = tag.getAttribute("fill")?tag.getAttribute("fill"):!zot(f)?f:generalFill;
			s = tag.getAttribute("stroke")?tag.getAttribute("stroke"):!zot(s)?s:generalStroke;
			ss = tag.getAttribute("stroke-width")?tag.getAttribute("stroke-width"):!zot(ss)?ss:generalStrokeSize;
			a = tag.getAttribute("fill-opacity")?tag.getAttribute("fill-opacity"):!zot(a)?a:generalAlpha;
			aa = tag.getAttribute("stroke-opacity")?tag.getAttribute("stroke-opacity"):!zot(aa)?aa:generalStrokeAlpha;

			var x = tag.getAttribute("x")?tag.getAttribute("x"):0;
			x = tag.getAttribute("cx")?tag.getAttribute("cx"):x;
			var y = tag.getAttribute("y")?tag.getAttribute("y"):0;
			y = tag.getAttribute("cy")?tag.getAttribute("cy"):y;
			if (!zot(a) && !zot(f)) f = zim.convertColor(f, "rgba", Number(a));
			if (!zot(aa) && !zot(s)) s = zim.convertColor(s, "rgba", Number(aa));
			return [f,s,Number(ss),Number(a),Number(aa),Number(x),Number(y)];
		}

		function processPath (path, make) {
			if (zot(make)) make = true;
			var commands = ["M","m","L","l","H","h","V","v","C","c","S","s","Q","q","T","t","A","a","z","Z"];
			var commandsRelative = ["m","l","h","v","c","s","q","t","a","z"];

			var position = new zim.Point(0,0); // the current position - relative places based on this
			
			var d;
			if (zot(path.getAttribute)) {
				d = path;
			} else {
				// var id = path.getAttribute("id");
				d = path.getAttribute("d");
			}

			// m251.85 119.04c7.85 10.45-9.81			
			d = d.replace(/,/g ," ");
			d = d.replace(/([a-zA-Z])/g, " $1 ");
			d = d.replace(/-/g, " -");
			d = d.replace(/\s+/g, " ");
			
			// can also bump decimal numbers together if one decimal place in first - sigh... Cat 01 
			// 10.93.12 is really 10.93 .12		
			d = d.replace(/\.(\d*)\./g, ".$1 .");			
			
			if (make) {
				var g = processGeneral(path); // want ES6
				var f = g[0]; var s = g[1]; var ss = g[2]; 
				// var a = g[3]; var aa = g[4];
			}

			var shape;																									//kv adjust logic
			var aNumber;																								//kv adjust logic
			//var points = [[0,0]];																						//kv adjust logic
			var points = [];																							//kv adjust logic
			var lastTempPoint = [0,0];																					//kv adjust logic
			var line = new zim.Point(0,0);
			var quad = new zim.Point(0,0,0,0);
			var cube = new zim.Point(0,0,0,0,0,0);
			var arc = new zim.Point(0,0,0,0,0,0,0);
			//kv var data = d.split(" ");																				//kv adjust logic
			var dataOrigin = d.split(" ");																				//kv adjust logic
			var data = dataOrigin.slice(1,dataOrigin.length);															//kv adjust logic
			var aCommand = [];																							//kv adjust logic
			var missingCommand = false;													//not used yet					//kv adjust logic
			var lastCommand;																						//kv adjust label
			var previousCommand;													//not used yet					//kv adjust logic
			var adding = false;
			var what;
			var type = "squiggle";
			var dataType = null;
			//kv loop(data, function (command) {					//kv adjust logic
			zim.loop(data, function (command, i) {																					//kv adjust logic
				if (i==0) {
					startPosition.x = 0; 
					startPosition.y = 0;
					lastTempPoint = [0,0];
					lastCommand = "";
					previousCommand = "";
				}
				if (commands.indexOf(command) == -1) {
					if (what == "lxo") {what="lx"; aCommand.push("l");missingCommand=true;}								//kv adjust logic
					if (what == "lyo") {what="ly"; missingCommand=true;}												//kv adjust logic
					if (what == "Lxo") {what="Lx"; aCommand.push("L");missingCommand=true;}								//kv adjust logic
					if (what == "Lyo") {what="Ly"; missingCommand=true;}												//kv adjust logic
					aNumber = Number(command);																			//kv adjust logic
					aNumber = Math.round(aNumber * 100) / 100;															//kv adjust logic
					// position
					if (what == "X") {
						startPosition.x = aNumber;
						what = "Y";
					} else if (what == "Y") {
						startPosition.y = aNumber;
						//kv what = "Lx"; // in case no letters come next												//kv adjust logic
						what = "Lxo"; // in case no letters come next													//kv adjust logic
						points.push([startPosition.x, startPosition.y]);												//kv adjust logic
						// what = null;
					} else if (what == "x") {
						//if (points.length > 1) {
						//	startPosition.x = points[points.length-1][0]; 												//kv adjust logic
						//	startPosition.y = points[points.length-1][1]												//kv adjust logic
						//} else {
						//	startPosition.x = lastTempPoint[0];															//kv adjust logic
						//	startPosition.y = lastTempPoint[1]															//kv adjust logic
						//};
						startPosition.x = startPosition.x+aNumber;
						what = "y";
					} else if (what == "y") {
						startPosition.y = startPosition.y+aNumber;
						what = "lxo";																					//kv adjust logic
						//kv what = "lx"; // in case no letters come next												//kv adjust logic
						points.push([startPosition.x, startPosition.y]);												//kv adjust logic
						// what = null;
					}

					// left, right, top or bottom
					if (what == "H" || what == "h") {
						position.x = points[points.length-1][0];														//kv adjust logic
						position.y = points[points.length-1][1];														//kv adjust logic
						position.x = position.x + (what=="h"?aNumber:aNumber-startPosition.x);
						points.push([position.x, position.y]);
						what = "Lx";
					} else if (what == "V" || what == "v") {
						position.x = points[points.length-1][0];														//kv adjust logic
						position.y = points[points.length-1][1];														//kv adjust logic
						position.y = position.y + (what=="v"?aNumber:aNumber-startPosition.y);
						points.push([position.x, position.y]);
						what = "lx";
					}

					// line
					if (what == "Lx") {
						//kv line.x = aNumber-startPosition.x;							//kv adjust logic
						line.x = aNumber;												//kv adjust logic
						what = "Ly";
					} else if (what == "Ly") {
						//kv line.y = aNumber-startPosition.y;							//kv adjust logic
						line.y = aNumber;												//kv adjust logic
						position.x = line.x;
						position.y = line.y;
						points.push([position.x, position.y]);
						what = "Lx";
					} else if (what == "lx") {
						if (aCommand.length > 0) {										//kv adjust logic
							if (position.x != 0 && position.y != 0 ) {
								startPosition.x = position.x;
								startPosition.y = position.y;
							}
							else {
							startPosition.x = position.x + startPosition.x;				//kv adjust logic
							startPosition.y = position.y + startPosition.y;				//kv adjust logic
							//startPosition.x = position.x + lastTempPoint[0];			//kv adjust logic
							//startPosition.y = position.y + lastTempPoint[1];			//kv adjust logic
							}
						}																//kv adjust logic
						line.x = startPosition.x + aNumber;								//kv adjust logic
						//kv line.x = line.x + aNumber;									//kv adjust logic
						if (missingCommand) {what="lyo";} else							//kv adjust logic
						what = "ly";
					} else if (what == "ly") {
						line.y = startPosition.y + aNumber;								//kv adjust logic
						//line.y = line.y + aNumber;									//kv adjust logic
						position.x = line.x;
						position.y = line.y;
						points.push([position.x, position.y]);
						what = "lx";
					}

					var lastPoint;
					// Quadratic
					if (what == "qx" || what == "Qx") {
						if (points.length > 0) {								//kv adjust logic
							startPosition.x = points[points.length-1][0]; 		//kv adjust logic
							startPosition.y = points[points.length-1][1];		//kv adjust logic
						} else {												//kv adjust logic
							startPosition.x = 0;						 		//kv adjust logic
							startPosition.y = 0;								//kv adjust logic
						}														//kv adjust logic

						//kv quad.x = what=="qx"?position.x+aNumber:aNumber-startPosition.x;
						quad.x = what=="qx"?startPosition.x+aNumber:aNumber;	//kv adjust logic
						what = what=="qx"?"qy":"Qy";
					} else if (what == "qy" || what == "Qy") {
						//kv quad.y = what=="qy"?position.y+aNumber:aNumber-startPosition.y;
						quad.y = what=="qy"?startPosition.y+aNumber:aNumber;	//kv adjust logic
						what = what=="qy"?"qz":"Qz";
						if (adding) {
							adding = false;
							lastPoint = points[points.length-1];
							lastPoint[6] = -lastPoint[4];
							lastPoint[7] = -lastPoint[5];
							lastPoint[8] = "mirror";
							position.x = quad.x;
							position.y = quad.y;
							points[points.length] = [
								position.x, position.y,
								0, 0,
								-lastPoint[6], lastPoint[7],
								0,0,
								"free"
							];
							what = what=="qy"?"qx":"Qx";
						}
					} else if (what == "qz" || what == "Qz") {
						//kv quad.z = what=="qz"?position.x+aNumber:aNumber-startPosition.x;
						quad.z = what=="qz"?startPosition.x+aNumber:aNumber;							//kv adjust logic
						what = what=="qz"?"qq":"Qq";
					} else if (what == "qq" || what == "Qq") {
						//kv quad.w = what=="qq"?position.y+aNumber:aNumber-startPosition.y;
						quad.w = what=="qq"?startPosition.y+aNumber:aNumber;							//kv adjust logic
                        lastPoint = points[points.length-1];
                        position.x = lastPoint[0]; 													    //kv adjust logic
                        position.y = lastPoint[1];													    //kv adjust logic
						if (points.length == 1) {														//kv adust logic
							lastPoint[2] = 0; lastPoint[3] = 0; lastPoint[4] = 0; lastPoint[5] = 0;		//kv adjust logic    																	//kv debug
							lastPoint[6] = 2/3 *(quad.x - position.x); // relative needs position and absolute does not it
							lastPoint[7] = 2/3 *(quad.y - position.y);
							lastPoint[8] = "free";
						}																				//kv adjust logic
						else {																			//kv adjust logic
							points[points.length] = [													//kv adjust logic
								position.x, position.y,													//kv adjsut logic
								0, 0, 0, 0,																//kv adjust logic
								2/3*(quad.x-position.x), 												//kv adjust logic
								2/3*(quad.y-position.y),												//kv adjust logic
								"free"																	//kv adjust logic
							];																			//kv adjust logic
						}																				//kv adjust logic
						position.x = quad.z; // assign this point's position - fix this and apply throughout...
						position.y = quad.w;
						points[points.length] = [
							position.x, position.y,
							0, 0,
							// relative needs - startPosition and absolute does not
							2/3*(quad.x-position.x), 2/3*(quad.y-position.y),
							0,0,
							"free"
						];
						what = what=="qq"?"qx":"Qx";
					}
					// Cubic
					if (what == "cx" || what == "Cx") {
						if (points.length > 0) {														//kv adjust logic
							startPosition.x = points[points.length-1][0]; 								//kv adjust logic
							startPosition.y = points[points.length-1][1];								//kv adjust logic
						} else {																		//kv adjust logic
							startPosition.x = 0;						 								//kv adjust logic
							startPosition.y = 0;															//kv adjust logic
						}																				//kv adjust logic

						//kv cube.x = what=="cx"?position.x+aNumber:aNumber-startPosition.x;
						cube.x = what=="cx"?startPosition.x+aNumber:aNumber;							//kv adjust logic
						what = what=="cx"?"cy":"Cy";
					} else if (what == "cy" || what == "Cy") {		// y Control Point 1
						//kv cube.y = what=="cy"?position.y+aNumber:aNumber-startPosition.y;
						cube.y = what=="cy"?startPosition.y+aNumber:aNumber;							//kv adjust logic
						what = what=="cy"?"cz":"Cz";
					} else if (what == "cz" || what == "Cz") {		// x Control Point 2
						//kv cube.z = what=="cz"?position.x+aNumber:aNumber-startPosition.x;
						cube.z = what=="cz"?startPosition.x+aNumber:aNumber;							//kv adjust logic
						what = what=="cz"?"cq":"Cq";
					} else if (what == "cq" || what == "Cq") {		// y Control Point 2
						//kv cube.q = what=="cq"?position.y+aNumber:aNumber-startPosition.y;
						cube.q = what=="cq"?startPosition.y+aNumber:aNumber;							//kv adjust logic
						what = what=="cq"?"cr":"Cr";
						if (adding) {
							if (lastCommand=="s") {previousCommand = "s";} else {previousCommand = "S";}
							//kv adding = false;
							//kv update previous point
							lastPoint = points[points.length-1];
							lastPoint[2] = 0;							//kv adjust logic
							lastPoint[3] = 0;							//kv adjust logic
							if(zot(lastPoint[4])) {lastPoint[4] =0;}	//kv adjust logic
							if(zot(lastPoint[5])) {lastPoint[5] =0;}	//kv adjust logic
							lastPoint[6] = -lastPoint[4];
							lastPoint[7] = -lastPoint[5];
							// lastPoint[6] = - (cube.x-cube.z);			//kv adjust logic
							// lastPoint[7] = - (cube.y-cube.q);			//kv adjust logic
							lastPoint[8] = "mirror";
							//kv create very lastPoint
							position.x = cube.z;
							position.y = cube.q;
							points[points.length] = [
								position.x, position.y,
								0, 0,
								cube.x-position.x, cube.y-position.y,
								0,0,
								"free"
							];
							//kv what = what=="cq"?"cx":"Cx";
							what = what=="cr"?"cx":"Cx";																			//kv adjust logic
						}
					} else if (what == "cr" || what == "Cr") {
						//kv cube.r = what=="cr"?position.x+aNumber:aNumber-startPosition.x;
						cube.r = what=="cr"?startPosition.x+aNumber:aNumber;													//kv adjust logic
						what = what=="cr"?"cs":"Cs";
					} else if (what == "cs" || what == "Cs") {																	// y 2nd Point
						//kv cube.s = what=="cs"?position.y+aNumber:aNumber-startPosition.y;
						cube.s = what=="cs"?startPosition.y+aNumber:aNumber;													//kv adjust logic
						//points.push([cube.r, cube.s]);																		//kv adjust logic
						//[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType],					//kv debug
						lastPoint = points[points.length-1];
						if (points.length == 1) {lastPoint[2] = 0; lastPoint[3] = 0; lastPoint[4] = 0; lastPoint[5] = 0;}		//kv adjust logic
						lastPoint[6] = cube.x-lastPoint[0];
						lastPoint[7] = cube.y-lastPoint[1];
						lastPoint[8] = "free";
						position.x = cube.r;
						position.y = cube.s;
						points[points.length] = [
							position.x, position.y,
							0, 0,
							cube.z-position.x, cube.q-position.y,
							0,0,
							"free"
						];
						what = what=="cs"?"cx":"Cx";
										
					// Arc 
					// https://github.com/colinmeinke/svg-arc-to-cubic-bezier/issues/7
					// rx ry x-axis-rotation large-arc-flag sweep-flag x y
					} else if (what == "ax" || what == "Ax") {						
						if (points.length > 0) {																					
							startPosition.x = points[points.length-1][0]; 								
							startPosition.y = points[points.length-1][1];			
						} else {																		
							startPosition.x = 0;						 								
							startPosition.y = 0;														
						}		
						arc.x = aNumber; // radius x
						what = what=="ax"?"ay":"Ay";
					} else if (what == "ay" || what == "Ay") {
						arc.y = aNumber; // radius y
						what = what=="ay"?"az":"Az";
					} else if (what == "az" || what == "Az") {
						arc.z = aNumber; // x-axis-rotation
						what = what=="az"?"aq":"Aq";
					} else if (what == "aq" || what == "Aq") {
						arc.q = aNumber; // large-arc-flag
						what = what=="aq"?"ar":"Ar";
					} else if (what == "ar" || what == "Ar") {
						arc.r = aNumber; // sweep-flag
						what = what=="ar"?"as":"As";
					} else if (what == "as" || what == "As") {
						arc.s = what=="as"?startPosition.x+aNumber:aNumber;
						what = what=="as"?"at":"At";
					} else if (what == "at" || what == "At") {
						arc.t = what=="at"?startPosition.y+aNumber:aNumber;
						
						// rx ry x-axis-rotation large-arc-flag sweep-flag x y					
						if (!arcToBezier) arcToBezier = makeArcCode();
							
						var curves = arcToBezier({
							px: startPosition.x,
							py: startPosition.y,
							cx: arc.s,
							cy: arc.t,
							rx: arc.x,
							ry: arc.y,
							xAxisRotation: arc.z,
							largeArcFlag: arc.q,
							sweepFlag: arc.r,
						});
					
						zim.loop(curves, function (curve, ii) {
							lastPoint = points[points.length-1];
							if (points.length == 1) {lastPoint[2] = 0; lastPoint[3] = 0; lastPoint[4] = 0; lastPoint[5] = 0;}		//kv adjust logic
														
							if (ii==0 && points.length == 1) {
								lastPoint[6] = curve.x1-position.x-startPosition.x;
								lastPoint[7] = curve.y1-position.y-startPosition.y;
							} else { 
								lastPoint[6] = curve.x1-position.x;
								lastPoint[7] = curve.y1-position.y;
							}
							lastPoint[8] = "free";
							position.x = curve.x;
							position.y = curve.y;
							points[points.length] = [
								position.x, position.y,
								0, 0,
								curve.x2-position.x, curve.y2-position.y,
								0,0,
								"free"
							];
						});
						what = what=="at"?"ax":"Ax";
					}
				}
				
				else {
					aCommand.push(command);													// kv adjust logic

					// Commands
					if (command != "s") {
						adding = false;
					} 								// kv adjust logic
					if (aCommand.length > 1) {												// kv adjust logic
						// if (aCommand[aCommand.length-2] != command) {
						if (command=="M" || command=="m") {
							makeShape(aCommand);
							if (command=="M") {startPosition.x = 0; startPosition.y=0;}
							else {
								startPosition.x = points[points.length-1][0]; startPosition.y=points[points.length-1][1];
							}
							points = [];
							aCommand = [];
							aCommand.push(command);
						}
					}																		// kv adjust logic

					if (command=="M") {
						what = "X";
					} else if (command=="m") {
						what = "x";
					} else if (command=="L") {
						what = "Lx";
						if (splitTypes && dataType && (dataType != "l")) makeShape(aCommand);
						dataType = "l";
					} else if (command=="l") {
						what = "lx";
						if (splitTypes && dataType && (dataType != "l")) makeShape(aCommand);
						dataType = "l";
					} else if (command=="H") {
						what = "H";
						if (splitTypes && dataType && (dataType != "l")) makeShape(aCommand);
						dataType = "l";
					} else if (command=="h") {
						what = "h";
						if (splitTypes && dataType && (dataType != "l")) makeShape(aCommand);
						dataType = "l";
					} else if (command=="V") {
						what = "V";
						if (splitTypes && dataType && (dataType != "l")) makeShape(aCommand);
						dataType = "l";
					} else if (command=="v") {
						what = "v";
						if (splitTypes && dataType && (dataType != "l")) makeShape(aCommand);
						dataType = "l";
					} else if (command=="C") {
						what = "Cx";
						if (splitTypes && dataType && (dataType != "c")) makeShape(aCommand);
						dataType = "c";
					} else if (command=="c") {
						what = "cx";
						if (splitTypes && dataType && (dataType != "c")) makeShape(aCommand);
						dataType = "c";
					} else if (command=="S") {
						adding = true;
						what = "Cx";
						if (splitTypes && dataType && (dataType != "c")) makeShape(aCommand);
						dataType = "c";
					} else if (command=="s") {
						adding = true;
						what = "cx";
						if (splitTypes && dataType && (dataType != "c")) makeShape(aCommand);
						dataType = "c";
					} else if (command=="Q") {
						what = "Qx";
						if (splitTypes && dataType && (dataType != "q")) makeShape(aCommand);
						dataType = "q";
					} else if (command=="q") {
						what = "qx";
						if (splitTypes && dataType && (dataType != "q")) makeShape(aCommand);
						dataType = "q";
					} else if (command=="T") {
						adding = true;
						what = "Qx";
						if (splitTypes && dataType && (dataType != "q")) makeShape(aCommand);
						dataType = "q";
					} else if (command=="t") {
						adding = true;
						what = "qx";
						if (splitTypes && dataType && (dataType != "q")) makeShape(aCommand);
						dataType = "q";
					} else if (command=="A") {
						// type = null;
						what = "Ax";
						if (splitTypes && dataType && (dataType != "a")) makeShape();
						dataType = "a";
					} else if (command=="a") {
						what = "ax";
						if (splitTypes && dataType && (dataType != "a")) makeShape();
						dataType = "a";
					} else if (command=="z" || command=="Z") {
						type = "blob";
					}

				}	// end of Command process

			}); // end of data loop

			function makeShape() {
				// var myCommand;
				// var shape;																		//kv adjust logic
				lastCommand = aCommand[aCommand.length-1];																//kv adjust logic
				if (points.length >= 2)
					// M 100 350 l 150 -300
					if (lastCommand == "z" || lastCommand == "Z") {type = "blob";}										//kv adjust logic
					//if (zot(shape)) {																					//kv adjust logic
						if (type == "squiggle") shape = new zim.Squiggle(s, ss, points, null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
						else shape = new zim.Blob(f, s, ss, points, null, null, null, null, showControls, null, null, null, null, null, null, null, null, null, null, null, null, null, interactive);
						shape.loc(0,0,that);																					//kv adjust logic
					//} else {																							//kv adjust logic
					//	var dataPointsArray = [];																		//kv adjust logic
					//	dataPointsArray = shape.getPoints().concat(points);											//kv adjust logic
					//	//shape.removeFrom();																			//kv adjust logic
					//	if (type == "squiggle") shape = new Squiggle(s, ss, dataPointsArray)							//kv adjust logic
					//	else shape = new Blob(f, s, ss, dataPointsArray)												//kv adjust logic
					//};
					//kv shape.loc(startPosition.x, startPosition.y, that);												//kv adjust logic
					//kv startPosition.x = startPosition.x + position.x;												//kv adjust logic
					//kv startPosition.y = startPosition.y + position.y;												//kv adjust logic
					lastCommand = aCommand[aCommand.length-1];															//kv adjust logic
					previousCommand = aCommand[aCommand.length-2];														//kv adjust logic
					if (commandsRelative.indexOf(lastCommand) >= 0) {
						//if (aCommand[aCommand.length-1] == "m") {														//kv adjust logic
						lastTempPoint[0] = points[points.length-1][0]; lastTempPoint[1] = points[points.length-1][1];	//kv adjust logic
						startPosition.x = points[points.length-1][0]; startPosition.y = points[points.length-1][1];		//kv adjust logic
						points = [];																					// LATEST CHANGES
						points.push([lastTempPoint[0], lastTempPoint[1]]);												//kv adjust logic
					} else {lastTempPoint = [0,0]; points = [[0,0]];}

					aCommand = [];																						//kv adjust logic
					if (lastCommand != "z" && lastCommand != "Z") aCommand.push(lastCommand);							//kv adjust logic

					position.x = 0;
					position.y = 0;
					//kv points = [[0,0]];

				var transform = path.getAttribute("transform");
				if (transform || currentTransform) processTransform(shape, transform || currentTransform);
			}

			if (make) makeShape();
			return points;

		} // end process path

		that.processPath = function(path) {
			return processPath(path,false);
		};

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
		this.clone = function() {
			return that.cloneProps(new zim.SVGContainer(svg, splitTypes, geometric, showControls, interactive, style, this.group, inherit));
		};
	};
	zim.extend (zim.SVGContainer, zim.Container, "clone", "zimContainer", false);
	//-50.95

/*--
zim.Tag = function(width, height, id, frame, backgroundColor, padding, paddingH, paddingV, expand, style, group, inherit)

Tag
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Creates a <div></div> with id of id and overlays it on the Canvas with the createjs DOMElement
The tag is scaled and positioned with ZIM code and can be filled with any HTML desired
Access to the HTML tag is provided with the tag property (so you can use innerHTML or style on this)
However a convenience innerHTML and style properties have been added to Tag
CSS Styles can be applied to the HTML tag as with any HTML div tag
Or use the chainable add() method to add a String of HTML (instead of setting innerHTML)

SEE: https://zimjs.com/explore/tag.html

NOTE: due to the HTML tag being overlayed, the tag.resize() must be called if it is manually scaled or moved
(This is called automatically when the stage is resized)

NOTE: if the tag is placed in a container and the container is removed or added again
the tag must be manually removed or added again with tag.removeFrom() or tag.addTo().
This is so ZIM does not have to keep track of HTML tags each time a container is added or removed.

NOTE: rotation and skewing of Tag is not supported - although might work with custom CSS transformations

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const tag = new Tag(300, 60).center().add("<h1>TITLE TEXT</h1>");
tag.style.color = red;
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 250) the width of the div tag
height - (default 70) the height of the div tag
	Note: to set scrollBars use CSS: tag.style.overflow = "auto";
id - (default zimTag_randomNumber) a string id for the HTML div tag.
frame - (default the zdf) a reference to the Frame (to scale and position the HTML tag)
backgroundColor - (default "rgba(0,0,0,0)") a ZIM Rectangle used as a background
padding - (default 10) inner padding between edge of background rectangle and HTML tag
paddingH - (default padding) inner horizontal padding between edge of background rectangle and HTML tag
paddingV - (default padding) inner vertical padding between edge of background rectangle and HTML tag
expand - (default 20) hit area around background to count as a press on Tag - handy for dragging as HTML tag area will override mouse on canvas
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(htmlString) - chainable method to add HTML to tag - calling add() again will append
	see innerHTML property as alternative or to overwrite the innerHTML
resize(update) - call the resize event if the scale or position of the tag is changed
	this will sync the location of the div tag
	resize() is only needed if the scale or x, y of the tag (or its container) is changed
	it is not needed for general window resizing - the Tag handles this
	Note: if the Frame itself changes location in the HTML document, call a F.update()
	this will then dispatch an update event to the Tag and it will resize()
	this is not needed if resizing the window or scrolling - see Frame update() method docs
	update defaults to true - set to false to not update the stage during a resize()
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
tagID - the assigned id of the tag
tag - the HTML div tag - just a regular HMTL div tag which can be styled
innerHTML - the innerHTML property of the tag (so myTag.tag.innerHTML is not needed)
background - access to the ZIM Rectangle used as the background
frame - get or set the frame - set this if changing frames

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS: See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.7
zim.Tag = function(width, height, id, frame, backgroundColor, padding, paddingH, paddingV, expand, style, group, inherit) {
    var sig = "width, height, id, frame, backgroundColor, padding, paddingH, paddingV, expand, style, group, inherit";
    var duo; if (duo = zob(zim.Tag, arguments, sig, this)) return duo;
    z_d("67.7");
    this.group = group;
    var DS = style===false?{}:zim.getStyle("Tag", this.group, inherit);

    if (zot(width)) width = DS.width!=null?DS.width:250;
    if (zot(height)) height = DS.height!=null?DS.height:70;
    if (zot(id)) id = DS.id!=null?DS.id:"zimTag_" + zim.rand(10000);
    if (typeof frame == "undefined") {
        if (WW.zdf) {
            var frame = WW.zdf;
        } else {
            if (zon) {zogy("zim.Tag - please provide a reference to zim Frame");} return;
        }
    }
    if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"rgba(0,0,0,0)";
    if (zot(padding)) padding = DS.padding!=null?DS.padding:10;
    if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:padding;
    if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:padding;
    if (zot(expand)) expand = DS.expand!=null?DS.expand:20;
    if (expand === true) expand = 20;
    
    this.zimContainer_constructor(width, height, null, null, false);
    this.type = "Tag";
    this.tagID = id;
    this.id = id;
    var that = this;
    var stage = frame.stage;

    that.background = new zim.Rectangle(width+paddingH, height+paddingV, backgroundColor).center(this).expand(expand?expand:0);

    var tag = that.tag = document.createElement("div");		
    if (frame.tag) {
        frame.tag.appendChild(tag);
    } else {
        document.body.appendChild(tag);
    }	
        
    tag.setAttribute("id", id);
    tag.setAttribute("name", id);

    tag.zimDisplay = tag.style.display || "inline-block";		
    tag.style.cssText = "resize:none; z-index:3; width:" + width + "px; height:" + height + "px; overflow:hidden; outline:none;"
        + "position:absolute; left:0px; top:0px; display:none;";
    
    var cjsTag = new createjs.DOMElement(tag);
    cjsTag.alpha = 0;
    
    var pRatio = frame.retina?(WW.devicePixelRatio || 1):1;	
            
    this.resize = function(update, last) {
        if (zot(update)) update = true;
        if (that.time1) clearTimeout(that.time1);
        // before ZIM ZIM 01 rand the setTimeout on the whole resize code 
        // but that was causing jutters in damped window scrolling
        // so implemented a final call to help with a delayed update 
        // which was probably put in place to capture a mobile orientation change
        if (!last) {
            that.time1 = setTimeout(function() {
                that.resize(null, true);	
            }, 40);
        }			
        var displayProps = that.getConcatenatedMatrix().decompose();
        var point = that.localToGlobal(0, 0);
        if (frame.retina) {					
            var sc = zim.browserZoom();					
            if (frame.tag) {
                cjsTag.x = point.x/pRatio/sc;
                cjsTag.y = point.y/pRatio/sc;
            } else {
                cjsTag.x = frame.x/stage.scaleX + point.x/pRatio/sc;
                cjsTag.y = frame.y/stage.scaleY + point.y/pRatio/sc;
            }															
            // CreateJS DOMElement is scaling tag as stage scales
            zim.sca(cjsTag, displayProps.scaleX/pRatio/stage.scaleX/sc, displayProps.scaleY/pRatio/stage.scaleY/sc);
        } else {
            cjsTag.x = frame.x + point.x * frame.scale;
            cjsTag.y = frame.y + point.y * frame.scale;
            zim.sca(cjsTag, frame.scale*displayProps.scaleX, frame.scale*displayProps.scaleY);
        }				
        cjsTag.alpha = that.alpha;
        if (that.parent) cjsTag.alpha *= that.parent.alpha;
        if (update && that.stage) stage.update();
        // }, 50);
        return that;
    };
    this.resize();
    that.added(addedCallback);		
    function addedCallback() {
        stage.addChild(cjsTag);
        that.time2 = setTimeout(function() {
            tag.style.display = tag.zimDisplay;
        }, 50);
        that.resize();
        that.on("added", addedCallback, null, true); // once
    }
    that.on("removed", function() {
        if (that.time1) clearTimeout(that.time1);
        if (that.time2) clearTimeout(that.time2);
        stage.removeChild(cjsTag);
        if (tag) tag.style.display = "none";
    });

    this.add = function(html) {
        tag.innerHTML += html;
        return that;
    };

    Object.defineProperty(this, 'innerHTML', {
        get: function() {
            return tag.innerHTML;
        },
        set: function(value) {
            tag.innerHTML = value;
        }
    });

    Object.defineProperty(this, 'style', {
        get: function() {
            return tag.style;
        },
        set: function(value) {
            tag.style = value;
        }
    });

    if (style!==false) zim.styleTransforms(this, DS);
    this.clone = function() {
        var u = new zim.Tag(width, height, id, frame, backgroundColor, padding, paddingH, paddingV, expand, style, this.group, inherit);
        return that.cloneProps(u);
    };
    Object.defineProperty(this, 'frame', {
        get: function() {
            return frame;
        },
        set: function(value) {
            if (value != frame) {
                frame.off("update", that.updateEvent);
                frame.off("resize", that.resizeEvent);
                frame = value;
                that.resizeEvent = frame.on("resize", that.resize);
                that.updateEvent = frame.on("update", that.resize);
                that.resize();
            }
        }
    });
    this.resizeEvent = frame.on("resize", that.resize);
    this.updateEvent = frame.on("update", that.resize);
    this.dispose = function(a,b,disposing) {
        var stage;
        if (that.stage) stage = that.stage;
        frame.off("update", that.updateEvent);
        frame.off("resize", that.resizeEvent);
        if (tag && tag.parentNode) {
            tag.parentNode.removeChild(tag);
        }
        tag = null;			
        // if we are not coming from a container
        // then call container's dispose
        // let the container's dispose know
        // that we have already disposed this custom dispose
        // so it does not try and dispose it again
        if (!disposing) {
            this.zimContainer_dispose(true);
            if (stage) stage.update();
        }
        return true;
    };
};
zim.extend(zim.Tag, zim.Container, ["clone", "dispose"], "zimContainer", false);
//-67.7


// SUBSECTION SHADERS

/*--
zim.Shader = function(width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, group, inherit)

Shader
zim class - extends a zim.Bitmap which extends a createjs.Bitmap

DESCRIPTION
Makes a Bitmap from shader code.  The Bitmap will update automatically if set to dynamic (default).
Shaders run on the GPU and are very fast for cool visual effects and are also the basis for 3D.
For 3D, we recommend using three.js with ZIM and the the Three helper module - overlayed or with TextureActive.
BUT - shaders are also commonly used for amazing 2D effects.

Also see ShaderOverlay() that overlays the raw WebGL Canvas on ZIM as a Tag() rather than converting to a Bitmap.

The best way to see what shaders are about are to look at the many examples on ShaderToy, for instance:
https://www.shadertoy.com

Many of the shaders from ShaderToy will work in ZIM Shader() with a simple cut and paste.
However, ones with multiple channels are currently not supported - but you may be able to add equivilant code.
For instance, a picture can be brought into the shader rather than using a channel.
There are many more shaders other than in ShaderToy.

Shaders have their own coding language called GLSL https://en.wikipedia.org/wiki/OpenGL_Shading_Language
ZIM Shader was built for OpenGL 3.0 but other versions may work.
This is a very complicated coding world based on C - so do not expect to easily make shaders.
Most likely, you will start with copying and perhaps modifying code - but it is not easy.
When looking at reference materials, note that ZIM has greatly simplified the requirements
So tend to ignore how shaders are set up to run
and concentrate on the actual fragment (and sometimes vertex) shader code
https://learnopengl.com/Getting-started/Shaders
https://thebookofshaders.com/
https://thebookofshaders.com/glossary/

ZIM Shader() abstracts a couple hundred lines of somewhat famously complicated WebGL code.
There are three main inputs (beyond width and height)

FRAGMENT 
Shader code that changes the pixel colors.
This is the code that is displayed in ShaderToy and is most popular in 2D shaders.
Fragment shaders run after Vertex shaders but it is an early parameter because the Vertex shader is usually default.

UNIFORMS
These are variables that we pass in to the shader.
ZIM provides a Uniforms() object for this purpose for easy animate() and wiggle() and component interactivity.
The uniforms will automatically be updated by ZIM Shader.
The following code will get inserted at the top of the shader code:

	#version 300 es                     // version number - see versions parameter
	precision mediump float;            // can reset a different precision if desired        
	uniform vec3      iResolution;      // width and height of shader (in pixels)
	uniform float     iTime;            // shader playback time (in seconds)
	uniform float     iTimeDelta;       // render time (in seconds)
	uniform float     iFrameRate;       // shader frame rate (frames per second)
	uniform int       iFrame;           // shader playback frame
	uniform vec4      iMouse;           // mouse coordinates x, y (in pixels), down (0/1), click (0/1)
	uniform vec4      iDate;            // year (full), month (0-11), day, time (in seconds from midnight)
	uniform float     iChange;          // increases with the rate (parameter or property) of the Shader

VERTEX 
Shader code that changes the verticies (points) of triangles.
This defaults to two triangles in a strip that make a rectangle based on the provided width and height.
This code will probably not be needed and is not shown in ShaderToy - but can be used in ZIM Shader()

TIPS 
In the shader code, data types matter, are declared and need to match properly - for example:
	float num = 1.0;
	int count = 1;
	vec2 size = vec(0.0, 1.0); 
Vectors are used a lot and can have 2, 3, or 4 components (like array elements) that we access with x, y, z, w (or rgba or stpq)
These can be accessed and adjusted in multiple ways - called "swizzling"  (examples from learnopengl.com)
	vec2 someVec; // has two components
	vec4 differentVec = someVec.xyxx; // make 4 components from the two components - repeating is fine
	vec3 anotherVec = differentVec.zyw; // has three components
	vec4 otherVec = someVec.xxxx + anotherVec.yxzy; // added components together
	vec2 vect = vec2(0.5, 0.7); // two components - use leading 0 and trailing 0 to keep as float if desired
	vec4 result = vec4(vect, 0.0, 0.0); // vect will be spread across the first two components
	vec4 otherResult = vec4(result.xyz, 1.0); // first three components of results are spread across otherResult
ShaderToy uses a slightly different format which is converted by ZIM - see the Docs under fragment parameter.
	A main thing to watch out for is that ShaderToy fragCoord is a vec2 
	whereas gl_FragCoord (WebGL 1.0) is a vec3 so use gl_FragCoord.xy to match fragCoord
Conditionals are often avoided for performance https://theorangeduck.com/page/avoiding-shader-conditionals

ZIM Shader() defaults to dynamic which means that it will update.
Set the dynamic parameter to false if the shader does not need to update.

SEE: https://zimjs.com/016/shaders for a mini-site of shaders in ZIM.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE 
// A simple horizontal gradient shown four ways 
// These four ways can be used throughout the examples 
// but we will show the rest as the ShaderToy format.

// https://www.shadertoy.com/view/MlK3DK
// iResolution is a default uniform (see Uniforms above)

// VERSION 1 - ShaderToy mainImage(out, in) {} Format
const fragment = `  
	void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
		fragColor = mix(vec4(1,1,0,1), vec4(0,1,1,1), fragCoord.x/iResolution.x);
	}
`;    
new Shader(W, H, fragment).center();

// VERSION 2 - main() {} - traditional GLSL 3 format
const fragment = `  
	out vec4 fragColor;
	void main() {
		vec2 fragCoord = gl_FragCoord.xy; // convert default input vec3 gl_FragCoord to vec2 fragCoord
		fragColor = mix(vec4(1,1,0,1), vec4(0,1,1,1), fragCoord.x/iResolution.x);
	}
`;
new Shader(W, H, fragment).center();

// VERSION 3 - using gl_FragCoord directly
const fragment = `  
	out vec4 fragColor;
	void main() {
		fragColor = mix(vec4(1,1,0,1), vec4(0,1,1,1), gl_FragCoord.x/iResolution.x);
	}
`;    
new Shader(W, H, fragment).center();

// VERSION 4 - traditional GLSL 1 format (note version param in Shader)
const fragment = `  
	void main() {
		gl_FragColor = mix(vec4(1,1,0,1), vec4(0,1,1,1), gl_FragCoord.x/iResolution.x);
	}
`;    
new Shader({width:W, height:H, fragment:fragment, version:""}).center();
END EXAMPLE 

EXAMPLE
// Animating with the iTime uniform (see default uniforms)
const fragment = `
	void mainImage( out vec4 fragColor, in vec2 fragCoord ) {        
		vec2 uv = fragCoord.xy / iResolution.xy;
		vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));
		fragColor = vec4(vec3(color), 1.0);
	} 
`;    
new Shader(W, H, fragment).center();
END EXAMPLE

EXAMPLE 
// https://zimjs.com/016/shader/spiral.html
// loading shader from file - often a glsl extension
// VS Code has a glsl-literal extension that will color syntax shader code

new Frame(FILL, 1024, 768, purple, black, ready, "spiral.glsl");
function ready() { 
	new Shader(W, H, asset("spiral.glsl")).addTo();    
} 
END EXAMPLE

EXAMPLE
// A circle - using rgb() and circle() functions
const fragment = `    
	// center will be wiggled outside in ZIM so need a uniform
	uniform vec2 center;

	// prepare a function to convert RGB 0-255 to 0-1
	vec3 rgb(float r, float g, float b) {
		return vec3(r/255.0, g/255.0, b/255.0); // 0-1
	}

	// prepare a function to see if each point (uv) is inside or outside radius
	// from wherever the center of the circle is located (pos - based on center uniform)
	vec4 circle(vec2 uv, vec2 pos, float rad, vec3 color) {
		float d = length(pos - uv) - rad;
		float t = clamp(d, 0.0, 1.0); // threshhold 0 if within radius range from center
		return vec4(color, 1.0 - t); // alpha 0 if outside radius
	}

	void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
		// circle will be 1/2 the height 
		float radius = 0.25 * iResolution.y;

		// Background
		vec4 layer1 = vec4(rgb(255.0, 165.0, 0.0), 1.0);

		// Circle
		vec3 red = rgb(255.0, 0.0, 0.0);
		vec4 layer2 = circle(fragCoord.xy, center, radius, red);

		// Blend the two using the alpha of the circle
		fragColor = mix(layer1, layer2, layer2.a);
	}    
`; 

const width = 500;
const height = 500;

const uniforms = {
	center:[width/2, height/2]
};
const u = new Uniforms(uniforms).wiggle("center_A", width/2, 50,100, 2,4);
new Shader(width, height, fragment, u).center().drag();
END EXAMPLE

EXAMPLE 
// a double spiral with speed set by iChange uniform
// which is controlled by the shader rate parameter/property
F.color = purple;
const fragment = `
	void mainImage(out vec4 fragColor, in vec2 fragCoord) {   
		// https://www.shadertoy.com/view/cl3BWr
		vec2 uv = 0.5-fragCoord/iResolution.xy;
		uv.y*=iResolution.y/iResolution.x;
		float angle=atan(uv.y, uv.x);
		float stage=sin(-iChange + 10.*(length(uv)*10.+.2*angle));
		fragColor = vec4(mix(.1,.9,smoothstep(-1.,1.,stage/fwidth(stage))));
	}
`;               
const shader = new Shader(W, H, fragment).center();

// shader.animate({ // would animate the rate
//     props:{rate:5},
//     time:5,
//     rewind:true,
//     loop:true
// })

const slider = new Slider({
	min:0, 
	max:1, 
	currentValue:.5,
	barLength:100
}).pos(50,50,RIGHT,BOTTOM).change(()=>{
	shader.rate = Math.exp(slider.currentValue*3)-1;
});
shader.rate =  Math.exp(slider.currentValue*3)-1;   
END EXAMPLE

EXAMPLE 
// Make a chessboard with a Fragment Shader - from https://medium.com/@banksysan_10088/webgl-checkerboard-42e15490603c
// Change the col and row counts with a Stepper using Uniforms
const fragment = `    
	uniform vec2 counts; // cols and rows
	uniform vec4 color1; // rgba
	uniform vec4 color2;

	void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
		vec2 boardCoordinates = floor(fragCoord.xy * counts.xy / iResolution.xy);
		float xMod = mod(boardCoordinates.x, 2.0);
		float yMod = mod(boardCoordinates.y, 2.0);
		float state = mod(xMod + yMod, 2.0);
		fragColor = mix(color1, color2, state);
	}    
`;   

const start = 8;
const uniforms = new Uniforms({ 
	counts:[start, start],
	color1:[0,0,0,1],
	color2:[1,1,1,1]
});
const board = new Shader(500, 500, fragment, uniforms, null, false).center(); // false for not dynamic

const stepper = new Stepper({min:1, max:20, currentValue:start}).sca(.8).pos(0,30,CENTER,BOTTOM).change(()=>{
	uniforms.counts_A = stepper.currentValue;
	uniforms.counts_B = stepper.currentValue;
	board.update(); // update needed as dynamic is set to false
	S.update();
});
END EXAMPLE

EXAMPLE
// make a chessboard from a little bw image - from https://medium.com/@banksysan_10088/webgl-checkerboard-42e15490603c
// not sure if this is the easiest or only way to do this...
new Frame(FIT, 1024, 768, light, dark, ready, "board.jpg");
function ready() {
	const vertex = `
		in vec3 vertexPosition;
		out vec3 vPosition; // will get passed to fragment shader
		void main() {
			vPosition = vertexPosition;
			gl_Position = vec4(vertexPosition, 1.0);
		}
	`;

	const fragment = `
		uniform sampler2D TEXTURE; // texture captured here
		in vec3 vPosition;
		void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
			// texture comes in flipped and on different coordinates
			vec2 normalizedCoordinates = (vPosition.xy * vec2(0.5, -0.5)) + vec2(0.5, 0.5);
			fragColor = texture(TEXTURE, normalizedCoordinates); // note this is texture2D() in OpenGL 1
		}
	`;

	const before = function(program, gl, canvas) {    
		const textureImageElement = new Pic("board.jpg").image;
		const texture = gl.createTexture();    
		gl.bindTexture(gl.TEXTURE_2D, texture);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
		gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST); // nearest as linear will blend
		gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureImageElement);
	}

	const board = new Shader(500, 500, fragment, null, vertex, false, before).center();
}
END EXAMPLE

EXAMPLE
// make a chessboard with the Vertex Shader - from https://medium.com/@banksysan_10088/webgl-checkerboard-42e15490603c
// adding only certain squares - add a Fragment Shader with a color to change the default black
const after = function(program, gl, canvas, vertexData) {
	const counts = [8,8];
	const size = {width:2/counts[0], height:2/counts[1]};
	let rowAlternate = true;
	for (let i=-1; i<1; i+=size.width) {
		let cellAlternate = rowAlternate;
		for (let j=-1; j<1; j+=size.height) {
			cellAlternate = !cellAlternate;
			if (cellAlternate) continue; // do not add anything
			const v1 = [i, j];
			const v2 = [i, j + size.height];
			const v3 = [i + size.width, j + size.height];
			const v4 = [i + size.width, j];
			vertexData.push(...v1);
			vertexData.push(...v3);
			vertexData.push(...v2);
			vertexData.push(...v3);
			vertexData.push(...v1);
			vertexData.push(...v4);
		}
		rowAlternate = !rowAlternate;
	}
}
                    
new Rectangle(500,500,white).center();
const board = new Shader({
	width:500, 
	height:500, 
	dynamic:false, 
	postCall:after,
	strip:false // use TRIANGLES not TRIANGEL_STRIP (might not show on iOS)
}).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 500) the width of the Shader
	this can be retrieved in the Shader code as iResolution.x
height - (default 500) the height of the Shader
	this can be retrieved in the Shader code as iResolution.y
fragment - provide the code as a string for the Fragment Shader which affects the pixels
	This can be passed in as a variable with `` for multiline or preloaded as an asset and read using asset("filename.glsl")
	ShaderToy uses "void mainImage(out vec4 fragColor, in vec2 fragCoord) {}"
	But basic GLSL uses main(), fragColor for OUT, and gl_FragCoord as IN 
	ZIM converts the ShaderToy so that you can use either.
	To see the final Fragment Shader in the console set the Shader() log parameter to true
	Here is the default Fragment Shader for OpenGL 3 (verion 1 is slightly different):
		// START AUTO - do not include below
		#version 300 es
		precision mediump float;
		// plus all the default Uniforms mentioned above        
		// END AUTO - do not include above
		void main() {            
			vec2 fragCoord = gl_FragCoord.xy; // a 2D variable of IN coordinates
			gl_FragColor = vec4(0.0, 0.0, 0.0, 1.0); // OUT variable
		}
uniforms - (default null) a ZIM Uniform object or an object literal {} with uniform names and values (use arrays for vectors)
	if a {} is passed in, a Uniform object will be made and in either case available as the uniform property of the Shader
	the uniform properties match the {} properties except any array is made into individual properties to make animation easier
	For instance, passing in:
		{   
			alpha:.5,
			position:[100,200]
		}
	would result in three properties on the uniform object:
		shader.uniform.alpha // .5 
		shader.position_A // 100 
		shader.position_B // 200
	These could be animated or wiggled like:
		shader.uniform.animate({position_A:300}, 2); // animate position.x inside the shader
		shader.wiggle("alpha", .5, .1, .4, 1, 2); // wiggle alpha inside the shader - probably on the "z" or "a" component of a color vec4        
vertex - provide the code as a string for the Vertex Shader which affects the points
	this will be used less with 2D outputs - see the Fragment Shader parameter for similar details
	To see the final Fragment Shader in the console set the Shader() log parameter to true
	Here is the default Vertex Shader for OpenGL 3 (verion 1 is slightly different):
		// START AUTO - do not include below
		precision mediump float;
		// plus all the default Uniforms mentioned above 
		vec2 fragCoord = gl_FragCoord.xy; // a 2D variable of IN coordinates
		// END AUTO - do not include above
		void main() {        
			gl_Position = vec4(vertexPosition, 0.0, 1.0); // OUT variable
		}
dynamic - (default true) set to false to not update the uniforms of the shaders constanty
preCall - (default null) a function to run just before before gl.useProgram(program); and after createProgram(gl, vertex, fragment)
	the function will receive (program, gl, canvas) arguments to its parameters
postCall - (default null) a function to run after createProgram(gl, vertex, fragment) and gl.useProgram(program);
	the function will receive (program, gl, canvas, vertexData) arguments to its parameters
	Note: the vertexData is a [] and can be filled in this function 
	if it is not filled then it defaults to two triangles making a rectangle of width and height
	Also see the strip parameter below
rate - |ZIM VEE| (default 1) set the rate of the iChange uniform.
	many shaders use iTime to animate the effect.  Instead, you can use an iChange uniform 
	and setting a rate of 2 will animate it twice as fast, .5 half as fast, etc.
	this can be set with a ZIM VEE value and can also be adjusted with the rate property of the shader 
	(this could also be done with the iFrameRate uniform but then the Ticker.setFPS() would have to be changed)
version - (default "#version 300 es") string version to add to top of shader code - would suggest leaving this as default
	use "" for lower versions.  Higher versions probably will work using the #
canvas - (default a canvas tag) a canvas tag will be created for the Shader or pass in an existing canvas tag
	this will be available as the canvas property
vertexPosition - (default "vertexPosition") the variable name for the vertexPosition
strip - (default true) use gl.TRIANGLE_STRIP - set to false to use gl.TRIANGLES for vertex data
	Note: could not get gl.TRIANGLES working on iOS (iPad2)
	strip:true will use     vertexData = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0]; // two triangles strips
	strip:false will use:   vertexData = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0]; // two triangles
	in either case, if vertexData is set in the postCall then this overrides the default vertexData above.
log - (default false) - set to true to log the vertex and fragment shaders in the console - in that order
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
update() - update the shader - not needed if dynamic is true (default)
clone() - makes a copy of the Shader
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Bitmap (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(), etc.

PROPERTIES
type - holds the class name as a String
dynamic - get or set whether the shader is dynamic
rate - |ZIM VEE| get or set the rate of the iChange uniform - can use for animating the shader - see also the rate parameter
canvas - the canvas for the shader 
gl - the WebGL context for the canvas for the shader 
uniforms - the uniforms object stored on the shader - use uniforms.obj for the original object literal 
	uniforms holds all the properties as individual properties
	vectors (arrays) are accessed as vector_A, vector_B, vector_C, vector_D 
	see ZIM Uniforms for more info
fragment - the fragment shader - also see the log parameter to view final shaders in console
vertex - the vertex shader 
program - the WebGL program with the shaders
ticker - the ZIM Ticker that runs the updates

ALSO: see ZIM Bitmap for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Bitmap properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseEnabled, parent, etc.

EVENTS
See the CreateJS Easel Docs for Bitmap events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+50.96
zim.Shader = function(width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, group, inherit) {
    var sig = "width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, group, inherit";    
    var duo; if (duo = zob(zim.Shader, arguments, sig, this)) return duo;        
    z_d("50.96");
    this.group = group;
    var DS = style===false?{}:zim.getStyle("Shader", this.group, inherit);
    var s = makeShader(DS, width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, this);
    
    this.zimBitmap_constructor(s.canvas);
    this.type = "Shader";   

    this.uniforms = s.uniforms; // now a Uniforms object - use uniforms.obj to see original
    this.canvas = s.canvas;
    this.gl = s.gl;
    this.setUniform = s.setUniform;
    this.update = s.update;      
    this.program = s.program;     
    this.fragment = s.fragment;     
    this.vertex = s.vertex;     
    this.ticker = s.ticker;
    var that = this;
    var _dynamic = s.dynamic;

    Object.defineProperty(this, 'dynamic', {
        get: function() {
            return _dynamic;
        },
        set: function(value) {
            if (value) {
                zim.Ticker.add(this.ticker);
            } else {
                zim.Ticker.remove(this.ticker);
            }
            _dynamic = value?true:false;
        }
    });

    if (style!==false) zim.styleTransforms(this, DS); 
    
    this.clone = function() {		
        return that.cloneProps(new zim.Shader(width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, this.group, inherit));
    };

    this.dispose = function(temp, b, disposing) {
        if (this.ticker) zim.Ticker.remove(this.ticker);
        if (this.uniforms) this.uniforms.dispose();
        this.canvas = null;
        this.gl = null;    
        this.program = null;     
        this.ticker = null;
		if (!disposing) this.zimBitmap_dispose(true);
		return true;
    }

}	
zim.extend(zim.Shader, zim.Bitmap, ["clone", "dispose"], "zimBitmap", false);
//-50.96

/*--
zim.ShaderOverlay = function(width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, group, inherit)

ShaderOverlay
zim class - extends a zim.Tag

DESCRIPTION
ShaderOverlay is a ZIM Tag() that holds a canvas with a shader from provided shader code.  
This is the same as ZIM Shader() so see the Docs for Shader above.
The only difference is that the shader canvas is placed in a Tag() so overlayed on ZIM.
This can also be underlayed by setting the z-index of the tag.

The advantage of a tag is that the canvas is used directly with its WebGL context
rather than passed into a Bitmap() to be displayed on the Canvas2D context.

The disadvantage is that the tag can only be overlayed or underlayed 
and not be in the normal ZIM canvas container levels.
Also, if manually adjusting, a shaderOverlay.update() might need to be called.
But for the most part, the Tag() should take care of it - for instance, resizing the window.
See ZIM Tag() for more tips regarding update().

EXAMPLE
new Frame(FILL, 1024, 768, clear, clear, ready);
function ready() {
	const fragment = `
		void main() {
			vec2 uv = gl_FragCoord.xy / iResolution.xy;
			vec3 color = 0.5 + 0.5 * cos(iTime + uv.xyx + vec3(0,2,4));
			gl_FragColor = vec4(vec3(color), 1.0);
		} 
	`;    
	const shader = new zim.ShaderOverlay(W, H, fragment).center();
	shader.tag.style.zIndex = -50; // put shader beneath stage

	const list = new List({
		backdropColor:faint, 
		bgColor:white.toAlpha(.5),
		rollBgColor:dark.toAlpha(.5),
		selectedBgColor:dark.toAlpha(.8),
	}).sca(1.5).center();
	F.on("resize", ()=>{list.center();});
} // end ready
END EXAMPLE

--*///+50.962
zim.ShaderOverlay = function(width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, group, inherit) {
    var sig = "width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, group, inherit";    
    var duo; if (duo = zob(zim.ShaderOverlay, arguments, sig, this)) return duo;        
    z_d("50.962");
    this.group = group;
    var DS = style===false?{}:zim.getStyle("ShaderOverlay", this.group, inherit);
    var s = makeShader(DS, width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, this);
    
    this.zimTag_constructor(width, height);
    this.type = "ShaderOverlay";   

    this.uniforms = s.uniforms; // now a Uniforms object - use uniforms.obj to see original
    this.canvas = s.canvas;
    this.gl = s.gl;
    this.setUniform = s.setUniform;
    this.update = s.update;      
    this.program = s.program;     
    this.fragment = s.fragment;     
    this.vertex = s.vertex;     
    this.ticker = s.ticker;
    var that = this;
    var _dynamic = s.dynamic;

    that.canvas.style.visibility = "visible";
    that.tag.appendChild(that.canvas);

    Object.defineProperty(this, 'dynamic', {
        get: function() {
            return _dynamic;
        },
        set: function(value) {
            if (value) {
                zim.Ticker.add(this.ticker);
            } else {
                zim.Ticker.remove(this.ticker);
            }
            _dynamic = value?true:false;
        }
    });

    if (style!==false) zim.styleTransforms(this, DS); 
    
    this.clone = function() {		
        return that.cloneProps(new zim.Shader(width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, style, this.group, inherit));
    };

    this.dispose = function(temp, b, disposing) {
        if (this.ticker) zim.Ticker.remove(this.ticker);
        if (this.uniforms) this.uniforms.dispose();
        this.canvas = null;
        this.gl = null;    
        this.program = null;     
        this.ticker = null;
		if (!disposing) this.zimTag_dispose(true);
		return true;
    }

}	
zim.extend(zim.ShaderOverlay, zim.Tag, ["clone", "dispose"], "zimTag", false);
//-50.962

/*--
makeShader = function(DS, width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, tether) 

makeShader
function - used internally only

DESCRIPTION
This is the general code to make a Shader in JS.  It is used by Shader() and ShaderOverlay().
It is included in the docs to more easily reference the code.
See Shader() and ShaderOverlay() for more information.

The code is a compilation of MDN Shader instructions and organization by David Banks
https://developer.mozilla.org/en-US/docs/Web/API/WebGLShader
https://medium.com/@banksysan_10088/webgl-checkerboard-42e15490603c
With a portion in the middle of ZIM code to handle uniforms, etc.
primarily to match default uniforms at ShaderToy https://www.shadertoy.com/
Introduced in ZIM 016

--*///+50.964
function makeShader(DS, width, height, fragment, uniforms, vertex, dynamic, preCall, postCall, rate, version, canvas, vertexPosition, strip, log, tether) {
    z_d("50.964");   

    if (zot(width)) width = DS.width!=null?DS.width:500;
    if (zot(height)) height = DS.radius!=null?DS.height:500;
    if (zot(rate)) rate = DS.rate!=null?DS.rate:1;
    if (zot(version)) version = DS.version!=null?DS.version:"#version 300 es";
    var defaultV;
    var defaultF;
    if (version == "") defaultV = "attribute vec3 vertexPosition;\nvoid main() {\n\tgl_Position = vec4(vertexPosition, 1.0);\n}";
    else defaultV = "in vec3 vertexPosition;\nvoid main() {\n\tgl_Position = vec4(vertexPosition, 1.0);\n}";
    if (zot(vertex)) vertex = DS.vertex!=null?DS.vertex:defaultV;
    if (version == "") defaultF = "void main() {\n\tgl_FragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}";
    else defaultF = "out vec4 fragColor;\nvoid main() {\n\tfragColor = vec4(0.0, 0.0, 0.0, 1.0);\n}";
    if (zot(fragment)) fragment = DS.fragment!=null?DS.fragment:defaultF;
    if (zot(uniforms)) uniforms = DS.uniforms!=null?DS.uniforms:null;
    if (zot(dynamic)) dynamic = DS.dynamic!=null?DS.dynamic:true;
    if (zot(preCall)) preCall = DS.preCall!=null?DS.preCall:null;
    if (zot(postCall)) postCall = DS.postCall!=null?DS.postCall:null;
    if (zot(canvas)) canvas = DS.canvas!=null?DS.canvas:null;
    if (zot(vertexPosition)) vertexPosition = DS.vertexPosition!=null?DS.vertexPosition:"vertexPosition";
    if (zot(strip)) strip = DS.strip!=null?DS.strip:true;
    if (zot(log)) log = DS.log!=null?DS.log:null;

    if (zot(canvas)) {
        canvas = document.createElement("canvas");
        canvas.setAttribute("width", width);
        canvas.setAttribute("height", height);
        canvas.setAttribute("id", "shaderCanvas");
    }

    fragment = version + "\nprecision mediump float;\n\n// ZIM Default Uniforms\nuniform vec3 iResolution;\nuniform float iTime;\nuniform float iTimeDelta;\nuniform float iFrameRate;\nuniform float iFrame;\nuniform vec4 iMouse;\nuniform vec4 iDate;\nuniform float iChange;\n" + fragment;
    vertex = version + "\nprecision mediump float;\n\n// ZIM Default Uniforms\nprecision mediump float;\nuniform vec3 iResolution;\nuniform float iTime;\nuniform float iTimeDelta;\nuniform float iFrameRate;\nuniform float iFrame;\nuniform vec4 iMouse;\nuniform vec4 iDate;\nuniform float iChange;\n\n" + vertex;

    // Replace ShaderToy mainImage
    var matches = fragment.match(/(void |.*)mainImage\(\s*(out\s*vec4\s*([^,]*)),\s*in\s*(vec[234]\s*[^)\s]*)\s*\)/i);
    fragment = fragment.replace(/(void |.*)mainImage\(\s*(out\s*vec4\s*[^,]*),\s*in\s*(vec[234]\s*[^)\s]*)\s*\)/i,  "$2;\nvoid main()");
    if (matches && matches[4]) {
        var append = "main() {\n\t"+matches[4]+" = gl_FragCoord.xy; // ZIM shadertoy adjust";
        fragment = fragment.replace(/main\(\)\s*{/i, append);
        fragment = fragment.replace(/main\(\)\s*(\n|\r)\s*{/i, append);
        if (matches && matches[3]) fragment = fragment.replace(/gl_FragColor/g, matches[3]);
    }
    if (log) {
        zogd("VERTEX SHADER:\n\n" + vertex);
        zogd("FRAGMENT SHADER:\n\n" + fragment);
    }

    if (zot(canvas)) {
        canvas = document.createElement("canvas");
        canvas.setAttribute(id, "shaderCanvas_" + zim.makeID());
    }
    if (!zot(uniforms)) {
        if (uniforms.type != "Uniforms") {
            uniforms = new zim.Uniforms(uniforms);
        }
    }

    tether.dynamic = dynamic;    
    tether.rate = zik(rate);
    tether.change = 0;

    // base code from https://medium.com/@banksysan_10088/webgl-checkerboard-42e15490603c
    var gl = canvas.getContext('webgl2');
    gl.enable(gl.CULL_FACE);
    gl.cullFace(gl.BACK);
    gl.frontFace(gl.CCW); 
    gl.clearColor(1.0, 1.0, 1.0, 1.0);
    gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

    var program = createProgram(gl, vertex, fragment);
    if (preCall && typeof preCall=="function") preCall(program, gl, canvas);  // ZIM
    gl.useProgram(program);
    var vertexData = [];
    if (postCall && typeof postCall=="function") {
        postCall(program, gl, canvas, vertexData);   
    }
    
    if (strip) {
        if (vertexData.length == 0) vertexData = [1.0, 1.0, -1.0, 1.0, 1.0, -1.0, -1.0, -1.0]; // two triangles strips
    } else {
        if (vertexData.length == 0) vertexData = [-1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0, 1.0, -1.0, -1.0, 1.0, -1.0]; // two triangles
    }
    var vertexBuffer = gl.createBuffer();
    gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);
    gl.bufferData(gl.ARRAY_BUFFER, new Float32Array(vertexData), gl.STATIC_DRAW);
    var vertexAttributeLocation = gl.getAttribLocation(program, vertexPosition);
    gl.vertexAttribPointer(vertexAttributeLocation, 2, gl.FLOAT, false, 2 * Float32Array.BYTES_PER_ELEMENT, 0);
    gl.enableVertexAttribArray(vertexAttributeLocation);

    // ZIM
    function setUniform(type, name, v1, v2, v3, v4) {
        if (zot(type)) type = "1f";
        if (zot(name)) {zogf("uniform - must have name"); return;}
        gl["uniform"+type](gl.getUniformLocation(program, name), v1, v2, v3, v4);
    }
    var frameNum = 0;       
    function update(e) {   
        // process uniforms 
        if (!zot(uniforms)) {
            uniforms.update(); // takes from properties and updates obj
            zim.loop(uniforms.obj, function(name,val) {
                var n = 1;
                if (Array.isArray(val)) n = val.length;
                else val = [val]; 
                // if (name=="time") zog(val[0])
                setUniform(n+"f", name, val[0], val[1], val[2], val[3]);
            });
        }       

        // DEFAULT UNIFORMS 
        var date = new Date();            
        setUniform("3f", "iResolution", width, height);        
        var time = zim.decimals(date.getHours()*60*60+date.getMinutes()*60+date.getSeconds()+date.getMilliseconds()/1000, 4);
        setUniform("4f", "iDate", date.getFullYear(), date.getMonth(), time);    
        setUniform("1f", "iTime", e?zim.decimals(e.runTime/1000, 4):0);
        setUniform("1f", "iChange", tether.rate);
        setUniform("1f", "iChange", tether.change+=tether.rate/60);                       
        setUniform("1f", "iTimeDelta", e?zim.decimals(e.delta/1000, 4):0);
        setUniform("1f", "iFrame", e?frameNum++:0);                       
        setUniform("1f", "iFrameRate", zim.decimals(createjs.Ticker.getMeasuredFPS()));
        if (tether.stage) {
            var mou = tether.globalToLocal(tether.stage.frame.mouseX, tether.stage.frame.mouseY);
            setUniform("4f", "iMouse", mou.x, height-mou.y, downCheck?1:0, clickCheck?1:0);
            clickCheck = false;
        }          
        
        if (strip) gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        else gl.drawArrays(gl.TRIANGLES, 0, vertexData.length);
        
    }
    var downCheck = false;
    var clickCheck = false;
    tether.on("mousedown", function() {downCheck = true;});
    tether.on("pressup", function() {downCheck = false;});
    tether.tap(function() {clickCheck = true;});
    update();
    var ticker = zim.Ticker.add(update);
    if (!dynamic) {
        zim.Ticker.remove(ticker);
        setTimeout(update, 50);
        if (tether.stage) tether.stage.update();
    }           
    return {dynamic:dynamic, fragment:fragment, vertex:vertex, program:program, uniforms:uniforms, gl:gl, canvas:canvas, update:update, setUniform:setUniform, ticker:ticker};      

    // private
    function createProgram(webGlContext, vertexShaderText, fragmentShaderText, verify) {
        if (zot(verify)) verify = true;
        if (!webGlContext) {
            console.error("This browser doesn't support WebGL");
        }

        webGlContext.clearColor(0.0, 0.0, 0.0, 0.0);
        webGlContext.clear(
            webGlContext.COLOR_BUFFER_BIT | webGlContext.DEPTH_BUFFER_BIT
        );

        var vertexShader = webGlContext.createShader(webGlContext.VERTEX_SHADER);
        var fragmentShader = webGlContext.createShader(
            webGlContext.FRAGMENT_SHADER
        );

        webGlContext.shaderSource(vertexShader, vertexShaderText);
        webGlContext.shaderSource(fragmentShader, fragmentShaderText);

        webGlContext.compileShader(vertexShader);
        webGlContext.compileShader(fragmentShader);

        var compileStatus = {
            vertexStatus:
                webGlContext.getShaderParameter(
                    vertexShader,
                    webGlContext.COMPILE_STATUS
                ) || webGlContext.getShaderInfoLog(vertexShader),
            fragmentStatus:
                webGlContext.getShaderParameter(
                    fragmentShader,
                    webGlContext.COMPILE_STATUS
                ) || webGlContext.getShaderInfoLog(fragmentShader),
        };

        if (
            compileStatus.vertexStatus !== true ||
            compileStatus.fragmentStatus !== true
        ) {
            throw new Error("Failed to compile. " + JSON.stringify(compileStatus, null, 2));
        }

        var program = webGlContext.createProgram();

        webGlContext.attachShader(program, vertexShader);
        webGlContext.attachShader(program, fragmentShader);
        webGlContext.linkProgram(program);

        var linkingStatus =
            webGlContext.getProgramParameter(program, webGlContext.LINK_STATUS) ||
            webGlContext.getProgramInfoLog(program);

        if (linkingStatus !== true) {
            throw new Error("Linking filed:\n" + linkingStatus);
        }

        if (verify) {
            webGlContext.validateProgram(program);
            var validationStatus =
                webGlContext.getProgramParameter(
                    program,
                    webGlContext.VALIDATE_STATUS
                ) || webGlContext.getProgramInfoLog(program);

            if (validationStatus !== true) {
                throw new Error("Validation failed.\n" + validationStatus);
            }
        }

        return program;
    }
} // end makeShader
//-50.964

/*--
zim.Uniforms = function(obj)

Uniforms
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes an object to hold uniforms for a ZIM Shader() or ShaderOverlay().
(This is not to be used as a display object despite extending a Container)
Uniforms are variables to pass in to the shader code.
They are often arrays to make vectors and array values are hard to animate.
ZIM Uniforms stores each array element as an individual property.
Uniforms extends a Container giving it animate() and wiggle() methods.
This means we can animate or wiggle any of the Uniforms properties
and ZIM will update the shader if the shader's dynamic parameter or property is true.

HOW IT WORKS 
An object literal {} is passed into the Uniforms(obj).
This will have all the uniform names and values.
If the value is an array that is used to set vector uniforms, then ZIM splits this up 
so that each array value has a property called the name_A, name_B, name_C, name_D as needed.
There are only ever 2, 3, or 4 component vectors.
If the value is a single value, then it is stored as the name alone.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const uniforms = new Uniforms({
	age:20,
	color:[.5, .2, .8, 1]
});

// the the Uniforms object will have:
zog(uniforms.age);      // 20 
zog(uniforms.color_A);  // .5
zog(uniforms.color_B);  // .2
zog(uniforms.color_C);  // .8
zog(uniforms.color_D);  // 1

uniforms.wiggle("color_A", .5, .2, .4, 1, 2); // would wiggle the red

// inside the shader they must be declared if they are to be used
// uniform float age;
// uniform vec4 color;

const fragment = `
	uniform vec4 color; // declare our uniform - only using color, age will be ignored
	void mainImage( out vec4 fragColor, in vec2 fragCoord ) {
		fragColor = color; // gl_FragColor or fragColor is the default output
	}       
`;   

new Shader(500, 500, fragment, uniforms).center().drag(); // draggable animated color box
END EXAMPLE

PARAMETERS
obj - the object literal {} with uniform properties and values

METHODS
update() - update the uniforms as long as dynamic is true or the update() method of the shader is called 
	this is handled automatically by the shader update() so may as well call update() on shader

PROPERTIES
type - holds the class name as a String
obj - the original object literal - its properties get updated as the uniforms properties are updated 
***
Each property in the object literal 
with arrays being split into a property for each element in the format 
name_A, name_B, name_C, name_D as dicted by the number of elements in the value for the property
{year:2024, dimensions:[200,500]}
would get:
uniforms.year = 2024
uniforms.dimensions_A = 200
uniforms.dimensions_B = 500
--*///+50.966
zim.Uniforms = function(obj) {
    // extends container to give wiggle() and animate() 
    // to use these on any uniform value
    this.zimContainer_constructor();
    z_d("50.966");
    var that = this;
    that.type = "Uniforms";
    zim.loop(obj, function(item, val) {
        if (val)
        that[obj]
    });
    that.obj = obj;
    var suf = ["A","B","C","D"];
    zim.loop(obj, function(name,val) {
        // make props from obj
        if (!Array.isArray(val)) val = [val]; 
        zim.loop(val, function(item, i, t) {
            if (t==1) {
                that[name] = val[0];
            } else {
                that[name + "_" + suf[i]] = val[i];
            }
        });
    });
    that.update = function() {        
        // put props back into obj
        zim.loop(obj, function(name,val) {
            if (!Array.isArray(val)) val = [val]; 
            zim.loop(val, function(item, i, t) {
                if (t==1) {
                    obj[name] = that[name];
                } else {
                    val[i] = that[name + "_" + suf[i]];
                }
            });
        });            
    }
}
zim.extend(zim.Uniforms, zim.Container, null, "zimContainer", false);
//-50.966


// SUBSECTION ZIM SHAPES

/*--
zim.CustomShape = function(x, y, w, h)

CustomShape
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Used internally to make ZIM Shapes - Circle, Rectangle, Triangle, etc.
Holds the following properties in common:
color, colorRange, borderColor, borderWidth, thickness, dashed, dashedOffset, corner
Holds the following functions in common:  (most methods applied through ZIM 4TH methods)
setColorRange, cloneAll(), linearGradient (depreciated), radialGradient (depreciated)

NOTE: this is NOT a generic Shape - see the zim.Shape() class for that.

EXAMPLE
// would recommend just extending a Container() for custom shapes / objects
// unless properties listed above are needed over multiple projects
// but it could be done with matching various private properties, etc.
// also note that a Blob can make just about any shape...
const Smile = function(color) {
	this.super_constructor(-100,-20,200,70);
	this._color = color;
	this.shape = new Shape().addTo(this);
	// this is an example of how ZIM changes shape color
	// will need to go through and do similar things for borderColor, etc.
	this.colorCommand = this.shape.f(this._color).command;
	this.shape.mt(-100,-20).bt(0,70,0,70,100,-20);
}
extend(Smile, CustomShape);

const s = new Smile(red).center();
timeout(1, function () {
	s.color = blue;
	S.update();
});
END EXAMPLE

SEE - ZIM shapes for details.
--*///+50.97

zim.CustomShape = function(x, y, w, h) {
	if (!zim.zimCustomShapeCheck) {z_d("50.97"); zim.zimCustomShapeCheck=true;}

	this.zimContainer_constructor(x, y, w, h, false);

	var that = this;
	this.mouseChildren = false;
	that._dashedOffset = 5;
	
	Object.defineProperty(that, 'color', {
		get: function() {
			return that._color;
		},
		set: function(value) {
			if (zot(value)) value = "black";
			that._color = value;
			if (value && value.type) that.specialColor(that.colorCommand, value, that);
			else that.colorCommand.style = value;
		}
	});
	this.setColorRange = function(color1, color2) {
		if (zot(color2)) {
			that.startColor = that.color;
			that.endColor = color1;
		} else if (zot(color1)) {
			that.startColor = that.color;
			that.endColor = color2;
		} else {
			that.startColor = color1;
			that.endColor = color2;
		}
		return that;
	};
	that._colorRange = 0;
	Object.defineProperty(that, 'colorRange', {
		get: function() {
			return that._colorRange;
		},
		set: function(value) {
			that._colorRange = value;
			if (!zot(that.startColor) && !zot(that.endColor)) {
				that.color = zim.colorRange(that.startColor, that.endColor, value);
			}
		}
	});
	Object.defineProperty(that, 'borderColor', {
		get: function() {
			return that._borderColor;
		},
		set: function(value) {
			that._borderColor = value;
			if (value && !that.borderWidth) {
				that.borderWidth = 1;
			}
			if (!that.borderColorCommand) {
				that.drawShape();
			}
			else if (value && value.type) that.specialColor(that.borderColorCommand, value, that);
			else that.borderColorCommand.style = value;
		}
	});
	Object.defineProperty(that, 'borderWidth', {
		get: function() {
			return that._borderWidth;
		},
		set: function(value) {
			if (!(value>0)) value = 0;
			that._borderWidth = value;			
			if (!that.borderWidthCommand || that._borderWidth == 0) {
				that.borderWidthCommand = null;
				that.drawShape();				
			}
			else {
				that.borderWidthCommand.width = that._borderWidth;
				if (that._dashed) {
					that.borderDashedCommand.segments = that._dashed;
					that.borderDashedCommand.offset = that._dashedOffset;
				}
			}
		}
	});
	Object.defineProperty(that, 'thickness', {
		get: function() {
			return that._thickness;
		},
		set: function(value) {
			if (!(value>0)) value = 0;
			that._thickness = value;
			if (!that.thicknessCommand || that._thickness == 0) that.drawShape();
			else {
				that.thicknessCommand.width = that._thickness;
				if (that._dashed) {
					that.dashedCommand.segments = that._dashed;
					that.dashedCommand.offset = that._dashedOffset;
				}
			}
		}
	});
	Object.defineProperty(that, 'dashed', {
		get: function() {
			return that._dashed;
		},
		set: function(value) {
			that._dashed = value;
			if (value && !Array.isArray(that._dashed)) that.dashed = [10, 10];
			var dashedCommand;
			if (that.type == "Squiggle" || that.type == "Line") {
				if (!that.thicknessCommand || that._thickness == 0) return;
				dashedCommand = that.dashedCommand;
			} else {
				if (!that.borderWidthCommand || that._borderWidth == 0) return;
				dashedCommand = that.borderDashedCommand;
			}
			if (!dashedCommand) {
				that.drawShape();
			} else {
				if (that._dashed) {
					dashedCommand.segments = that._dashed;
					dashedCommand.offset = that._dashedOffset;
				} else {
					dashedCommand.segments = null;
					dashedCommand.offset = null;
				}
			}
		}
	});
	Object.defineProperty(that, 'dashedOffset', {
		get: function() {
			return that._dashedOffset;
		},
		set: function(value) {
			if (isNaN(value)) value = 5;
			that._dashedOffset = value;
			var dashedCommand;
			if (that.type == "Squiggle" || that.type == "Line") {
				if (!that.thicknessCommand || that._thickness == 0) return;
				dashedCommand = that.dashedCommand;
			} else {
				if (!that.borderWidthCommand || that._borderWidth == 0) return;
				dashedCommand = that.borderDashedCommand;
			}

			if (!dashedCommand) {
				that.drawShape();
			} else {
				if (that._dashed) {
					dashedCommand.segments = that._dashed;
					dashedCommand.offset = that._dashedOffset;
				} else {
					dashedCommand.segments = null;
					dashedCommand.offset = null;
				}
			}
		}
	});
	Object.defineProperty(that, 'corner', {
		get: function() {
			return that._corner;
		},
		set: function(value) {
			that._corner = value;
			that.drawShape();
		}
	});

	// depreciated
	this.linearGradient = function(colors,ratios,x0,y0,x1,y1) {
		this.linearGradientParams = Array.prototype.slice.call(arguments);
		this.colorCommand.linearGradient(colors,ratios,x0,y0,x1,y1);
		return this;
	};
	this.radialGradient = function(colors,ratios,x0,y0,radius0,x1,y1,radius1) {
		this.radialGradientParams = Array.prototype.slice.call(arguments);
		this.colorCommand.radialGradient(colors,ratios,x0,y0,radius0,x1,y1,radius1);
		return this;
	};
	
	// special clone that clones contents of shape
	this.cloneAll = function(exact, style, group, inherit) {
		var currentBounds = this.getBounds();
		if (zot(currentBounds)) currentBounds = {x:null, y:null, width:null, height:null};
		var body = this.cloneChildren(this.cloneProps(new zim.Container(currentBounds.x,currentBounds.y,currentBounds.width,currentBounds.height, style, group, inherit)), exact);
		body.mouseChildren = false;
		body.type = this.type;
		return body;
	};

};
zim.extend(zim.CustomShape, zim.Container, null, "zimContainer", false);
//-50.97


/*--
zim.Circle = function(radius, color, borderColor, borderWidth, dashed, percent, percentClose, percentArc, strokeObj, style, group, inherit)

Circle
zim class - extends a zim.CustomShape which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a circle shape inside a container.
The registration and origin will be the center.
NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Circle(50, red).center();

// or with 10 pixel grey stroke
const circle = new Circle(50, red, grey, 10).center();

// change the color of the circle to a radial gradient fill
circle.color = new RadialColor([yellow,green], [0, .7], 0, 0, 20, 0, 0, 50);

// make a half circle - or any percent of a circle
new Circle({radius:200, color:pink, percent:50}).center();
END EXAMPLE

EXAMPLE 
const circle = new Circle({min:10, max:50}, [red, green, blue]).center();
interval(1, ()=>{
	// apply a different values picked from original ZIM VEE values
	zog(circle.veeObj)
	circle.radius = Pick.choose(circle.veeObj.radius); // or zik(circle.veeObj.radius)
	circle.color = Pick.choose(circle.veeObj.color);
	S.update();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
radius - |ZIM VEE| (default 50) the radius (from the center to the edge or half the diameter) ;-)
color - |ZIM VEE| (default black) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
borderColor - |ZIM VEE| (default null) the stroke color
borderWidth - |ZIM VEE| (default 1 if stroke is set) the size of the stroke in pixels
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
percent - (default 100) set to a percentage of a circle (arc) - registration stays at radius center, bounds shrink to arc
percentClose - (default true) set to false to not close the border of a circle with percent set
percentArc - (default false) set to a percent to make moon shapes - must have percent turned on
    the value is the distance the arc-making circle is placed from the original circle's edge
    this distance is given as a percentage of the original circle's radius
    so if percentArc is set to 0 then the arc-making circle is at the radius (the edge) of the original circle
    if the percentArc is set to 50 then the arc-making circle is half the radius outside the original radius and the arc is less
    if the percentArc is set to -50 then the arc-making circle is half the radius inside the original radius and the arc is more
        Note, due to canvas winding, the arc will not do very thin cresents as expected 
        instead once the inner arc is as wide as the outer arc,  it makes a straight line
        for thin crecents, overlap the circle with a circle that matches the background color
        or if the background is an image, etc. then mask a clone of the background with the arc circle
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	// note, not all applicable to a Circle - perhaps just ignoreScale...
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy of the shape
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
	Warning: clone does not clone any content added to a shape - use a Container for that - see cloneAll()
cloneAll(exact, style, group, inherit) - copies shape and any custom content in shape - experimental
	exact (default false) in theory will copy ZIM VEE values as they are in the original
	see main class for style, group, inherit parameters
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
shape - gives access to the circle shape
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	depreciated - see ZIM GradientColor, RadialColor and BitmapColor
borderColor - get and set the stroke color
borderColorCommand - access to the CreateJS stroke command for bitmap, linearGradient and radialGradient strokes
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Stroke.html
borderWidth - get and set the stroke size in pixels
borderWidthCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
radius - gets or sets the radius.
	The radius is independent of scaling and can be different than the width/2
	Setting the radius redraws the circle but any current scaling is kept
percentage - get or set the percent of the circle (see percent parameter) 
	NOTE not percent property which interferes with animate percent
percentClose - get or set the percent close of the circle (see percentClose parameter)
percentArc - get or set the percent arc (see percentArc parameter)
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+51
	zim.Circle = function(radius, color, borderColor, borderWidth, dashed, percent, percentClose, percentArc, strokeObj, style, group, inherit) {
		var sig = "radius, color, borderColor, borderWidth, dashed, percent, percentClose, percentArc, strokeObj, style, group, inherit";
		var duo; if (duo = zob(zim.Circle, arguments, sig, this)) return duo;
		z_d("51");
		this.zimCustomShape_constructor(null,null,null,null,false);
		this.type = "Circle";
		this.group = group;
		// var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		// adjustments for groupOnly - to set style:false and still use group
		var DS = style===false?group!=null?zim.getStyle(null,null,inherit,this.group):{}:zim.getStyle(this.type,this.group,inherit);
		if (zot(radius)) radius = DS.radius!=null?DS.radius:50;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.black);
		if (zot(percent)) percent = DS.percent!=null?DS.percent:100;
		if (zot(percentClose)) percentClose = DS.percentClose!=null?DS.percentClose:true;
		if (zot(percentArc)) percentArc = DS.percentArc!=null?DS.percentArc:null;
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};


		// PICK
		var oa = remember(radius, color, borderColor, borderWidth, percent);
		this.veeObj = {radius:oa[0], color:oa[1], borderColor:oa[2], borderWidth:oa[3], percent:oa[4]};
		function remember() {return arguments;} // for cloning PICK
		radius = zim.Pick.choose(radius);
		color = zim.Pick.choose(color);
		borderColor = zim.Pick.choose(borderColor);
		borderWidth = zim.Pick.choose(borderWidth);
		percent = zim.Pick.choose(percent);

		var that = this;
		that._radius = radius;
		that._color = color;
		that._borderColor = borderColor;
		that._borderWidth = borderWidth;
		that._dashed = dashed;
		if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];

		var circle = this.shape = new createjs.Shape();
		this.addChild(circle);

		var g = circle.graphics;
		that.drawShape = function() {
			g.c();
			that.colorCommand = g.f(that._color).command;
			if (that._color && that._color.type) that.specialColor(that.colorCommand, that._color, that);
			// border of 0 or a string value still draws a border in CreateJS
			if (zot(that._borderWidth) || that._borderWidth > 0) { // no border specified or a border > 0
				if (!zot(that._borderColor) || !zot(that._borderWidth)) { // either a border color or thickness
					if (zot(that._borderColor)) that._borderColor = zim.black;
					that.borderColorCommand = g.s(that._borderColor).command;
					if (that._borderColor && that._borderColor.type) that.specialColor(that.borderColorCommand, that._borderColor, that);
					that.borderWidthCommand = g.ss(that._borderWidth, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
					if (that._dashed) that.borderDashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
				}
			}
			var h = that._radius*2;
			if (typeof percent == "number" && percent >= 0 && percent < 100) {
				var p = 360*percent/100/2;
				g.arc(0, 0, that._radius, (-p-90)*Math.PI/180, (p-90)*Math.PI/180, false);
              
                var dX = Math.sin(p*Math.PI/180)*that._radius;
                var dY = Math.cos(p*Math.PI/180)*that._radius;            
                if (!zot(percentArc)) {
					var r2 = Math.sqrt(Math.pow(dX,2) + Math.pow((that._radius+dY)+percentArc/100*that._radius,2));
					var a1 = Math.asin(dX/r2);
					g.arc(0, that._radius+percentArc/100*that._radius, r2, (-90*RAD+a1), (-90*RAD-a1), true);          
				}      
				if (percentClose) g.cp();
				h = that._radius-dY;
			} else {
				g.dc(0,0,that._radius);
			}
			that.setBounds(-that._radius,-that._radius,that._radius*2,h);
		};
		that.drawShape();
		if (color.type) that.color = color;

		Object.defineProperty(that, 'radius', {
			get: function() {
				return that._radius;
			},
			set: function(value) {
				that._radius = value;
				that.drawShape();
			}
		});
		
		Object.defineProperty(that, 'percentage', {
			get: function() {
				return percent;
			},
			set: function(value) {
				percent = value;
				that.drawShape();
			}
		});
		
		Object.defineProperty(that, 'percentClose', {
			get: function() {
				return percentClose;
			},
			set: function(value) {
				percentClose = value;
				that.drawShape();
			}
		});

        Object.defineProperty(that, 'percentArc', {
			get: function() {
				return percentArc;
			},
			set: function(value) {
				percentArc = value;
				that.drawShape();
			}
		});

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// NOTE: extends ZIM CustomShape for more properties and a few functions.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.clone = function(exact, useStyle) {
			var cloneStyle = zot(useStyle)?style:useStyle;
			if (exact) cloneStyle = false; 
			var newShape = that.cloneProps(new zim.Circle((exact||!zim.isPick(oa[0]))?that.radius:oa[0], (exact||!zim.isPick(oa[1]))?that.color:oa[1], (exact||!zim.isPick(oa[2]))?that.borderColor:oa[2], (exact||!zim.isPick(oa[3]))?that.borderWidth:oa[3], that.dashed, (exact||!zim.isPick(oa[4]))?percent:oa[4], percentClose, percentArc, strokeObj, cloneStyle, this.group, inherit));
			if (that.linearGradientParams) newShape.linearGradient.apply(newShape, that.linearGradientParams);
			if (that.radialGradientParams) newShape.radialGradient.apply(newShape, that.radialGradientParams);
			return newShape;
		};
	};
	zim.extend(zim.Circle, zim.CustomShape, "clone", "zimCustomShape", false);
	//-51

/*--
zim.Rectangle = function(width, height, color, borderColor, borderWidth, corner, dashed, strokeObj, scaleDimensions, style, group, inherit)

Rectangle
zim class - extends a zim.CustomShape which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a rectangle shape inside a container.
The registration and origin will be top left corner.
NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Rectangle(200, 100, blue).center();

// or with rounded corners
new Rectangle({width:200, height:100, color:blue, corner:20}).center();

// or with individual corners 
new Rectangle({width:100, height:100, corner:[50,0,50,0]}).center();

// or with skewed corners 
// this will have a radius of 50 in the horizontal but 20 in the vertical
new Rectangle({width:100, height:100, corner:[50,20]}).center();

// or a combination of corner values and skewed values 
new Rectangle({width:100, height:100, corner:[0, 50, [10,50], [40, 20]}).center();

// or with 2 pixel white stroke
new Rectangle(200, 100, blue, white, 2).center();

// fill the rectangle with a Bitmap fill assuming icon has been loaded - not the image property
new Rectangle(200, 300, new BitmapColor(new Pic("icon.png"))).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - |ZIM VEE| (default the height if provided else 100) the width
height - |ZIM VEE| (default the width if provided else 100) the height
color - |ZIM VEE| (default black) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
borderColor - |ZIM VEE| (default null) the stroke color
borderWidth - |ZIM VEE| (default 1 if stroke is set) the size of the stroke in pixels
corner - (default 0) the round of corner
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
	can also be an array of [horizontal, vertical] which skews each corner
	can also be a combination array of values and skew arrays 
	[topLeft, [horizontal, vertical], bottomRight, [horizontal, vertical]]
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
scaleDimensions - (default true) set to false to redraw the shape rather than scale the shape 
	when using width, height widthOnly, and heightOnly 
	a false setting will keep the corner and the borderWidth the same size 
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy of the shape
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
	Warning: clone does not clone any content added to a shape - use a Container for that - see cloneAll()
cloneAll(exact style, group, inherit) - copies shape and any custom content in shape - experimental
	exact (default false) in theory will copy ZIM VEE values as they are in the original
	see main class for style, group, inherit parameters
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
shape - gives access to the rectangle shape
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	depreciated - see ZIM GradientColor, RadialColor and BitmapColor
borderColor - get and set the stroke color
borderColorCommand - access to the CreateJS stroke command for bitmap, linearGradient and radialGradient strokes
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Stroke.html
borderWidth - get and set the stroke size in pixels
borderWidthCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
corner - get or set the corner or array of corners (see corner parameter)
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true
scaleDimensions - get or set whether the shape scales when width, height, widthOnly or heightOnly are used
	also see the scaleDimensions paramater
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+52
zim.Rectangle = function(width, height, color, borderColor, borderWidth, corner, dashed, strokeObj, scaleDimensions, style, group, inherit) {
    var sig = "width, height, color, borderColor, borderWidth, corner, dashed, strokeObj, scaleDimensions, style, group, inherit";
    var duo; if (duo = zob(zim.Rectangle, arguments, sig, this)) return duo;
    z_d("52");
    this.zimCustomShape_constructor(null,null,null,null,false);
    this.type = "Rectangle";
    this.group = group;

    var DS = style===false?group!=null?zim.getStyle(null,null,inherit,this.group):{}:zim.getStyle(this.type, this.group, inherit);

    if (zot(width)) width = DS.width!=null?DS.width:null;
    if (zot(height)) height = DS.height!=null?DS.height:!zot(width)?width:100;
    if (zot(width)) width = height;
    if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
    if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
    if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
    if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
    if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
    else if (borderColor!=null && borderWidth==null) borderWidth = 1;
    if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.black);
	if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};
    if (zot(scaleDimensions)) scaleDimensions = DS.scaleDimensions!=null?DS.scaleDimensions:true;

    // PICK
    var oa = remember(width, height, color, borderColor, borderWidth);
	this.veeObj = {width:oa[0], height:oa[1], color:oa[2], borderColor:oa[3], borderWidth:oa[4]};
    function remember() {return arguments;} // for cloning PICK
    width = zim.Pick.choose(width);
    height = zim.Pick.choose(height);
    color = zim.Pick.choose(color);
    borderColor = zim.Pick.choose(borderColor);
    borderWidth = zim.Pick.choose(borderWidth);

    var that = this;
    that._color = color;
    that._borderColor = borderColor;
    that._borderWidth = borderWidth;
	that._dashed = dashed;    
    if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];
	that._corner = corner;
	that.scaleDimensions = scaleDimensions;

	that.setWidth = function(w) {width = w;}
	that.setHeight = function(h) {height = h;}

    var rectangle = this.shape = new createjs.Shape();
    this.addChild(rectangle);

    var g = rectangle.graphics;
    that.drawShape = function() {
        g.c();
        that.colorCommand = g.f(that._color).command;
        if (color && color.type) that.specialColor(that.colorCommand, color, that);
        // border of 0 or a string value still draws a border in CreateJS
        if (zot(that._borderWidth) || that._borderWidth > 0) { // no border specified or a border > 0
            if (!zot(that._borderColor) || !zot(that._borderWidth)) { // either a border color or thickness
                if (zot(that._borderColor)) that._borderColor = zim.black;
                that.borderColorCommand = g.s(that._borderColor).command;
                if (that._borderColor && that._borderColor.type) that.specialColor(that.borderColorCommand, that._borderColor, that);
                that.borderWidthCommand = g.ss(that._borderWidth, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
                if (that._dashed) that.borderDashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
            }
        }
			
        if (Array.isArray(that._corner)) {	
			var r = that._corner;	
			if (r.length==2) r = [r,r,r,r];	
			var temp = [];
			var flag = false;
			for (var i=0; i<4; i++) {
                if (zot(r[i])) r[i] = 0;
				if (Array.isArray(r[i])) {
					flag = true;
					temp.push(r[i]);
				} else {
					temp.push([r[i],r[i]]);
				}            
			}
			r = temp;
			if (flag) {				       
				g.mt(0, r[0][1]).curveTo (0,0,r[0][0],0).lt(width-r[1][0],0)
					.curveTo (width,0,width,r[1][1]).lt(width,height-r[2][1])
					.curveTo (width,height,width-r[2][0],height).lt(r[3][0],height)
					.curveTo (0,height,0,height-r[3][1]).cp();
			} else {
				g.rc(0,0,width,height,that._corner[0],that._corner[1],that._corner[2],that._corner[3]);
			}            
        } else if (that._corner > 0) {
            g.rr(0,0,width,height,that._corner);
        } else {
            g.r(0,0,width,height);
        }

        that.setBounds(0,0,width,height);
		if (color.type) that.color = color;
		
    };
	that.drawShape();
	
	// Object.defineProperty(that, 'corner', {
	// 	get: function() {
	// 		return corner;
	// 	},
	// 	set: function(value) {
	// 		corner = value;
	// 		that.drawShape();
	// 	}
	// });

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NOTE: extends ZIM CustomShape for more properties and a few functions.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if (style!==false||group!=null) zim.styleTransforms(this, DS);
    this.clone = function(exact, useStyle) {
		var cloneStyle = zot(useStyle)?style:useStyle;
		if (exact) cloneStyle = false; 
        var newShape =  that.cloneProps(new zim.Rectangle((exact||!zim.isPick(oa[0]))?width:oa[0], (exact||!zim.isPick(oa[1]))?height:oa[1], (exact||!zim.isPick(oa[2]))?that.color:oa[2], (exact||!zim.isPick(oa[3]))?that.borderColor:oa[3], (exact||!zim.isPick(oa[4]))?that.borderWidth:oa[4], corner, that._dashed, strokeObj, that.scaleDimensions, cloneStyle, this.group, inherit));
        return newShape;
    };
};
zim.extend(zim.Rectangle, zim.CustomShape, "clone", "zimCustomShape", false);
//-52

/*--
zim.Triangle = function(a, b, c, color, borderColor, borderWidth, corner, center, adjust, dashed, strokeObj, style, group, inherit)

Triangle
zim class - extends a zim.CustomShape which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a triangle shape inside a container using three line lengths.
Passing one length parameter makes an equilateral triangle.
Passing two length parameters makes an isosceles triangle.
Passing -1 as the middle or last length parameter makes a 90 degree triangle.
NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Triangle(200, null, null, "green").center();

// all three sides specified - tall pointy triangle with yellow stroke of 10 pixels
 new Triangle(100, 200, 200, "green", "yellow", 10).center();

// here we adjust so rotation looks better
const tri = new Triangle({a:200, color:"green", adjust:30})
	.center()
	.animate({obj:{rotation:360}, time:3, ease:"linear", loop:true});

// here we fill the triangle with a linear gradient color
tri.color = new GradientColor([green, blue ,green], [.2, .5, .8], 0, 0, tri.width, 0);
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
a, b and c - |ZIM VEE| (default 100) the lengths of the sides
	a will run horizontally along the bottom
	b is upwards and c is back to the origin
	if b or c is set to -1 will assume a 90 angle
color - |ZIM VEE| (default black) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
borderColor - |ZIM VEE| (default null) the stroke color
borderWidth - |ZIM VEE| (default 1 if stroke is set) the size of the stroke in pixels
corner - (default 0) the round of corner
   can also be an array of [bottomLeft, bottomRight, top]
center - (default true) puts the registration point to the center
adjust - (default 0) pixels to bring center towards vertical base
	the actual center is not really the weighted center
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
	strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
ignoreScale set to true will draw the specified line thickness regardless of object scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
if one color is used, the current color is used and color1 is the second color in the range
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy of the shape
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
	Warning: clone does not clone any content added to a shape - use a Container for that - see cloneAll()
cloneAll(exact style, group, inherit) - copies shape and any custom content in shape - experimental
	exact (default false) in theory will copy ZIM VEE values as they are in the original
	see main class for style, group, inherit parameters
exact (default false) in theory will copy ZIM VEE values as they are in the original
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
shape - gives access to the triangle shape
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	depreciated - see ZIM GradientColor, RadialColor and BitmapColor
borderColor - get and set the stroke color
borderColorCommand - access to the CreateJS stroke command for bitmap, linearGradient and radialGradient strokes
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Stroke.html
borderWidth - get and set the stroke size in pixels
borderWidthCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
corner - get or set the corner or array of corners (see corner parameter)
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
one, two, three - read only - points with x, y properties for bottom left, bottom right, top right
angles - read only - Array of angles [bottom left, bottom right, top right]
adjusted - read only - the value of the adjust parameter or 0 if no adjust was supplied
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53
zim.Triangle = function(a, b, c, color, borderColor, borderWidth, corner, center, adjust, dashed, strokeObj, style, group, inherit) {
    var sig = "a, b, c, color, borderColor, borderWidth, corner, center, adjust, dashed, strokeObj, style, group, inherit";
    var duo; if (duo = zob(zim.Triangle, arguments, sig, this)) return duo;
    z_d("53");
    this.zimCustomShape_constructor(null,null,null,null,false);
    this.type = "Triangle";
    this.group = group;
    var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

    if (zot(a)) a = DS.a!=null?DS.a:100;
    if (zot(b)) b = DS.b!=null?DS.b:a;
    if (zot(c)) c = DS.c!=null?DS.c:a;
    if (b==-1) b = Math.sqrt(Math.pow(a,2)+Math.pow(c,2));
    if (c==-1) c = Math.sqrt(Math.pow(a,2)+Math.pow(b,2));
	if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
    if (zot(center)) center = DS.center!=null?DS.center:true;
    if (zot(adjust)) adjust = DS.adjust!=null?DS.adjust:0;
    if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
    if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
    if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
    else if (borderColor!=null && borderWidth==null) borderWidth = 1;
    if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.black);
    if (zot(adjust)) adjust = DS.adjust!=null?DS.adjust:0;
    if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};

    // PICK
    var oa = remember(a, b, c, color, borderColor, borderWidth);
	this.veeObj = {a:oa[0], b:oa[1], c:oa[2], color:oa[3], borderColor:oa[4], borderWidth:oa[5]};
    function remember() {return arguments;} // for cloning PICK
    a = zim.Pick.choose(a);
    b = zim.Pick.choose(b);
    c = zim.Pick.choose(c);
    this.a = a;
    this.b = b;
    this.c = c;
    color = zim.Pick.choose(color);
    borderColor = zim.Pick.choose(borderColor);
    borderWidth = zim.Pick.choose(borderWidth);

    var that = this;
    that._color = color;
    that._borderColor = borderColor;
    that._borderWidth = borderWidth;
    that._dashed = dashed;
    if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];
	that._corner = corner;


    var lines = [a,b,c];
    lines.sort(function(a, b){return b-a;});
    var aa = lines[0];
    var bb = lines[1];
    var cc = lines[2];
    var order = [lines.indexOf(a), lines.indexOf(b), lines.indexOf(c)];

    if (aa > bb+cc) {
        zogy("zim display - Triangle(): invalid triangle lengths");
        return;
    }

    var tri = this.shape = new createjs.Shape();
    this.adjusted = adjust;
    this.addChild(tri);

    var g = tri.graphics;
    that.drawShape = function() {
		var corners = [];		
		if (Array.isArray(that._corner)) corners = that._corner;
		else corners.push(that._corner, that._corner, that._corner);
		for(var i=0; i<3; i++) {
			if (corners[i] < 0 || typeof corners[i] != "number") corners[i] = 0;
		}
		
        g.c();
        that.colorCommand = g.f(that._color).command;
        if (that._color && that._color.type) that.specialColor(that.colorCommand, that._color, that);
        // border of 0 or a string value still draws a border in CreateJS
        if (zot(that._borderWidth) || that._borderWidth > 0) { // no border specified or a border > 0
            if (!zot(that._borderColor) || !zot(that._borderWidth)) { // either a border color or thickness
                if (zot(that._borderColor)) that._borderColor = zim.black;
                that.borderColorCommand = g.s(that._borderColor).command;
                if (that._borderColor && that._borderColor.type) that.specialColor(that.borderColorCommand, that._borderColor, that);
                that.borderWidthCommand = g.ss(that._borderWidth, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
                if (that._dashed) that.borderDashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
            }
        }
		
		// g.mt(5,100)
		// g.at(100,100, 0,0, 15).at(0,0, 0,100, 5).at(0,100,100,100, 5)
		
        
        that.one={x:0,y:0};        
        that.two={x:a,y:0};

        // find biggest angle with cosine rule
        var angle1 = Math.acos( (Math.pow(bb,2) + Math.pow(cc,2) - Math.pow(aa,2)) / (2 * bb * cc) ) * 180 / Math.PI;

        // use the sine rule for next biggest angle
        var angle2 = Math.asin( bb * Math.sin(angle1 * Math.PI / 180) / aa ) * 180 / Math.PI;

        // find last angle
        var angle3 = 180 - angle1 - angle2;

        // get position of angles by mapping to opposite side sizes
        // as in smallest angle is across from smallest side
        // largest angle is across from largest size, etc.
        var temp = [angle1, angle2, angle3]; // largets to smallest
        that.angles = [temp[order[1]], temp[order[2]], temp[order[0]]];

        var nextAngle = that.angles[1];
        var backX = Math.cos(nextAngle * Math.PI / 180) * b;
        var upY = Math.sin(nextAngle * Math.PI / 180) * b;

        var width = Math.max(a, a-backX);
        var height = upY;
        that.setBounds(0,adjust,width,height);
        tri.y = height;
			
        that.three={x:a-backX,y:0-upY};
				
		var sX = a*corners[0]/((corners[0]+corners[1])||1);
		g
			.mt(sX,0)
			.at(a,0, a-backX,0-upY, corners[1])
			.at(a-backX,0-upY, 0,0, corners[2])
			.at(0,0, a,0, corners[0])
			.lt(sX,0);
			
		g.cp();

        if (center) {
            that.regX = width/2;
            that.regY = height/2;
        }
        if (adjust) {
            that.shape.y+=adjust;
        }
    };
	that.drawShape();
	if (color.type) that.color = color;

    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    // NOTE: extends ZIM CustomShape for more properties and a few functions.
    // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

    if (style!==false) zim.styleTransforms(this, DS);
    this.clone = function(exact, useStyle) {
		var cloneStyle = zot(useStyle)?style:useStyle;
		if (exact) cloneStyle = false; 
        var newShape = that.cloneProps(new zim.Triangle((exact||!zim.isPick(oa[0]))?a:oa[0], (exact||!zim.isPick(oa[1]))?b:oa[1], (exact||!zim.isPick(oa[2]))?c:oa[2], (exact||!zim.isPick(oa[3]))?that.color:oa[3], (exact||!zim.isPick(oa[4]))?that.borderColor:oa[4], (exact||!zim.isPick(oa[5]))?that.borderWidth:oa[5], corner, center, adjust, dashed, strokeObj, cloneStyle, this.group, inherit));
        if (that.linearGradientParams) newShape.linearGradient.apply(newShape, that.linearGradientParams);
        if (that.radialGradientParams) newShape.radialGradient.apply(newShape, that.radialGradientParams);
        return newShape;
    };
};
zim.extend(zim.Triangle, zim.CustomShape, "clone", "zimCustomShape");
//-53

/*--
zim.Poly = function(radius, sides, pointSize, color, borderColor, borderWidth, dashed, strokeObj, style, group, inherit)

Poly
zim class - extends a zim.CustomShape which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a regular polygon with radius like a Circle.
The number of sides can be set as well as a pointSize that will make star-like shapes
The registration and origin will be the center.
NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Poly(200, 5, 0, pink).center(); // pentagon

new Poly(200, 5, .6, pink).center(); // five point star
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
radius - |ZIM VEE| (default 50) the radius (from the center to the edge or half the diameter) ;-)
sides - |ZIM VEE| (default 5) the number of sides
pointSize - |ZIM VEE| (default 0) a factor that will indent or outdent the sides to form stars
	0 is no indent - 1 is a complete indent - which will have no fill and if there is a border will look like a stick figure
	beyond 1 is cool - it overlaps on itself and makes multiple patterns
color - |ZIM VEE| (default black) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
borderColor - |ZIM VEE| (default null) the stroke color
borderWidth - |ZIM VEE| (default 1 if stroke is set) the size of the stroke in pixels
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy of the shape
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
cloneAll(exact style, group, inherit) - copies shape and any custom content in shape - experimental - usually shapes do not have content (use a Container)
	exact (default false) in theory will copy ZIM VEE values as they are in the original
	see main class for style, group, inherit parameters
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
radius - gets or sets the radius.
	The radius is independent of scaling and can be different than the width/2
	Setting the radius redraws the circle but any current scaling is kept
sides - get or set the sides of the shape
pointSize - get or set the point size of the shape (can be animated too)
shape - gives access to the poly shape
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	depreciated - see ZIM GradientColor, RadialColor and BitmapColor
borderColor - get and set the stroke color
borderColorCommand - access to the CreateJS stroke command for bitmap, linearGradient and radialGradient strokes
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Stroke.html
borderWidth - get and set the stroke size in pixels
borderWidthCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53.1
	zim.Poly = function(radius, sides, pointSize, color, borderColor, borderWidth, dashed, strokeObj, style, group, inherit) {
		var sig = "radius, sides, pointSize, color, borderColor, borderWidth, dashed, strokeObj, style, group, inherit";
		var duo; if (duo = zob(zim.Poly, arguments, sig, this)) return duo;
		z_d("53.1");
		this.zimCustomShape_constructor(null,null,null,null,false);

		this.type = "Poly";

		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(radius)) radius = DS.radius!=null?DS.radius:50;
		if (zot(sides)) sides = DS.sides!=null?DS.sides:5;
		if (zot(pointSize)) pointSize = DS.pointSize!=null?DS.pointSize:0;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.black);
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};

		// PICK
		var oa = remember(radius, sides, pointSize, color, borderColor, borderWidth);
		this.veeObj = {radius:oa[0], sides:oa[1], pointSize:oa[2], color:oa[3], borderColor:oa[4], borderWidth:oa[5]};
		function remember() {return arguments;} // for cloning PICK
		radius = zim.Pick.choose(radius);
		sides = zim.Pick.choose(sides);
		pointSize = zim.Pick.choose(pointSize);
		color = zim.Pick.choose(color);
		borderColor = zim.Pick.choose(borderColor);
		borderWidth = zim.Pick.choose(borderWidth);

		var that = this;
		that._radius = radius;
		that._color = color;
		that._sides = sides;
		that._pointSize = pointSize;
		that._borderColor = borderColor;
		that._borderWidth = borderWidth;
		that._dashed = dashed;
		if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];

		var poly = this.shape = new createjs.Shape();
		this.addChild(poly);
		
		var g = poly.graphics;
		that.drawShape = function() {
			g.c();
			that.colorCommand = g.f(that._color).command;
			if (that._color && that._color.type) that.specialColor(that.colorCommand, that._color, that);
			// border of 0 or a string value still draws a border in CreateJS
			if (zot(that._borderWidth) || that._borderWidth > 0) { // no border specified or a border > 0
				if (!zot(that._borderColor) || !zot(that._borderWidth)) { // either a border color or thickness
					if (zot(that._borderColor)) that._borderColor = zim.black;
					that.borderColorCommand = g.s(that._borderColor).command;
					if (that._borderColor && that._borderColor.type) that.specialColor(that.borderColorCommand, that._borderColor, that);
					that.borderWidthCommand = g.ss(that._borderWidth, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
					if (that._dashed) that.borderDashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
				}
			}
			g.dp(0,0,that._radius, that._sides, that._pointSize, -90);
			that.setBounds(-that._radius,-that._radius, that._radius*2, that._radius*2);
		};
		that.drawShape();
		if (color.type) that.color = color;

		Object.defineProperty(that, 'radius', {
			get: function() {
				return that._radius;
			},
			set: function(value) {
				that._radius = value;
				that.drawShape();
			}
		});

		Object.defineProperty(that, 'sides', {
			get: function() {
				return that._sides;
			},
			set: function(value) {
				that._sides = value;
				that.drawShape();
			}
		});

		Object.defineProperty(that, 'pointSize', {
			get: function() {
				return that._pointSize;
			},
			set: function(value) {
				that._pointSize = value;
				that.drawShape();
			}
		});

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// NOTE: extends ZIM CustomShape for more properties and a few functions.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.clone = function(exact, useStyle) {
			var cloneStyle = zot(useStyle)?style:useStyle;
			if (exact) cloneStyle = false; 
			var newShape = that.cloneProps(new zim.Poly((exact||!zim.isPick(oa[0]))?that.radius:oa[0], (exact||!zim.isPick(oa[1]))?that.sides:oa[1], (exact||!zim.isPick(oa[2]))?that.pointSize:oa[2], (exact||!zim.isPick(oa[3]))?that.color:oa[3], (exact||!zim.isPick(oa[4]))?that.borderColor:oa[4], (exact||!zim.isPick(oa[5]))?that.borderWidth:oa[5], that.dashed, strokeObj, cloneStyle, this.group, inherit));
			if (that.linearGradientParams) newShape.linearGradient.apply(newShape, that.linearGradientParams);
			if (that.radialGradientParams) newShape.radialGradient.apply(newShape, that.radialGradientParams);
			return newShape;
		};
	};
	zim.extend(zim.Poly, zim.CustomShape, "clone", "zimCustomShape", false);
	//-53.1

/*--
zim.Line = function(length, thickness, color, startHead, endHead, dashed, strokeObj, lineType, lineOrientation, curveH, curveV, points, startLength, endLength, style, group, inherit)

Line
zim class - extends a zim.CustomShape which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a straight line with a length and thickness.
See also ZIM Squiggle() with points:[[0,0], [100,0], etc. with Bezier handles
See also ZIM Shape() for custom lines, curves, etc.
The registration and origin will be at the start point at the left.
Start point and end point can be adjusted in various ways to accommodate animation, etc.
NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Line(500).center(); // centered line
END EXAMPLE

EXAMPLE
new Line({points:[[0,0],[100,0],[100,100],[200,100]]}).center(); // over, up, over, etc.
// or with quadratic curves:
// 100,0 is control point to x,y of 100,50
new Line({points:[[0,0],[100,0,100,50],[100,100,200,100]]}).center(); // over, up, over
// or with bezier curves:
// 100,0 is first control point, 100,0 is second control point and 100,50 is final point
new Line({points:[[0,0],[100,0,100,0,100,50],[100,100,100,100,200,100]]}).center(); // over, up, over
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
length - |ZIM VEE| (default 100) the length of the line - see also length property and start and end point properties
thickness - |ZIM VEE| (default 3) the size of the stroke in pixels
color - |ZIM VEE| (default black) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
startHead - |ZIM VEE| (default "none") the start head of the line - set to "arrow" (or "triangle") or "circle" or a custom DisplayObject - probably centerReg this
endHead - |ZIM VEE| (default "none") the end head of the line - set to "arrow" (or "triangle") or "circle" or a custom DisplayObject - probably centerReg this
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
lineType - (default "straight") - by default the line is a straight line between points
	set to "corner" to draw only horizontal and vertical lines at 90 degree angles between lines (see lineOrientation)
	set to "curve" to draw horizontal and vertical lines with curves between lines (see lineOrientation)
lineOrientation - (default AUTO) - for lineType other than straight automatically decide between horizontal or vertical
	set to HORIZONTAL to draw two horizontal lines and one vertical line between points
	set to VERTICAL to draw two vertical lines and one horizontal line between points
curveH - (default 100) - for "curve" lineType this is the horizontal distance of the curve
curveV - (default 100) - for "curve" lineType this is the vertical distance of the curve
points - (default null) an Array of points for the line which will ignore length and lineType parameters
	points in the array can have the following formats (a mix is okay too):
	[x,y] points for straight lines.  This format should also be used for first point
	[cpX, cpY, x, y] for quadratic curve to with a single control point followed by the destination point
	[cp1X, cp1Y, cp2X, cp2Y, x, y] for Bezier curve to with start and end control points followed by the destination point
	// see the ZIM Shape docs (or https://www.createjs.com/docs/easeljs/classes/Graphics) for details on the curves
startLength - |VEE| (default null) for lineType corner or curved, the length the line will start.
	should be less than half the line distance (either vertical or horizontal depending on lineOrientation) otherwise ignored
	varying this will avoid overlap when used with Connectors - also see endLength
	for the corner lineType both can be set but usually one would be set
	for the curved lineType the endLength will be chosen over the startLength
endLength - |VEE| (default null) for lineType corner or curved, the length the line will end.
	should be less than half the line distance (either vertical or horizontal depending on lineOrientation) otherwise ignored
	varying this will avoid overlap when used with Connectors - also see startLength
	for the corner lineType both can be set but usually one would be set
	for the curved lineType the endLength will be chosen over the startLength
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setPoints(a, b, c, d) - pass in two ZIM Points or four numbers to set start points and end points or an array of points
	this will not change the x and y of the shape
	also see startPoint, endPoint, startX, startY, endX, endY properties
	if an array is used the points are remade like when made with the points parameter
from(a, b, localToLocal) - pass in a ZIM Point or two numbers to set the start point
	if a DisplayObject is passed in then it will locate the point adjusting for coordinate space (unless localToLocal is false)
to(a, b, localToLocal) - pass in a ZIM Point or two numbers to set the end point
	if a DisplayObject is passed in then it will locate the point adjusting for coordinate space (unless localToLocal is false)
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy of the shape
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
cloneAll(exact style, group, inherit) - copies shape and any custom content in shape - experimental - usually shapes do not have content (use a Container)
	exact (default false) in theory will copy ZIM VEE values as they are in the original
	see main class for style, group, inherit parameters
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
** below will not change the x and y of the shape
** if points is being used: length, startPoint, start and end X and Y, endPoint and angle are ignored - use the point property
length - gets or sets the length of the line - will grow from its registration point
startPoint - (ZIM Point or x,y object) get or set the start point
startX - get or set the start x point - allows for animation
startY - get or set the start y point - allows for animation
endPoint - (ZIM Point or x,y object) get or set the end point
endX - get or set the end x point - allows for animation
endY - get or set the end y point - allows for animation
startHead - get or set the start head - see startHead parameter
endHead - get or set the end head - see endHead parameter
startLength - get or set the start length of the line (see startLength parameter)
endLength - get or set the end length of the line (see endLength parameter)
angle - gets (not sets) the current angle relative to the line (does not include line rotation)
points - get and set the points array (see points parameter) - ignoring all settings above
** above will not change the x and y of the shape
shape - gives access to the line shape
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	depreciated - see ZIM GradientColor, RadialColor and BitmapColor
thickness - get and set the stroke size in pixels
thicknessCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
   See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
lineType - read only access to type of line "straight", "corner", "curve"
lineOrientation - get or set the lineOrientation to AUTO, HORIZONTAL or VERTICAL - see Line params for info
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53.15
	zim.Line = function(length, thickness, color, startHead, endHead, dashed, strokeObj, lineType, lineOrientation, curveH, curveV, points, startLength, endLength, style, group, inherit) {
		var sig = "length, thickness, color, startHead, endHead, dashed, strokeObj, lineType, lineOrientation, curveH, curveV, points, startLength, endLength, style, group, inherit";
		var duo; if (duo = zob(zim.Line, arguments, sig, this)) return duo;
		z_d("53.15");
		this.zimCustomShape_constructor(null,null,null,null,false);
		this.type = "Line";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		if (zot(length)) length = DS.length!=null?DS.length:100;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		if (zot(thickness)) thickness = DS.thickness!=null?DS.thickness:3;
		if (zot(color)) color = DS.color!=null?DS.color:zim.black;
		if (zot(startHead)) startHead = DS.startHead!=null?DS.startHead:null;
		if (zot(endHead)) endHead = DS.endHead!=null?DS.endHead:null;
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};

		if (zot(lineType)) lineType = DS.lineType!=null?DS.lineType:"straight";
		if (lineType !== "corner" && lineType != "curve") lineType = "straight";
		if (zot(lineOrientation)) lineOrientation = DS.lineOrientation!=null?DS.lineOrientation:"auto";
		if (lineOrientation !== "vertical" && lineOrientation != "horizontal") lineOrientation = "auto";

		if (zot(curveH)) curveH = DS.curveH!=null?DS.curveH:20;
		if (zot(curveV)) curveV = DS.curveV!=null?DS.curveV:20;
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};

		if (zot(startLength)) startLength = DS.startLength!=null?DS.startLength:null;
		if (zot(endLength)) endLength = DS.endLength!=null?DS.endLength:null;
	
		// PICK
		var oa = remember(length, color, thickness, startHead, endHead, startLength, endLength);
		this.veeObj = {length:oa[0], color:oa[1], thickness:oa[2], startHead:oa[3], endHead:oa[4], startHead:oa[5], endHead:oa[6]};
		function remember() {return arguments;} // for cloning PICK
		length = zim.Pick.choose(length);
		color = zim.Pick.choose(color);
		thickness = zim.Pick.choose(thickness);
		startHead = zim.Pick.choose(startHead);
		endHead = zim.Pick.choose(endHead);
		// do below otherwise will be the same head and get moved if cloned
		if (startHead && startHead.clone) startHead = startHead.clone();
		if (endHead && endHead.clone) endHead = endHead.clone();
		startLength = zim.Pick.choose(startLength);
		endLength = zim.Pick.choose(endLength);		

		var that = this;
		that._length = length;
		that._color = color;
		that._thickness = thickness;
		that._dashed = dashed;
		if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];

		that._startX = 0;
		that._startY = 0;
		that._endX = length;
		that._endY = 0;
		that._startHead = startHead;
		that._endHead = endHead;
		that._points = points;
		that._lineOrientation = lineOrientation;
		that.angle = 0;
		that.lineType = lineType;

		if (that._startHead) prepareHead("start", that._startHead);
		if (that._endHead) prepareHead("end", that._endHead);
		function prepareHead(type, head) {
			if (head == "triangle" || head == "arrow") {
				var h = that["_"+type+"Head"] = new zim.Triangle(thickness*4, thickness*4, thickness*4, color);
				h.rotation = 90;
			} else if (head == "circle") {
				that["_"+type+"Head"] = new zim.Circle(thickness*2.2, color);
			}
			if (zot(that["_"+type+"Head"].startAngle)) that["_"+type+"Head"].startAngle = that["_"+type+"Head"].rotation;
		}

		startHead = that._startHead;
		endHead = that._endHead;

		if (startHead && startHead.type == "Triangle") startHead.startRegY = startHead.regY;
		if (endHead && endHead.type == "Triangle") endHead.startRegY = endHead.regY;

		var shape = this.shape = new createjs.Shape();
		this.addChild(shape);

		var g = shape.graphics;
		that.drawShape = function(arrowAdjustStart, arrowAdjustEnd) {
			g.c();
			that.colorCommand = g.s(that._color).command;
			if (color && color.type) that.specialColor(that.colorCommand, color, that);
			that.thicknessCommand = g.ss(that._thickness, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
			if (that._dashed) {
				that.dashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
			}
			var startArrowGuide;
			var endArrowGuide;
			if (that._points) {
				var start = that._points[0];
				that._startX = start[0];
				that._startY = start[1];
				var endPoint = that._points[that._points.length-1];
				var end = [endPoint[endPoint.length-2], endPoint[endPoint.length-1]];
				that._endX = end[0];
				that._endY = end[1];
				g.mt(start[0], start[1]);
				for (var i=1; i<that._points.length; i++) {
					var point = that._points[i];
					if (i==1) startArrowGuide = [that._startX, that._startY, point[0], point[1]];
					if (point.length==2) g.lt(point[0], point[1]);
					else if (point.length==4) g.qt(point[0], point[1], point[2], point[3]);
					else if (point.length==6) g.bt(point[0], point[1], point[2], point[3], point[4], point[5]);
				}
				// end arrow will go along last control line or from last point to penultimate point if no control line
				if (point.length >= 4) { // last point in loop
					endArrowGuide = [point[point.length-4], point[point.length-3], that._endX, that._endY];
				} else {
					var penPoint = that._points[that._points.length-2];
					endArrowGuide = [penPoint[penPoint.lenth-2], penPoint[penPoint.lenth-1], that._endX, that._endY];
				}
			} else {

				var sX = that._startX;
				var sY = that._startY;
				var eX = that._endX;
				var eY = that._endY;
				var d;
				
				if (that.lineType == "straight") {
					if (startHead && startHead.type == "Triangle") {
						startHead.regY = 0;
						d = zim.dist(sX,sY,eX,eY);
						if (d != 0) sX = sX + that._startHead.height/2*(eX-sX)/d;
						if (d != 0) sY = sY + that._startHead.height/2*(eY-sY)/d;
					}
					if (endHead && endHead.type == "Triangle") {
						endHead.regY = 0;
						d = zim.dist(sX,sY,eX,eY);
						if (d != 0) eX = eX - that._endHead.height/2*(eX-sX)/d;
						if (d != 0) eY = eY - that._endHead.height/2*(eY-sY)/d;
					}
				} else {
					if (arrowAdjustStart) {
						if (that._lineOrientation == "horizontal" || that.autoOrientation == "horizontal") {
							if (startHead && startHead.type == "Triangle") {
								startHead.regY = 0;
								// if (eX > sX) sX += that._startHead.height/2;
								// else sX -= that._startHead.height/2;
								if (eX > sX) {
									sX = Math.min(eX, sX+that._startHead.height/2);
								} else {
									sX = Math.max(eX, sX-that._startHead.height/2);
								}
							}
						} else {
							if (startHead && startHead.type == "Triangle") {
								startHead.regY = 0;
								// if (eY > sY) sY += that._startHead.height/2;
								// else sY -= that._startHead.height/2;
								if (eY > sY) {
									sY = Math.min(eY, sY+that._startHead.height/2);
								} else {
									sY = Math.max(eY, sY-that._startHead.height/2);
								}
							}
						}
					} else {
						if (startHead && startHead.type == "Triangle") startHead.regY = startHead.startRegY;
					}
					if (arrowAdjustEnd) {
						if (that._lineOrientation == "horizontal" || that.autoOrientation == "horizontal") {
							if (endHead && endHead.type == "Triangle") {
								endHead.regY = 0;
								if (eX > sX) eX -= that._endHead.height/2;
								else eX += that._endHead.height/2;
							}
						} else {
							if (endHead && endHead.type == "Triangle") {
								endHead.regY = 0;
								if (eY > sY) eY -= that._endHead.height/2;
								else eY += that._endHead.height/2;
							}
						}
					} else {
						if (endHead && endHead.type == "Triangle") endHead.regY = endHead.startRegY;
					}
				}

				if (that.lineType == "straight") {
					g.mt(sX, sY).lt(eX, eY);
					startArrowGuide = endArrowGuide = [sX, sY, eX, eY];

				} else if (that.lineType == "corner") {
					var midX = sX + (eX-sX)*.4;
					var midY = sY + (eY-sY)*.4;
					if (that._lineOrientation == "auto") {
						that.autoOrientation = (Math.abs(sX-eX) > Math.abs(sY-eY))?"horizontal":"vertical";
					}
					if (that._lineOrientation == "horizontal" || that.autoOrientation == "horizontal") {
						startArrowGuide = endArrowGuide = [sX, sY, midX, sY];
						// startArrowGuide = endArrowGuide = [that._startX, that._startY, midX, that._startY];					
						var mX1 = midX;
						var mX2;
						if (startLength!=null) {							
							if (midX > sX) {
								if (midX-sX > startLength) mX1 = sX + startLength;
							} else {
								if (sX-midX > startLength) mX1 = sX - startLength;
							}
						} 
						if (endLength!=null) {
							if (eX > midX) {
								if (eX-midX > endLength) mX2 = eX - endLength;
								else mX2 = midX;
							} else {
								if (midX-eX > endLength) mX2 = eX + endLength;
								else mX2 = midX;
							}
							if (startLength==null) mX1 = mX2;
						} else {							
							mX2 = mX1;
						}
						g.mt(sX, sY).lt(mX1, sY).lt(mX2, eY).lt(eX, eY);
					} else {
						startArrowGuide = endArrowGuide = [sX, sY, sX, midY];
						// startArrowGuide = endArrowGuide = [that._startX, that._startY, that._startX, midY];
						var mY1 = midY;
						var mY2;
						if (startLength!=null) {							
							if (midY > sY) {
								if (midY-sY > startLength) mY1 = sY + startLength;
							} else {
								if (sY-midY > startLength) mY1 = sY - startLength;
							}
						} 
						if (endLength!=null) {
							if (eY > midY) {
								if (eY-midY > endLength) mY2 = eY - endLength;
								else mY2 = midY;
							} else {
								if (midY-eY > endLength) mY2 = eY + endLength;
								else mY2 = midY;
							}
							if (startLength==null) mY1 = mY2;
						} else {							
							mY2 = mY1;
						}
						g.mt(sX, sY).lt(sX, mY1).lt(eX, mY2).lt(eX, eY);
					}
				} else { // "curve"

			
					var hSign = (sX > eX)?-1:1;
					var vSign = (sY > eY)?-1:1;

					var nextX = sX; // relative drawing would be handy but not implemented in version yet
					var nextY = sY;
					var distX = Math.abs(sX - eX);
					var distY = Math.abs(sY - eY);
					var curveX = Math.min(curveH, distX*.5); // need proportion curve until hits curveH
					var curveY = Math.min(curveV, distY*.5);

					if (that._lineOrientation == "auto") {
						that.autoOrientation = (Math.abs(sX-eX) > Math.abs(sY-eY))?"horizontal":"vertical";
					}

					if (startLength!=null && endLength!=null) {
						startLength=null;
						if (zon) zogy("ZIM Line() - startLength ignored");
					}

					var insideDistance,outsideDistance,lastX,lastY;
					if (that._lineOrientation == "horizontal" || that.autoOrientation == "horizontal") {

						insideDistance = (distY-curveY*2);
						outsideDistance = (distX-curveX*2)/2;

						var diff = 0;
						if (startLength != null) diff = Math.max(0, distX/2-startLength);
						if (endLength != null) diff = Math.min(0, -(distX/2-endLength));
						
						g.mt(nextX, nextY);
						if (outsideDistance > 0) {
							nextX = nextX+(outsideDistance-diff)*hSign;
							g.lt(nextX, nextY);
						}

						lastY = nextY;
						nextY = nextY+curveY*vSign;
						nextX = nextX+curveX*hSign;
						g.qt(nextX, lastY, nextX, nextY);

						startArrowGuide = endArrowGuide = [sX, sY, nextX, sY];

						if (insideDistance > 0) {
							nextY = nextY+insideDistance*vSign;
							g.lt(nextX, nextY);
						}
						nextY = nextY+curveY*vSign;
						lastX = nextX;
						nextX = nextX+curveX*hSign;
						g.qt(lastX, nextY, nextX, nextY);
						if (outsideDistance > 0) {
							nextX = nextX+(outsideDistance+diff)*hSign;
							g.lt(nextX, nextY);
						}

					} else {

						insideDistance = (distX-curveX*2);
						outsideDistance = (distY-curveY*2)/2;

						var diff = 0;
						if (startLength != null) diff = Math.max(0, distY/2-startLength);
						if (endLength != null) diff = Math.min(0, -(distY/2-endLength));

						g.mt(nextX, nextY);
						if (outsideDistance > 0) {
							nextY = nextY+(outsideDistance-diff)*vSign;
							g.lt(nextX, nextY);
						}

						lastX = nextX;
						nextX = nextX+curveX*hSign;
						nextY = nextY+curveY*vSign;
						g.qt(lastX, nextY, nextX, nextY);

						startArrowGuide = endArrowGuide = [sX, sY, sX, nextY];

						if (insideDistance > 0) {
							nextX = nextX+insideDistance*hSign;
							g.lt(nextX, nextY);
						}
						nextX = nextX+curveX*hSign;
						lastY = nextY;
						nextY = nextY+curveY*vSign;
						g.qt(nextX, lastY, nextX, nextY);
						if (outsideDistance > 0) {
							nextY = nextY+(outsideDistance+diff)*vSign;
							g.lt(nextX, nextY);
						}
					}
				}
			}

			that.setBounds(Math.min(that._startX, that._endX),Math.min(that._startY, that._endY),Math.abs(that._startX-that._endX),Math.abs(that._startY-that._endY));
			that._length = Math.sqrt(Math.pow(that._startX-that._endX,2) + Math.pow(that._startY-that._endY,2));
			that.angle = Math.atan2(that._endY-that._startY, that._endX-that._startX) * 180 / Math.PI;
			if (that._startHead && that._startHead.loc) {
				that._startHead.loc(that._startX, that._startY, that);
				var startAngle = Math.atan2(startArrowGuide[3]-startArrowGuide[1], startArrowGuide[2]-startArrowGuide[0]) * 180 / Math.PI;
				that._startHead.rotation = startAngle-180+that._startHead.startAngle;
			}
			if (that._endHead && that._endHead.loc) {
				that._endHead.loc(that._endX, that._endY, that);
				var endAngle = Math.atan2(endArrowGuide[3]-endArrowGuide[1], endArrowGuide[2]-endArrowGuide[0]) * 180 / Math.PI;
				that._endHead.rotation = endAngle+that._endHead.startAngle;
			}

		};
		that.drawShape();
		if (color.type) that.color = color;

		// ALSO ADJUST ZIM ZIM 02 - to localToLocal
		this.setPoints = function(a, b, c, d, arrowAdjustStart, arrowAdjustEnd) {
			if (Array.isArray(a) && zot(b)) {
				that.points = a;
				return that;
			} else if (a && !zot(a.x)) {
				that._startX = zot(a.x)?that._startX:a.x;
				that._startY = zot(a.y)?that._startY:a.y;
				if (b) {
					that._endX = zot(b.x)?that._endX:b.x;
					that._endY = zot(b.y)?that._endY:b.y;
				}
			} else {
				that._startX = zot(a)?that._startX:a;
				that._startY = zot(b)?that._startY:b;
				that._endX = zot(c)?that._endX:c;
				that._endY = zot(d)?that._endY:d;
			}
			that.drawShape(arrowAdjustStart, arrowAdjustEnd);
			return that;
		};

		this.from = function(a, b, localToLocal) {			
			if (zot(localToLocal)) localToLocal = true;
			var x, y;
			if (a && a.parent && that.parent && localToLocal) {
				var point = a.parent.localToLocal(a.x, a.y, that.parent);
				x = point.x;
				y = point.y;
			} 
			if (a && !zot(a.x)) {
				that._startX = !zot(x)?x:zot(a.x)?that._startX:a.x;
				that._startY = !zot(y)?y:zot(a.y)?that._startY:a.y;
			} else {
				that._startX = zot(a)?that._startX:a;
				that._startY = zot(b)?that._startY:b;
			}
			that.drawShape();
			return that;
		};

		this.to = function(a, b, localToLocal) {
			if (zot(localToLocal)) localToLocal = true;
			var x, y;
			if (a && a.parent && that.parent && localToLocal) {
				var point = a.parent.localToLocal(a.x, a.y, that.parent);
				x = point.x;
				y = point.y;
			} 
			if (a && !zot(a.x)) {
				that._endX = !zot(x)?x:zot(a.x)?that._endX:a.x;
				that._endY = !zot(y)?y:zot(a.y)?that._endY:a.y;
			} else {
				that._endX = zot(a)?that._endX:a;
				that._endY = zot(b)?that._endY:b;
			}
			that.drawShape();
			return that;
		};


		Object.defineProperty(that, 'length', {
			get: function() {
				return that._length;
			},
			set: function(value) {
				var s = that.length!=0 ? value/that.length : 0;
				if (isNaN(s)) return;
				var startScaleX = that.scaleX;
				var startScaleY = that.scaleY;
				that.scaleX *= s;
				that.scaleY *= s;
				var gStart = that.localToGlobal(that._startX, that._startY);
				var gEnd = that.localToGlobal(that._endX, that._endY);
				that.scaleX = startScaleX;
				that.scaleY = startScaleY;
				var lStart = that.globalToLocal(gStart.x, gStart.y);
				var lEnd = that.globalToLocal(gEnd.x, gEnd.y);
				that.setPoints(lStart, lEnd);
			}
		});
		Object.defineProperty(that, 'startPoint', {
			get: function() {
				return new zim.Point(that._startX, that._startY);
			},
			set: function(value) {
				that._startX = zot(value.x)?that._startX:value.x;
				that._startY = zot(value.y)?that._startY:value.y;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'endPoint', {
			get: function() {
				return new zim.Point(that._endX, that._endY);
			},
			set: function(value) {
				that._endX = zot(value.x)?that._endX:value.x;
				that._endY = zot(value.y)?that._endY:value.y;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'startHead', {
			get: function() {
				return that._startHead;
			},
			set: function(value) {
				that._startHead = value;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'endHead', {
			get: function() {
				return that._endHead;
			},
			set: function(value) {
				that._endHead = value;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'startX', {
			get: function() {
				return that._startX;
			},
			set: function(value) {
				that._startX = value||0;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'startY', {
			get: function() {
				return that._startY;
			},
			set: function(value) {
				that._startY = value||0;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'endX', {
			get: function() {
				return that._endX;
			},
			set: function(value) {
				that._endX = value||0;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'endY', {
			get: function() {
				return that._endY;
			},
			set: function(value) {
				that._endY = value||0;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'startLength', {
			get: function() {
				return startLength;
			},
			set: function(value) {
				oa[5] = value;
				startLength = zik(value);
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'endLength', {
			get: function() {
				return endLength;
			},
			set: function(value) {
				oa[6] = value;
				endLength = zik(value);
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'points', {
			get: function() {
				return that._points;
			},
			set: function(value) {
				if (!value) return;
				that._points = value;
				that.drawShape();
			}
		});
		Object.defineProperty(that, 'lineOrientation', {
			get: function() {
				return that._lineOrientation;
			},
			set: function(value) {
				if (!value) return;
				that._lineOrientation = value;
				that.drawShape();
			}
		});

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// NOTE: extends ZIM CustomShape for more properties and a few functions.
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.clone = function(exact, useStyle) {
			var cloneStyle = zot(useStyle)?style:useStyle;
			if (exact) cloneStyle = false; 
			var startH = (exact||!zim.isPick(oa[3]))?that._startHead:oa[3];
			if (startH) {
				if (startH.clone) {
					startH = startH.clone();
					startH.rotation = that._startHead.startAngle;
				}
			}
			var endH = (exact||!zim.isPick(oa[4]))?that._endHead:oa[4];
			if (endH) {
				if (endH.clone) {
					endH = endH.clone();
					endH.rotation = that._endHead.startAngle;
				}
			}
			var newShape = that.cloneProps(new zim.Line((exact||!zim.isPick(oa[0]))?that.length:oa[0], (exact||!zim.isPick(oa[2]))?that.thickness:oa[2], (exact||!zim.isPick(oa[1]))?that.color:oa[1], startH, endH, that.dashed, strokeObj, lineType, that._lineOrientation, curveH, curveV, zim.copy(points), (exact||!zim.isPick(oa[5]))?startLength:oa[5], (exact||!zim.isPick(oa[6]))?endLength:oa[6], cloneStyle, this.group, inherit));
			if (that.points) newShape.setPoints(that.points);
			else newShape.setPoints(that._startX, that._startY, that._endX, that._endY);

			if (that.linearGradientParams) newShape.linearGradient.apply(newShape, that.linearGradientParams);
			if (that.radialGradientParams) newShape.radialGradient.apply(newShape, that.radialGradientParams);
			return newShape;
		};
	};
	zim.extend(zim.Line, zim.CustomShape, "clone", "zimCustomShape", false);
	//-53.15

/*--
zim.Squiggle = function(color, thickness, points, length, controlLength, controlType, lockControlType, showControls, lockControls, handleSize, allowToggle, move, dashed, onTop, circleColor, circleBorderColor, stickColor, stickThickness, selectColor, selectPoints, editPoints, interactive, strokeObj, style, group, inherit)

Squiggle
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a squiggly line with a number of points.
The points have Bezier controls - little handles that change the shape of the line.
The type of control can be specified overall and individually - and can be hidden or shown
The type of control can be changed by double clicking the point - colors of the handles will change
Points can be added by clicking on the line or removed by SHIFT clicking a point.
CTRL Z will undo adding or removing a point
The shape of the line can be recorded with the recordData() method and recreated with the setData() method
The Squiggle is set by default to show and hide controls when clicked
It is also draggable by default when the controls are showing
It can be set to copy with a shift click

SEE: https://www.youtube.com/watch?v=P2hDe5JCINY for Blob and Squiggle Basics
SEE: https://zimjs.com/paths/ to make points for Blob and Squiggle

MULTIPLE SELECT
Multiple points can be selected with the CTRL key held and then dragged
or moved with the keyboard arrows (moves 10 pixels with shift key down)

NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Squiggle().center(); // makes a line with default 4 points with Bezier controls
END EXAMPLE 

EXAMPLE
new Squiggle({points:2, controlType:"none"}).pos(100,100); // makes a diagonal straight line that is editable
END EXAMPLE

EXAMPLE
// Animate along a Squiggle
// see https://zimjs.com/explore/squiggleAnimate.html for more
const path = new Squiggle().center();
new Circle(10, red).addTo().animate({path:path}, 1);
END EXAMPLE

EXAMPLE
// there are so many examples for Blob and Squiggle 
// see https://www.youtube.com/watch?v=P2hDe5JCINY 

// Add a new second smaller part to the Squiggle 
// reverse points from right to left and animate along Squiggle
const s1 = new Squiggle({showControls:false}).center();
const s2 = new Squiggle()
    .transformPoints("scale", .5)
    .transformPoints("x", s1.width);
s.appendPoints(s2.points).reversePoints();
new Circle(10).addTo().animate({path:s1}, 5);
END EXAMPLE 

EXAMPLE 
// split Squiggle and change color of second part
const s1 = new Squiggle().center();
const s2 = s1.splitPoints(2);
s2.color = red;
END EXAMPLE

EXAMPLE 
// split Blob into Squiggles
const b1 = new Blob().center();
const s1 = b1.makeSquiggle(0).loc(b1);
const s2 = s1.splitPoints(2).loc(b1);
s2.color = red;
b1.removeFrom();

// // and put back again
// s1.appendPoints(s2.points, "mirror");
// const b2 = s1.makeBlob().loc(s1);
// b2.color = blue;
// b2.borderColor = null;
// s1.removeFrom();
// s2.removeFrom();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
color - |ZIM VEE| (default green) the line color as any CSS color including "rgba()" for alpha
thickness - (default 2) the thickness of the line in pixels
points - (default 5) a number of points to start with to make the shape
	OR an SVG path like: points:"M0,129.5c22,0,40-31,40-41c0-8-3.2-13-10-13" etc. (also see SVGContainer)
	OR an array of points as follows - https://zimjs.com/paths has a tool to make points in this format
	[[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType], [etc]]
	controlX and controlY - the x and y location of the control Container which holds the point circle and the two control rectangles
	rect1X, rect1Y, rect2X, rect2Y - (default based on controlLength) the x and y location of the control rectangles relative to the control location
	circleX and circleY - (default 0) the x and y location of the circle relative to the control location (usually 0, 0)
	controlType - (default main controlType parameter or "straight" if not controlType parameter) the point's controlType "none", "mirror", "straight" or "free"
	custom points will start with approximateBounds() called 
	but approximateBounds() must be called manually anytime afterwards when new bounds are desired.
length - (default 300) the default length of line used to create the squiggle (also specifies the squiggle's bounds(0, 0, length, thickness))
controlLength - |ZIM VEE| (default radius*numPoints/4) specify a Number to override the calculated default
controlType - (default "straight") one of four String values as follows:
	none - there are no control rectangles (they are actually set at 0,0).  This makes a corner at the circle point.
	mirror - the control rectangles reflect one another about the point circle - lengths are kept even
	straight - the control rectangles keep a straight line through the point circle but length is independent
	free - the control rectangle moves independently from the other control rectangle
	** The controlType can be specified for each point - see the points parameter
	** The controlType can be changed by doubleClicking the point circle to cycle through the controls in the order above - unless the lockControlType is set to true
lockControlType - (default false) set to true to disable doubleClicking of point circles to change controlType
showControls - (default true) set to false to start with controls not showing - can change this after with controlsVisible property or showControls() and hideControls() methods
lockControls - (default false) set to true to lock the editing of controls - can't move the points or handles - but can see them if showControls is set to true
handleSize - (default 20 mobile 10 for non-mobile) the size of control boxes and affects the circles too proportionally
allowToggle - (default true) set false to let turn off clicks showing and hiding controls
move - (default true) set to false to disable dragging when controls are showing
	can also set to "always" to allow movement when controls are not showing
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
onTop - (default true) set to false to not bring shape to top of container when dragging
circleColor - (default light) set the circle color of the controls
circleBorderColor - (default dark) set the circle border color of the controls
stickColor - (default darker) set the stick color of the controls
stickThickness - (default 1) set the stick thickness of the controls
selectColor - (default white) the color of the selected circle or rectangle of the controls if selectPoints is true
selectPoints - (default true) set to false to not allow point controls to be selected for keyboard control
editPoints - (default true) lets user add points by pressing on shape path or remove points by shift click or hold
	set to "anywhere" to let users add points anywhere - will add points with controlType:"none"
	set to false to not allow adding or removing points with shift click or hold
interactive - (default true) set to false to turn off controls, move, toggle, select, edit - leaving just the shape
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
approximateBounds(num, showPoints, margin) - update the bounds based on a Rectangle
	that surrounds the number of points (default 80) distributed around the object path
	set showPoints to true to draw little dots on points
	margin increases (or if negative decreases) the bounds on all sides by the margin
	use outline() after object has been added to the stage to see the bounds
	Squiggles with custom points will start with approximateBounds() called 
	but approximateBounds() must be called manually anytime afterwards when new bounds are desired.
addPoint(percent, controlType) - add a point at a percent (100) of the total curve
	this is handy to make path have the same number of points for animate() path tweens
	controlType can be as specified in main points parameter
	returns index of new point
addPoints(num, controlType, startPoint, spread, dataOnly, points, even) - add num points between existing points
	controlType can be as specified in main points parameter
	specify a startPoint to add points between the startPoint and the next point (one segment of points)
	spread (default false) set to true to spread points evenly around path rather than evenly between segments
	dataOnly and points are used internally
	returns object for chaining
removePoint(index) - remove a point at the specified index
interpolate(num, startPoint, spread, points, even) - get point data {x,y} for existing points and num (default 1) points inbetween
	used with hitTestPath() and animate() drag on path - also add points (note add points does not use even:true)
	specify a startPoint to get points between the startPoint and the next point (one segment of points)
	spread (default false) set to true to spread number of points around path rather equal number between segments
	points (default all points) the points to work with in the same format as the points property
	even (default false) set to true to use zim.Bezier() with even turned on for even percentage distribution
	returns an array of point objects with x, y properties and an r property for ratio of distance along path
recordData(toJSON) - returns an object with x, y, points, color, borderColor, borderWidth, move, toggle, controls PROPERTIES to be used with setData() method
	if toJSON (default false) is set to true, the return value is a JSON string
	the points data comes from the points property
setData(data, fromJSON) - sets the properties to match the data object passed in - this should come from recordData()
	if fromJSON (default false) is set to true, it will assume a JSON string is passed in as data
	the points data is parsed with the set setPoints() so the number of points should be the same
	returns object for chaining
getPoints(popup) - returns an array with the same format as the points parameter - or can just use points property - also recordPoints() for backwards compatibility
	popup - (default false) set to true to open a zim Pane (squiggle.pane) with the points in a zim TextArea (squiggle.textArea) (click off to close)
	NOTE: the TextArea output uses JSON.stringify() - to add the points to the points parameter of the Squiggle use JSON.parse(output);
	NOTE: using zog(JSON.stringify(squiggle.recordData()))... the console will remove the quotes from the controlTypes so those would have to be manually put back in before parse() will work
	also see points property
setPoints(data) - sets the Squiggle points to the data from getPoints
	this does not remake the Squiggle but rather shifts the controls so the number of points should be the same
	also see points property
changeControl(index, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY, update) - change a control type and properties at an index
	accepts ZIM DUO normal parameters or configuration object literal with parameter names as propterties
	passing in null as the index will change all points to the specified properties
	the update parameter defaults to false so set to true to show update or call update() below
	this is so multiple changes can be batched before calling update - for instance when animating blobs.
transformPoints(transformType, amount, x, y, approximateBounds) - scale, rotate, move points without affecting controls or borderWidth - returns object for chaining	
	transformType - String any of: "scale", "scaleX", "scaleY", "rotation", "x", "y"
	amount - the amount to transform
	x, y - (default 0, 0) the x and y position to transform about
	approximateBounds defaults to true - set to false to not call approximateBounds after transforming points
reversePoints() - reverse the order of the points
	this also swaps each rectangle in the Bezier controls 
	also see the Code module for reversePoint(points) function to operate on data points in Squiggle format 	
appendPoints(points, controlType) - add points at end of points - updates Squiggle
	it is assumed that the first point of the new points is in the same place as the last point of the Squiggle 
	by default these will transfer control types but can override with controlType
	this will not have immediate effect but will be triggered when the joining point handle is moved	
prependPoints(points, controlType) - add points at start of points - updates Squiggle
	it is assumed that the last point of the new points is in the same place as the first point of the Squiggle 
	by default these will transfer control types but can override with controlType
	this will not have immediate effect but will be triggered when the joining point handle is moved
splitPoints(index) - breaks the Squiggle into two Squiggles at the index (length / 2)
	the original Squiggle is the first Squiggle 
	returns a reference to the second Squiggle 
makeBlob(controlType, mergeDist) - makes a new Blob from the Squiggle 
	returns the new Blob - the Squiggle remains unchanged so may need to remove it
	controlType (default "free" if not merged and "mirror" if merged) 
		controlType for the joined end points - also see mergeDist below
		this will not change the control sticks until their handles are dragged
	mergeDist (default 5) merges overlapping end points (within this pixel distance) 
update(normalize) - update the Squiggle if animating control points, etc. would do this in a Ticker
	set normalize (default false) to true to use pointsAdjusted for rotated and scaled points
	and if animating along the path after setting rotation or scale on point
	just leave out if only animating points
showControls() - shows the controls (and returns squiggle) also see controlsVisible property
hideControls() - hides the controls (and returns squiggle) also see controlsVisible property
toggle(state - default null) - shows controls if hidden and hides controls if showing (returns the object for chaining)
	or pass in true to show controls or false to hide controls
traverse(obj, start, end, time) - animates obj from start point to end point along path - thanks KV for the thought!
	set start point greater than end point to traverse backwards
	will dispatch a "traversed" event when done
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
getPointAngle(index) - gets the angle made by the tangent at the index provided
getSegmentPoint(point1, point2) - returns an array of [point1, controlPoint1, controlPoint2, point2]
	used internally for animating to path and adding removing Bezier points
getAdjacentSegmentData(index) - returns an array of two arrays:
	The first is an array of cubic Bezier points for segments adjacent and including the provided point index
	each element is in the form of [point1, controlPoint1, controlPoint2, point2]
	The second is an array of starting point indexes for the segments that were tested
	used internally to drag an animation along the path
getCurvePoint(ratio, segmentRatios, segmentPoints, getAngle) gets a point along whole curve at the ratio (0-1) provided
	along with x and y values, the point has a z value that is the index of the squiggle point before the calculated point
	if the getAngle parameter is true (default false) the point also has an angle property which is the angle of the tangent at the point
	ratio is 0-1 with 0 being at the first point and 1 being at the end of the last segment
	segmentRatios and segmentPoints will be calculated if not provided
	used internally for animating along the path - if lockControls is true, only animate will precalculate these values
linearGradient([colors],[ratios], x0,y0, x1,y1) - shortcut to thicknessCommand linearGradient method (see properties below)
radialGradient([colors],[ratios], x0,y0,radius0, x1,y1,radius1) - shortcut to thicknessCommand radialGradient method (see properties below)
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact, commands) - makes a copy of the object
	exact (default false)
		ZIM VEE (Pick) values are active in clones unless exact is set to true
		For instance, if the object's color is [blue, green]
		then its clone might be blue or green - which could be different than the original
		If exact is set to true then the clone will be the color of the original object
	commands (default false) makes clones with current color and borderColor commands of object
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
shape - gives access to the shape of the squiggle
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
circleColor - get or set the circle color of the controls - requires an update() to see changes
circleBorderColor - get or set the circle borderColor of the controls - requires an update() to see changes
stickColor - get or set the stickColor - requires an update() to see changes
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	eg. shape.colorCommand.linearGradient([green, blue ,green], [.2, .5, .8], 0, 0, shape.width, 0)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Fill.html
thickness - get and set the stroke size in pixels
thicknessCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
dashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
num - get the number of points - to set, use the points property
points - get or set the points array of the Squiggle in the same format as the points parameter:
	[[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType], [etc]]
	also see getPoints(popup) and setPoints() methods
pointsAdjusted - get points with any point rotation converted to 0 - see update(true)
pointControls - get an array of controls (a container) - use this to animate controls
pointCircles - get an array of control circles - use this to place some other object at the point
pointObjects - get an array of point objects for each point in the following format:
	[[control, circle, rect1, rect2, controlType], [etc.]]
	control - the container for the control that holds the circle and rectangles (also see pointControls)
	circle - the control point circle (also see pointCircles)
	rect1 - the first control point rectangle
	rect2 - the second control point rectangle
	controlType - the control type: default is "straight" (or null) and there is also "mirror", "free" and "none"
	NOTE: control, circle, rect1, rect2 can be positioned or animated and controlType can be changed
	NOTE: the update() method must be called if manually changing the control positions or type
	NOTE: if constantly animating the controls then use a Ticker.add(function(){squiggle.update();})
	NOTE: also see recordData(), setData(), getPoints(), setPoints() methods for further options
addPointFactor - (default 20) used when placing new points along edge (editPoints is true)
	divides the distance between points by this amount - the smaller the more accurate but also slower
addMinDistance - (default 15) edge press needs to be within this distance to add a point to the edge
segmentPoints - a read-only array of cubic Bezier points for each segment
	each element is in the form of [point1, controlPoint1, controlPoint2, point2]
	used internally to animate to the path and add and remove Bezier points
segmentRatios - a read-only array of cumulative ratio lengths of segments
	for instance the default five points (four segments) is [.25, .5, .75, 1]
	used internally to animate to the path and attribute proportional time to each segment
controls - access to the container that holds the sets of controls
	each control is given a read-only num property
sticks - access to the Shape that has the control sticks
lastSelected - access to the last selected (or created) control container
lastSelectedIndex - the index number of the last selected controls
controlsVisible - get or set the visibility of the controls - or use showControls() and hideControls()
toggled - read-only Boolean property as to whether picker is showing
types - get or set the general array for the types ["mirror", "straight", "free", "none"]
	changing this or removing a type will adjust the order when the user double clicks the points to change their type
	this is not an array of types for each point - see the points property to access the types of each point
lockControls - Boolean to lock controls from being adjusted or not
lockControlType - Boolean to lock the type of the controls in their current state or not
allowToggle - Boolean to get or set clicking to show and hide controls
move - Boolean to drag or not drag Squiggle when controls are showing
	can also set to "always" to allow movement when controls are not showing
onTop - get or set the onTop
selectPoints - get or set whether points can be selected
interactive - get or set whether the shape is interactive - toggle, move, change or add controls, etc.
keyFocus - get or set the keyboard focus on the DisplayObject - see also zim.KEYFOCUS
   will be set to true if this DisplayObject is the first made or DisplayObject is the last to be used with keyboard
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
   for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event for when the bezier controls are adjusted (pressup only)
	if monitoring constant change is needed add a pressmove event to Squiggle.controls
	the change event object has a transformType property with values of "move", "bezierPoint", "bezierHandle", "bezierSwitch"
dispatches "controlsshow" and "controlshide" events when clicked off and on and toggle is true
dispatches an "update" event if the points are changed or a point is added or removed
	this removes all listeners on the old shape and controls
	so any custom listeners on shape and controls will need to be re-applied - use the update event to do so
dispatches a "traversed" event when traverse() is done - the event object has an obj property for the traversing object
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover

MORE
https://zimjs.com/squiggle
https://www.youtube.com/watch?v=BA1bGBU4itI&list=PLCIzupgRt1pYtMlYPtNTKCtztFBeOtyc0
Note the points property has been split into points and pointObjects (and there have been a few property changes) since the time of the video
--*///+53.2

	zim.Squiggle = function(color, thickness, points, length, controlLength, controlType, lockControlType, showControls, lockControls, handleSize, allowToggle, move, dashed, onTop, circleColor, circleBorderColor, stickColor, stickThickness, selectColor, selectPoints, editPoints, interactive, strokeObj, style, group, inherit) {
		var sig = "color, thickness, points, length, controlLength, controlType, lockControlType, showControls, lockControls, handleSize, allowToggle, move, dashed, onTop, circleColor, circleBorderColor, stickColor, stickThickness, selectColor, selectPoints, editPoints, interactive, strokeObj, style, group, inherit";
		var duo; if (duo = zob(zim.Squiggle, arguments, sig, this)) return duo;
		z_d("53.2");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Squiggle", this.group, inherit);

		if (zot(thickness)) thickness = DS.thickness!=null?DS.thickness:6;
		if (zot(length)) length = DS.length!=null?DS.length:300;
		if (zot(points)) points = DS.points!=null?DS.points:5;		
		if (typeof points == "string") {
			var svgProcessor = new zim.SVGContainer();
			points = svgProcessor.processPath(points);
		}
		var approxCheck = typeof points != "number";
		var num = typeof points == "number" ? points : points.length;
		if (num == 0) return;
		if (zot(controlLength)) controlLength = DS.controlLength!=null?DS.controlLength:(length / num);
		this.zimCustomShape_constructor(length, controlLength, null, null, false);
		this.type = "Squiggle";

		this.mouseChildren = true; // set to false in CustomShape

		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		if (zot(color)) color = DS.color!=null?DS.color:zim.blue;
		if (color.style) {this.colorCommand = color; color = zim.black;}

		if (zot(controlType)) controlType = DS.controlType!=null?DS.controlType:null;
		var originalControlType = controlType;
		if (zot(controlType)) controlType = "mirror";
		if (zot(lockControlType)) lockControlType = DS.lockControlType!=null?DS.lockControlType:false;
		if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:true;
		if (zot(showControls)) showControls = DS.showControls!=null?DS.showControls:interactive;
		var _controls = showControls;
		if (zot(lockControls)) lockControls = DS.lockControls!=null?DS.lockControls:!interactive;
		if (zot(handleSize)) handleSize = DS.handleSize!=null?DS.handleSize:zim.mobile()?20:10;
		if (zot(allowToggle)) allowToggle = DS.allowToggle!=null?DS.allowToggle:interactive;
		if (zot(move)) move = DS.move!=null?DS.move:interactive;
		if (zot(circleColor)) circleColor = DS.circleColor!=null?DS.circleColor:zim.light;
		if (zot(circleBorderColor)) circleBorderColor = DS.circleBorderColor!=null?DS.circleBorderColor:zim.dark;
		if (zot(stickColor)) stickColor = DS.stickColor!=null?DS.stickColor:zim.darker;
		if (zot(stickThickness)) stickThickness = DS.stickThickness!=null?DS.stickThickness:1;
		if (zot(selectColor)) selectColor = DS.selectColor!=null?DS.selectColor:zim.white;
		if (zot(selectPoints)) selectPoints = DS.selectPoints!=null?DS.selectPoints:interactive;
		this.circleColor = circleColor;
		this.circleBorderColor = circleBorderColor;
		this.stickColor = stickColor;
		this.stickThickness = stickThickness;

		if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:true;
		if (zot(editPoints)) editPoints = DS.editPoints!=null?DS.editPoints:interactive;
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};

		var oa = remember(color);
		this.veeObj = {color:oa[0]};
		function remember() {return arguments;} // for cloning PICK
		color = zim.Pick.choose(color);

		var that = this;
		var stage;
		this.types = ["mirror", "straight", "free", "none"];
		this.interactive = interactive;
		this.num = num;
		this.onTop = onTop;
		this.move = move;
		this.editPoints = editPoints;
		this.allowToggle = allowToggle;
		this.lockControlType = lockControlType;
		this.selectPoints = selectPoints;
		this.lockControls = lockControls;

		var _points;
		var _pointCircles;
		var _pointControls;
		that._color = color;
		that._thickness = thickness;
		that._dashed = dashed;
		if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];

		var shape;
		var moveDownEvent;
		var movePressEvent;
		var moveUpEvent;

		var draggingCheck = that.move;
		var min = 2; // min distance within which a click will add a point

		var mapMove;
		var sets;

		if (originalControlType && typeof points != "number") {
			// override controlType
			zim.loop(points, function(point) {
				point[8]=originalControlType;
				if (originalControlType == "none") {
					point[4]=point[5]=point[6]=point[7]=0;
				}
			});
		}

		init();
		function init() {
			if (sets) sets.removeAllEventListeners();

			that.num = num = typeof points == "number" ? points : points.length;
			num = Math.max(2,num);
			controlLength = length / num;

			shape = that.shape = new zim.Shape({style:false}).addTo(that);
			var sticks = that.sticks = new zim.Shape({style:false}).addTo(that);
			if (handleSize <= 0) sticks.removeFrom();
			var g = shape.graphics;
			g.c();
			var s = sticks.graphics;
			s.c();

			var ballS = handleSize/10*8;
			var rectS = handleSize;

			if (that.selectPoints) {
				that.selectedBalls = new zim.SelectionSet();
				that.selectedRect1s = new zim.SelectionSet();
				that.selectedRect2s = new zim.SelectionSet();

				that.selectionManager = new zim.SelectionManager([
					that.selectedBalls,
					that.selectedRect1s,
					that.selectedRect2s
				], "ctrl", false);
			} else {
				that.selectionManager = new zim.SelectionManager(null, "ctrl");
			}

			var mobile = zim.mobile();

			sets = that.controls = new zim.Container({style:false}).addTo(that); // sets - a set contains a ball and two rects
			if (that.interactive) sets.drag({onTop:!mobile});
			_points = [];
			_pointControls = [];
			_pointCircles = [];

			var i, point, temp, set, rect1, rect2, ball, type, setInfo;

			for (i=0; i<num; i++) {
				set = new zim.Container({style:false}).addTo(sets);
				set.num = i;
				if (typeof points == "number") { // no sets yet
					var stickLength = zim.Pick.choose(controlLength);
					temp = new zim.Container(stickLength, thickness, null, null, false).addTo(that).loc({x:i*length/(num-1)-stickLength/2, y:i%2*stickLength});
					ball = new zim.Circle(ballS, that.selectPoints&&that.selectedBalls.isSelected(i)?selectColor:that.circleColor, that.circleBorderColor, 2, null, null, null, null, null, false)
						.centerReg(temp)
						.loc({x:stickLength/2, y:0});
					rect1 = new zim.Rectangle(rectS, rectS, that.selectPoints&&that.selectedRect1s.isSelected(i)?selectColor:getBackgroundColor(controlType),  handleSize==0?null:zim.dark,  handleSize==0?null:2, null, null, null, null, false)
						.centerReg(temp)
						.loc({x:0,y:0});
					rect2 = new zim.Rectangle(rectS, rectS, that.selectPoints&&that.selectedRect2s.isSelected(i)?selectColor:getBackgroundColor(controlType),  handleSize==0?null:zim.dark,  handleSize==0?null:2, null, null, null, null, false)
						.centerReg(temp)
						.loc({x:stickLength,y:0});

					var ballPoint = temp.localToLocal(ball.x, ball.y, sets);
					ball.x = ballPoint.x;
					ball.y = ballPoint.y;
					ball.addTo(set, null, false);
					var rect1Point = temp.localToLocal(rect1.x, rect1.y, sets);
					rect1.x = controlType=="none"?0:rect1Point.x-ball.x;
					rect1.y = controlType=="none"?0:rect1Point.y-ball.y;
					rect1.addTo(set, null, false);
					var rect2Point = temp.localToLocal(rect2.x, rect2.y, sets);
					rect2.x = controlType=="none"?0:rect2Point.x-ball.x;
					rect2.y = controlType=="none"?0:rect2Point.y-ball.y;
					rect2.addTo(set, null, false);
					set.x = ball.x;
					set.y = ball.y;
					ball.x = 0;
					ball.y = 0;
					if (controlType=="none") ball.addTo(set, null, false); // on top

				} else { // passing in set data

					// _pointCircles are relative to squiggle but handles are relative to ball
					// points is an array of [[setX, setY, ballX, ballY, handleX, handleY, handle2X, handle2Y, type], etc.]

					setInfo = points[i];
					type = setInfo[8] ? setInfo[8] : controlType;
					set.loc({x:setInfo[0], y:setInfo[1]});
					ball = new zim.Circle(ballS, that.circleColor, that.circleBorderColor, 2, null, null, null, null, null, false)
						.centerReg({add:false})
						.addTo(set)
						.loc({x:setInfo[2],y:setInfo[3]});
					rect1 = new zim.Rectangle(rectS, rectS, getBackgroundColor(type),  handleSize==0?null:zim.dark,  handleSize==0?null:2, null, null, null, null, false)
						.centerReg({add:false})
						.addTo(set, 0)
						.loc({x:setInfo[4],y:setInfo[5]});
					rect2 = new zim.Rectangle(rectS, rectS, getBackgroundColor(type), handleSize==0?null:zim.dark,  handleSize==0?null:2, null, null, null, null, false)
						.centerReg({add:false})
						.addTo(set, 0)
						.loc({x:setInfo[6],y:setInfo[7]});
				}

				ball.mySet = set;
				ball.rect1 = rect1;
				ball.rect2 = rect2;
				ball.index = i;

				if (mobile) {
					ball.on("mousedown", mobileDouble);
				} else {
					ball.on("dblclick", doubleIt);
				}

				rect1.ball = ball;
				rect1.other = rect2;
				rect2.ball = ball;
				rect2.other = rect1;

				if (handleSize==0) {
					ball.expand(10);
					rect1.expand(10);
					rect2.expand(10);
				}

				if (mobile) {
					ball.expand();
					rect1.expand();
					rect2.expand();
				}

				point = [set, ball, rect1, rect2, setInfo?setInfo[8]:controlType];
				_points.push(point);
				_pointCircles.push(ball);
				_pointControls.push(set);
			}

			var tappedTwice = false;
			function mobileDouble(e) {
				if (!tappedTwice) {
					tappedTwice = true;
					setTimeout(function() {
						tappedTwice = false;
					}, 300);
				} else {
					e.preventDefault();
					doubleIt(e);
				}
			}

			function doubleIt(e) {
				if (that.lockControlType) return;
				var ball = e.target;
				// cycle through the types
				var type = _points[ball.index][4] ? _points[ball.index][4] : controlType;
				if (Math.abs(ball.rect1.x) <= 2 && Math.abs(ball.rect1.y) <= 2 && Math.abs(ball.rect2.x) <= 2 && Math.abs(ball.rect2.y) <= 2) {
					type = "none";
				}
				if (type == "none") {
					ball.parent.addChildAt(ball, 0);
				}
				// modulus going backwards needs to add the length so it does not go negative
				type = that.types[(that.types.indexOf(type)+(that.shiftKey?-1:1)+that.types.length)%that.types.length];
				if (type == "none") {
					ball.rect1.x =  ball.rect1.y =  ball.rect2.x =  ball.rect2.y = 0;
					ball.parent.addChild(ball);
					e.stopImmediatePropagation();
				}
				_points[ball.index][4] = type;

				ball.rect1.color = getBackgroundColor(type);
				ball.rect2.color = getBackgroundColor(type);
				that.drawShape();
				if (color.type) that.color = color;
				var ev = new createjs.Event("change");
				ev.controlType = "bezierSwitch";
				that.dispatchEvent(ev);
				ball.stage.update();
			}

			function getBackgroundColor(type) {
				var colors = {straight:"#e472c4", free:"#ebcb35", none:"#50c4b7"};
				return colors[type] ? colors[type] : "#993399";
			}
			var mob = zim.mobile();
			that.drawShape = function () {
				g.c();
				var minThickness = mob ? 10 : 6;
				var i,currentIndex,nextIndex,set,ball;
				var control1,control2,nextSet,ballPoint,nextBall,nextControl1,control1Point,control2Point,nextControl1Point,nextBallPoint;
								
				if (thickness < minThickness) {
					// 1. draw backing grab line
					g.s("rgba(0,0,0,.01)").ss(minThickness);
					set = _points[0][0];
					ballPoint = set.localToLocal(_points[0][1].x, _points[0][1].y, shape);
					g.mt(ballPoint.x, ballPoint.y);

					for (i=0; i<_points.length; i++) {
						currentIndex = i;
						nextIndex = (i+1)%_points.length;

						set = _points[currentIndex][0];
						ball = _points[currentIndex][1];
						control1 = _points[currentIndex][2];
						control2 = _points[currentIndex][3];

						nextSet = _points[nextIndex][0];
						nextBall = _points[nextIndex][1];
						nextControl1 = _points[nextIndex][2];
						// nextControl2 = _points[nextIndex][3];
						// var ctype = _points[currentIndex][4]; // STEFAN
						
						control2Point = set.localToLocal(control2.x, control2.y, shape);
						nextControl1Point = nextSet.localToLocal(nextControl1.x, nextControl1.y, shape);
						nextBallPoint = nextSet.localToLocal(nextBall.x, nextBall.y, shape);

						if (i != _points.length-1) {
							// if (ctype == 'none') { // STEFAN
							// 	g.lt(nextBallPoint.x, nextBallPoint.y);
							// } else {
								g.bt(
									control2Point.x, control2Point.y,
									nextControl1Point.x, nextControl1Point.y,
									nextBallPoint.x, nextBallPoint.y
								);
							// }						
						}
					}
				}

				// 2. draw real line

				if (!that.colorCommand) {
					that.colorCommand = g.s(that._color).command;
					if (color && color.type) that.specialColor(that.colorCommand, color, that);
				}
				if (!that.thicknessCommand) that.thicknessCommand = g.ss(that._thickness, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
				if (that._dashed) {
					if (!that.dashedCommand) that.dashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
				}

				set = _points[0][0];
				ballPoint = set.localToLocal(_points[0][1].x, _points[0][1].y, shape);
				g.mt(ballPoint.x, ballPoint.y);

				s.c().s(that.stickColor).ss(that.stickThickness);
				
				
				for (i=0; i<_points.length; i++) {
					currentIndex = i;
					nextIndex = (i+1)%_points.length;
				
					set = _points[currentIndex][0];
					ball = _points[currentIndex][1];
					control1 = _points[currentIndex][2];
					control2 = _points[currentIndex][3];
					// var ctype = _points[currentIndex][4]; // STEFAN
				
					nextSet = _points[nextIndex][0];
					nextBall = _points[nextIndex][1];
					nextControl1 = _points[nextIndex][2];
					// nextControl2 = _points[nextIndex][3];
				
					control2Point = set.localToLocal(control2.x, control2.y, shape);
					nextControl1Point = nextSet.localToLocal(nextControl1.x, nextControl1.y, shape);
					nextBallPoint = nextSet.localToLocal(nextBall.x, nextBall.y, shape);
				
					if (i != _points.length-1) {
						g.bt(
							control2Point.x, control2Point.y,
							nextControl1Point.x, nextControl1Point.y,
							nextBallPoint.x, nextBallPoint.y
						);
					}
				
					// create the sticks
					ballPoint = set.localToLocal(ball.x, ball.y, shape);
					control1Point = set.localToLocal(control1.x, control1.y, shape);
				
					if (i == 0) control1.visible = 0;
					if (i != 0) s.mt(ballPoint.x, ballPoint.y).lt(control1Point.x, control1Point.y);
					if (i != _points.length-1) s.mt(ballPoint.x, ballPoint.y).lt(control2Point.x, control2Point.y);
					if (i == _points.length-1) control2.visible = 0;
				}
				
				if (that._dashed) g.append(that.dashedCommand);
				g.append(that.thicknessCommand);
				g.append(that.colorCommand);
			};
			that.drawShape();
			if (color.type) that.color = color;

			var startPosition;
			var mDown = false;
			sets.on("mousedown", function(e) {
				stage = e.target.stage;
				if (that.lockControls) return;
				mDown = true;
				sets.loop(function(set) {
					if (set == e.target.parent) return;					
					if (set.lastChildren==null) set.lastChildren = set.mouseChildren;
					if (set.lastMouse==null) set.lastMouse = set.mouseEnabled;
					set.noMouse();
				});
				if (shape.lastMouse==null) shape.lastMouse = shape.mouseEnabled;
				shape.mouseEnabled = false;
				if (that.selectPoints) that.keyFocus = true;
				startPosition = {x:e.target.x, y:e.target.y};
				if (e.target.rect1) { // then mousedown on ball - which has a rect1
					ball = e.target;
					ball.startX = ball.x;
					ball.startY = ball.y;
					ball.rect1.startX = ball.rect1.x;
					ball.rect1.startY = ball.rect1.y;
					ball.rect2.startX = ball.rect2.x;
					ball.rect2.startY = ball.rect2.y;
				} else { // mousedown on control
					var rect = e.target;
					rect.startX = rect.x;
					rect.startY = rect.y;
					ball = rect.ball;
					var index = ball.index;
					var type = controlType;
					if (!zot(_points[index][4])) type = _points[index][4];
					if (type == "straight") {
						var other = rect.other;
						var dX = other.x - ball.x;
						var dY = other.y - ball.y;
						other.stickLength = Math.sqrt(Math.pow(dX,2) + Math.pow(dY,2));
					}
				}
				if (that.selectPoints) {
					// need to reset all start points for each control circle and rectangle moved
					var currentSet = that.selectionManager.currentSet;
					if (currentSet && currentSet.selections && currentSet.selections.length > 0) {
						for(i=0; i<currentSet.selections.length; i++) {
							var point = that.pointObjects[currentSet.selections[i]];
							point[1].startX = point[1].x;
							point[1].startY = point[1].y;
							point[2].startX = point[2].x;
							point[2].startY = point[2].y;
							point[3].startX = point[3].x;
							point[3].startY = point[3].y;
						}
					}
				}
			});

			if (that.selectPoints) {
				sets.tap(function (e) {
					if (e.target.rect1) { // then mousedown on ball - which has a rect1
						var ball = e.target;
						that.selectedBalls.toggle(ball.parent.num);
					} else { // mousedown on control
						var rect = e.target;
						rect.color = "white";
						ball = rect.ball;
						if (ball.rect1 == rect) that.selectedRect1s.toggle(ball.parent.num);
						else that.selectedRect2s.toggle(ball.parent.num);
					}
					// loop through all controls and set to right color based on selection
					for (i=0; i<that.pointObjects.length; i++) {
						var po = that.pointObjects[i];
						po[1].color = that.selectedBalls.isSelected(i)?selectColor:that.circleColor;
						po[2].color = that.selectedRect1s.isSelected(i)?selectColor:getBackgroundColor(po[4]);
						po[3].color = that.selectedRect2s.isSelected(i)?selectColor:getBackgroundColor(po[4]);
					}
					stage.update();
				});
			}

			sets.on("pressmove", function(e) {
				if (that.lockControls) return;
				if (that.selectPoints) {
					var currentSelected = getCurrentSelected();
					if (currentSelected.indexOf(e.target) == -1) {
						mapMove(e.target);
						that.drawShape();
					} else {
						if (currentSelected.length > 0) {
							var diffX = e.target.x-e.target.startX;
							var diffY = e.target.y-e.target.startY;
							for(var i=0; i<currentSelected.length; i++) {
								var pointObj = currentSelected[i];
								pointObj.x = pointObj.startX + diffX;
								pointObj.y = pointObj.startY + diffY;
								mapMove(pointObj);
							}
							that.drawShape();
						}
					}
				} else {
					mapMove(e.target);
					that.drawShape();
				}
			});

			sets.on("pressup", function(e) {
				if (that.lockControls) return;
				mDown = false;
				sets.loop(function(set) {
					if (set == e.target.parent) return;					
					if (set.lastChildren!=null) set.mouseChildren = set.lastChildren;
					if (set.lastMouse!=null) set.mouseEnabled = set.lastMouse;
					set.lastChildren = null;
					set.lastMouse = null;
				});
				if (shape.lastMouse!=null) shape.mouseEnabled = shape.lastMouse;
				shape.lastMouse = null;
				var moveControlCheck = (e.target.x != startPosition.x || e.target.y != startPosition.y);
				var ev = new createjs.Event("change");
				if (e.target.rect1) { // pressup on ball
					ev.controlType = "bezierPoint";
					endMove(e.target);
				} else {
					ev.controlType = "bezierHandle";
				}
				if (moveControlCheck) that.dispatchEvent(ev);
			});

			function endMove(target) {
				if (that.selectPoints) {
					var currentSelected = getCurrentSelected();
					if (currentSelected && currentSelected.indexOf(target) == -1) {
						replaceControls(target);
					} else if (currentSelected && currentSelected.length>0) {
						for(var i=0; i<currentSelected.length; i++) {
							replaceControls(currentSelected[i]);
						}
					} else {
						replaceControls(target);
					}
				} else {
					replaceControls(target);
				}
			}

			that.changeControl = function(index, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY, update) {
				var sig = "index, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY, update";
				var duo; if (duo = zob(that.changeControl, arguments, sig)) return duo;
				if (zot(index)) {
					for (i=0; i<_points.length; i++) {
						that.changeControl(i, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY);
					}
					return;
				}
				var point = _points[index];
				point[4] = type;
				if (type == "none") {
					if (!zot(circleX)) point[2].x = circleX;
					if (!zot(circleY)) point[2].y = circleY;
					point[2].x = point[1].x;
					point[2].y = point[1].y;
					point[3].x = point[1].x;
					point[3].y = point[1].y;
					point[1].parent.addChild(point[1]);
				} else {
					if (!zot(rect1X)) point[2].x = rect1X;
					if (!zot(rect1Y)) point[2].y = rect1Y;
					if (!zot(rect2X)) point[3].x = rect2X;
					if (!zot(rect2Y)) point[3].y = rect2Y;
					if (!zot(circleX)) point[1].x = circleX;
					if (!zot(circleY)) point[1].y = circleY;
					point[1].parent.addChildAt(point[1], 0);
				}
				if (update) {
					that.update();
					if (stage) stage.update();
				}
			};

			that.transformPoints = function(transformType, amount, x, y, approximateBounds) {
				if (zot(approximateBounds)) approximateBounds = true;
				that.points = zim.transformPoints(that.points, transformType, amount, x, y);
				if (approximateBounds) that.approximateBounds();
				return that;
			};

			that.traverse = function(obj, start, end, time, reverse) {		
				
				var ratios = zim.copy(that.segmentRatios);
				ratios.unshift(0);
				if (zot(end)) end = start+1;
				var startPercent = ratios[start]*100;
				var endPercent = ratios[end]*100;
				
				var amount;
				if (!reverse && startPercent > endPercent) amount = 100 - startPercent + endPercent;
				else if (!reverse && startPercent < endPercent) amount = endPercent - startPercent;				
				else if (reverse && startPercent > endPercent) amount = - (startPercent - endPercent);
				else if (reverse && startPercent < endPercent) amount =  - (100 - endPercent + startPercent);

				var eventObj = new createjs.Event("traversed");
				eventObj.obj = obj;			
				
				obj.animate({
					ease:"linear",
					props:{path:that, startPercent:startPercent, percent:amount},
					time:time,
					call:function() {
						that.dispatchEvent(eventObj);
					}
				});

				return that;

				// old

				// var ratios = zim.copy(that.segmentRatios);
				// ratios.unshift(0);
				// if (zot(end)) end = start+1;
				// var forward = start < end;
				// var startPercent, endPercent;
				// if (forward) {
				// 	startPercent = ratios[start]*100;
				// 	endPercent = ratios[end]*100;
				// } else {
				// 	startPercent = 50 + (100 - ratios[start]*100)/2;
				// 	endPercent = 50 + (100 - ratios[end]*100)/2;
				// }

				// obj.percentComplete = obj.zimStartPercent = startPercent+.1;
				// obj.animate({
				// 	ease:"linear",
				// 	props:{path:that},
				// 	rewind:!forward,
				// 	time:time,
				// 	events:true
				// });
				// obj.on("animation", function (e) {
				// 	// when it hits the end it may start over
				// 	if (obj.percentComplete > endPercent || obj.percentComplete == 0) {
				// 		obj.stopAnimate();
				// 		e.remove();
				// 		var eventObj = new createjs.Event("traversed");
				// 		eventObj.obj = obj;
				// 		that.dispatchEvent(eventObj);
				// 	}
				// });
				// return that;
			};
			
			that.reversePoints = function() {			
				points = zim.copy(that.points);
				that.points = zim.reversePoints(zim.copy(that.points));
				that.update();
				return that;
			};
						
			that.appendPoints = function(points, controlType) {
				var current = zim.copy(that.points);
				that.points = zim.appendPoints(current, points, controlType);				
				that.update();
				return that;
			};
			
			that.prependPoints = function(point, controlType) {
				var current = zim.copy(that.points);
				that.points = zim.rependPoints(current, points, controlType);				
				that.update();
				return that;
			};
			
			that.splitPoints = function(index) {
				var current = zim.copy(that.points);
				if (index < 1 || index > current.length-1) return;
				var split = zim.splitPoints(current, index);				
				var first = split[0];
				var second = split[1];
				var s = that.clone();
				that.points = first;
				that.update();
				s.points = second;
				if (that.parent) s.addTo(that.parent);
				return s;
			};
			
			that.makeBlob = function(controlType, mergeDist) {	
				if (zot(controlType)) controlType = "mirror";			
				if (zot(mergeDist)) mergeDist = 5;			
				var points = zim.copy(that.points);				
				zim.loop(points, function (p, i, t) {					
					if (!p[8]) p[8] = "mirror";
					if (i==0) {
						if (controlType == "free") p[4] = p[5] = 0;
						p[8] = controlType;
					}
					if (i==t-1) {
						if (controlType == "free") p[6] = p[7] = 0;
						p[8] = controlType;
					}					
				});
				// check if squiggle is already joined
				if (Math.abs(points[0][0]-points[points.length-1][0]) < mergeDist && Math.abs(points[0][1]-points[points.length-1][1]) < mergeDist) {
					points[0][4] = points[points.length-1][4];
					points[0][5] = points[points.length-1][5];
					points.pop(); // remove last point
				}
				var b = new zim.Blob({
					points:points,
					borderColor:that.color, 
					borderWidth:that.thickness, 
					showControls:that.controlsVisible,
					interactive:that.interactive,
					onTop:that.onTop,
					dashed:that.dashed,
					stickColor:that.stickColor,
					stickThickness:that.stickThickness
				});
				return b;
			};

			that.update = function(normalize) {
				if (normalize) {
					// located any rotated or scaled points
					// and set them back to non-rotated and non-scaled
					// but keep control handles at the earlier positions
					// need to normalize before doing more manual updates with Beziers
					// do not need to normalize if animating blob points
					that.points = that.pointsAdjusted;
				} else {
					that.drawShape();
				}
				that.zimAnimateChanged = true;
				return that;
			};

			// squiggle
			if (that.interactive) {
				if (move) shape.drag({onTop:false});
				moveDownEvent = shape.on("mousedown", function(e) {
					stage = e.target.stage;
					startPosition = {x:shape.x, y:shape.y};
					if (that.selectPoints) that.keyFocus = true;
					upTop();
				});
				movePressEvent = shape.on("pressmove", function() {
					sets.x = shape.x;
					sets.y = shape.y;
					sticks.x = shape.x;
					sticks.y = shape.y;
				});
				moveUpEvent = shape.on("pressup", function() {
					var moveControlCheck = (shape.x != startPosition.x || shape.y != startPosition.y);
					var movePoint = shape.localToLocal(that.regX,that.regY,that.parent);
					that.x = movePoint.x;
					that.y = movePoint.y;
					sets.x = sets.y = sticks.x = sticks.y = shape.x = shape.y = 0;
					if (moveControlCheck) {
						var ev = new createjs.Event("change");
						ev.controlType = "move";
						that.dispatchEvent(ev);
					}
					if (stage) stage.update();
				});

				if (!that.move) stopDragging(true); // true is first time
			}

			function upTop() {
				if (that.onTop) {
					var nc = that.parent.numChildren-1;
					if (that.parent.getChildAt(nc).type == "Keyboard") nc--;
					that.parent.setChildIndex(that, nc);
				}
			}

			that.toggleEvent = that.on("mousedown", function() {
				if (!that.allowToggle) return;
				if (!_controls) {
					that.showControls();
					that.dispatchEvent("controlsshow");
				}
			});
						
			that.added(function() {
				stage = that.stage;
				if (that.toggleStageEvent) stage.off("stagemousedown", that.toggleStageEvent);
				that.toggleStageEvent = stage.on("stagemousedown", function(e) {
					if (mDown || !that.allowToggle || !that.stage) return;
					if (_controls && !that.hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY, false)) {
						that.hideControls();
						that.dispatchEvent("controlshide");
					}
				});			
			});

			that.clickEvent = that.on("click", function() {
				if (that.ctrlKey) {
					setTimeout(function() { // give time for record to work if drag with ctrl down
						that.clone(true).addTo(that.stage).mov(0, 100);
						if (that.allowToggle) {
							that.hideControls();
							that.dispatchEvent("controlshide");
						}
						var ev = new createjs.Event("change");
						ev.controlType = "move";
						that.dispatchEvent(ev);
						that.stage.update();
					}, 50);
				}
			});

			that.hideControls = function() {
				that.toggled = false;
				sets.visible = false;
				sticks.visible = false;
				_controls = false;
				if (that.stage) that.stage.update();
				if (!that.allowToggle && that.move) stopDragging();
				return that;
			};
			if (!showControls) that.hideControls();
			that.showControls = function() {
				that.toggled = true;
				// if call this with code then will not trigger a change event - not good for TransformManager.persist()
				sets.visible = true;
				sticks.visible = true;
				_controls = true;
				sets.x = shape.x;
				sets.y = shape.y;
				sticks.x = shape.x;
				sticks.y = shape.y;
				that.addChildAt(shape,0); // put to bottom incase dragged
				if (that.move && !that.allowToggle) startDragging();
				if (that.stage) that.stage.update();
				return that;
			};

			that.toggle = function(state) {
				if (state===true) that.showControls();
				else if (state===false) that.hideControls();
				else if (_controls) that.hideControls();
				else that.showControls();
				return that;
			};

			that.recordData = function(toJSON) {
				if (zot(toJSON)) toJSON = false;
				var obj = {
					type:"Squiggle",
					index:that.parent?that.parent.getChildIndex(that):-1,
					x:that.x, y:that.y,
					points:that.getPoints(),
					color:that.color,
					thickness:that.thickness,
					move:that.move,
					allowToggle:that.allowToggle,
					controlsVisible:_controls
				};
				if (toJSON) return JSON.stringify(obj);
				return obj;
			};

			that.setData = function(data, fromJSON) {
				if (zot(data)) return;
				if (fromJSON) {
					try {
						data = JSON.parse(data);
					} catch (e) {
						return;
					}
				}
				var index = data.index;
				if (zot(index)) index = -1;
				delete data.index;

				var pointData = data.points;
				if (!zot(pointData)) that.setPoints(pointData);
				delete data.points;
				that.num = pointData.length;

				for (var d in data) {
					that[d] = data[d];
				}
				if (that.parent) {
					that.parent.setChildIndex(that, index);
				}
				that.update();
				return that;
			};

			that.getPoints = function(popup) {
				// balls are relative to blob but handles are relative to ball
				// points is an array of [[ballX, ballY, handleX, handleY, handle2X, handle2Y, type], etc.]
				if (zot(popup)) popup = false;
				var points = that.points;
				if (popup) {
					if (!that.pane) {
						var pane = that.pane = new zim.Pane({
							container:that.stage,
							width:Math.min(500, that.stage.width-20),
							height:Math.min(500, that.stage.height-20),
							draggable:true,
						});
						var textArea = that.textArea = new zim.TextArea(Math.min(400, that.stage.width-70), Math.min(400, that.stage.height-70));
						pane.add(textArea);
					}
					that.textArea.text = JSON.stringify(points);					
					that.pane.show();
				}
				return points;
			};
			that.recordPoints = that.getPoints

			that.setPoints = function(points) {
				// adjust blob to match points passed in from getPoints
				var p;
				var p2;
				for (var i=0; i<points.length; i++) {
					p = _points[i];
					p2 = points[i];
					if (zot(p)) continue;
					p[0].x = p2[0];
					p[0].y = p2[1];
					p[1].x = p2[2];
					p[1].y = p2[3];
					p[2].x = p2[4];
					p[2].y = p2[5];
					p[3].x = p2[6];
					p[3].y = p2[7];
					p[4] = p2[8];
				}
				that.update();
				return that;
			};
			if (style!==false) zim.styleTransforms(that, DS);
			that.clone = function(exact, commands) {
				var tList = [];
				var tCheck = false;
				zim.loop(that.pointControls,function(p){
					if (p.scaleX+p.scaleY+p.regX+p.regY+p.rotation!=2) tCheck = true;
					tList.push([p.scaleX,p.scaleY,p.regX,p.regY,p.rotation]);
				});
				var newShape =  that.cloneProps(new zim.Squiggle(commands?that.colorCommand:((exact||!zim.isPick(oa[0]))?that.color:oa[0]), that.thickness, that.getPoints(), length, controlLength, controlType, lockControlType, sets.visible, lockControls, handleSize, that.allowToggle, that.move, dashed, onTop, that.circleColor, that.circleBorderColor, that.stickColor, that.stickThickness, selectColor, selectPoints, that.editPoints, interactive, strokeObj, style, that.group, inherit));
				if (tCheck) {
					zim.loop(newShape.pointControls,function(p,i){					
						p.scaleX = tList[i][0];
						p.scaleY = tList[i][1];
						p.regX = tList[i][2];
						p.regY = tList[i][3];
						p.rotation = tList[i][4];					
					});
					newShape.update();
				}
				if (that.linearGradientParams) newShape.linearGradient.apply(newShape, that.linearGradientParams);
				if (that.radialGradientParams) newShape.radialGradient.apply(newShape, that.radialGradientParams);
				return newShape;				
			};

			// to add a control - make sure click in one spot - not drag
			that.shape.on("mousedown", function (e) {
				stage = e.target.stage;
				if (!that.editPoints) return;
				if (that.controlsVisible) {
					that.pressX = e.stageX/zim.scaX;
					that.pressY = e.stageY/zim.scaX;
				} else {
					that.pressX = null;
					that.pressY = null;
				}
			});
			that.addPointFactor = 10;
			that.addMinDistance = 15;

			that.shape.on("pressup", function (e) {
				if (!that.editPoints) return;
				if (that.pressX && Math.abs(that.pressX-e.stageX/zim.scaX) < min && Math.abs(that.pressY-e.stageY/zim.scaY) < min) {
					if (that.selectPoints) that.lastPoints = zim.copy(that.points);
					var points = that.points;
					var point = that.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
					var pointBefore = zim.closestPointAlongCurve(point, that.segmentPoints);
					if (that.editPoints == "anywhere") {
						points.splice(pointBefore+1, 0, [point.x, point.y, 0,0, 0,0, 0,0]);
						that.points = points;
						that.changeControl({index:pointBefore+1, type:"mirror", update:true});
					} else { // only on edge
						// test close enough to edge otherwise return
						var p = that.pointsAdjusted;
						var cubic = that.getSegmentPoint(p[pointBefore], p[(pointBefore+1)%p.length]);
						var length = zim.distanceAlongCurve(cubic);
						var testNum = Math.round(length/that.addPointFactor);
						var testPoints = that.interpolate(testNum, pointBefore, false, points);
						// interpolate is setting 2 more points than asked
						var closest=10000;
						var closestIndex;
						zim.loop(testPoints, function (p, k) {
							var d = zim.dist(p, point);
							if (d < closest) {
								closest = d;
								closestIndex = k;
							}
						});
						if (closest < that.addMinDistance) {
							var ratios = that.segmentRatios;
							var currentRatio = ratios[pointBefore];
							var lastRatio = pointBefore>0?ratios[pointBefore-1]:0;
							that.addPoint(100*(lastRatio+(currentRatio-lastRatio)*((closestIndex)/(testNum+1))));
						}
					}
					
					that.lastSelectedIndex = pointBefore+1;
					that.lastSelected = that.controls.getChildAt(that.lastSelectedIndex);
					that.stage.update();
				}
			});

			// remove point
			that.controls.on("click", function (e) {
				that.lastSelected = e.target.parent;
				that.lastSelectedIndex = that.controls.getChildIndex(e.target.parent);
				if (!that.editPoints) return;
				if (that.selectionManager.shiftKey) { // remove
					// if (that.selectionManager.currentSet == that.selectedBalls && that.selectedBalls.selections.length > 0) return;
					removeControl(e);
				}
			});

			function removeControl(e) {
				if (e.target.type == "Circle") {
					var index = that.lastSelectedIndex = that.controls.getChildIndex(e.target.parent);
					if (that.controls.numChildren <= 2) return;
					var points = that.points;
					if (that.selectPoints) that.lastPoints = zim.copy(points);
					points.splice(index, 1); // remove the point at the index
					that.points = points;
					that.stage.update();
					that.lastSelected = that.lastSelectedIndex = null;
				}
			}
			that.controls.hold(removeControl);

			if (!_controls) that.hideControls();
			that.dispatchEvent("update");
		} // end of init()

		// if (that.selectPoints) {
		function getCurrentSelected() {
			var answer = [];
			var currentSet = that.selectionManager.currentSet;
			if (currentSet && currentSet.selections && currentSet.selections.length > 0) {
				for(var i=0; i<currentSet.selections.length; i++) {
					var point = that.pointObjects[currentSet.selections[i]];
					if (currentSet == that.selectedBalls) {
						answer.push(point[1]);
					} else if (currentSet == that.selectedRect1s) {
						answer.push(point[2]);
					}	else if (currentSet == that.selectedRect2s) {
						answer.push(point[3]);
					} else {
						continue;
					}
				}
			}
			return answer;
		}


		function replaceControls(target) {
			// move ball back to origin and move set accordingly
			// so if we animate the set it will behave as expected
			if (target.type != "Circle") return;
			var ball = target;
			var set = ball.mySet;
			var rect1 = ball.rect1;
			var rect2 = ball.rect2;
			rect1.x -= ball.x;
			rect1.y -= ball.y;
			rect2.x -= ball.x;
			rect2.y -= ball.y;
			set.x += ball.x;
			set.y += ball.y;
			ball.x = 0;
			ball.y = 0;
		}

		that.selectionManager.on("keydown", function (e) {
			if (!that.selectPoints) return;
			if (!that.keyFocus) return;
			if (e.keyCode >= 37 && e.keyCode <= 40) {
				var currentSelected = getCurrentSelected();
				if (currentSelected.length > 0) {
					for(var i=0; i<currentSelected.length; i++) {
						var pointObj = currentSelected[i];
						if (e.keyCode == 37) pointObj.x -= that.selectionManager.shiftKey?10:1;
						else if (e.keyCode == 39) pointObj.x += that.selectionManager.shiftKey?10:1;
						else if (e.keyCode == 38) pointObj.y -= that.selectionManager.shiftKey?10:1;
						else if (e.keyCode == 40) pointObj.y += that.selectionManager.shiftKey?10:1;
						mapMove(pointObj);
					}
					that.drawShape();
					that.dispatchEvent("update");
					if (that.stage) that.stage.update();
				}
			}
		});

		that.selectionManager.on("keyup", function (e) {
			if (!that.selectPoints) return;
			if (!that.keyFocus) return;
			if (e.keyCode >= 37 && e.keyCode <= 40) {
				var currentSelected = getCurrentSelected();
				if (currentSelected.length > 0) {
					for(var i=0; i<currentSelected.length; i++) {
						replaceControls(currentSelected[i]);
					}
				}
			}
		});

		that.selectionManager.on("undo", function () {
			if (!that.selectPoints) return;
			if (!that.keyFocus) return;
			if (that.lastPoints) {
				var tempPoints = zim.copy(that.lastPoints);
				that.lastPoints = zim.copy(that.points);
				that.points = tempPoints;
				if (that.stage) that.stage.update();
			}
		});
		// }


		mapMove = function (target) {
			if (that.lockControls) return;
			var ball;
			if (target.rect1) { // pressmove on ball
				ball = target;
				var diffX = ball.x - ball.startX;
				var diffY = ball.y - ball.startY;
				ball.rect1.x = ball.rect1.startX + diffX;
				ball.rect1.y = ball.rect1.startY + diffY;
				ball.rect2.x = ball.rect2.startX + diffX;
				ball.rect2.y = ball.rect2.startY + diffY;
			} else { // pressmove on control
				var rect = target;
				var other = rect.other; // the other handle
				ball = rect.ball;
				var index = ball.index;
				var type = controlType;
				if (!zot(_points[index][4])) type = _points[index][4];
				if (type == "straight" || type == "mirror") {
					var dX = rect.x - ball.x;
					var dY = rect.y - ball.y;
					if (type == "mirror") {
						other.x = ball.x - dX;
						other.y = ball.y - dY;
					} else {
						var a = Math.atan2(dY, dX);
						var dNewX = -other.stickLength * Math.cos(a+Math.PI);
						var dNewY = -other.stickLength * Math.sin(a+Math.PI);
						other.x = ball.x - dNewX;
						other.y = ball.y - dNewY;
					}
				}
			}

			// that.setBounds();
			// decided not to dynamically set bounds
			// they really just go around the control points and not the shape
			// and if dynamically set they go to null if the control points are not showing
		};

		Object.defineProperty(that, 'move', {
			get: function() {
				return move;
			},
			set: function(value) {
				if (move != value) {
					move = value;
					if (value) {
						startDragging();
					} else {
						stopDragging();
					}
				}
			}
		});

		Object.defineProperty(that, 'interactive', {
			get: function() {
				return interactive;
			},
			set: function(value) {
				interactive = value;
				_controls = interactive;
				that.allowToggle = interactive;
				that.editPoints = interactive;
				that.lockControls = !interactive; // note negative!
				that.selectPoints = interactive;
				that.move = interactive;
				var p = that.points; // force remake
				that.points = p;
			}
		});

		Object.defineProperty(that, 'allowToggle', {
			get: function() {
				return allowToggle;
			},
			set: function(value) {
				if (allowToggle != value) {
					allowToggle = value;
					if (allowToggle) {
						if (that.move) startDragging();
					} else {
						if (!_controls && that.move) stopDragging();
					}
				}
			}
		});

		function startDragging() {
			if (that.move=="always") return;
			if (draggingCheck) return;
			draggingCheck = true;
			shape.drag({onTop:false});
			moveDownEvent = shape.on("mousedown", moveDownEvent);
			movePressEvent = shape.on("pressmove", movePressEvent);
			moveUpEvent = shape.on("pressup", moveUpEvent);
		}
		function stopDragging(making) {
			if (that.move=="always") return;
			if (!making && !draggingCheck) return;
			draggingCheck = false;
			shape.noDrag();
			shape.off("mousedown", moveDownEvent);
			shape.off("pressmove", movePressEvent);
			shape.off("pressup", moveUpEvent);
		}

		var _lockControls = lockControls;
		Object.defineProperty(that, 'lockControls', {
			get: function() {
				return _lockControls;
			},
			set: function(value) {
				_lockControls = value;
				if (value) {
					that.controls.mouseChildren = false;
					that.controls.mouseEnabled = false;
				} else {
					that.controls.mouseChildren = true;
					that.controls.mouseEnabled = true;
				}
			}
		});
		that.lockControls = _lockControls;

		Object.defineProperty(that, 'controlsVisible', {
			get: function() {
				return _controls;
			},
			set: function(value) {
				_controls = value;
				if (value) {
					that.showControls();
				} else {
					that.hideControls();
				}
			}
		});


		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (!zim.KEYFOCUS) setFocus();
		function setFocus() {if (!that.selectPoints) return; that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}


		Object.defineProperty(that, 'points', {
			get: function() {
				var points = [];
				var point; var p;				
				for (var i=0; i<_points.length; i++) {
					p = _points[i];
					point = [
						zim.decimals(p[0].x),
						zim.decimals(p[0].y),
						zim.decimals(p[1].x),
						zim.decimals(p[1].y),
						zim.decimals(p[2].x),
						zim.decimals(p[2].y),
						zim.decimals(p[3].x),
						zim.decimals(p[3].y)
					];
					if (p[4] && p[4]!=="mirror") point.push(p[4]);
					points.push(point);
				}
				return points;
			},
			set: function(value) {			
				var x = that.x;
				var y = that.y;
				var v = that.visible;
				
				var tList = [];
				var tCheck = false;
				zim.loop(that.pointControls,function(p){
					if (p.scaleX+p.scaleY+p.regX+p.regY+p.rotation!=2) tCheck = true;
					tList.push([p.scaleX,p.scaleY,p.regX,p.regY,p.rotation]);
				});				
				that.dispose(true);
				points = value;
				// if (that.shape) {
				// 	that.shape.graphics.clear();
				// 	that.sticks.graphics.clear();
				// 	that.controls.noDrag();
				// 	that.removeAllChildren();
				// 	delete that.shape;
				// 	delete that.sticks;
				// 	delete that.controls;
				// }
				init(); // remake Squiggle
				that.lockControls = _lockControls;
				that.x = x;
				that.y = y;
				that.visible = v;
				if (tCheck) {
					zim.loop(that.pointControls,function(p,i){					
						p.scaleX = tList[i][0];
						p.scaleY = tList[i][1];
						p.regX = tList[i][2];
						p.regY = tList[i][3];
						p.rotation = tList[i][4];
					
					});
					that.update();
				}
			}
		});

		Object.defineProperty(that, 'pointsAdjusted', { // points with rotation
			get: function() {
				var points = [];
				var point; var p; var po;
				var pObjects = that.pointObjects;
				zim.loop(pObjects.length, function(i) {
					po = pObjects[i];
					p = _points[i];
					if (po[0].rotation==0 && po[0].scaleX==0 && po[0].scaleY==0) { // get points
						point = [
							zim.decimals(p[0].x),
							zim.decimals(p[0].y),
							zim.decimals(p[1].x),
							zim.decimals(p[1].y),
							zim.decimals(p[2].x),
							zim.decimals(p[2].y),
							zim.decimals(p[3].x),
							zim.decimals(p[3].y)
						];
					} else {
						var lo1 = po[0].localToLocal(po[2].x, po[2].y, po[0].parent);
						var lo2 = po[0].localToLocal(po[3].x, po[3].y, po[0].parent);
						point = [
							zim.decimals(p[0].x),
							zim.decimals(p[0].y),
							zim.decimals(p[1].x),
							zim.decimals(p[1].y),
							zim.decimals(lo1.x-p[0].x),
							zim.decimals(lo1.y-p[0].y),
							zim.decimals(lo2.x-p[0].x),
							zim.decimals(lo2.y-p[0].y)
						];
					}
					if (p[4] && p[4]!=="mirror") point.push(p[4]);
					points.push(point);
				});
				return points;
			},
			set: function () {
				if (zon) zogy("Squiggle() - pointsAdjusted is read only");
			}
		});

		Object.defineProperty(that, 'pointObjects', {
			get: function() {
				return _points;
			},
			set: function () {
				if (zon) { zogy("Squiggle() - pointObjects is read only - but its contents can be manipulated - use squiggle.update() after changes"); }
			}
		});

		Object.defineProperty(that, 'pointControls', {
			get: function() {
				return _pointControls;
			},
			set: function() {
				if (zon) {zogy("Squiggle() - pointControls is read only - but its contents can be manipulated - use blob.update() after changes");}
			}
		});

		Object.defineProperty(that, 'pointCircles', {
			get: function() {
				return _pointCircles;
			},
			set: function() {
				if (zon) {zogy("Squiggle() - pointCircles is read only - but its contents can be manipulated - use blob.update() after changes");}
			}
		});

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// path manipulation and animating to path methods

		Object.defineProperty(that, 'segmentPoints', {
			get: function() {
				var array = []; // array of prepared segment points
				var p = that.pointsAdjusted;
				zim.loop(p.length-1, function(i) {
					var s = that.getSegmentPoint(p[i], p[i+1]);
					array.push(s);
				});
				return array;
			},
			set: function() {
				if (zon) {zogy("Squiggle() - segmentPoints is read only");}
			}
		});

		Object.defineProperty(that, 'segmentRatios', {
			get: function() {
				var distances = [];
				var total = 0;
				zim.loop(that.segmentPoints, function(points) {
					var d = zim.distanceAlongCurve(points);
					distances.push(d);
					total += d;
				});
				var percents = [];
				var totalPercents = 0;
				zim.loop(distances, function (d) {
					var p = d/total;
					totalPercents += p;
					percents.push(totalPercents);
				});
				return percents;
			},
			set: function() {
				if (zon) {zogy("Squiggle() - segmentRatios is read only");}
			}
		});

		that.approximateBounds = function(num, showPoints, margin) {
			if (zot(num)) num = 80;
			if (zot(margin)) margin = 0;
			num /= that.num;
			var points = that.interpolate(num, null, true, null, true);
			var bounds = zim.boundsAroundPoints(points);
			that.setBounds(bounds.x-margin, bounds.y-margin, bounds.width+margin*2, bounds.height+margin*2);
			if (showPoints) {
				if (!that.parent) {
					if (zon) zogy("approximateBounds() - add to stage to first to see points");
					return that;
				}
				if (!that.hitPathPoints) that.hitPathPoints = new zim.Container().addTo();
				else that.hitPathPoints.removeAllChildren();
				that.hitPathPoints.top();
				for (var i=0; i<points.length; i++) {
					var point = points[i];
					point = that.localToGlobal(point.x, point.y);
					new zim.Circle(3).loc(point.x, point.y, that.hitPathPoints);
				}
			}
			return that;
		};

		that.getPointAngle = function(index) {
			var p = that.pointObjects[index][0]; // parent
			var r1 = that.pointObjects[index][2];
			var r2 = that.pointObjects[index][3];
			var globalR1, globalR2;
			if (p==that.stage) {
				globalR1 = new zim.Point(r1.x, r1.y);
				globalR2 = new zim.Point(r2.x, r2.y);
			} else {
				globalR1 = p.localToGlobal(r1.x, r1.y);
				globalR2 = p.localToGlobal(r2.x, r2.y);
			}
			return zim.angle(globalR1.x, globalR1.y,globalR2.x, globalR2.y);
		};

		that.getSegmentPoint = function(point1, point2) {
			if (zot(point1) || zot(point2)) return;
			// dragging points temporarily puts data out of order
			if (point1[2] != 0 || point1[3] != 0) {
				point1[4] -= point1[2];
				point1[5] -= point1[3];
				point1[6] -= point1[2];
				point1[7] -= point1[3];
				point1[0] += point1[2];
				point1[1] += point1[3];
				point1[2] = 0;
				point1[3] = 0;
			}
			if (point2[2] != 0 || point2[3] != 0) {
				point2[4] -= point2[2];
				point2[5] -= point2[3];
				point2[6] -= point2[2];
				point2[7] -= point2[3];
				point2[0] += point2[2];
				point2[1] += point2[3];
				point2[2] = 0;
				point2[3] = 0;
			}
			var p1 = {x:point1[0], y:point1[1]};
			var p2 = {x:point1[0]+point1[6], y:point1[1]+point1[7]};
			var p3 = {x:point2[0]+point2[4], y:point2[1]+point2[5]};
			var p4 = {x:point2[0], y:point2[1]};
			if (sets.x != 0 || sets.y !=0) {
				p1.x+=sets.x;
				p2.x+=sets.x;
				p3.x+=sets.x;
				p4.x+=sets.x;
				p1.y+=sets.y;
				p2.y+=sets.y;
				p3.y+=sets.y;
				p4.y+=sets.y;
			}
			return [p1,p2,p3,p4];
		};

		that.getAdjacentSegmentData = function(index) {
			if (zot(index)) index = 0;
			var p = that.pointsAdjusted;
			if (that.num == 2) {
				return [
					[that.getSegmentPoint(p[0], p[1])],
					[0]
				];
			}
			if (index == 0) {
				return [
					[that.getSegmentPoint(p[0], p[1]),
					that.getSegmentPoint(p[1], p[2])],
					[0,1]
				];
			} else if (index >= that.num-2) {
				return [
					[that.getSegmentPoint(p[that.num-3], p[that.num-2]),
					that.getSegmentPoint(p[that.num-2], p[that.num-1])],
					[that.num-3, that.num-2]
				];
			} else {
				return [
					[that.getSegmentPoint(p[index-1], p[index]),
					that.getSegmentPoint(p[index], p[index+1]),
					that.getSegmentPoint(p[index+1], p[index+2])],
					[index-1,index,index+1]
				];
			}
		};

		that.getCurvePoint = function(ratio, segmentRatios, segmentPoints, getAngle, even) {

			if (zot(ratio) || isNaN(ratio)) ratio = 0;
			if (zot(segmentRatios)) segmentRatios = that.segmentRatios;
			if (zot(segmentPoints)) segmentPoints = that.segmentPoints;
			if (zot(getAngle)) getAngle = false;
			if (zot(even)) even = false;
			var percents = segmentRatios;
			var segments = segmentPoints;
			var afterIndex = zim.loop(percents, function (p, i) {
				if (p >= ratio) return i;
			});
			var earlierPercent = afterIndex > 0 ? percents[afterIndex-1] : 0;
			var localTotal = afterIndex > 0 ? (percents[afterIndex]-percents[afterIndex-1]):percents[afterIndex];
			if (!localTotal) return undefined;
			var localPercent = (ratio-earlierPercent)/localTotal;
			var finalPoint = zim.pointAlongCurve(segments[afterIndex], localPercent, getAngle, true);
			var finalFinalPoint = that.localToGlobal(finalPoint.x, finalPoint.y);
			finalFinalPoint.angle = finalPoint.angle;
			finalFinalPoint.z = afterIndex;
			return !zot(finalFinalPoint) ? finalFinalPoint : undefined;
		};

		function proportion(p1, p2, ratio) {
			return {
				x:p1.x + (p2.x-p1.x)*ratio,
				y:p1.y + (p2.y-p1.y)*ratio
			};
		}
		function insertPointData(points, controls, ratios, percent, controlType, skipPoint, dataOnly, even) {
			var index = points.length-1; // adjust for squiggle
			var lastRatio = 0;
			var currentRatio = 0;
			if (percent == 100 && that.type == "Squiggle") percent = 99.99;
			percent = (percent+100000)%100;
			zim.loop(ratios, function (ratio, i) {
				if (percent/100 < ratio) {
					index = i;
					currentRatio = ratio;
					return true;
				}
				lastRatio = ratio;
			});
			var segment = that.segmentPoints[index];
			var r = currentRatio > 0?(percent/100-lastRatio)/(currentRatio-lastRatio):0;
			var point = zim.pointAlongCurve(segment, r, null, even);
			var newPoint = [point.x,point.y, 0, 0];
			if (skipPoint) return;
			if (dataOnly) {
				that.interpolatedPoints.push({x:point.x, y:point.y, r:percent/100});
				return;
			}
			if (controlType != "none") {
				// calculate new handles and adjust old handles
				// [controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType]
				var startHandle = proportion(segment[0], segment[1], r);
				var midPoint = proportion(segment[1], segment[2], r);
				var endHandle = proportion(segment[2], segment[3], r);
				var newStartHandle = proportion(startHandle, midPoint, r);
				var newEndHandle = proportion(midPoint, endHandle, r);
				newPoint[4] = newStartHandle.x-point.x;
				newPoint[5] = newStartHandle.y-point.y;
				newPoint[6] = newEndHandle.x-point.x;
				newPoint[7] = newEndHandle.y-point.y;
				var start = that.localToLocal(startHandle.x, startHandle.y, controls[index]);
				points[index][6] = start.x;
				points[index][7] = start.y;
				var end = that.localToLocal(endHandle.x, endHandle.y, controls[(index+1)%points.length]);
				points[(index+1)%points.length][4] = end.x;
				points[(index+1)%points.length][5] = end.y;
			}
			if (controlType) newPoint[8] = controlType;
			// else newPoint[8] = "straight";
			// points[index][8] = "straight"
			// points[index+1][8] = "straight"
			points.splice(index+1, 0, newPoint);
			return index+1;
		}

		this.addPoint = function(percent, controlType) {
			if (zot(percent)) percent = 100;
			var points = that.points;
			var ratios = that.segmentRatios;
			var controls = that.pointControls;
			controlType = controlType ? controlType : originalControlType;
			var index = insertPointData(points, controls, ratios, percent, controlType);
			that.points = points;
			that.num = points.length;
			return index;
		};

		this.removePoint = function(index) {	
			if (zot(index) || index < 0) return;		
			var currentPoints = zim.copy(that.points);
			currentPoints.splice(index, 1);
			that.points = currentPoints;
			if (that.stage) that.stage.update();
			return that;
		}

		this.addPoints = function(num, controlType, startPoint, spread, dataOnly, points, even) {
			if (zot(points)) points = zim.copy(that.points);
			var ratios = zim.copy(that.segmentRatios);
			var lastRatio = 0;

			if (dataOnly) that.interpolatedPoints = [];

			// dataOnly should add points to current point too
			// but can't just use current point because sometimes that is static
			// like when dragging the shape or a point - it does not register until mouseup
			// and things like hitTestPath need that to be dynamic
			// So the below does not work:
			// if (dataOnly) {
			// 	that.interpolatedPoints = [];
			// 	zim.loop(points, function (point, i) {
			// 		if (!zot(startPoint) && i!=startPoint) return;
			// 		that.interpolatedPoints.push({x:point[0], y:point[1]})
			// 	});
			// }
			if (spread) var totalPoints = ratios.length*num;
			zim.loop(ratios, function (ratio, j) {
				if (dataOnly) insertPointData(points, that.pointControls, that.segmentRatios, lastRatio*100, controlType, !zot(startPoint) && j!=startPoint, dataOnly, even);
				var numCount = spread?Math.round(totalPoints*(ratio-lastRatio)):num;
				var div = 1/(numCount+1);
				zim.loop(numCount, function(i) {
					var r = lastRatio + (ratio-lastRatio)*div*(i+1);
					insertPointData(points, that.pointControls, that.segmentRatios, r*100, controlType, !zot(startPoint) && j!=startPoint, dataOnly, even);
					if (!dataOnly && num > 0) that.points = points;
				});
				lastRatio = ratio;
			});
			if (dataOnly && that.type == "Squiggle") {
				// changed to skipPoint false in zim 10.7.0 - not sure why it was true...
				insertPointData(points, that.pointControls, that.segmentRatios, 100, controlType, false, dataOnly, even);
			}
			if (that.stage) that.stage.update();
			that.num = points.length;
			return that;
		};
		this.interpolate = function(num, startPoint, spread, points, even) {
			if (zot(num)) num = 1;
			// dataOnly will add Point to start point too
			that.addPoints(num, "none", startPoint, spread, true, points, even);
			return that.interpolatedPoints;
		};
		if (approxCheck) that.approximateBounds();

		this.dispose = function(temp, b, disposing) {
			if (!that.shape) return;
			zim.gD(that); // globalDispose function for common elements			
			if (stage && that.toggleStageEvent) stage.off("stagemousedown", that.toggleStageEvent);
			that.controls.noDrag();	// sets	
			that.controls.removeAllEventListeners();
			if (that.selectPoints && that.selectionManager) that.selectionManager.dispose();
			that.selectedBalls = null;
			that.selectedRect1s = null;
			that.selectedRect2s = null;
			that.selectionManager = null;		
			that.off("mousedown", that.toggleEvent);
			that.off("click", that.clickEvent);
				
			if (temp) {
				that.shape.dispose();				
				that.shape = null;				
				for (var i=0; i<that.points.length; i++) {
					that.pointObjects[i][0].removeAllEventListeners();
					that.pointObjects[i][1].removeAllEventListeners();
					that.pointObjects[i][2].removeAllEventListeners();
					that.pointObjects[i][3].removeAllEventListeners();
				}
				that.controls.removeFrom(that);
				that.sticks.dispose();
				_points = null;
				_pointCircles = null;
			} else {
				that.removeAllEventListeners();	
				_points = null;
				_pointCircles = null;		
				if (!disposing) this.zimCustomShape_dispose(true);				
			}
			return true;
		};
	};
	zim.extend(zim.Squiggle, zim.CustomShape, ["clone", "dispose"], "zimCustomShape", false);
	//-53.2


/*--
zim.Blob = function(color, borderColor, borderWidth, points, radius, controlLength, controlType, lockControlType, showControls, lockControls, handleSize, allowToggle, move, dashed, onTop, circleColor, circleBorderColor, stickColor, stickThickness, selectColor, selectPoints, editPoints, interactive, strokeObj, style, group, inherit)

Blob
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a blob shape inside a container using a number of points.
The points have Bezier controls - little handles that change the shape of the Blob.
The type of control can be specified overall and individually - and can be hidden or shown
The type of control can be changed by double clicking the point - colors of the handles will change
Points can be added by clicking on the shape or removed by SHIFT clicking a point.
CTRL Z will undo adding or removing a point
The shape of the Blob can be recorded with the recordData() method and recreated with the setData() method
The Blob is set by default to show and hide controls when clicked
It is also draggable by default when the controls are showing

SEE https://zimjs.com/paths for a tool to make Blob and Squiggle shapes
SEE https://www.youtube.com/watch?v=P2hDe5JCINY for Basics Video

MULTIPLE SELECT
Multiple points can be selected with the CTRL key held and then dragged
or moved with the keyboard arrows (moves 10 pixels with shift key down)

NOTE: mouseChildren is turned to false for all zim Shape containers.
NOTE: with the ZIM namespace zns = false, this overwrites a JS Blob - so the JS Blob is stored as document.Blob

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Blob().center(); // makes a circle with default 4 points with Bezier controls
END EXAMPLE

EXAMPLE
new Blob({
	points:12, // 12 points for more complex shape
}).center();
END EXAMPLE

EXAMPLE
new Blob({
	color:purple,
	controlType:"free", // free will be default control type (rather than "straight")
	points:[
		// the control position x, y
		// then three point positions inside the control - so relative to the control position
		// 1. circle position x, y (usually the same as the control position - so 0,0)
		// 2. the location of the first control rectangle x and y
		// 3. the location of the second control rectangle x and y
		// then an optional specific type of control that overrides the controlType parameter (or the default type of "straight")
		[-100,-100,-100,100,100,-100,0,0,"mirror"], // this will be type "mirror"
		[100,-100,100,0,-50,0], // this will be type "free" because controlType parameter
		[100,100], // these will be type "none" because no dimensions (or dimensions 0) specified for controls
		[-100,100]
	]
}).centerReg();
END EXAMPLE

EXAMPLE
// Transform the original points of a Blob
// If you rotate or scale, this affects the control points - the little rectangles rotate or they scale
// To avoid this, the points themselves can be transformed (scaleX, scaleY, scale, rotation, x, y)
// This makes a square and scales it bigger without affecting control size or stroke size (if there were a stroke)
// Note the default number of points is 4 but they are arranged at the top, bottom and sides - so would make a diamond with just controlType:"none"
new Blob({controlType:"none"}).transformPoints("rotation", 45).transformPoints("scale", 2).center();
END EXAMPLE

EXAMPLE
// make a Blob the shape of basic ZIM shapes
// this overrides the path parameter
new Blob({points:"circle"}).pos(200,200);
new Blob({points:new Rectangle(100,200)}).center();
new Blob({points:new Triangle()}).transformPoints("rotation", 90).pos(50,50,true,true);
END EXAMPLE

EXAMPLE
// Animate along a Blob
// see https://zimjs.com/nio/ examples
// see https://zimjs.com/explore/blobAnimate.html for more
// see https://zimjs.com/explore/blobAnimate2.html for more
const path = new Blob().center();
new Circle(10, red).addTo().animate({path:path}, 1);
END EXAMPLE

EXAMPLE
// Animate one Blob into another
const targetBlob = new Blob({points:"rectangle"});
const blob = new Blob({radius:50, points:"circle", interactive:false})
	.pos(200,200)
	.transformPoints("rotation", -45) // to better tween to rectangle
	.animate({
		props:{shape:targetBlob},
		time:1,
		rewind:true,
		loop:true
	});
END EXAMPLE

EXAMPLE 
// split Blob into Squiggles
const b1 = new Blob().center();
const s1 = b1.makeSquiggle(0).loc(b1);
const s2 = s1.splitPoints(2).loc(b1);
s2.color = red;
b1.removeFrom();

// // and put back again
// s1.appendPoints(s2.points, "mirror");
// var b2 = s1.makeBlob().loc(s1);
// b2.color = blue;
// b2.borderColor = null;
// s1.removeFrom();
// s2.removeFrom();
END EXAMPLE

EXAMPLE 
// Split a blob into two blobs
const blobs = new Blob().center().splitBlob(1,3);
blobs[0].color = blue;

// or with points - cuts diagonally across blob
const blobs = new Blob().center().splitBlob(new Point(0,0), new Point(W,H));
blobs[0].color = blue;
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
color - |ZIM VEE| (default green) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
borderColor - |ZIM VEE| (default null) the stroke color
borderWidth - (default 1 if stroke is set) the size of the stroke in pixels
num - get the number of points - to set, use the points property
points - (default 4) a number of points to start with to make the shape
	OR a shape string of "circle", "rectangle" or "triangle"
	OR a ZIM Circle, Rectangle, Triangle or Flare with any dimensions that will be matched
	OR an SVG path like: points:"M0,129.5c22,0,40-31,40-41c0-8-3.2-13-10-13" etc. (also see SVGContainer)
	OR an array of points as follows - see https://zimjs.com/paths for a tool to make points in this format:
	[[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType], [etc]]
	controlX and controlY - the x and y location of the control Container which holds the point circle and the two control rectangles
	circleX and circleY - (default 0) the x and y location of the circle relative to the control location (usually 0, 0)
	rect1X, rect1Y, rect2X, rect2Y - (default based on controlLength) the x and y location of the control rectangles relative to the control location
	controlType - (default main controlType parameter or "straight" if not controlType parameter) the point's controlType "none", "mirror", "straight" or "free"
	custom points will start with approximateBounds() called 
	but approximateBounds() must be called manually anytime afterwards when new bounds are desired.
radius - (default 100) the default radius of the circle used to create the blob (also specifies the blob's bounds(-radius, -radius, radius*2, radius*2))
controlLength - |ZIM VEE| (default radius*numPoints/4) specify a Number to override the calculated default
controlType - (default "straight") one of four String values as follows:
	none - there are no control rectangles (they are actually set at 0,0).  This makes a corner at the circle point.
	mirror - the control rectangles reflect one another about the point circle - lengths are kept even
	straight - the control rectangles keep a straight line through the point circle but length is independent
	free - the control rectangle moves independently from the other control rectangle
	** The controlType can be specified for each point - see the points parameter
	** The controlType can be changed by doubleClicking the point circle to cycle through the controls in the order above - unless the lockControlType is set to true
lockControlType - (default false) set to true to disable doubleClicking of point circles to change controlType
showControls - (default true) set to false to start with controls not showing - can change this after with control property or showControls() method
lockControls - (default false) set to true to lock the editing of controls - can't move the points or handles - but can see them if showControls is set to true
handleSize - (default 20 mobile 10 for non-mobile) the size of control boxes and affects the circles too proportionally
	If a handleSize of 0 is chosen, then the sticks will disappear too
allowToggle - (default true) set false to let turn off clicks showing and hiding controls
move - (default true) set to false to disable dragging when controls are showing
	can also set to "always" to allow movement when controls are not showing
dashed - (default false) set to true for dashed border (if borderWidth or borderColor set)
	or set to an array of line size then space size, etc.
	eg. [20, 10] is 20 line and 10 space repeated and [20,100,50,10] is 20 line, 100 space, 50 line, 10 space, etc.
onTop - (default true) set to false to not bring shape to top of container when dragging
circleColor - (default light) set the circle color of the controls
circleBorderColor - (default dark) set the circle border color of the controls
stickColor - (default darker) set the stick color of the controls
stickThickness - (default 1) set the stick thickness of the controls
selectColor - (default white) the color of the selected circle or rectangle of the controls if selectPoints is true
selectPoints - (default true) set to false to not allow point controls to be selected for keyboard control
editPoints - (default true) lets user add points by pressing on shape path.
	set to "anywhere" to let users add points anywhere - will add points with controlType:"none"
	set to false to not allow adding or removing points with click or shift click
interactive - (default true) set to false to turn off controls, move, toggle, select, edit - leaving just the shape
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:10, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
approximateBounds(num, showPoints) - update the bounds based on a Rectangle
	that surrounds the number of points (default 80) distributed around the object path
	set showPoints to true to draw little dots on points
	use outline() after object has been added to the stage to see the bounds
	Blobs with custom points will start with approximateBounds() called 
	but approximateBounds() must be called manually anytime afterwards when new bounds are desired.
addPoint(percent, controlType) - add a point at a percent (100) of the total curve
	this is handy to make path have the same number of points for animate() path tweens
	controlType can be as specified in main points parameter
	returns index of new point
addPoints(num, controlType, startPoint, spread, dataOnly, points, even) - add num points between existing points
	controlType can be as specified in main points parameter
	specify a startPoint to add points between the startPoint and the next point (one segment of points)
	spread (default false) set to true to spread points evenly around path rather than evenly between segments
	dataOnly and points are used internally
	returns object for chaining
removePoint(index) - remove the point at the specified index
interpolate(num, startPoint, spread, points, even) - get point data {x,y} for existing points and num (default 1) points inbetween
	used with hitTestPath() and animate() drag on path - also add points (note add points does not use even:true)
	specify a startPoint to get points between the startPoint and the next point (one segment of points)
	spread (default false) set to true to spread number of points around path rather equal number between segments
	points (default all points) the points to work with in the same format as the points property
	even (default false) set to true to use zim.Bezier() with even turned on for even percentage distribution
	returns an array of point objects with x, y properties and an r property for ratio of distance along path
recordData(toJSON) - returns an object with x, y, points, color, borderColor, borderWidth, move, toggle, controls PROPERTIES to be used with setData() method
	if toJSON (default false) is set to true, the return value is a JSON string
	the points data comes from the points property
setData(data, fromJSON) - sets the properties to match the data object passed in - this should come from recordData()
	if fromJSON (default false) is set to true, it will assume a JSON string is passed in as data
	the points data is parsed with the set setPoints() so the number of points should be the same
	returns object for chaining
getPoints(popup) - returns an array with the same format as the points parameter - or can just use points property - also recordPoints() for backwards compatibility
	popup - (default false) set to true to open a zim Pane (blob.pane) with the points in a zim TextArea (blob.textArea) (click off to close)
	NOTE: the TextArea output uses JSON.stringify() - to add the points to the points parameter of the Blob use JSON.parse(output);
	NOTE: using zog(JSON.stringify(blob.recordData()))... the console will remove the quotes from the controlTypes so those would have to be manually put back in before parse() will work
	also see points property
setPoints(data) - sets the Blob points to the data from getPoints()
	this does not remake the Blob but rather shifts the controls so the number of points should be the same
	also see points property
changeControl(index, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY, update) - change a control type and properties at an index
	accepts ZIM DUO normal parameters or configuration object literal with parameter names as propterties
	passing in null as the index will change all points to the specified properties
	the update parameter defaults to false so set to true to show update or call update() below
	this is so multiple changes can be batched before calling update - for instance when animating blobs.
transformPoints(transformType, amount, x, y, approximateBounds) - scale, rotate, move points without affecting controls or borderWidth - returns object for chaining
	transformType - String any of: "scale", "scaleX", "scaleY", "rotation", "x", "y"
	amount - the amount to transform
	x, y - (default 0, 0) the x and y position to transform about
	approximateBounds defaults to true - set to false to not call approximateBounds after transforming points
reversePoints(sameStart) - reverse the order of the points
	sameStart defaults to true and will keep the start point the same 
	set to false to make the last point before the start point, the start point
	This also swaps each rectangle in the Bezier controls 
	also see the Code module for reversePoint(points) function to operate on data points in Squiggle format
	Note: reversing blob points with the reversePoints function will make the starting point the last point
makeSquiggle(index) - create a new Squiggle by cutting blob at index (default 0)
	returns the new Squiggle - the blob remains unchanged - so may need to remove it
splitBlob(a, b, num, clean) - split a Blob into two blobs - returns an array with each blob 
	this uses makeSquiggle() then splitPoints() to split squiggle then makeBlob() to make two blobs
	a - (default 0) an index of the blob - or an object with an x and y property (read globally) 
		note - if using x, y points, these points do not have to be on the Blob - and they are global
	b - (default Math.ceil(num points / 2)) an index of the blob - or an object with an x and y property (read globally) 
	num - (default 50) if points are used, this is how many points to add along the line between points to estimate cut point 
	clean - (default true) remove original blob - set to false to not remove
update(normalize) - update the Blob if animating control points, etc. would do this in a Ticker
	set normalize (default false) to true to use pointsAdjusted for rotated and scaled points
	use true for manually editing points after setting rotation or scale on point
	just leave out if only animating points
showControls() - shows the controls (and returns blob) - or use  blob.controlsVisible = true property
hideControls() - hides the controls (and returns blob) - or use blob.controlsVisible = false property
toggle(state - default null) - shows controls if hidden and hides controls if showing (returns the object for chaining)
	or pass in true to show controls or false to hide controls
traverse(obj, start, end, time) - animates obj from start point to end point along path - thanks KV for the thought!
	set start point greater than end point to traverse backwards
	will dispatch a "traversed" event when done
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
getPointAngle(index) - gets the angle made by the tangent at the index provided
getSegmentPoint(point1, point2) - returns an array of [point1, controlPoint1, controlPoint2, point2]
	used internally for animating to path and adding removing Bezier points
getAdjacentSegmentData(index) - returns an array of two arrays:
	The first is an array of cubic Bezier points for segments adjacent and including the provided point index
	each element is in the form of [point1, controlPoint1, controlPoint2, point2]
	The second is an array of starting point indexes for the segments that were tested
	used internally to drag an animation along the path
	will wrap around the blob if needed
getCurvePoint(ratio, segmentRatios, segmentPoints, getAngle) gets a point along whole curve at the ratio (0-1) provided
	along with x and y values, the point has a z value that is the index of the blob point before the calculated point
	if the getAngle parameter is true (default false) the point also has an angle property which is the angle of the tangent at the point
	ratio is 0-1 with 0 being at the first point and 1 being at the end of the last segment (the first point)
	segmentRatios and segmentPoints will be calculated if not provided
	used internally for animating along the path - if lockControls is true, only animate will precalculate these values
linearGradient([colors],[ratios], x0,y0, x1,y1) - shortcut to colorCommand linearGradient method (see properties below)
radialGradient([colors],[ratios], x0,y0,radius0, x1,y1,radius1) - shortcut to colorCommand radialGradient method (see properties below)
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact, commands) - makes a copy of the object
	exact (default false)
		ZIM VEE (Pick) values are active in clones unless exact is set to true
		For instance, if the object's color is [blue, green]
		then its clone might be blue or green - which could be different than the original
		If exact is set to true then the clone will be the color of the original object
	commands (default false) makes clones with current color commands of object
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
shape - gives access to the shape of the blob
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
colorCommand - access to the CreateJS fill command for bitmap, linearGradient and radialGradient fills
	eg. shape.colorCommand.linearGradient([green, blue ,green], [.2, .5, .8], 0, 0, shape.width, 0)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Fill.html
borderColor - get and set the stroke color
borderColorCommand - access to the CreateJS stroke command for bitmap, linearGradient and radialGradient strokes
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.Stroke.html
borderWidth - get and set the stroke size in pixels
borderWidthCommand - access to the CreateJS stroke style command (width, caps, joints, miter, ignoreScale)
	See: https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeStyle.html
dashed - get and set the dashed - use true / false or an array (see dashed parameter)
dashedOffset - get and set the offset of the dash (50 default) - can animate this property for a marquee effect
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
circleColor - get or set the circle color of the controls - requires an update() to see changes
circleBorderColor - get or set the circle borderColor of the controls - requires an update() to see changes
stickColor - get or set the stick color of the controls - requires an update() to see changes
points - get or set the points array of the Blob in the same format as the points parameter:
	a number, a shape string ("circle", "rectangle", "triangle"), a ZIM Circle, Rectangle, Triangle
	or an array as follows:
	[[controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType], [etc]]
	see also getPoints(popup) and setPoints() methods
pointsAdjusted - get points with any point rotation converted to 0 - see update(true)
pointControls - get an array of controls (a container) - use this to animate controls
pointCircles - get an array of control circles - use this to place some other object at the point
pointObjects - get an array of point objects for each point in the following format:
	[[control, circle, rect1, rect2, controlType], [etc.]]
	control - the container for the control that holds the circle and rectangles (also see pointControls)
	circle - the control point circle (also see pointCircles)
	rect1 - the first control point rectangle
	rect2 - the second control point rectangle
	controlType - the control type: default is "straight" (or null) and there is also "mirror", "free" and "none"
	NOTE: control, circle, rect1, rect2 can be positioned or animated and controlType can be changed
	NOTE: the update() method must be called if manually changing the control positions or type
	NOTE: if constantly animating the controls then use a Ticker.add(function(){blob.update();})
	NOTE: also see recordData(), setData(), getPoints(), setPoints() methods for further options
addPointFactor - (default 20) used when placing new points along edge (editPoints is true)
	divides the distance between points by this amount - the smaller the more accurate but also slower
addMinDistance - (default 15) edge press needs to be within this distance to add a point to the edge
segmentPoints - a read-only array of cubic Bezier points for each segment
	each element is in the form of [point1, controlPoint1, controlPoint2, point2]
	used internally to animate to the path and add and remove Bezier points
segmentRatios - a read-only array of cumulative ratio lengths of segments
	for instance the default four points is [.25, .5, .75, 1]
	used internally to animate to the path and attribute proportional time to each segment
controls - access to the container that holds the sets of controls
	each control is given a read-only num property
sticks - access to the Shape that has the control sticks
lastSelected - access to the last selected (or created) control container
lastSelectedIndex - the index number of the last selected controls
controlsVisible - get or set the visibility of the controls - or use showControls() and hideControls()
types - get or set the general array for the types ["mirror", "straight", "free", "none"]
	changing this or removing a type will adjust the order when the user double clicks the points to change their type
	this is not an array of types for each point - see the points property to access the types of each point
lockControls - Boolean to lock controls from being adjusted or not
allowToggle - Boolean to get or set clicking to show and hide controls
move - Boolean to drag or not drag Blob when controls are showing
	can also set to "always" to allow movement when controls are not showing
lockControlType - Boolean to lock the type of the controls in their current state or not
onTop - get or set the onTop property
selectPoints - get or set whether points can be selected
interactive - get or set whether the shape is interactive - toggle, move, change or add controls, etc.
keyFocus - get or set the keyboard focus on the DisplayObject - see also zim.KEYFOCUS
   will be set to true if this DisplayObject is the first made or DisplayObject is the last to be used with keyboard
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
   for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event for when the bezier controls are adjusted (pressup only or moving with keys - thanks Yui Kim for find)
	if monitoring constant change is needed add a pressmove event to Blob.sets
	the change event object has a transformType property with values of "move", "bezierPoint", "bezierHandle", "bezierSwitch"
dispatches "controlsshow" and "controlshide" events when clicked off and on and toggle is true
dispatches an "update" event if the points are changed or a point is added or removed
	this removes all listeners on the old shape and controls
	so any custom listeners on shape and controls will need to be re-applied - use the update event to do so
dispatches a "traversed" event when traverse() is done - the event object has an obj property for the traversing object
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53.5
	zim.Blob = function(color, borderColor, borderWidth, points, radius, controlLength, controlType, lockControlType, showControls, lockControls, handleSize, allowToggle, move, dashed, onTop, circleColor, circleBorderColor, stickColor, stickThickness, selectColor, selectPoints, editPoints, interactive, strokeObj, style, group, inherit) {
		var sig = "color, borderColor, borderWidth, points, radius, controlLength, controlType, lockControlType, showControls, lockControls, handleSize, allowToggle, move, dashed, onTop, circleColor, circleBorderColor, stickColor, stickThickness, selectColor, selectPoints, editPoints, interactive, strokeObj, style, group, inherit";
		var duo; if (duo = zob(zim.Blob, arguments, sig, this)) return duo;
		z_d("53.5");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Blob", this.group, inherit);

		if (zot(radius)) radius = DS.radius!=null?DS.radius:100;
		this.zimCustomShape_constructor(-radius,-radius,radius*2,radius*2,false);
		this.type = "Blob";

		this.mouseChildren = true; // set to false in CustomShape

		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.green);
		if (color.style) {this.colorCommand = color; color = zim.black;}
		if (borderColor && borderColor.style) {this.borderColorCommand = borderColor; borderColor = zim.black;}
		if (zot(points)) points = DS.points!=null?DS.points:4;
		var approxCheck = typeof points != "number";
		var num = typeof points == "number" ? points : points.length;
		var controlLengthOriginal = controlLength;
		if (zot(controlLength)) controlLength = DS.controlLength!=null?DS.controlLength:(radius * 4 / num);
		if (zot(controlType)) controlType = DS.controlType!=null?DS.controlType:null;
		var originalControlType = controlType;
		if (zot(controlType)) controlType = "straight";
		if (zot(lockControlType)) lockControlType = DS.lockControlType!=null?DS.lockControlType:false;
		if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:true;
		if (zot(showControls)) showControls = DS.showControls!=null?DS.showControls:interactive;
		var _controls = showControls;
		if (zot(lockControls)) lockControls = DS.lockControls!=null?DS.lockControls:!interactive;
		if (zot(handleSize)) handleSize = DS.handleSize!=null?DS.handleSize:(zim.mobile()?20:10);
		if (zot(allowToggle)) allowToggle = DS.allowToggle!=null?DS.allowToggle:interactive;
		if (zot(move)) move = DS.move!=null?DS.move:interactive;
		if (zot(circleColor)) circleColor = DS.circleColor!=null?DS.circleColor:zim.light;
		if (zot(circleBorderColor)) circleBorderColor = DS.circleBorderColor!=null?DS.circleBorderColor:zim.dark;
		if (zot(stickColor)) stickColor = DS.stickColor!=null?DS.stickColor:zim.darker;
		if (zot(stickThickness)) stickThickness = DS.stickThickness!=null?DS.stickThickness:1;
		if (zot(selectColor)) selectColor = DS.selectColor!=null?DS.selectColor:zim.white;
		if (zot(selectPoints)) selectPoints = DS.selectPoints!=null?DS.selectPoints:interactive;
		this.circleColor = circleColor;
		this.circleBorderColor = circleBorderColor;
		this.stickColor = stickColor;
		this.stickThickness = stickThickness;		

		if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:true;
		if (zot(editPoints)) editPoints = DS.editPoints!=null?DS.editPoints:interactive;
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{};

		var oa = remember(color, borderColor);
		this.veeObj = {color:oa[0], borderColor:oa[1]};
		function remember() {return arguments;} // for cloning PICK
		color = zim.Pick.choose(color);
		borderColor = zim.Pick.choose(borderColor);

		var that = this;
		this.interactive = interactive;
		this.num = num;
		this.editPoints = editPoints;
		this.selectPoints = selectPoints;
		this.lockControls = lockControls;
		this.onTop = onTop;
		this.move = move;
		this.allowToggle = allowToggle;
		this.lockControlType = lockControlType;

		this.types = ["mirror", "straight", "free", "none"];

		var _points;
		var _pointCircles;
		var _pointControls;
		that._color = color;
		that._borderColor = borderColor;
		that._borderWidth = borderWidth;
		that._dashed = dashed;
		if (that._dashed && !Array.isArray(that._dashed)) that._dashed = [10, 10];

		var shape;
		var moveDownEvent;
		var movePressEvent;
		var moveUpEvent;
		var stage;

		var draggingCheck = that.move;
		var min = 2; // distance within which to count as click to add point

		var mapMove;
		var sets;

		points = checkForShape(points);
		function checkForShape(shape) {
			if (shape=="circle" || shape == "rectangle" || shape =="triangle") {
				if (shape == "circle") shape = new zim.Circle(radius);
				if (shape == "rectangle") shape = new zim.Rectangle(radius*2,radius*2).centerReg({add:false});
				if (shape == "triangle") shape = new zim.Triangle(radius*2,radius*2,radius*2);
			}
			var points;
			if (shape.type == "Circle" || shape.type == "Rectangle" || shape.type == "Triangle" || shape.type == "Flare") {
				var b = shape.getBounds();
				if (shape.type == "Circle") {
					points = 4;
					controlLengthOriginal = controlLength = radius*2*.5523;
				} else if (shape.type == "Rectangle") {
					shape.centerReg({add:false});
                    if (shape.corner) { // normalize to array of four arrays with pair arrays
                        var c = zim.copy(shape.corner);
                        if (typeof c == "number") c = [[c,c],[c,c],[c,c],[c,c]]; 
                        else if (Array.isArray(c)) {
                            if (c.length==2) c = [c,c,c,c]; // distributing a single pair input
                            zim.loop(4, function(i){
                                if (zot(c[i])) c[i]=[0,0];
                                if (!Array.isArray(c[i])) c[i] = [c[i],c[i]];
                            });
                        }
                        var adj = .55; // when uneven, .7 works better...
                        points = [
                            [
                                -b.width/2, -(b.height/2 - c[0][1]), 
                                0, 0, 
                                0, 0, 
                                0, -c[0][1] * adj, 
                                "straight"
                            ],
                            [
                                -(b.width/2 - c[0][0]), -b.height/2, 
                                0, 0, 
                                -c[0][0] * adj, 0, 
                                0, 0, 
                                "straight"
                            ],
                            
                            [
                                (b.width/2 - c[1][0]), -b.height/2, 
                                0, 0, 
                                0, 0, 
                                c[1][0] * adj, 0, 
                                "straight"
                            ],
                            [   
                                b.width/2, -(b.height/2 - c[1][1]), 
                                0, 0, 
                                0, -c[1][1] * adj, 
                                0, 0, 
                                "straight"
                            ],
                            
                            [
                                b.width/2, (b.height/2 - c[2][1]), 
                                0, 0, 
                                0, 0, 
                                0, c[2][1] * adj, 
                                "straight"
                            ],
                            [
                                (b.width/2 - c[2][0]), b.height/2, 
                                0, 0, 
                                c[2][0] * adj, 0, 
                                0, 0, 
                                "straight"
                            ],
                            
                            [
                                -(b.width/2 - c[3][0]), b.height/2, 
                                0, 0, 
                                0, 0, 
                                -c[3][0] * adj, 0, 
                                "straight"
                            ],
                            [
                                -b.width/2, (b.height/2 - c[3][1]), 
                                0, 0, 
                                0, c[3][1] * adj, 
                                0, 0, 
                                "straight"
                            ]
                    
                        ]
                    } else {
                        points = [[b.x-b.width/2, b.y-b.height/2],[b.x+b.width/2, b.y-b.height/2],[b.x+b.width/2, b.y+b.height/2],[b.x-b.width/2, b.y+b.height/2]];
                    }                    
					that.setBounds(b.x-b.width/2, b.y-b.height/2, b.width, b.height);
					that.regX = shape.regX-b.width/2;
					that.regY = shape.regY-b.height/2;
					// this.rotation = shape.rotation;
					// this.scaleX = shape.scaleX;
					// this.scaleY = shape.scaleY;
				} else if (shape.type == "Triangle") {
					points = [[shape.three.x-shape.width/2, shape.three.y+shape.height/2+shape.adjusted],[shape.two.x-shape.width/2, shape.two.y+shape.height/2+shape.adjusted],[shape.one.x-shape.width/2, shape.one.y+shape.height/2+shape.adjusted]];
					that.setBounds(b.x-b.width/2, b.y-b.height/2, b.width, b.height);
				} else if (shape.type == "Flare") {
					var diffX = b.width/2+b.x;
					var diffY = b.height/2+b.y;
					points = [];
					var fp = zim.copy(shape.points);
					var lastP = {x:null,y:null};					
					zim.loop(fp, function(p, i) {
						var px = Math.round(p.x);
						var py = Math.round(p.y);
						if (px==lastP.x && py==lastP.y) return;
						lastP = {x:px, y:py};
						points.push([px-diffX, p.y-diffY]);
					});				
					that.setBounds(-shape.width/2, -shape.height/2, shape.width, shape.height);
				}
				return points;
			} else {
				return shape;
			}
		}
		if (typeof points == "string") {
			var svgProcessor = new zim.SVGContainer();
			points = svgProcessor.processPath(points);
			// added ZIM NFT 01 - keep watch...
			// if first and last point are at same place merge points
			if (points[0][0]==points[points.length-1][0] && points[0][1]==points[points.length-1][1]) {
				points[0][4] = points[points.length-1][4];
				points[0][5] = points[points.length-1][5];
				points.pop();
			}
		}

		if (originalControlType && typeof points != "number") {
			// override controlType
			zim.loop(points, function(point) {
				point[8]=originalControlType;
				if (originalControlType == "none") {
					point[4]=point[5]=point[6]=point[7]=0;
				}
			});
		}

		init();
		function init() {
			if (sets) sets.removeAllEventListeners();

			if (that.selectPoints) {
				that.selectedBalls = new zim.SelectionSet();
				that.selectedRect1s = new zim.SelectionSet();
				that.selectedRect2s = new zim.SelectionSet();

				that.selectionManager = new zim.SelectionManager([
					that.selectedBalls,
					that.selectedRect1s,
					that.selectedRect2s
				], "ctrl", false);
			} else {
				that.selectionManager = new zim.SelectionManager(null, "ctrl");
			}

			num = typeof points == "number" ? points : points.length;
			if (num <= 0) return;
			if (zot(controlLengthOriginal)) controlLength = radius * 4 / num;

			shape = that.shape = new zim.Shape({style:false}).addTo(that);
			var sticks = that.sticks = new zim.Shape({style:false}).addTo(that);
			if (handleSize <= 0) sticks.removeFrom();
			var g = shape.graphics;
			g.c();
			var s = sticks.graphics;
			s.c();

			var ballS = handleSize/10*8;
			var rectS = handleSize;

			var mobile = zim.mobile();

			sets = that.controls = new zim.Container({style:false}).addTo(that); // sets - a set contains a ball and two rects
			if (that.interactive) sets.drag({onTop:!mobile});

			_points = [];
			_pointControls = [];
			_pointCircles = [];

			var i, point, temp, set, rect1, rect2, ball, type, setInfo;
			
			for (i=0; i<num; i++) {
				set = new zim.Container({style:false}).addTo(sets);
				set.num = i;
				if (typeof points == "number") { // no sets yet

					// easier to create controls in a temp vertical Container
					// set the registration point at the circle center
					// then rotate the temp container
					// then get the resulting rotated coordinates and use localToLocal
					// to find coordinates of controls in set Container
					// afterwards, adjust controls in set Container so origin and registration is at ball
					// then move the set Container so it matches that adjustment
					// (or could have calculated all positions to start with aTan2, sin, cos etc.)
					var length = zim.Pick.choose(controlLength);
					temp = new zim.Container(length, radius, null, null, false).reg(length/2, radius).addTo(that);
					temp.rotation = i/num * 360;
					ball = new zim.Circle(ballS, that.selectPoints&&that.selectedBalls.isSelected(i)?selectColor:that.circleColor, that.circleBorderColor, 2, null, null, null, null, null, false)
						.centerReg(temp)
						.loc({x:length/2,y:0});
					rect1 = new zim.Rectangle(rectS, rectS, that.selectPoints&&that.selectedRect1s.isSelected(i)?selectColor:getBackgroundColor(controlType), handleSize==0?null:zim.dark, handleSize==0?null:2, null, null, null, null, false)
						.centerReg(temp)
						.loc({x:0,y:0});
					rect2 = new zim.Rectangle(rectS, rectS, that.selectPoints&&that.selectedRect2s.isSelected(i)?selectColor:getBackgroundColor(controlType), handleSize==0?null:zim.dark, handleSize==0?null:2, null, null, null, null, false)
						.centerReg(temp)
						.loc({x:length,y:0});

					var ballPoint = temp.localToLocal(ball.x, ball.y, sets);
					ball.x = ballPoint.x;
					ball.y = ballPoint.y;
					ball.addTo(set, null, false);
					var rect1Point = temp.localToLocal(rect1.x, rect1.y, sets);
					rect1.x = controlType=="none"?0:rect1Point.x-ball.x;
					rect1.y = controlType=="none"?0:rect1Point.y-ball.y;
					rect1.addTo(set, null, false);
					var rect2Point = temp.localToLocal(rect2.x, rect2.y, sets);
					rect2.x = controlType=="none"?0:rect2Point.x-ball.x;
					rect2.y = controlType=="none"?0:rect2Point.y-ball.y;
					rect2.addTo(set, null, false);
					set.x = ball.x;
					set.y = ball.y;
					ball.x = 0;
					ball.y = 0;
					if (controlType=="none") ball.addTo(set, null, false); // on top

				} else { // passing in set data

					// balls are relative to blob but handles are relative to ball
					// points is an array of [[setX, setY, ballX, ballY, handleX, handleY, handle2X, handle2Y, type], etc.]

					setInfo = points[i];
					type = setInfo[8] ? setInfo[8] : controlType;
					set.loc({x:setInfo[0], y:setInfo[1]});
					ball = new zim.Circle(ballS, that.circleColor, that.circleBorderColor, 2, null, null, null, null, null, false)
						.centerReg({add:false})
						.addTo(set)
						.loc({x:setInfo[2],y:setInfo[3]});
					rect1 = new zim.Rectangle(rectS, rectS, getBackgroundColor(type), handleSize==0?null:zim.dark, handleSize==0?null:2, null, null, null, null, false)
						.centerReg({add:false})
						.addTo(set, 0)
						.loc({x:setInfo[4],y:setInfo[5]});
					rect2 = new zim.Rectangle(rectS, rectS, getBackgroundColor(type), handleSize==0?null:zim.dark, handleSize==0?null:2, null, null, null, null, false)
						.centerReg({add:false})
						.addTo(set, 0)
						.loc({x:setInfo[6],y:setInfo[7]});
				}

				ball.mySet = set;
				ball.rect1 = rect1;
				ball.rect2 = rect2;
				ball.index = i;

				if (handleSize==0) {
					ball.expand(10);
					rect1.expand(10);
					rect2.expand(10);
				}

				if (mobile) {
					ball.on("mousedown", mobileDouble);
				} else {
					ball.on("dblclick", doubleIt);
				}

				rect1.ball = ball;
				rect1.other = rect2;
				rect2.ball = ball;
				rect2.other = rect1;

				if (mobile) {
					ball.expand();
					rect1.expand();
					rect2.expand();
				}

				point = [set, ball, rect1, rect2, setInfo?setInfo[8]:controlType];
				_points.push(point);
				_pointCircles.push(ball);
				_pointControls.push(set);
			}

			var tappedTwice = false;
			function mobileDouble(e) {
				if (!tappedTwice) {
					tappedTwice = true;
					setTimeout(function() {
						tappedTwice = false;
					}, 300);
				} else {
					e.preventDefault();
					doubleIt(e);
				}
			}

			function doubleIt(e) {
				if (that.lockControlType) return;
				var ball = e.target;
				// cycle through the types
				var type = _points[ball.index][4] ? _points[ball.index][4] : controlType;
				if (Math.abs(ball.rect1.x) <= 2 && Math.abs(ball.rect1.y) <= 2 && Math.abs(ball.rect2.x) <= 2 && Math.abs(ball.rect2.y) <= 2) {
					type = "none";
				}
				if (type == "none") {
					ball.parent.addChildAt(ball, 0);
				}
				// modulus going backwards needs to add the length so it does not go negative
				type = that.types[(that.types.indexOf(type)+(that.shiftKey?-1:1)+that.types.length)%that.types.length];
				if (type == "none") {
					ball.rect1.x =  ball.rect1.y =  ball.rect2.x =  ball.rect2.y = 0;
					ball.parent.addChild(ball);
					e.stopImmediatePropagation();
				}
				_points[ball.index][4] = type;
				ball.rect1.color = getBackgroundColor(type);
				ball.rect2.color = getBackgroundColor(type);
				that.drawShape();
				var ev = new createjs.Event("change");
				ev.controlType = "bezierSwitch";
				that.dispatchEvent(ev);
				ball.stage.update();
			}

			function getBackgroundColor(type) {
				var colors = {mirror:"#993399", free:"#ebcb35", none:"#50c4b7"};
				return colors[type] ? colors[type] : "#e472c4";
			}

			that.drawShape = function() {
				
				var currentIndex,nextIndex;
				var set,control1,control2,nextSet,ballPoint,nextBall,nextControl1,control1Point,control2Point,nextControl1Point,nextBallPoint;
						
				g.c();
				if (!that.colorCommand) {
					that.colorCommand = g.f(that._color).command;
					if (color && color.type) that.specialColor(that.colorCommand, color, that);
				}
				// border of 0 or a string value still draws a border in CreateJS
				if (zot(that._borderWidth) || that._borderWidth > 0) { // no border specified or a border > 0
					if (!zot(that._borderColor) || !zot(that._borderWidth)) { // either a border color or thickness
						if (zot(that._borderColor)) that._borderColor = zim.black;
						if (!that.borderColorCommand) {
							that.borderColorCommand = g.s(that._borderColor).command;
							if (that._borderColor && that._borderColor.type) that.specialColor(that.borderColorCommand, that._borderColor, that);
						}
						if (!that.borderWidthCommand) that.borderWidthCommand = g.ss(that._borderWidth, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
						if (that._dashed) {
							if (!that.borderDashedCommand) that.borderDashedCommand = g.sd(Array.isArray(that._dashed)?that._dashed:[10, 10], that._dashedOffset).command;
						}
					}
				}
				set = _points[0][0];
				ballPoint = set.localToLocal(_points[0][1].x, _points[0][1].y, shape);
				g.mt(ballPoint.x, ballPoint.y);

				s.c().s(that.stickColor).ss(that.stickThickness);

				for (var i=0; i<_points.length; i++) {
					currentIndex = i;
					nextIndex = (i+1)%_points.length;

					set = _points[currentIndex][0];
					ball = _points[currentIndex][1];
					control1 = _points[currentIndex][2];
					control2 = _points[currentIndex][3];

					nextSet = _points[nextIndex][0];
					nextBall = _points[nextIndex][1];
					nextControl1 = _points[nextIndex][2];
					// nextControl2 = _points[nextIndex][3];

					control2Point = set.localToLocal(control2.x, control2.y, shape);
					nextControl1Point = nextSet.localToLocal(nextControl1.x, nextControl1.y, shape);
					nextBallPoint = nextSet.localToLocal(nextBall.x, nextBall.y, shape);

					g.bt(
						control2Point.x, control2Point.y,
						nextControl1Point.x, nextControl1Point.y,
						nextBallPoint.x, nextBallPoint.y
					);


					// create the sticks
					ballPoint = set.localToLocal(ball.x, ball.y, shape);
					control1Point = set.localToLocal(control1.x, control1.y, shape);

					s.mt(ballPoint.x, ballPoint.y).lt(control1Point.x, control1Point.y);
					s.mt(ballPoint.x, ballPoint.y).lt(control2Point.x, control2Point.y);
				}
				g.cp();

				g.append(that.colorCommand);
				if (that._dashed) g.append(that.borderDashedCommand);
				if (that.borderWidthCommand) g.append(that.borderWidthCommand);
				if (that.borderColorCommand) g.append(that.borderColorCommand);
			};
			that.drawShape();
			if (color.type) that.color = color;

			var startPosition;
			var mDown;
			sets.on("mousedown", function(e) {
				if (that.lockControls) return;
				sets.loop(function(set) {
					if (set == e.target.parent) return;					
					if (set.lastChildren==null) set.lastChildren = set.mouseChildren;
					if (set.lastMouse==null) set.lastMouse = set.mouseEnabled;
					set.noMouse();
				});
				if (shape.lastMouse==null) shape.lastMouse = shape.mouseEnabled;
				shape.mouseEnabled = false;
				mDown = true;
				if (that.selectPoints) that.keyFocus = true;
				startPosition = {x:e.target.x, y:e.target.y};
				var ball;
				if (e.target.rect1) { // then mousedown on ball
					ball = e.target;
					ball.startX = ball.x;
					ball.startY = ball.y;
					ball.rect1.startX = ball.rect1.x;
					ball.rect1.startY = ball.rect1.y;
					ball.rect2.startX = ball.rect2.x;
					ball.rect2.startY = ball.rect2.y;
				} else { // mousedown on control
					var rect = e.target;
					rect.startX = rect.x;
					rect.startY = rect.y;
					ball = rect.ball;
					var index = ball.index;
					var type = controlType;
					if (!zot(_points[index][4])) type = _points[index][4];
					if (type == "straight") {
						var other = rect.other;
						var dX = other.x - ball.x;
						var dY = other.y - ball.y;
						other.stickLength = Math.sqrt(Math.pow(dX,2) + Math.pow(dY,2));
					}
				}
				if (that.selectPoints) {
					// need to reset all start points for each control circle and rectangle moved
					var currentSet = that.selectionManager.currentSet;
					if (currentSet && currentSet.selections && currentSet.selections.length > 0) {
						for(var i=0; i<currentSet.selections.length; i++) {
							var point = that.pointObjects[currentSet.selections[i]];
							point[1].startX = point[1].x;
							point[1].startY = point[1].y;
							point[2].startX = point[2].x;
							point[2].startY = point[2].y;
							point[3].startX = point[3].x;
							point[3].startY = point[3].y;
						}
					}
				}
			});

			if (that.selectPoints) {
				sets.tap(function (e) {
					var ball;
					if (e.target.rect1) { // then mousedown on ball - which has a rect1
						ball = e.target;
						that.selectedBalls.toggle(ball.parent.num);
					} else { // mousedown on control
						var rect = e.target;
						rect.color = "white";
						ball = rect.ball;
						if (ball.rect1 == rect) that.selectedRect1s.toggle(ball.parent.num);
						else that.selectedRect2s.toggle(ball.parent.num);
					}
					// loop through all controls and set to right color based on selection
					for (var i=0; i<that.pointObjects.length; i++) {
						var po = that.pointObjects[i];
						po[1].color = that.selectedBalls.isSelected(i)?selectColor:that.circleColor;
						po[2].color = that.selectedRect1s.isSelected(i)?selectColor:getBackgroundColor(po[4]);
						po[3].color = that.selectedRect2s.isSelected(i)?selectColor:getBackgroundColor(po[4]);
					}
					e.target.stage.update();
				});
			}

			sets.on("pressmove", function(e) {
				if (that.lockControls) return;
				if (that.selectPoints) {
					var currentSelected = getCurrentSelected();
					if (currentSelected.indexOf(e.target) == -1) {
						mapMove(e.target);
						that.drawShape();
					} else {
						if (currentSelected.length > 0) {
							var diffX = e.target.x-e.target.startX;
							var diffY = e.target.y-e.target.startY;
							for(var i=0; i<currentSelected.length; i++) {
								var pointObj = currentSelected[i];
								pointObj.x = pointObj.startX + diffX;
								pointObj.y = pointObj.startY + diffY;
								mapMove(pointObj);
							}
							that.drawShape();
						}
					}
				} else {
					mapMove(e.target);
					that.drawShape();
				}
			});

			sets.on("pressup", function(e) {
				if (that.lockControls) return;
				sets.loop(function(set) {
					if (set == e.target.parent) return;					
					if (set.lastChildren!=null) set.mouseChildren = set.lastChildren;
					if (set.lastMouse!=null) set.mouseEnabled = set.lastMouse;
					set.lastChildren = null;
					set.lastMouse = null;
				});
				if (shape.lastMouse!=null) shape.mouseEnabled = shape.lastMouse;
				shape.lastMouse = null;
				mDown = false;
				var moveControlCheck = (e.target.x != startPosition.x || e.target.y != startPosition.y);
				var ev = new createjs.Event("change");
				if (e.target.rect1) { // pressup on ball
					ev.controlType = "bezierPoint";
					endMove(e.target);
				} else {
					ev.controlType = "bezierHandle";
				}
				if (moveControlCheck) that.dispatchEvent(ev);
			});

			function endMove(target) {
				if (that.selectPoints) {
					var currentSelected = getCurrentSelected();
					if (currentSelected && currentSelected.indexOf(target) == -1) {
						replaceControls(target);
					} else if (currentSelected && currentSelected.length>0) {
						for(var i=0; i<currentSelected.length; i++) {
							replaceControls(currentSelected[i]);
						}
					} else {
						replaceControls(target);
					}
				} else {
					replaceControls(target);
				}
			}

			that.changeControl = function(index, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY, update) {
				var sig = "index, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY, update";
				var duo; if (duo = zob(that.changeControl, arguments, sig)) return duo;
				if (zot(index)) {
					for (var i=0; i<_points.length; i++) {
						that.changeControl(i, type, rect1X, rect1Y, rect2X, rect2Y, circleX, circleY);
					}
					return that;
				}
				var point = _points[index];
				point[4] = type;
				if (type == "none") {
					if (!zot(circleX)) point[1].x = circleX;
					if (!zot(circleY)) point[1].y = circleY;
					point[2].x = point[1].x,
					point[2].y = point[1].y;
					point[3].x = point[1].x,
					point[3].y = point[1].y;
					point[1].parent.addChild(point[1]);
				} else {
					if (!zot(circleX)) point[1].x = circleX;
					if (!zot(circleY)) point[1].y = circleY;
					if (!zot(rect1X)) point[2].x = rect1X;
					if (!zot(rect1Y)) point[2].y = rect1Y;
					if (!zot(rect2X)) point[3].x = rect2X;
					if (!zot(rect2Y)) point[3].y = rect2Y;
					point[1].parent.addChildAt(point[1], 0);
				}
				point[2].color = getBackgroundColor(type);
				point[3].color = getBackgroundColor(type);
				if (update) {
					that.update();
					if (that.stage) that.stage.update();
				}
				return that;
			};
			
			that.transformPoints = function(transformType, amount, x, y, approximateBounds) {
				if (zot(approximateBounds)) approximateBounds = true;
				that.points = zim.transformPoints(that.points, transformType, amount, x, y);
				if (approximateBounds) that.approximateBounds();
				return that;
			};

			that.traverse = function(obj, start, end, time, reverse) {
				
				var ratios = zim.copy(that.segmentRatios);
				ratios.unshift(0);
				if (zot(end)) end = start+1;
				var startPercent = ratios[start]*100;
				var endPercent = ratios[end]*100;

				// **** the values we are getting for the points are correct - I have double checked them 
				// I think below is right but maybe going forward with startPercent and amount in animate() is off 
				// why it would be off going forward and not backwards, I don't know.
				
				var amount;
				if (!reverse && startPercent > endPercent) amount = 100 - startPercent + endPercent;
				else if (!reverse && startPercent < endPercent) amount = endPercent - startPercent;
				else if (reverse && startPercent > endPercent) amount = - (startPercent - endPercent);
				else if (reverse && startPercent < endPercent) amount =  - (100 - endPercent + startPercent);

				var eventObj = new createjs.Event("traversed");
				eventObj.obj = obj;			

				obj.animate({
					ease:"linear",
					// **************** problem in animate?
					props:{path:that, startPercent:startPercent, percent:amount},
					time:time,
					call:function() {
						that.dispatchEvent(eventObj);
					}
				});

				return that;
			};
			
			that.reversePoints = function(sameStart) {	
				if (zot(sameStart)) sameStart = true;		
				points = zim.copy(that.points);				
				points.reverse();
				if (sameStart) points.unshift(points.pop()); // keep the start point the same
				zim.loop(points, function(p) {
					var p6 = p[6];					
					p[6] = p[4];
					p[4] = p6;
					var p7 = p[7];
					p[7] = p[5];
					p[5] = p7;
					// [point[6], point[7], point[4], point[5]] = [point[4], point[5], point[6], point[7]];                        
				});
				
				that.points = points;
				that.update();
				return that;
			};			
			
						
			that.splitPoints = function(index) {
				var current = zim.copy(that.points);
				if (index < 1 || index > current.length-1) return;
				var first = zim.copy(current.slice(0,index+1));
				var second = zim.copy(current.slice(index));
				zim.trimPointEnds(first);
				zim.trimPointEnds(second);
				var s = that.clone();
				that.points = first;
				that.update();
				s.points = second;
				if (that.parent) s.addTo(that.parent);
				return s;
			};
			
			that.makeSquiggle = function(index) {	
				var current = zim.copy(that.points);
				if (zot(index)) index = 0;
				index = (index+current.length*1000)%current.length;
				var first = zim.copy(current.slice(index));
				var second = zim.copy(current.slice(0,index+1));
				current = first.concat(second);
				zim.trimPointEnds(current);
				var s = new zim.Squiggle({
					points:current,
					color:that.borderColor, 
					thickness:that.borderWidth, 
					showControls:that.controlsVisible,
					interactive:that.interactive,
					onTop:that.onTop,
					dashed:that.dashed,
					stickColor:that.stickColor,
					stickThickness:that.stickThickness					
				});
				return s;
			};

			that.splitBlob = function(a, b, num, clean) {
				if (zot(a)) a = 0;
				if (zot(b)) b = Math.ceil(that.points.length/2);				
				if (zot(num)) num = 50;
				if (zot(clean)) clean = true;
				if (typeof a == "number" && typeof b == "number") {
					var c = a;
					if (a > b) {
						a = b;
						b = c;
					} 
				}
			
				if (!zot(a.x) || !zot(b.x)) {
					// this gets array of cubic beziers that closestPointAlongCurve needs
					var blobSegments = that.segmentPoints;
				}

				var p1, p2, i1, i2;
				if (!zot(a.x)) { // a global x,y point provided
					var bb = b;		
					if (zot(b.x)) bb = that.pointCircles[b].localToGlobal(0,0);	
					var point1 = zim.loop(num, function(i,t) {
						var p = zim.getPointAtPercent(a.x,a.y,bb.x,bb.y,i/t*100);
						if (that.hitTestPoint(p.x, p.y)) return p;
					});
					if (point1 === true) return; // not intersecting
					p1 = that.globalToLocal(point1.x, point1.y);
					// point, segmentPoints, num, interpolate, percentage
					var percent1 = zim.closestPointAlongCurve(p1, blobSegments, 20, false, true);					
				} else {
					i1 = a;
					p1 = that.pointCircles[a];
				}			

				if (!zot(b.x)) { // a global x,y point provided			
					var aa = a;		
					if (zot(a.x)) aa = that.pointCircles[a].localToGlobal(0,0);			
					var point2 = zim.loop(num, function(i,t) {
						var p = zim.getPointAtPercent(aa.x,aa.y,b.x,b.y,i/t*100);
						if (that.hitTestPoint(p.x, p.y)) return p;
					}, true); // reverse
					if (point2 === true) return; // not intersecting
					p2 = that.globalToLocal(point2.x, point2.y);
					var percent2 = zim.closestPointAlongCurve(p2, blobSegments, 20, false, true);
				} else {
					i2 = b;
					p2 = that.pointCircles[b];
				}					
				
				if (!zot(a.x)) i1 = that.addPoint(percent1); // returns index of point
				if (!zot(b.x)) i2 = that.addPoint(percent2);

				if (!zot(a.x) && zot(b.x) && i1 <= i2) i2++;
				if (!zot(b.x) && zot(a.x) && i2 <= i1) i1++;
				if (!zot(a.x) && !zot(b.x) && i2 <= i1) i1++;
					
				// turn the blob into a squiggle at the first point
				var s1 = that.makeSquiggle(i1).loc(that); // returns Squiggle
				
				// once the blob is cut into a squiggle 
				// we need to find the new index of the second point
				// we will store this as i3
				var num = that.points.length;
				let i3 = (i1 > i2) ? num-i1+i2 : i2-i1;
				
				// split the squiggle into two at the adjusted second point
				var s2 = s1.splitPoints(i3).loc(that); // returns second Squiggle
					
				// turn the squiggles into blobs
				var b1 = s1.makeBlob("free").loc(s1);
				var b2 = s2.makeBlob("free").loc(s2);

				b1.color = that.color;
				b2.color = that.color;
				b1.borderColor = that.borderColor;
				b2.borderColor = that.borderColor;
								
				// remove the old parts				
				s1.dispose();
				s2.dispose();
				if (clean) that.dispose();
				
				return [b1, b2];

			}

			that.update = function(normalize) {
				if (normalize) {
					// located any rotated or scaled points
					// and set them back to non-rotated and non-scaled
					// but keep control handles at the earlier positions
					// need to normalize before doing more manual updates with Beziers
					// do not need to normalize if animating blob points
					that.points = that.pointsAdjusted;
				} else {
					that.drawShape();
				}
				that.zimAnimateChanged = true;
				return that;
			};

			// blob
			if (that.move && that.interactive) shape.drag({onTop:false});
			moveDownEvent = shape.on("mousedown", function(e) {
				stage = e.target.stage;
				startPosition = {x:shape.x, y:shape.y};
				if (that.selectPoints) that.keyFocus = true;
				upTop();
			});
			movePressEvent = shape.on("pressmove", function() {
				sets.x = shape.x;
				sets.y = shape.y;
				sticks.x = shape.x;
				sticks.y = shape.y;
			});
			moveUpEvent = shape.on("pressup", function() {
				var moveControlCheck = (shape.x != startPosition.x || shape.y != startPosition.y);
				var movePoint = shape.localToLocal(that.regX,that.regY,that.parent);
				that.x = movePoint.x;
				that.y = movePoint.y;
				sets.x = sets.y = sticks.x = sticks.y = shape.x = shape.y = 0;
				if (moveControlCheck) {
					var ev = new createjs.Event("change");
					ev.controlType = "move";
					that.dispatchEvent(ev);
				}
				stage.update();
			});

			if (!move) stopDragging(true);

			function upTop() {
				if (that.onTop) {
					var nc = that.parent.numChildren-1;
					if (that.parent.getChildAt(nc).type == "Keyboard") nc--;
					that.parent.setChildIndex(that, nc);
				}
			}
			that.toggleEvent = that.on("mousedown", function() {
				if (!that.allowToggle) return;
				if (!_controls) {
					that.showControls();
					that.dispatchEvent("controlsshow");
				}
			});

			that.added(function() {
				stage = that.stage;
				if (that.toggleStageEvent) that.stage.off("stagemousedown", that.toggleStageEvent);
				that.toggleStageEvent = that.stage.on("stagemousedown", function(e) {
					if (mDown || !that.allowToggle || !that.stage) return;
					if (_controls && !that.hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY, false)) {
						that.hideControls();
						that.dispatchEvent("controlshide");
					}
				});
			});

			that.clickEvent = that.on("click", function() {
				if (that.ctrlKey) {
					setTimeout(function() { // give time for record to work if drag with ctrl down
						that.clone(true).addTo(that.stage).mov(100);
						if (that.allowToggle) {
							that.hideControls();
							that.dispatchEvent("controlshide");
						}
						var ev = new createjs.Event("change");
						ev.controlType = "move";
						that.dispatchEvent(ev);
						that.stage.update();
					}, 50);
				}
			});

			that.hideControls = function() {
				that.toggled = false;
				sets.visible = false;
				sticks.visible = false;
				_controls = false;
				if (that.stage) that.stage.update();
				if (!that.allowToggle && that.move) stopDragging();
				return that;
			};
			if (!_controls) that.hideControls();
			that.showControls = function() {
				// if call this with code then will not trigger a change event - not good for TransformManager.persist()
				that.toggled = true;
				sets.visible = true;
				sticks.visible = true;
				_controls = true;
				sets.x = shape.x;
				sets.y = shape.y;
				sticks.x = shape.x;
				sticks.y = shape.y;
				that.addChildAt(shape,0); // put to bottom in case dragged
				if (that.move && !that.allowToggle) startDragging();
				if (that.stage) that.stage.update();
				return that;
			};

			that.toggle = function(state) {
				if (state===true) that.showControls();
				else if (state===false) that.hideControls();
				else if (_controls) that.hideControls();
				else that.showControls();
				return that;
			};

			that.recordData = function(toJSON) {
				if (zot(toJSON)) toJSON = false;
				var obj = {
					type:"Blob",
					index:that.parent?that.parent.getChildIndex(that):-1,
					x:that.x, y:that.y,
					points:that.getPoints(),
					color:that.color,
					borderColor:that.borderColor,
					borderWidth:that.borderWidth,
					move:that.move,
					allowToggle:that.allowToggle,
					controlsVisible:_controls
				};
				if (toJSON) return JSON.stringify(obj);
				return obj;
			};

			that.setData = function(data, fromJSON) {
				if (zot(data)) return;
				if (fromJSON) {
					try{
						data = JSON.parse(data);
					} catch (e) {
						return;
					}
				}
				var index = data.index;
				if (zot(index)) index = -1;
				delete data.index;

				var pointData = data.points;
				if (!zot(pointData)) that.setPoints(pointData);
				delete data.points;
				this.num = pointData.length;

				for (var d in data) {
					that[d] = data[d];
				}
				if (that.parent) {
					that.parent.setChildIndex(that, index);
				}
				return that;
			};

			that.getPoints = function(popup) {
				// _pointCircles are relative to blob but handles are relative to ball
				// points is an array of [[ballX, ballY, handleX, handleY, handle2X, handle2Y, type], etc.]
				if (zot(popup)) popup = false;
				var points = that.points;
				if (popup) {
					if (!pane) {
						var pane = that.pane = new zim.Pane({
							displayClose:false,
							container:that.stage,
							width:Math.min(500, that.stage.width-20),
							height:Math.min(500, that.stage.height-20),
							draggable:true,
						});
						var textArea = that.textArea = new zim.TextArea(Math.min(400, that.stage.width-70), Math.min(400, that.stage.height-70));
						pane.add(textArea);
					} 
					pane.show();		
					textArea.text = JSON.stringify(points);
				}
				return points;
			};
			that.recordPoints = that.getPoints;

			that.setPoints = function(points) {
				// adjust blob to match points passed in from getPoints
				var p;
				var p2;
				for (var i=0; i<points.length; i++) {
					p = _points[i];
					p2 = points[i];
					if (zot(p)) continue;
					p[0].x = p2[0];
					p[0].y = p2[1];
					p[1].x = p2[2];
					p[1].y = p2[3];
					p[2].x = p2[4];
					p[2].y = p2[5];
					p[3].x = p2[6];
					p[3].y = p2[7];
					p[4] = p2[8];
					p[2].color = getBackgroundColor(p[4]);
					p[3].color = getBackgroundColor(p[4]);
				}
				that.update();
				return that;
			};
			if (style!==false) zim.styleTransforms(that, DS);
			that.clone = function(exact, commands) {
				var tList = [];
				var tCheck = false;
				zim.loop(that.pointControls,function(p){
					if (p.scaleX+p.scaleY+p.regX+p.regY+p.rotation!=2) tCheck = true;
					tList.push([p.scaleX,p.scaleY,p.regX,p.regY,p.rotation]);
				});
				var newShape =  that.cloneProps(new zim.Blob(commands?that.colorCommand:((exact||!zim.isPick(oa[0]))?that.color:oa[0]), commands?that.borderColorCommand:((exact||!zim.isPick(oa[1]))?that.borderColor:oa[1]), that.borderWidth, that.getPoints(), radius, controlLength, controlType, lockControlType, sets.visible, lockControls, handleSize, that.allowToggle, that.move, dashed, onTop, that.circleColor, that.circleBorderColor, that.stickColor, that.stickThickness, selectColor, selectPoints, that.editPoints, interactive, strokeObj, style, that.group, inherit));
				if (tCheck) {
					zim.loop(newShape.pointControls,function(p,i){					
						p.scaleX = tList[i][0];
						p.scaleY = tList[i][1];
						p.regX = tList[i][2];
						p.regY = tList[i][3];
						p.rotation = tList[i][4];					
					});
					newShape.update();
				}
				
				if (that.linearGradientParams) newShape.linearGradient.apply(newShape, that.linearGradientParams);
				if (that.radialGradientParams) newShape.radialGradient.apply(newShape, that.radialGradientParams);
				return newShape;
			};

			// to add a control - make sure click in one spot - not drag
			that.shapeMousedownEvent = that.shape.on("mousedown", function (e) {
				stage = e.target.stage;
				if (!that.editPoints) return;
				if (that.controlsVisible) {
					that.pressX = e.stageX/zim.scaX;
					that.pressY = e.stageY/zim.scaY;
				} else {
					that.pressX = null;
					that.pressY = null;
				}
			});
			that.addPointFactor = 10;
			that.addMinDistance = 15;
			that.shapePressupEvent = that.shape.on("pressup", function (e) {

				if (!that.editPoints) return;
				if (that.pressX && Math.abs(that.pressX-e.stageX/zim.scaX) < min && Math.abs(that.pressY-e.stageY/zim.scaY) < min) {
					if (that.selectPoints) that.lastPoints = zim.copy(that.points);
					var points = that.points;
					var point = that.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
					var pointBefore = zim.closestPointAlongCurve(point, that.segmentPoints);

					if (that.editPoints == "anywhere") {
						points.splice(pointBefore+1, 0, [point.x, point.y, 0,0, 0,0, 0,0]);
						that.points = points;
						that.changeControl({index:pointBefore+1, type:"mirror", update:true});
					} else { // only on edge
						// test close enough to edge otherwise return
						var p = that.pointsAdjusted;
						var cubic = that.getSegmentPoint(p[pointBefore], p[(pointBefore+1)%p.length]);
						var length = zim.distanceAlongCurve(cubic);
						var testNum = Math.round(length/that.addPointFactor);
						var testPoints = that.interpolate(testNum, pointBefore, false, points);
						var closest=10000;
						var closestIndex;

						zim.loop(testPoints, function (p, k) {
							if (k==0) return; // don't put on existing point
							var d = zim.dist(p, point);
							if (d < closest) {
								closest = d;
								closestIndex = k;
							}
						});
						if (closest < that.addMinDistance) {
							var ratios = that.segmentRatios;
							var currentRatio = ratios[pointBefore];
							var lastRatio = pointBefore>0?ratios[pointBefore-1]:0;
							that.addPoint(100*(lastRatio+(currentRatio-lastRatio)*(closestIndex/(testNum+1))));
						}
					}

					that.lastSelectedIndex = pointBefore+1;
					that.lastSelected = that.controls.getChildAt(that.lastSelectedIndex);
					that.stage.update();
				}
			});

			// remove point
			that.controlsClickEvent = that.controls.on("click", function (e) {
				that.lastSelected = e.target.parent;
				that.lastSelectedIndex = that.controls.getChildIndex(e.target.parent);
				if (!that.editPoints) return;
				if (that.selectionManager.shiftKey) { // remove
					removeControl(e);
				}
			});

			function removeControl(e) {
				if (e.target.type == "Circle") {
					var index = that.lastSelectedIndex = that.controls.getChildIndex(e.target.parent);
					if (that.controls.numChildren <= 2) return;
					var points = that.points;
					if (that.selectPoints) that.lastPoints = zim.copy(points);
					points.splice(index, 1); // remove the point at the index
					that.points = points;
					that.stage.update();
					that.lastSelected = that.lastSelectedIndex = null;
				}
			}
			that.controls.hold(removeControl);

			if (!_controls) that.hideControls();
			that.dispatchEvent("update");
		} // end of init()

		function getCurrentSelected() {
			var answer = [];
			var currentSet = that.selectionManager.currentSet;
			if (currentSet && currentSet.selections && currentSet.selections.length > 0) {
				for(var i=0; i<currentSet.selections.length; i++) {
					var point = that.pointObjects[currentSet.selections[i]];
					if (currentSet == that.selectedBalls) {
						answer.push(point[1]);
					} else if (currentSet == that.selectedRect1s) {
						answer.push(point[2]);
					}	else if (currentSet == that.selectedRect2s) {
						answer.push(point[3]);
					} else {
						continue;
					}
				}
			}
			return answer;
		}

		function replaceControls(target) {
			if (!that.selectPoints) return;
			// move ball back to origin and move set accordingly
			// so if we animate the set it will behave as expected
			if (target.type != "Circle") return;
			var ball = target;
			var set = ball.mySet;
			var rect1 = ball.rect1;
			var rect2 = ball.rect2;
			rect1.x -= ball.x;
			rect1.y -= ball.y;
			rect2.x -= ball.x;
			rect2.y -= ball.y;
			set.x += ball.x;
			set.y += ball.y;
			ball.x = 0;
			ball.y = 0;
		}

		that.selectionManager.on("keydown", function (e) {
			if (!that.selectPoints) return;
			if (!that.keyFocus) return;
			if (e.keyCode >= 37 && e.keyCode <= 40) {
				var currentSelected = getCurrentSelected();
				if (currentSelected.length > 0) {
					for(var i=0; i<currentSelected.length; i++) {
						var pointObj = currentSelected[i];
						if (e.keyCode == 37) pointObj.x -= that.selectionManager.shiftKey?10:1;
						else if (e.keyCode == 39) pointObj.x += that.selectionManager.shiftKey?10:1;
						else if (e.keyCode == 38) pointObj.y -= that.selectionManager.shiftKey?10:1;
						else if (e.keyCode == 40) pointObj.y += that.selectionManager.shiftKey?10:1;
						mapMove(pointObj);
					}
					that.drawShape();
					that.dispatchEvent("update");
					if (that.stage) that.stage.update();
				}
			}
		});

		that.selectionManager.on("keyup", function (e) {
			if (!that.selectPoints) return;
			if (!that.keyFocus) return;
			if (e.keyCode >= 37 && e.keyCode <= 40) {
				var currentSelected = getCurrentSelected();
				if (currentSelected.length > 0) {
					for(var i=0; i<currentSelected.length; i++) {
						replaceControls(currentSelected[i]);
					}
				}
			}
		});

		that.selectionManager.on("undo", function () {
			if (!that.selectPoints) return;
			if (!that.keyFocus) return;
			if (that.lastPoints) {
				var tempPoints = zim.copy(that.lastPoints);
				that.lastPoints = zim.copy(that.points);
				that.points = tempPoints;
				if (that.stage) that.stage.update();
			}
		});


		mapMove = function (target) {
			if (that.lockControls) return;
			var ball;
			if (target.rect1) { // pressmove on ball
				ball = target;
				var diffX = ball.x - ball.startX;
				var diffY = ball.y - ball.startY;
				ball.rect1.x = ball.rect1.startX + diffX;
				ball.rect1.y = ball.rect1.startY + diffY;
				ball.rect2.x = ball.rect2.startX + diffX;
				ball.rect2.y = ball.rect2.startY + diffY;
			} else { // pressmove on control
				var rect = target;
				var other = rect.other; // the other handle
				ball = rect.ball;
				var index = ball.index;
				var type = controlType;
				if (!zot(_points[index][4])) type = _points[index][4];
				if (type == "straight" || type == "mirror") {
					var dX = rect.x - ball.x;
					var dY = rect.y - ball.y;
					if (type == "mirror") {
						other.x = ball.x - dX;
						other.y = ball.y - dY;
					} else {
						var a = Math.atan2(dY, dX);
						var dNewX = -other.stickLength * Math.cos(a+Math.PI);
						var dNewY = -other.stickLength * Math.sin(a+Math.PI);
						other.x = ball.x - dNewX;
						other.y = ball.y - dNewY;
					}
				}
			}
		};

		Object.defineProperty(that, 'move', {
			get: function() {
				return move;
			},
			set: function(value) {
				if (move != value) {
					move = value;
					if (value) {
						startDragging();
					} else {
						stopDragging();
					}
				}
			}
		});

		Object.defineProperty(that, 'interactive', {
			get: function() {
				return interactive;
			},
			set: function(value) {
				interactive = value;
				_controls = interactive;
				that.allowToggle = interactive;
				that.editPoints = interactive;
				that.lockControls = !interactive; // note negative
				that.selectPoints = interactive;
				that.move = interactive;
				var p = that.points; // force remake
				that.points = p;
			}
		});

		Object.defineProperty(that, 'allowToggle', {
			get: function() {
				return allowToggle;
			},
			set: function(value) {
				if (allowToggle != value) {
					allowToggle = value;
					if (allowToggle) {
						if (that.move) startDragging();
					} else {
						if (!_controls && that.move) stopDragging();
					}
				}
			}
		});

		function startDragging() {
			if (that.move=="always") return;
			if (draggingCheck) return;
			draggingCheck = true;
			shape.drag({onTop:false});
			moveDownEvent = shape.on("mousedown", moveDownEvent);
			movePressEvent = shape.on("pressmove", movePressEvent);
			moveUpEvent = shape.on("pressup", moveUpEvent);
		}
		function stopDragging(making) {
			if (that.move=="always") return;
			if (!making && !draggingCheck) return;
			draggingCheck = false;
			shape.noDrag();
			shape.off("mousedown", moveDownEvent);
			shape.off("pressmove", movePressEvent);
			shape.off("pressup", moveUpEvent);
		}

		Object.defineProperty(that, 'controlsVisible', {
			get: function() {
				return _controls;
			},
			set: function(value) {
				_controls = value;
				if (value) {
					that.showControls();
				} else {
					that.hideControls();
				}
			}
		});

		var _lockControls = lockControls;
		Object.defineProperty(that, 'lockControls', {
			get: function() {
				return _lockControls;
			},
			set: function(value) {
				_lockControls = value;
				if (value) {
					that.controls.mouseChildren = false;
					that.controls.mouseEnabled = false;
				} else {
					that.controls.mouseChildren = true;
					that.controls.mouseEnabled = true;
				}
			}
		});
		that.lockControls = _lockControls;

        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
        // NOTE: extends ZIM CustomShape for more properties and a few functions.
        // ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (that.selectPoints && !zim.KEYFOCUS) setFocus();
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}


		Object.defineProperty(that, 'points', {
			get: function() {
				var points = [];
				var point; var p;
				for (var i=0; i<_points.length; i++) {
					p = _points[i];
					point = [
						zim.decimals(p[0].x),
						zim.decimals(p[0].y),
						zim.decimals(p[1].x),
						zim.decimals(p[1].y),
						zim.decimals(p[2].x),
						zim.decimals(p[2].y),
						zim.decimals(p[3].x),
						zim.decimals(p[3].y)
					];
					if (p[4] && p[4]!=="straight") point.push(p[4]);
					points.push(point);
				}
				return points;
			},
			set: function(value) {
				var x = that.x;
				var y = that.y;
				var v = that.visible;
				var tList = [];
				var tCheck = false;
				zim.loop(that.pointControls,function(p){
					if (p.scaleX+p.scaleY+p.regX+p.regY+p.rotation!=2) tCheck = true;
					tList.push([p.scaleX,p.scaleY,p.regX,p.regY,p.rotation]);
				});
				that.dispose(true);
				points = checkForShape(value);
				if (that.shape) {
					that.shape.graphics.clear();
					that.sticks.graphics.clear();
					that.controls.noDrag();
					that.removeAllChildren();
					delete that.shape;
					delete that.sticks;
					delete that.controls;
				}
				that.visible = false;
				init(); // remake Blob				
				that.lockControls = _lockControls;
				that.x = x;
				that.y = y;
				that.visible = v;
				if (tCheck) {
					zim.loop(that.pointControls,function(p,i){					
						p.scaleX = tList[i][0];
						p.scaleY = tList[i][1];
						p.regX = tList[i][2];
						p.regY = tList[i][3];
						p.rotation = tList[i][4];
					
					});
					that.update();
				}
			}
		});

		Object.defineProperty(that, 'pointsAdjusted', { // points with rotation
			get: function() {
				var points = [];
				var point; var p; var po;
				var pObjects = that.pointObjects;
				zim.loop(pObjects.length, function(i) {
					po = pObjects[i];
					p = _points[i];
					if (po[0].rotation==0 && po[0].scaleX==0 && po[0].scaleY==0) { // get points
						point = [
							zim.decimals(p[0].x),
							zim.decimals(p[0].y),
							zim.decimals(p[1].x),
							zim.decimals(p[1].y),
							zim.decimals(p[2].x),
							zim.decimals(p[2].y),
							zim.decimals(p[3].x),
							zim.decimals(p[3].y)
						];
					} else {
						var lo1 = po[0].localToLocal(po[2].x, po[2].y, po[0].parent);
						var lo2 = po[0].localToLocal(po[3].x, po[3].y, po[0].parent);
						point = [
							zim.decimals(p[0].x),
							zim.decimals(p[0].y),
							zim.decimals(p[1].x),
							zim.decimals(p[1].y),
							zim.decimals(lo1.x-p[0].x),
							zim.decimals(lo1.y-p[0].y),
							zim.decimals(lo2.x-p[0].x),
							zim.decimals(lo2.y-p[0].y)
						];
					}
					if (p[4] && p[4]!=="mirror") point.push(p[4]);
					points.push(point);
				});
				return points;
			},
			set: function() {
				if (zon) zogy("Blob() - pointsAdjusted is read only");
			}
		});

		Object.defineProperty(that, 'pointObjects', {
			get: function() {
				return _points;
			},
			set: function() {
				if (zon) {zogy("Blob() - pointObjects is read only - but its contents can be manipulated - use blob.update() after changes");}
			}
		});

		Object.defineProperty(that, 'pointControls', {
			get: function() {
				return _pointControls;
			},
			set: function() {
				if (zon) {zogy("Blob() - pointControls is read only - but its contents can be manipulated - use blob.update() after changes");}
			}
		});

		Object.defineProperty(that, 'pointCircles', {
			get: function() {
				return _pointCircles;
			},
			set: function() {
				if (zon) {zogy("Blob() - pointCircles is read only - but its contents can be manipulated - use blob.update() after changes");}
			}
		});

		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// path manipulation and animating to path methods

		Object.defineProperty(that, 'segmentPoints', {
			get: function() {
				var p = that.pointsAdjusted;
				var array = []; // array of prepared segment points
				zim.loop(p.length, function(i, t) {
					var s = that.getSegmentPoint(p[i], p[i<t-1?i+1:0]);
					array.push(s);
				});
				return array;
			},
			set: function() {
				if (zon) {zogy("Blob() - segmentPoints is read only");}
			}
		});

		Object.defineProperty(that, 'segmentRatios', {
			get: function() {
				var distances = [];
				var total = 0;
				zim.loop(that.segmentPoints, function(points) {
					var d = zim.distanceAlongCurve(points);
					distances.push(d);
					total += d;
				});
				var percents = [];
				var totalPercents = 0;
				zim.loop(distances, function (d) {
					var p = d/total;
					totalPercents += p;
					percents.push(totalPercents);
				});
				return percents;
			},
			set: function() {
				if (zon) {zogy("Blob() - segmentRatios is read only");}
			}
		});

		that.approximateBounds = function(num, showPoints) {
			if (zot(num)) num = 80;
			num /= that.num;
			var points = that.interpolate(num, null, true, null, true);
			var bounds = zim.boundsAroundPoints(points);
			that.setBounds(bounds.x, bounds.y, bounds.width, bounds.height);
			if (showPoints) {
				if (!that.parent) {
					if (zon) zogy("approximateBounds() - add to stage to first to see points");
					return that;
				}
				if (!that.hitPathPoints) that.hitPathPoints = new zim.Container().addTo();
				else that.hitPathPoints.removeAllChildren();
				that.hitPathPoints.top();
				for (var i=0; i<points.length; i++) {
					var point = points[i];
					point = that.localToGlobal(point.x, point.y);
					new zim.Circle(3).loc(point.x, point.y, that.hitPathPoints);
				}
			}
			return that;
		};		

		that.getPointAngle = function(index) {
			var p = that.pointObjects[index][0]; // parent
			var r1 = that.pointObjects[index][2];
			var r2 = that.pointObjects[index][3];
			var globalR1, globalR2;
			if (p==that.stage) {
				globalR1 = new zim.Point(r1.x, r1.y);
				globalR2 = new zim.Point(r2.x, r2.y);
			} else {
				globalR1 = p.localToGlobal(r1.x, r1.y);
				globalR2 = p.localToGlobal(r2.x, r2.y);
			}
			return zim.angle(globalR1.x, globalR1.y,globalR2.x, globalR2.y);
		};

		that.getSegmentPoint = function(point1, point2) {
			if (zot(point1) || zot(point2)) return;
			// dragging points temporarily puts data out of order
			if (point1[2] != 0 || point1[3] != 0) {
				point1[4] -= point1[2];
				point1[5] -= point1[3];
				point1[6] -= point1[2];
				point1[7] -= point1[3];
				point1[0] += point1[2];
				point1[1] += point1[3];
				point1[2] = 0;
				point1[3] = 0;
			}
			if (point2[2] != 0 || point2[3] != 0) {
				point2[4] -= point2[2];
				point2[5] -= point2[3];
				point2[6] -= point2[2];
				point2[7] -= point2[3];
				point2[0] += point2[2];
				point2[1] += point2[3];
				point2[2] = 0;
				point2[3] = 0;
			}
			var p1 = {x:point1[0], y:point1[1]};
			var p2 = {x:point1[0]+point1[6], y:point1[1]+point1[7]};
			var p3 = {x:point2[0]+point2[4], y:point2[1]+point2[5]};
			var p4 = {x:point2[0], y:point2[1]};
			if (sets.x != 0 || sets.y !=0) {
				p1.x+=sets.x;
				p2.x+=sets.x;
				p3.x+=sets.x;
				p4.x+=sets.x;
				p1.y+=sets.y;
				p2.y+=sets.y;
				p3.y+=sets.y;
				p4.y+=sets.y;
			}
			return [p1,p2,p3,p4];
		};

		that.getAdjacentSegmentData = function(index) {
			if (zot(index)) index = 0;
			var p = that.pointsAdjusted;
			if (that.num == 2) {
				return [
					[that.getSegmentPoint(p[0], p[1]),
					that.getSegmentPoint(p[1], p[0])],
					[0,1]
				];
			}
			if (index == 0) {
				return [
					[that.getSegmentPoint(p[that.num-1], p[0]),
					that.getSegmentPoint(p[0], p[1]),
					that.getSegmentPoint(p[1], p[2])],
					[that.num-1,0,1]
				];
			} else if (index >= that.num-1) {
				return [
					[that.getSegmentPoint(p[that.num-2], p[that.num-1]),
					that.getSegmentPoint(p[that.num-1], p[0]),
					that.getSegmentPoint(p[0], p[1])],
					[that.num-2,that.num-1,0]
				];
			} else {
				var lastIndex = (index+2>=that.num)?0:index+2;
				return [
					[that.getSegmentPoint(p[index-1], p[index]),
					that.getSegmentPoint(p[index], p[index+1]),
					that.getSegmentPoint(p[index+1], p[lastIndex])],
					[index-1,index,index+1]
				];
			}
		};

		that.getCurvePoint = function(ratio, segmentRatios, segmentPoints, getAngle) {
			if (zot(segmentRatios)) segmentRatios = that.segmentRatios;
			if (zot(segmentPoints)) segmentPoints = that.segmentPoints;
			if (zot(getAngle)) getAngle = false;
			var percents = segmentRatios;
			var segments = segmentPoints;
			var afterIndex = zim.loop(percents, function (p, i) {
				if (p >= ratio) return i;
			});
			var earlierPercent = afterIndex > 0 ? percents[afterIndex-1] : 0;
			var localTotal = afterIndex > 0 ? (percents[afterIndex]-percents[afterIndex-1]):percents[afterIndex];
			var localPercent = (ratio-earlierPercent)/localTotal;
			var finalPoint = zim.pointAlongCurve(segments[afterIndex], localPercent, getAngle, true);
			if (zot(finalPoint)) return undefined;
			var finalFinalPoint = that.localToGlobal(finalPoint.x, finalPoint.y);
			finalFinalPoint.angle = finalPoint.angle;
			finalFinalPoint.z = afterIndex;
			return !zot(finalFinalPoint) ? finalFinalPoint : undefined;
		};

		function proportion(p1, p2, ratio) {
			return {
				x:p1.x + (p2.x-p1.x)*ratio,
				y:p1.y + (p2.y-p1.y)*ratio
			};
		}
		function insertPointData(points, controls, ratios, percent, controlType, skipPoint, dataOnly, even) {
			var index = points.length-1; // adjust for squiggle
			var lastRatio = 0;
			var currentRatio = 0;
			if (percent == 100 && that.type == "Squiggle") percent = 99.99;
			percent = (percent+100000)%100;

			zim.loop(ratios, function (ratio, i) {
				if (percent/100 < ratio) {
					index = i;
					currentRatio = ratio;
					return true;
				}
				lastRatio = ratio;
			});
			var segment = that.segmentPoints[index];
			var r = currentRatio > 0?(percent/100-lastRatio)/(currentRatio-lastRatio):0;
			// zog(percent)
			// zog(percent/100-currentRatio/ratios.length)
			// var r = currentRatio > 0?(percent/100-1/ratios.length*currentRatio)/(currentRatio-lastRatio):0

			var point = zim.pointAlongCurve(segment, r, null, even);
			var newPoint = [point.x,point.y, 0, 0];
			if (skipPoint) return;
			if (dataOnly) {
				that.interpolatedPoints.push({x:point.x, y:point.y, r:percent/100});
				return;
			}
			if (controlType != "none") {
				// calculate new handles and adjust old handles
				// [controlX, controlY, circleX, circleY, rect1X, rect1Y, rect2X, rect2Y, controlType]
				var startHandle = proportion(segment[0], segment[1], r);
				var midPoint = proportion(segment[1], segment[2], r);
				var endHandle = proportion(segment[2], segment[3], r);
				var newStartHandle = proportion(startHandle, midPoint, r);
				var newEndHandle = proportion(midPoint, endHandle, r);
				newPoint[4] = newStartHandle.x-point.x;
				newPoint[5] = newStartHandle.y-point.y;
				newPoint[6] = newEndHandle.x-point.x;
				newPoint[7] = newEndHandle.y-point.y;
				var start = that.localToLocal(startHandle.x, startHandle.y, controls[index]);
				points[index][6] = start.x;
				points[index][7] = start.y;
				var end = that.localToLocal(endHandle.x, endHandle.y, controls[(index+1)%points.length]);
				points[(index+1)%points.length][4] = end.x;
				points[(index+1)%points.length][5] = end.y;
			}
			if (controlType) newPoint[8] = controlType;
			
			points.splice(index+1, 0, newPoint);
			return index+1;
		}

		this.addPoint = function(percent, controlType) {
			if (zot(percent)) percent = 100;
			var points = that.points;
			var ratios = that.segmentRatios;
			var controls = that.pointControls;
			controlType = controlType ? controlType : originalControlType;
			var index = insertPointData(points, controls, ratios, percent, controlType);
			that.points = points;
			that.num = points.length;
			return index;
		};

		this.removePoint = function(index) {	
			if (zot(index) || index < 0) return;		
			var currentPoints = zim.copy(that.points);
			currentPoints.splice(index, 1);
			that.points = currentPoints;
			if (that.stage) that.stage.update();
			return that;
		}

		this.addPoints = function(num, controlType, startPoint, spread, dataOnly, points, even) {
			if (zot(points)) points = zim.copy(that.points);
			var ratios = zim.copy(that.segmentRatios);
			var lastRatio = 0;

			if (dataOnly) that.interpolatedPoints = [];

			// dataOnly should add points to current point too
			// but can't just use current point because sometimes that is static
			// like when dragging the shape or a point - it does not register until mouseup
			// and things like hitTestPath need that to be dynamic
			// So the below does not work:
			// if (dataOnly) {
			// 	that.interpolatedPoints = [];
			// 	zim.loop(points, function (point, i) {
			// 		if (!zot(startPoint) && i!=startPoint) return;
			// 		that.interpolatedPoints.push({x:point[0], y:point[1]})
			// 	});
			// }
			if (spread) var totalPoints = ratios.length*num;
			zim.loop(ratios, function (ratio, j) {
				if (dataOnly) insertPointData(points, that.pointControls, that.segmentRatios, lastRatio*100, controlType, !zot(startPoint) && j!=startPoint, dataOnly, even);
				var numCount = spread?Math.round(totalPoints*(ratio-lastRatio)):num;
				var div = 1/(numCount+1);
				zim.loop(numCount, function(i) {
					var r = lastRatio + (ratio-lastRatio)*div*(i+1);
					insertPointData(points, that.pointControls, that.segmentRatios, r*100, controlType, !zot(startPoint) && j!=startPoint, dataOnly, even);
					if (!dataOnly && num > 0) that.points = points;
				});
				lastRatio = ratio;
			});
			if (dataOnly && that.type == "Squiggle") insertPointData(points, that.pointControls, that.segmentRatios, 100, controlType, null, dataOnly, even);
			if (that.stage) that.stage.update();
			that.num = points.length;
			return that;
		};
		this.interpolate = function(num, startPoint, spread, points, even) {
			if (zot(num)) num = 1;
			// dataOnly will add Point to start point too
			that.addPoints(num, "none", startPoint, spread, true, points, even);
			return that.interpolatedPoints;
		};		
		if (approxCheck) that.approximateBounds();

		this.dispose = function(temp, d, disposing) {
			if (!that.shape) return;
			zim.gD(that); // globalDispose function for common elements			
			if (stage && that.toggleStageEvent) stage.off("stagemousedown", that.toggleStageEvent);
			that.controls.noDrag();	// sets	
			that.controls.removeAllEventListeners();			
			if (that.selectPoints && that.selectionManager) that.selectionManager.dispose();
			that.selectedBalls = null;
			that.selectedRect1s = null;
			that.selectedRect2s = null;
			that.selectionManager = null;
			
			that.off("mousedown", that.toggleEvent);
			that.off("click", that.clickEvent);		
					
			if (temp) {
				that.shape.dispose();				
				that.shape = null;				
				for (var i=0; i<that.points.length; i++) {
					that.pointObjects[i][0].removeAllEventListeners();
					that.pointObjects[i][1].removeAllEventListeners();
					that.pointObjects[i][2].removeAllEventListeners();
					that.pointObjects[i][3].removeAllEventListeners();
				}
				that.controls.removeFrom(that);
				that.sticks.dispose();
				_points = null;
				_pointCircles = null;
			} else {
				that.removeAllEventListeners();	
				_points = null;
				_pointCircles = null;				
				if (!disposing) this.zimCustomShape_dispose(true);				
			}
			return true;
			
		};
	};
	zim.extend(zim.Blob, zim.CustomShape, ["clone", "dispose"], "zimCustomShape", false);
	zimBlob = zim.Blob; // used in export so we do not obscure the JS Blob
	//-53.5


/*--
zim.Flare = function(color, borderColor, borderWidth, crossAngle, thickness, thicknessA, thicknessB, pin, startX, startY, lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close, dashed, strokeObj, spineColor, spineBorderWidth, spineBorderColor, spineDashed, spineStrokeObj, closeColor, closeBorderWidth, closeBorderColor, closeDashed, closeStrokeObj, style, group, inherit)

Flare
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a flare shape - a shape with a gradual widening like flared pants or skirts.
The shape defaults to a horizontal rectangle flared outwardly to the right.
The flare angleA and angleB can be specified at any angle negative or positive.
The flare axis or spine can be at any angle to the horizontal positive in the x.
The cross or end angles can be specified relative to a normal the spine so 0 is -90.
Different color and border options are available and editable as properties.

More than one flare can be created in the same shape - these are called segments.
Multiple Flare objects can be easily combined into a ZIM MultiFlare
and a special FlareBox can be used to place flares or multiFlares around a rectangle
to be used for backings on buttons, pictures, etc.

See https://zimjs.com/ten/flare.html for examples of a 3D wall, a rocket and a button frame

NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Flare().center();

// a Rocket
const rocket = new Flare({
	thickness:100,
	angles:-90, // all segment angles will point up
	lengths:[40,.5,100,150,105],
	anglesA:[-20,89,-12,0,-22], // anglesB will be mirrored by default
	color:new GradientColor([dark,silver,dark],[.1,.6,.9],-50,0,50,0),
	cross:true // add a line at segment borders
}).center();

// see also MultiFlare and FlareBox examples
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)

color - (default black) the color of the flare
	if null and a border is speficied the color will be transparent
borderColor - (default null) the stroke color
borderWidth - (default 1 if stroke is set) the size of the stroke in pixels
crossAngle - (default 0) the angle from the normal of the spine
	so if the spine goes to the right at 0 degrees then 0 crossAngle starts at -90 and goes positive clockwise
	a crossAangle of -45 would look like a picture frame bevel
	if the flare starts at the top left corner of a rectangle
thickness - (default 20) the thickness at the start of the flare assuming 0 crossAngle
	this will be divided evenly to thicknessA on one side of the spine and thicknessB on the other side of the spine
thicknessA - (default null) - will be set to half the thickness if thicknessB is not set otherwise thickness-thicknessB
thicknessB - (default null) - will be set to half the thickness if thicknessA is not set otherwise thickness-thicknessA
pin - (default null) - set to a segment number to set registration point at the start of the segment
	Pin is used with MultiFlare to align flares at pinned segments
	Pin is used with FlareBox to place pinned segments at any of the four corners of the box
	When doing so, the Flare will be automatically rotated (corner number - pin number) * 90
	This can be overriden by rotating the flare to the desired rotation after creation
startX - (default 0) shift the start of the flare in the x from the registration point (note, pin will reset registration)
startY - (default 0) shift the start of the flare in the y from the registration point (note, pin will reset registration)
lengths - (default [200]) an array of spine lengths
angles - (default [0]) an array of angles (degrees) for the spines relative to 0 along the positive x axis
anglesA - (default [10]) an array of relative angles to the left of the current spine when heading along the spine
	so if the spine heads to the right, angleA is positive from the spine upwards
	think of these as how much the shape flares out from the spine on one side
anglesB - (default anglesA) an array of relative angles to the right of the current spine when heading along the spine
	so if the spine heads to the right, angleB is positive from the spine downwards
	think of these as how much the shape flares out from the spine on another side
anglesEnd - (default [0]) an array of angles at the end of each segment from the normal of each segment spine
	so if the spine goes to the right at 0 degrees then a 0 anglesEnd is perpendicular to the spine
	an anglesEnd of 45 would look like a picture frame bevel
	as the segments are placed around the picture frame clockwise
	note: end angles greatly change the look of flared segments
		poorly chosen angles can lead to flares crossing or massively diverging
		good choices depend on the length of the flares, the spine angles and the flare angles
		generally, a trial and error technique is the easiest to find the desired solution
cross - (default true) draw a crossing line at each segment - this draws each segment as a closed path
crossColors - (default null) an array of colors for each segment if cross is true
close - (default false) join the end of the last segment to the start of the first segment
dashed - (default false) set the dashed of the border if the borderColor or borderWidth is specified
strokeObj - (default {caps:"butt", joints:"miter", miterLimit:2, ignoreScale:false}) set to adjust stroke properties
	caps options: "butt", "round", "square" or 0,1,2
	joints options: "miter", "round", "bevel" or 0,1,2
	miterLimit is the ration at which the mitered joint will be clipped
	ignoreScale set to true will draw the specified line thickness regardless of object scale
spineColor - (default null) as the spine is drawn, fill the shape it makes with this color
	this can create a picture frame effect as the spine color may hide half the flare for each segment
spineBorderWidth - (default null) the width of the spine
spineBorderColor - (default null) the color of the actual spine
spineDashed - (default false) set to true for dashed spine (if spineBorderWidth or spineBorderColor set)
spineStrokeObj - (default strokeObject) see strokeObject parameter for details
closeColor - (default color) the color of the segment created if closing the flare
closeBorderWidth - (default borderWidth) the borderWidth of the closing segment if closing the flare
closeBorderColor - (default borderColor) the borderColor of the closing segment if closing the flare
closeDashed - (default false) set to true for dashed closed segment (if closeBorderWidth or closeBorderColor set)
closeStrokeObj - (default strokeObject) see strokeObject parameter for details
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close) |ZIM DUO| - add segment(s) to the Flare - returns object for chaining
	see segment parameters for details - returns object for chaining
remake() - remake the Flare segments after setting properties
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy of the shape
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
shape - access to the ZIM Shape for the flare(s)
spineShape - access to the ZIM Shape for the spine if spine is true
closeShape - access to the ZIM Shape for the closing segment if close is true
pin - get or set the pin number - which spine has the registration point
	see the pin parameter for more details
points - access to array of flare shape points {x,y}
 	if not close - around outside then around inside
	if close - around each segment
pinPoints - access to array of spine points {x,y} and then to final end spine point
color - get and set the fill color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
borderColor - get and set the stroke color
borderWidth - get and set the stroke size in pixels
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
closeColor - get and set the fill color of the close segment
closeBorderColor - get and set the stroke color of the close segment
closeBorderWidth - get and set the stroke size in pixels of the close segment
closeBorderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
spineColor - get and set the fill color of the spine shape
spineBorderColor - get and set the stroke color of the spine shape
spineBorderWidth - get and set the stroke size in pixels of the spine shape
spineBorderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html

** the following properties can be read or changed
** if changed, the remake() method must be run to see changes
** see the Flare parameters for definitions
thicknessA - number
thicknessB - number
cross - boolean
close - boolean
lengths - array
angles - array
anglesA - array
anglesB - array
anglesEnd - array
crossColors - array
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53.6
	zim.Flare = function(color, borderColor, borderWidth, crossAngle, thickness, thicknessA, thicknessB, pin, startX, startY, lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close, dashed, strokeObj, spineColor, spineBorderWidth, spineBorderColor, spineDashed, spineStrokeObj, closeColor, closeBorderWidth, closeBorderColor, closeDashed, closeStrokeObj, style, group, inherit) {
		var sig = "color, borderColor, borderWidth, crossAngle, thickness, thicknessA, thicknessB, pin, startX, startY, lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close, dashed, strokeObj, spineColor, spineBorderWidth, spineBorderColor, spineDashed, spineStrokeObj, closeColor, closeBorderWidth, closeBorderColor, closeDashed, closeStrokeObj, style, group, inherit";
		var duo; if (duo = zob(zim.Flare, arguments, sig, this)) return duo;
		z_d("53.6");
		this.zimContainer_constructor();
		this.type = "Flare";
		this.group = group;

		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		var that = this;

		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.black);
		if (zot(borderWidth) || borderWidth > 0) { // no border specified or a border > 0
			if (!zot(borderColor) || !zot(borderWidth)) { // either a border color or thickness
				if (zot(borderColor)) borderColor = zim.black;
			}
		}

		if (zot(crossAngle)) crossAngle = DS.crossAngle!=null?DS.crossAngle:0;
		var crossAngleOriginal = crossAngle;
		crossAngle -= 90;

		if (zot(thickness)) thickness = DS.thickness!=null?DS.thickness:null;
		if (zot(thicknessA)) thicknessA = DS.thicknessA!=null?DS.thicknessA:null;
		if (zot(thicknessB)) thicknessB = DS.thicknessB!=null?DS.thicknessB:null;
		if (zot(thickness)) {
			if (zot(thicknessB) && !zot(thicknessA)) thicknessB = thicknessA;
			else if (zot(thicknessA) && !zot(thicknessB)) thicknessA = thicknessB;
			else thicknessB = thicknessA = 10;
		} else {
			if (zot(thicknessB) && !zot(thicknessA)) thicknessB = thickness-thicknessA;
			else if (zot(thicknessA) && !zot(thicknessB)) thicknessA = thickness-thicknessB;
			else thicknessB = thicknessA = thickness/2;
		}
		that.thickness = thicknessA + thicknessB; // read-only
		// from now on - do not use thickness

		if (zot(cross)) cross =DS.cross!=null?DS.cross:true;
		if (zot(crossColors)) crossColors =DS.crossColors!=null?DS.crossColors:null;
		if (!zot(crossColors) && !Array.isArray(crossColors)) crossColors = [crossColors];
		if (zot(close)) close = DS.close!=null?DS.close:false;

		if (zot(startX)) startX = DS.startX!=null?DS.startX:0;
		if (zot(startY)) startY = DS.startY!=null?DS.startY:0;

		// lengths, angles, anglesA, anglesB, anglesEnd
		if (zot(lengths)) lengths = DS.lengths!=null?DS.lengths:[200];
		if (!Array.isArray(lengths)) lengths = [lengths];
		if (zot(angles)) angles = DS.angles!=null?DS.angles:[0];
		if (!Array.isArray(angles)) angles = [angles];
		if (zot(anglesA)) anglesA = DS.anglesA!=null?DS.anglesA:[10];
		if (!Array.isArray(anglesA)) anglesA = [anglesA];
		if (zot(anglesB)) anglesB = DS.anglesB!=null?DS.anglesB:zim.copy(anglesA);
		if (!Array.isArray(anglesB)) anglesB = [anglesB];
		if (zot(anglesEnd)) anglesEnd = DS.anglesEnd!=null?DS.anglesEnd:[0];
		if (!Array.isArray(anglesEnd)) anglesEnd = [anglesEnd];
		if (zot(strokeObj)) strokeObj = DS.strokeObj!=null?DS.strokeObj:{miterLimit:2};

		if (zot(spineBorderColor)) spineBorderColor = DS.spineBorderColor!=null?DS.spineBorderColor:null;
		if (zot(spineBorderWidth)) spineBorderWidth = DS.spineBorderWidth!=null?DS.spineBorderWidth:null;
		if (spineBorderColor < 0 || spineBorderWidth < 0) spineBorderColor = spineBorderWidth = null;
		else if (spineBorderColor!=null && spineBorderWidth==null) spineBorderWidth = 1;
		if (zot(spineColor)) spineColor = DS.spineColor!=null?DS.spineColor:(spineBorderWidth>0?"rgba(0,0,0,0)":zim.black);
		if (zot(spineDashed)) spineDashed = DS.spineDashed!=null?DS.spineDashed:null;
		if (zot(spineStrokeObj)) spineStrokeObj = DS.spineStrokeObj!=null?DS.spineStrokeObj:{miterLimit:2};
		if (zot(spineBorderWidth) || spineBorderWidth > 0) {
			if (!zot(spineBorderColor) || !zot(spineBorderWidth)) {
				if (zot(spineBorderColor)) spineBorderColor = borderColor?borderColor:zim.black;
			}
		}

		if (zot(closeBorderColor)) closeBorderColor = DS.closeBorderColor!=null?DS.closeBorderColor:null;
		if (zot(closeBorderWidth)) closeBorderWidth = DS.closeBorderWidth!=null?DS.closeBorderWidth:null;
		if (closeBorderColor < 0 || closeBorderWidth < 0) closeBorderColor = closeBorderWidth = null;
		else if (closeBorderColor!=null && closeBorderWidth==null) closeBorderWidth = 1;
		if (zot(closeColor)) closeColor = DS.closeColor!=null?DS.closeColor:(closeBorderWidth>0?"rgba(0,0,0,0)":null);
		if (zot(closeDashed)) closeDashed = DS.closeDashed!=null?DS.closeDashed:null;
		if (zot(closeStrokeObj)) closeStrokeObj = DS.closeStrokeObj!=null?DS.closeStrokeObj:{miterLimit:2};
		if (zot(closeBorderWidth) || closeBorderWidth > 0) {
			if (!zot(closeBorderColor) || !zot(closeBorderWidth)) {
				if (zot(closeBorderColor)) closeBorderColor = borderColor?borderColor:zim.black;
			}
		}

		this.thicknessA = thicknessA;
		this.thicknessB = thicknessB;
		this.cross = cross;
		this.close = close;
		this.lengths = lengths;
		this.angles = angles;
		this.anglesA = anglesA;
		this.anglesB = anglesB;
		this.anglesEnd = anglesEnd;
		this.crossColors = crossColors;

		drawShape(lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close);
		if (color.type) that.color = color;
		function drawShape(lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close) {
			that.removeAllChildren();

			var s = that.shape = new zim.Shape().addTo(that);
			that.colorCommand = s.c().f(color).command;
			if (color && color.type) that.specialColor(that.colorCommand, color, that);
			if (zot(borderWidth) || borderWidth > 0) {
				if (!zot(borderColor) || !zot(borderWidth)) {
					if (zot(borderColor)) borderColor = zim.black;
					that.borderColorCommand = s.s(borderColor).command;
					if (borderColor && borderColor.type) that.specialColor(that.borderColorCommand, borderColor, that);
					that.borderWidthCommand = s.ss(borderWidth, strokeObj.caps, strokeObj.joints, strokeObj.miterLimit, strokeObj.ignoreScale).command;
					if (dashed) that.borderDashedCommand = s.sd([10, 10], 5).command;
				}
			}
			s.mt(0,0);

			if (spineBorderWidth > 0) {
				var spineS = that.spineShape = new zim.Shape().addTo(that);
				that.spineColorCommand = spineS.c().f(spineColor).command;
				if (spineColor && spineColor.type) that.specialColor(that.spineColorCommand, spineColor, that);
				if (zot(spineBorderWidth) || spineBorderWidth > 0) {
					if (!zot(spineBorderColor) || !zot(spineBorderWidth)) {
						if (zot(spineBorderColor)) spineBorderColor = zim.black;
						that.spineBorderColorCommand = spineS.s(spineBorderColor).command;
						if (spineBorderColor && spineBorderColor.type) that.specialColor(that.spineBorderColorCommand, spineBorderColor, that);
						that.spineBorderWidthCommand = spineS.ss(spineBorderWidth, spineStrokeObj.caps, spineStrokeObj.joints, spineStrokeObj.miterLimit, spineStrokeObj.ignoreScale).command;
						if (spineDashed) that.spineBorderDashedCommand = spineS.sd([10, 10], 5).command;
					}
				}
			}

			if (!zot(closeColor)) {
				var closeS = that.closeShape = new zim.Shape().addTo(that);
				that.closeColorCommand = closeS.c().f(closeColor).command;
				if (closeColor && closeColor.type) that.specialColor(that.closeColorCommand, closeColor, that);
				if (zot(closeBorderWidth) || closeBorderWidth > 0) {
					if (!zot(closeBorderColor) || !zot(closeBorderWidth)) {
						if (zot(closeBorderColor)) closeBorderColor = zim.black;
						that.closeBorderColorCommand = closeS.s(closeBorderColor).command;
						if (closeBorderColor && closeBorderColor.type) that.specialColor(that.closeBorderColorCommand, closeBorderColor, that);
						that.closeBorderWidthCommand = closeS.ss(closeBorderWidth, closeStrokeObj.caps, closeStrokeObj.joints, closeStrokeObj.miterLimit, closeStrokeObj.ignoreScale).command;
						if (closeDashed) that.closeBorderDashedCommand = closeS.sd([10, 10], 5).command;
					}
				}
				s.mt(0,0);
			}

			// start values
			var sX = startX;
			var sY = startY;
			var f2 = crossAngle;
			var f = f2-180;
			var tA = thicknessA;
			var tB = thicknessB;
			var num = Math.max(lengths.length, angles.length, anglesA.length, anglesB.length, anglesEnd.length);
			var lastB, lastC;
			var lastAngle = f;
			var pointsA = [];
			var pointsB = [];
			var pointsC = [];
			that.points = [];
			var spines = that.pinPoints = [];
			zim.loop(num, function(i) {
				var data = getSegment(i);
				var cosine = Math.cos(data.a*zim.RAD);
				var sine = Math.sin(data.a*zim.RAD);

				var AA = new zim.Point(sX+data.A.x*cosine-data.A.y*sine, sY+data.A.x*sine+data.A.y*cosine);
				var BB = new zim.Point(sX+data.B.x*cosine-data.B.y*sine, sY+data.B.x*sine+data.B.y*cosine);
				var CC = new zim.Point(sX+data.C.x*cosine-data.C.y*sine, sY+data.C.x*sine+data.C.y*cosine);
				var DD = new zim.Point(sX+data.D.x*cosine-data.D.y*sine, sY+data.D.x*sine+data.D.y*cosine);
				pointsA.push(AA,BB);
				pointsB.unshift(CC,DD);
				pointsC.push([AA,BB,CC,DD]); // for cross

				var FF = new zim.Point(sX+data.F.x*cosine-data.F.y*sine, sY+data.F.x*sine+data.F.y*cosine);
				var EE = new zim.Point(sX+data.E.x*cosine-data.E.y*sine, sY+data.E.x*sine+data.E.y*cosine);

				if (i==0) that.pinPoints.push(FF);
				that.pinPoints.push(EE);

				sX = EE.x;
				sY = EE.y;

				tA = data.tA;
				tB = data.tB;
			});

			that.points = pointsA.concat(pointsB);

			if (!cross) {
				zim.loop(pointsA, function (point, i) {
					if (i==0) s.mt(point.x, point.y);
					else s.lt(point.x, point.y);
				});
				if (close) {
					s.lt(pointsA[0].x, pointsA[0].y);
					s.cp();
				}
				zim.loop(pointsB, function (point, i) {
					if (i==0 && close) s.mt(point.x, point.y);
					else s.lt(point.x, point.y);
				});
				if (close) {
					s.lt(pointsB[0].x, pointsB[0].y);
				}
				s.cp();
			} else {
				that.crossCommands = [];
				zim.loop(pointsC, function (points, i) {
					s   .mt(points[0].x, points[0].y);
					if (!zot(crossColors) && !zot(crossColors[i])) {
						s.f(crossColors[i]);
						that.crossCommands[i] = s.f(crossColors[i]).command;
						if (crossColors[i] && crossColors[i].type) that.specialColor(that.crossCommands[i], crossColors[i], that);
						s.mt(points[0].x, points[0].y);						
					}
					s   .lt(points[1].x, points[1].y)
						.lt(points[2].x, points[2].y)
						.lt(points[3].x, points[3].y)
						.cp();
				});
				if (close) {
					s   .mt(pointsC[pointsC.length-1][1].x, pointsC[pointsC.length-1][1].y)
						.lt(pointsC[pointsC.length-1][2].x, pointsC[pointsC.length-1][2].y)
						.lt(pointsC[0][3].x, pointsC[0][3].y)
						.lt(pointsC[0][0].x, pointsC[0][0].y)
						.cp();
				}
			}

			if (spineS) {
				zim.loop(spines, function (spine,i) {
					if (i==0) spineS.mt(spine.x, spine.y);
					else spineS.lt(spine.x, spine.y);
				});
				if (close) {
					spineS.lt(spines[0].x, spines[0].y).cp();
				}
			}

			if (!zot(closeColor)) {
				zim.loop(pointsB, function (point,i) {
					if (i==0) closeS.mt(point.x, point.y);
					else closeS.lt(point.x, point.y);
				});
				if (close) {
					closeS.lt(pointsB[0].x, pointsB[0].y).cp();
				}
			}


			// segment values
			function getSegment(num) {
				var a = angles[num];
				var d = lengths[num];
				var aA = anglesA[num];
				var aB = anglesB[num];
				var e = anglesEnd[num];
				if (crossColors) var cc = crossColors[num];
				if (zot(a)) {a = lastAngle; that.angles[num] = a;}
				if (zot(d)) {d = 200; that.lengths[num] = d;}
				if (zot(aA)) {aA = 0; that.anglesA[num] = aA;}
				if (zot(aB)) {aB = 0; that.anglesB[num] = aB;}
				if (zot(e)) {e = 0; that.anglesEnd[num] = e;}
				if (crossColors && zot(cc)) {cc = color; that.crossColors[num] = cc;}
				e = e+90;

				var e2 = 180-e;
				var cosine = Math.cos((lastAngle-a)*zim.RAD);
				var sine = Math.sin((lastAngle-a)*zim.RAD);

				// GOAL is to find points F, A, B, C, D, E
				var F = new zim.Point(0,0);
				var E = new zim.Point(d,0);

				if (zot(lastB)) {
					var A = new zim.Point(Math.cos(f2*zim.RAD)*tA, Math.sin(f2*zim.RAD)*tA);
				} else {
					A = new zim.Point(lastB.x*cosine-lastB.y*sine, lastB.x*sine+lastB.y*cosine);
				}

				var pA = getEnd(d, A.x, A.y, aA, e2);
				var B = new zim.Point(d-pA.x, -pA.y);

				var D;
				if (zot(lastC)) {
					D = new zim.Point(Math.cos(f*zim.RAD)*tA, Math.sin(f*zim.RAD)*tB);
				} else {
					D =  new zim.Point(lastC.x*cosine-lastC.y*sine, lastC.x*sine+lastC.y*cosine);
				}

				var pB = getEnd(d, D.x, D.y, aB, e);
				var C = new zim.Point(d-pB.x, pB.y);

				lastB = new zim.Point(B.x-d, B.y);
				lastC = new zim.Point(C.x-d, C.y);
				lastAngle = a;

				// all the points, next start thickness AB
				return {a:a, A:A, B:B, C:C, D:D, E:E, F:F, tA:pA.t, tB:pB.t};
			}

			function getEnd(dist, frontX, frontY, flare, endAngle) {
				var u = endAngle-90;
				var w = 90-u;
				var v = 180-flare-w;

				var n = Math.tan(u*zim.RAD)*frontY;
				var s = dist-frontX-n;
				var t1 = s/Math.sin(v*zim.RAD)*Math.sin(flare*zim.RAD);
				var t2 = Math.sqrt(Math.pow(frontY,2) + Math.pow(n,2));
				var t = t1 + t2;
				var x = t*Math.sin(u*zim.RAD);
				var y = t*Math.cos(u*zim.RAD);
				return {x:x,y:y,t:t};
			}

		} // end makeShape

		// METHODS

		this.add = function(lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close) {
			var sig = "lengths, angles, anglesA, anglesB, anglesEnd, cross, crossColors, close";
			var duo; if (duo = zob(that.add, arguments, sig)) return duo;
			if (!zot(cross)) that.cross = cross;
			if (!zot(close)) that.close = close;
			if (!zot(lengths)) {
				if (!Array.isArray(lengths)) lengths = [lengths];
				if (zot(that.lengths)) that.lengths = lengths;
				else that.lengths = that.lengths.concat(lengths);
			}
			if (!zot(angles)) {
				if (!Array.isArray(angles)) angles = [angles];
				if (zot(that.angles)) that.angles = angles;
				else that.angles = that.angles.concat(angles);
			}
			if (!zot(anglesA)) {
				if (!Array.isArray(anglesA)) anglesA = [anglesA];
				if (zot(that.anglesA)) that.anglesA = anglesA;
				else that.anglesA = that.anglesA.concat(anglesA);
			}
			if (!zot(anglesB)) {
				if (!Array.isArray(anglesB)) anglesB = [anglesB];
				if (zot(that.anglesB)) that.anglesB = anglesB;
				else that.anglesB = that.anglesB.concat(anglesB);
			}
			if (!zot(anglesEnd)) {
				if (!Array.isArray(anglesEnd)) anglesEnd = [anglesEnd];
				if (zot(that.anglesEnd)) that.anglesEnd = anglesEnd;
				else that.anglesEnd = that.anglesEnd.concat(anglesEnd);
			}
			if (!zot(crossColors)) {
				if (zot(that.crossColors)) {
					if (zon) zogy("Flare() - must set crossColor for original object parameters");
				} else {
					if (!Array.isArray(crossColors)) crossColors = [crossColors];
					if (zot(that.crossColors)) that.crossColors = crossColors;
					else that.crossColors = that.crossColors.concat(crossColors);
				}
			}
			that.remake();
			return that;
		};
		this.remake = function() {
			thicknessA = this.thicknessA;
			thicknessB = this.thicknessB;
			drawShape(that.lengths, that.angles, that.anglesA, that.anglesB, that.anglesEnd, that.cross, that.crossColors, that.close);
			return that;
		};

		// PROPERTIES

		Object.defineProperty(that, 'color', {
			get: function() {
				return color;
			},
			set: function(value) {
				if (zot(value)) value = zim.black;
				color = value;
				if (value && value.type) that.specialColor(that.colorCommand, value, that);
				else that.colorCommand.style = value;
			}
		});
		var startColor;
		var endColor;
		this.setColorRange = function(color1, color2) {
			if (zot(color2)) {
				startColor = that.color;
				endColor = color1;
			} else if (zot(color1)) {
				startColor = that.color;
				endColor = color2;
			} else {
				startColor = color1;
				endColor = color2;
			}
			return that;
		};
		var colorRange = 0;
		Object.defineProperty(that, 'colorRange', {
			get: function() {
				return colorRange;
			},
			set: function(value) {
				colorRange = value;
				if (!zot(startColor) && !zot(endColor)) {
					that.color = zim.colorRange(startColor, endColor, value);
				}
			}
		});
		Object.defineProperty(that, 'borderColor', {
			get: function() {
				return borderColor;
			},
			set: function(value) {
				borderColor = value;
				if (!that.borderColorCommand) drawShape();
				else if (value && value.type) that.specialColor(that.borderColorCommand, value, that);
				else that.borderColorCommand.style = value;
			}
		});
		Object.defineProperty(that, 'borderWidth', {
			get: function() {
				return borderWidth;
			},
			set: function(value) {
				if (!(value>0)) value = 0;
				borderWidth = value;
				if (!that.borderWidthCommand || borderWidth == 0) drawShape();
				else {
					that.borderWidthCommand.width = borderWidth;
					if (dashed) {
						that.borderDashedCommand.segments = [20, 10];
						that.borderDashedCommand.offset = 5;
					}
				}
			}
		});

		Object.defineProperty(that, 'spineColor', {
			get: function() {
				return spineColor;
			},
			set: function(value) {
				if (zot(value)) value = zim.black;
				spineColor = value;
				if (!that.spineColorCommand) drawShape();
				else if (value && value.type) that.specialColor(that.spineColorCommand, value, that);
				else that.spineColorCommand.style = value;
			}
		});
		Object.defineProperty(that, 'spineBorderColor', {
			get: function() {
				return spineBorderColor;
			},
			set: function(value) {
				spineBorderColor = value;
				if (!that.spineBorderColorCommand) drawShape();
				else if (value && value.type) that.specialColor(that.spineBorderColorCommand, value, that);
				else that.spineBorderColorCommand.style = value;
			}
		});
		Object.defineProperty(that, 'spineBorderWidth', {
			get: function() {
				return spineBorderWidth;
			},
			set: function(value) {
				if (!(value>0)) value = 0;
				spineBorderWidth = value;
				if (!that.spineBorderWidthCommand || spineBorderWidth == 0) drawShape();
				else {
					that.spineBorderWidthCommand.width = spineBorderWidth;
					if (spineDashed) {
						that.spineBorderDashedCommand.segments = [20, 10];
						that.spineBorderDashedCommand.offset = 5;
					}
				}
			}
		});

		Object.defineProperty(that, 'closeColor', {
			get: function() {
				return closeColor;
			},
			set: function(value) {
				if (zot(value)) value = zim.black;
				closeColor = value;
				if (!that.closeColorCommand) drawShape();
				else if (value && value.type) that.specialColor(that.closeColorCommand, value, that);
				else that.closeColorCommand.style = value;
			}
		});
		Object.defineProperty(that, 'closeBorderColor', {
			get: function() {
				return closeBorderColor;
			},
			set: function(value) {
				closeBorderColor = value;
				if (!that.closeBorderColorCommand) drawShape();
				else if (value && value.type) that.specialColor(that.closeBorderColorCommand, value, that);
				else that.closeBorderColorCommand.style = value;
			}
		});
		Object.defineProperty(that, 'closeBorderWidth', {
			get: function() {
				return closeBorderWidth;
			},
			set: function(value) {
				if (!(value>0)) value = 0;
				closeBorderWidth = value;
				if (!that.closeBorderWidthCommand || closeBorderWidth == 0) drawShape();
				else {
					that.closeBorderWidthCommand.width = closeBorderWidth;
					if (closeDashed) {
						that.closeBorderDashedCommand.segments = [20, 10];
						that.closeBorderDashedCommand.offset = 5;
					}
				}
			}
		});

		Object.defineProperty(that, 'pin', {
			get: function() {
				return pin;
			},
			set: function(value) {
				if (!(value>0)) value = 0;
				if (value > that.pinPoints.length-1) pin = 0;
				pin = value;
				var point = that.pinPoints[pin];
				if (point) {
					that.regX = point.x;
					that.regY = point.y;
				}
			}
		});

		var b = zim.boundsAroundPoints(that.points);
		this.setBounds(b.x, b.y, b.width, b.height);
		if (!zot(pin)) that.pin = pin;

		this.mouseChildren = false;

		if (style!==false) zim.styleTransforms(this, DS);

		this.clone = function() {
			return that.cloneProps(new zim.Flare(color, borderColor, borderWidth, crossAngleOriginal, zim.copy(thickness), zim.copy(thicknessA), zim.copy(thicknessB), pin, startX, startY, zim.copy(lengths), zim.copy(angles), zim.copy(anglesA), zim.copy(anglesB), zim.copy(anglesEnd), cross, zim.copy(crossColors), close, dashed, strokeObj, spineColor, spineBorderWidth, spineBorderColor, spineDashed, spineStrokeObj, closeColor, closeBorderWidth, closeBorderColor, closeDashed, closeStrokeObj, style, this.group, inherit));
		};
	};
	zim.extend(zim.Flare, zim.Container, ["clone"], "zimContainer", false);
	//-53.6

//
/*--
zim.MultiFlare = function(flares, pins, angles, endToEnd, style, group, inherit)

MultiFlare
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Joins multiple Flare objects in one container
at the pin points of the flares or end to end.
See also ZIM Flare and ZIM FlareBox.

NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// a fan of legs with feet!
const flare = new Flare({lengths:[100,100,20,8],anglesA:[5,-5,60],anglesB:[5,-5,0]})
const multi = new MultiFlare().center();
loop(12, i=>{
	multi.add(flare.rot(i*360/12))
});

// or prepare flares and angles ahead of time
const flares = [];
const angles = [];
loop(12, i=>{
	flares.push(flare.clone());
	angles.push(i*360/12);
});
new MultiFlare(flares, null, angles).center();

// a ring of beads using endToEnd
const flare = new Flare({crossAngle:-360/12, lengths:[50,20,5,20,50],anglesA:[5,60,0,-60,-5]})
const flares = [];
const angles = [];
loop(12, i=>{
	flares.push(flare.clone());
	angles.push(i*360/12);
});
new MultiFlare(flares, null, angles, true).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
flares - (default null) an array of ZIM Flares objects to add - also see add() method
pins - (default null) an array of pin indexes for the flares
	pins will set the registration point for each flare at whatever segment matches the pin index
angles - (default null) an array angles for the flares
endToEnd - (default false) set to true to locate each first segment point of the flare at the last segment point of the last flare
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(flares) - add an array of flares or a single flare to MultiFlare
	add() redraws the whole flare so for many, make an array to start and pass it in as an argument
remove(flares) - remove an array of flares or a single flare to MultiFlare
	remove() redraws the whole flare so for many, make an array to start and pass it in as an argument
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy of the multiFlare cloning the flares too
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
** can get and change the following properties
** see the paremeters for details
** if properties are changed call the remake() method to update the MultiFlare
flares - array
pins - array
angles - array
endToEnd - boolean
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53.7
	zim.MultiFlare = function(flares, pins, angles, endToEnd, style, group, inherit) {
		var sig = "flares, pins, angles, endToEnd, style, group, inherit";
		var duo; if (duo = zob(zim.MultiFlare, arguments, sig, this)) return duo;
		z_d("53.7");
		this.zimContainer_constructor();
		this.type = "MultiFlare";
		this.group = group;

		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		var that = this;

		if (zot(flares)) flares = DS.flares!=null?DS.flares:[];
		if (!Array.isArray(flares)) flares = [flares];

		// pins, angles, endToEnd
		if (zot(pins)) pins = DS.pins!=null?DS.pins:null;
		if (zot(angles)) angles = DS.angles!=null?DS.angles:null;
		if (zot(endToEnd)) endToEnd = DS.endToEnd!=null?DS.endToEnd:false;

		that.flares = flares;
		that.pins = pins;
		that.angles = angles;
		that.endToEnd = endToEnd;
		that.mouseChildren = false;

		that.add = function(f, clone) {
			if (zot(f)) return that;
			if (zot(clone)) clone = true;
			if (!Array.isArray(f)) f = [f];
			zim.loop(f, function (flare) {
				if (clone) that.flares.push(flare.clone());
				else that.flares.push(flare);
			});
			that.remake();
			if (that.stage) that.stage.update();
			return that;
		};
		that.remove = function(f) {
			if (zot(f)) return that;
			if (!Array.isArray(f)) f = [f];
			zim.loop(f, function (flare) {
				var index = that.flares.indexOf(flare);
				if (index>=0) that.flares.splice(index, 1);
			});
			that.remake();
			if (that.stage) that.stage.update();
			return that;
		};
		that.remake = function () {
			that.removeAllChildren();
			zim.loop(that.flares, function (flare, i) {
				if (pins && !zot(pins[i])) flare.pin = pins[i];
				if (angles && !zot(angles[i])) flare.rotation = angles[i];
				flare.addTo(that);
				that.flares.push(flare);
				if (endToEnd) {
					if (i>0) {
						var last = flares[i-1];
						var lastPoint = last.pinPoints[last.pinPoints.length-1];
						var point1 = last.localToLocal(lastPoint.x, lastPoint.y, that);
						var firstPoint = flare.pinPoints[0];
						var point2 = flare.localToLocal(firstPoint.x, firstPoint.y, that);
						flare.mov(point1.x-point2.x, point1.y-point2.y);
					}
				}
			});
		};
		that.remake();

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.MultiFlare(zim.copy(flares,true), zim.copy(pins), zim.copy(angles), endToEnd, style, this.group, inherit));
		};
	};
	zim.extend(zim.MultiFlare, zim.Container, ["clone"], "zimContainer", false);
	//-53.7

/*--
zim.FlareBox = function(width, height, color, borderColor, borderWidth, flares, corners, pins, style, group, inherit)

FlareBox
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a Rectangle with ZIM Flare objects positioned around edges and corners.
Pass in an array of Flare objects or a MultiFlare
FlareBox places flares at specified corner indexes depending on flare pin index.
See also ZIM Flare and ZIM MultiFlare.

A FlareBox can be used as a backing and rollBacking for buttons and other components
to create exciting borders inspired by the tail lights of 2020 automibiles.

See: https://zimjs.com/ten/flare.html

NOTE: mouseChildren is turned to false for all zim Shape containers.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const border1 = new Flare({
	thickness:6,
	angles:[0,90], // to the right then down
	lengths:[60,90],
	anglesA:[3,-1.5], // flare angles
	anglesEnd:[45,0], // 0 is optional
	color:white,
	pin:1 // pin at flare corner
});

const border2 = new Flare({
	thickness:25,
	angles:[0,90], // to right then down
	lengths:[50,50],
	anglesA:[-2,2], // anglesB will mirror these if not provided
	anglesEnd:[45],
	color:dark,
	pin:1 // pin at flare corner
});

// put both flares at left top corner 0
// they each have pin of 1 so
// the rotation is (0-1)*90 = -90 (counter clockwise)
// they were to the right and down
// now they are up and to the right
const flareBox = new FlareBox(220, 100, blue, dark, 3, [border1, border2], [0,0])
	.centerReg();

// clone the flares for the rollover FlareBox
// put the first flare at corner 2
// the rotation becomes (2-1)*90 = 90 (clockwise)
// it was built to go to the right and down
// now it is going down and to the left
const flareBoxOver = new FlareBox(220, 100, green, dark, 3, [border1.clone(), border2.clone()], [2,0])
	.centerReg({add:false});

// use the flareBoxes as backings
const button = new Button({
	width:flareBox.width,
	height:flareBox.height,
	backing:flareBox,
	rollBacking:flareBoxOver
}).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 220) the width of the rectangle about which the Flare objects are placed
 	this is a little larger than the ZIM Button default width
height - (default 80) the height of the rectangle about which the Flare objects are placed
 	this is a little larger than the ZIM Button default height
color - (default black) the fill color as any CSS color including "rgba()" for alpha fill (set a to 0 for tranparent fill)
borderColor - (default null) the stroke color
borderWidth - (default 1 if stroke is set) the size of the stroke in pixels
flares - (default null) an array of ZIM Flare objects or a single flare or a ZIM MultiFlare
corners - (default [0]) an array of corner indexes to place the pin points of the ZIM Flare objects
	corner indexes are:
		0 - LEFT TOP
		1 - RIGHT TOP
		2 - RIGHT BOTTOM
		3 - LEFT BOTTOM
pins - (default null) an array of pins of the ZIM Flare objects
	The pin index can be set on the Flare or through the MultiFlare or here in the FlareBox
	The pin is also the registration point of the flare so the flare will be placed at the corner at its pin
	FlareBox will also automatically rotate the flares with this formula:
		flare.rotation = (corner-pin)*90
	This formula allows for easy setting of angles on corners
	See the Button at https://zimjs.com/ten/flare.html
	This can be overridden by setting the flare rotation after the FlareBox is created
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setColorRange(color1, color2) - set a color range for shape - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy of the flareBox and clone flares as well
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
multiFlare - gives access to the ZIM Multiflare object
	this is made automatically by FlareBox if an array of flares was used
flares - an array of flares that belong to the multiFlare
backing - gives access to the rectangle backing shape
color - get and set the fill color of the backing shape
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the backing shape
	for instance, shape.setColorRange(blue, pink) then shape.colorRange = .5
	will set the color of the shape to half way between blue and pink
	shape.animate({color:red}, 1); is a shortcut to animate the colorRange
	shape.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
borderColor - get and set the stroke color
borderWidth - get and set the stroke size in pixels
borderDashedCommand - access to the CreateJS stroke dashed command (segments, offset)
	see https://www.createjs.com/docs/easeljs/classes/Graphics.StrokeDash.html
mouseChildren - set to false to avoid dragging the shape inside
	to drag or interact with objects inside then set mouseChildren to true

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+53.8
	zim.FlareBox = function(width, height, color, borderColor, borderWidth, flares, corners, pins, style, group, inherit) {
		var sig = "width, height, color, borderColor, borderWidth, flares, corners, pins, style, group, inherit";
		var duo; if (duo = zob(zim.FlareBox, arguments, sig, this)) return duo;
		z_d("53.8");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("FlareBox", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:220;
		if (zot(height)) height = DS.height!=null?DS.height:80;

		this.zimContainer_constructor(width, height);
		this.type = "FlareBox";

		var that = this;
		this.mouseChildren = false;

		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(color)) color = DS.color!=null?DS.color:(borderWidth>0?"rgba(0,0,0,0)":zim.black);
		if (zot(borderWidth) || borderWidth > 0) { // no border specified or a border > 0
			if (!zot(borderColor) || !zot(borderWidth)) { // either a border color or thickness
				if (zot(borderColor)) borderColor = zim.black;
			}
		}

		if (zot(flares)) flares = DS.flares!=null?DS.flares:null;
		if (zot(corners)) corners = DS.corners!=null?DS.corners:null;
		if (zot(pins)) pins = DS.pins!=null?DS.pins:null;

		that.backing = new zim.Rectangle(width, height, color, borderColor, borderWidth).addTo(this);

		if (zot(flares)) return;
		if (flares.type != "MultiFlare") {
			if (!Array.isArray(flares)) {
				if (flares.type != "Flare") return;
				flares = [flares];
			}
			flares = new zim.MultiFlare(flares, pins);
		}

		flares.addTo(that);
		that.multiFlare = flares;
		that.flares = that.multiFlare.flares;
		flares.loop(function(flare, i) {
			if (pins && !zot(pins[i])) flare.pin = pins[i];
			else if (zot(flare.pin)) flare.pin = 0;
			if (corners && !zot(corners[i])) flare.corner = corners[i];
			else if (zot(flare.corner)) flare.corner = 0;

			if (flare.corner==1) {
				flare.loc(width,0);
			} else if (flare.corner==2) {
				flare.loc(width,height);
			} else if (flare.corner==3) {
				flare.loc(0,height);
			} else {
				flare.loc(0,0);
			}
			flare.rot((flare.corner-flare.pin)*90);

		});
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.FlareBox(width, height, color, borderColor, borderWidth, zim.copy(flares,true), zim.copy(corners), zim.copy(pins), style, this.group, inherit));
		};
	};
	zim.extend(zim.FlareBox, zim.Container, ["clone"], "zimContainer", false);
	//-53.8

// SUBSECTION COMPONENTS

/*--
zim.Label = function(text, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, bold, italic, variant, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, splitWords, style, group, inherit)

Label
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a label - wraps the createjs Text object.
Can use with Button, CheckBox, RadioButtons and Pane.
Text seems to come in different sizes so we do our best.
Have tended to find that left and alphabetic are most consistent across browsers.
Custom fonts loaded through css can be used as well.

NOTE: can wrap text at given width using lineWidth (or labelWidth) parameter.
To dynamically change the width without changing the font size use the labelWidth property.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Label("Hello").center(); // adds label to and centers on the stage

new Label({
	text:"CLICK",
	size:100,
	font:"courier",
	color:white,
	rollColor:red,
	bold:true,
	italic:true
}).loc(100,100).tap(()=>{zog("tapping");});
END EXAMPLE

EXAMPLE
// with text that wraps at labelWidth
// can also set this as a property later to dynamically change width of text 
// without changing the size
new Label({
	text:"this is a long bunch of text, this is a long bunch of text, this is a long bunch of text",
	labelWidth:200
}).center();
END EXAMPLE

EXAMPLE
STYLE = {font:"courier"};
new Label("Hi Courier").center(); // will be courier not arial

STYLE = {text:"YAY!", color:red};
new Label().center().mov(0,100); // will say YAY! in red arial font
new Label("Hello").center().mov(0,200); // will say Hello in red arial
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function

text - |ZIM VEE| String for the the text of the label
size - (default 36) the size of the font in pixels
font - (default arial) the font or list of fonts for the text
color - (default black) color of font (any CSS color)
rollColor - (default color) the rollover color of the font
shadowColor - (default -1) for no shadow - set to any css color to see
shadowBlur - (default 14) if shadow is present
align - ((default LEFT) text registration point alignment also CENTER/MIDDLE and RIGHT
	set to START to align LEFT for ZIM DIR constant is "ltr" or RIGHT when DIR="rtl" - END is the opposite
valign - (default TOP) vertical registration point alignment alse CENTER/MIDDLE, BOTTOM
bold - (default false) set the font to bold - note: fontOptions has been removed as of ZIM Cat
italic - (default false) set the font to italic - note: fontOptions has been removed as of ZIM Cat
variant - (default false) set to true to set the font to "small-caps" - note: fontOptions has been removed as of ZIM Cat
lineWidth - (default false) for no wrapping (use \n) Can set to number for wrap
lineHeight - (default getMeasuredLineHeight) set to number to adjust line height
backing - (default null) a Display object for the backing of the label (eg. Shape, Bitmap, Container, Sprite)
	the backing most likely should be centerReg() ie. backing:new Rectangle(200,50,yellow).centerReg()
	see ZIM Pizzazz module for a fun set of Shapes like Boomerangs, Ovals, Lightning Bolts, etc.
outlineColor - (default null - or black if outlineWidth set) - the color of the outline of the text
outlineWidth - (default null - or (size*.2) if outlineColor set) - the thickness of the outline of the text
backgroundColor - (default null) set to CSS color to add a rectangular color around the label
	The background color will change size to match the text of the label
	Note: the backgroundColor is different than a backing which can be any Display Object
	and background parameters are ignored if a backing parameter is set
backgroundBorderColor - (default null) the background stroke color
backgroundBorderWidth - (default null) thickness of the background border
corner - (default 0) the round of corner of the background if there is one
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
backgroundDashed - (default null) set to true for dashed background border (if backgroundBorderColor or backgroundBorderWidth set)
padding - (default 10 if backgroundColor set) places the border this amount from text (see paddingH and paddingV)
	padding parameters are ignored if there is no backgroundColor set (also ignored if a backing parameter is set)
paddingH - (default padding) places border out at top bottom
paddingV - (default padding) places border out at left and right
shiftH - |ZIM VEE| (default 0) move the label (CreateJS Text) inside the Label container horizontally
shiftV - |ZIM VEE| (default 0) move the label (CreateJS Text) inside the Label container vertically
rollPersist - (default false) set to true to maintain rollover stage as long as mousedown or press is activated (used by Buttons)
labelWidth - (default null) the same as the lineWidth - the text will wrap at the labelWidth (added to match labelHeight)
labelHeight - (default null) the height of the text - setting this will probably alter the font size - so the size parameter is overwritten
	for labelHeight to work, the labelWidth must also be set
	using labelWidth and labelHeight together allow you to fit as much text into specified width and height dimensions
maxSize - (default null) set to limit the font size when using labelWidth and labelHeight
splitWords - (default false) set to true when lineWidth > 0 to split words at the line width
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setColorRange(color1, color2) - set a color range for label - used by colorRange property - returns obj for chaining
	if one color is used, the current color is used and color1 is the second color in the range
showRollColor(visible) - default true to show roll color (used internally)
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy with properties such as x, y, etc. also copied
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.

ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
label - references the CreateJS Text object of the label
text - references the text property of the CreateJS Text object
size - the font size of the Label (without px)
font - get or set the font of the text
bold - get or set the bold (boolean) of the font
italic - get or set the italic (boolean) of the font
variant - get or set the variant (boolean) of the font (true is "small-caps")
align - get or set the horizontal alignment of the text
valign - get or set the vertical alignment of the text
paddingH - read-only value for paddingH of label
	note - no padding property - that gets split into paddingH and paddingV
paddingV - read-only value for paddingV of label
color - gets or sets the label text color (and the rollColor if they are the same to start)
colorOnly - gets or only sets the label color 
backgroundColor - gets or sets the label background color
colorRange - if setColorRange() is used, the colorRange is a ratio (0-1) between the colors
	setting the colorRange will change the color property of the label
	for instance, label.setColorRange(blue, pink) then label.colorRange = .5
	will set the color of the label to half way between blue and pink
	label.animate({color:red}, 1); is a shortcut to animate the colorRange
	label.wiggle("colorRange", .5, .2, .5, 1, 5) will wiggle the colorRange
rollColor - gets or sets the label rollover color
labelWidth - the width at which the text wraps
	currently does not work well with labelHeight and backgroundColor
labelHeight - setting this and labelWidth will change the font size to fit within the specified dimensions
outlineLabel - reference to the outline CreateJS Text object if there is an outline
backing - access to backing object
background - access to background Rectangle if backgroundColor is set
enabled - default is true - set to false to disable
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54
	zim.Label = function(text, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, bold, italic, variant, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, splitWords, style, group, inherit) {
		var sig = "text, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, bold, italic, variant, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, splitWords, style, group, inherit";
		var duo; if (duo = zob(zim.Label, arguments, sig, this)) return duo;
		z_d("54");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Label";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(text)) text=DS.text!=null?DS.text:"LABEL";
		if (zot(size)) size=DS.size!=null?DS.size:36;
		if (zot(font)) font=DS.font!=null?DS.font:"arial"; // arial unless manually set
		if (zot(color)) color=DS.color!=null?DS.color:zim.black;
		if (zot(bold)) bold=DS.bold!=null?DS.bold:false;
		if (zot(italic)) italic=DS.italic!=null?DS.italic:false;

		var oa = remember(text, size, font, color, bold, italic);
		this.veeObj = {text:oa[0], size:oa[1], font:oa[2], color:oa[3], bold:oa[4], italic:oa[5]};
		function remember() {return arguments;}

		text = zik(text);
		shiftH = zik(shiftH);
		shiftV = zik(shiftV);

		var emptyText = false;
		if (text === "") {
			text = " ";
			emptyText = true;
		}
		size = zim.Pick.choose(size);
		font = zim.Pick.choose(font);
		font = font.replace("+", " ");
		var fontTypes = ["ttf","otf","woff2","woff","fnt"];
		var ncheck = font.split(".");
		if (ncheck.length>0 && fontTypes.indexOf(ncheck[1])!=-1) font = ncheck[0];
		color = zim.Pick.choose(color);
		bold = zim.Pick.choose(bold);
		italic = zim.Pick.choose(italic);

		if (zot(rollColor)) rollColor=DS.rollColor!=null?DS.rollColor:null;
		if (zot(shadowColor) || shadowColor=="ignore") shadowColor=(DS.shadowColor!=null&&shadowColor!="ignore")?DS.shadowColor:-1;
		if (zot(shadowBlur) || shadowBlur=="ignore") shadowBlur=(DS.shadowBlur!=null&&shadowBlur!="ignore")?DS.shadowBlur:14;
		if (zot(align)) align=DS.align!=null?DS.align:"left";
		if (zot(valign)) valign=DS.valign!=null?DS.valign:"top";
		if ((!zot(outlineColor) || !zot(DS.outlineColor)) && zot(outlineWidth)) outlineWidth = DS.outlineWidth!=null?DS.outlineWidth:Math.round(size*.2);
		if ((!zot(outlineWidth) || !zot(DS.outlineWidth)) && zot(outlineColor)) outlineColor = DS.outlineColor!=null?DS.outlineColor:zim.black;
		if (zot(outlineWidth)) outlineWidth = DS.outlineWidth!=null?DS.outlineWidth:0;
		if (zot(backgroundColor) || backgroundColor=="ignore") backgroundColor = (DS.backgroundColor!=null&&backgroundColor!="ignore")?DS.backgroundColor:null;
		if (zot(backgroundBorderColor)) backgroundBorderColor = (DS.backgroundBorderColor!=null&&backgroundBorderColor!="ignore")?DS.backgroundBorderColor:null;
		if (zot(backgroundBorderWidth)) backgroundBorderWidth = (DS.backgroundBorderWidth!=null&&backgroundBorderWidth!="ignore")?DS.backgroundBorderWidth:null;
		if (zot(padding) || padding=="ignore") padding = (DS.padding!=null&&padding!="ignore")?DS.padding:10;
		if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:padding;
		if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:padding;
		if (zot(shiftH)) shiftH = DS.shiftH!=null?DS.shiftH:0;
		if (zot(shiftV)) shiftV = DS.shiftV!=null?DS.shiftV:0;
		if (zot(variant)) variant=DS.variant!=null?DS.variant:false;
		if (zot(lineWidth)) lineWidth = DS.lineWidth!=null?DS.lineWidth:null;
		if (zot(lineHeight)) lineHeight = DS.lineHeight!=null?DS.lineHeight:null;
		if (zot(backing) || backing=="ignore") backing = (DS.backing!=null&&backing!="ignore")?DS.backing.clone():null;
		if (zot(rollPersist)) rollPersist = DS.rollPersist!=null?DS.rollPersist:false;
		if (DS.labelWidth!=null) lineWidth = DS.labelWidth;
		if (!zot(labelWidth)) lineWidth = labelWidth;
		if (align == "middle") align = "center";
		if (zot(labelHeight)) labelHeight = DS.labelHeight!=null?DS.labelHeight:null;
		if (zot(maxSize)) maxSize = DS.maxSize!=null?DS.maxSize:null;
		size = maxSize?Math.min(size, maxSize):size;
		if (zot(splitWords)) splitWords=DS.splitWords!=null?DS.splitWords:false;

		var retina = (WW.zdf&&WW.zdf.retina);
		
		var that = this;
		this.mouseChildren = false;
		this.paddingV = paddingV;
		this.paddingH = paddingH;		
		
		// handle DIR effect 
		if ((WW.DIR && WW.DIR=="rtl") || (!WW.DIR && zim.DIR=="rtl")) {
			if (align=="start") align="right";
			else if (align=="end") align="left";
		} else {
			if (align=="start") align="left";
			else if (align=="end") align="right";
		}
		
		var options = [];
		options[0] = italic?"italic":"normal";
		options[1] = variant?"small-caps":"normal";
		options[2] = bold?"bold":"normal";
		options[3] = size+"px";
		options[4] = font;
		var opt = options.join(" ");
		text = String(text);
		var obj;
		
		var backingPlaced = false;
		var lW = lineWidth;
		var lH = labelHeight;
		if (zot(backing) && zot(backgroundColor)) {
			var hitArea = new createjs.Shape();
			that.hitArea = hitArea;
		} else {
			if (lW) lW = lW-paddingH*2;
			if (lH) lH = lH-paddingV*2;
		}
			
		function makeLabel(t) {
			var o = new createjs.Text(t, opt, color);
			o.lineWidth = lW;
			o.lineHeight = lineHeight;
			return o;	
		}	
		obj = makeLabel(text);
		
		// measure lines to make sure not going past lineWidth		
		function testLine(l, w, line) {
			var endIndex = Math.ceil(lW/w*line.length);
			var start = line.substr(0,endIndex);
			var l2 = makeLabel(start);
			var w2 = l2.getMeasuredWidth();
			if (w2 > lW) {
				while (w2 > lW) {
					endIndex--;
					start = line.substr(0,endIndex)
					l2 = makeLabel(start);
					w2 = l2.getMeasuredWidth();
				}
			} else if (w2 < lW) {
				while (w2 < lW) {
					endIndex++;
					start = line.substr(0,endIndex)
					l2 = makeLabel(start);
					w2 = l2.getMeasuredWidth();
				}							
				endIndex--;
				start = line.substr(0,endIndex)
			} 
			var end = line.substr(endIndex, line.length);
			return {endIndex:endIndex, start:start, end:end};
		}		
		
		if (splitWords && lW > size * 1.2) { // approximate			
			
			var metrics = obj.getMetrics();
			var wCount = 0;
			while (metrics.width > lW && wCount < 1000) {
				wCount++;
				zim.loop(metrics.lines, function(line, i) {
					line = line.replace(/^[\s\t]+/, "");
					var l = makeLabel(line);
					var w = l.getMeasuredWidth();					
					if (w > lW) {						
						var dat = testLine(l, w, line);	
						metrics.lines[i] = dat.start;
						// move extra letters into the next line if there is one
						if (metrics.lines.length > i+1) {  							
							dat.end.trim();
							metrics.lines[i+1] = dat.end + " " + metrics.lines[i+1];
						} else {
							metrics.lines.push(dat.end);
						}
						obj = makeLabel(metrics.lines.join(" "));
						metrics = obj.getMetrics();
						return false;
					}					
				}); // end line loop					
			} // end while	
		} // end split test		
		
		this.label = obj;
		obj.textAlign = align;
		obj.textBaseline = "alphabetic";
		
		if (outlineWidth > 0) {
			var obj2 = this.outlineLabel = obj.clone();
			obj2.color = outlineColor;
			obj2.outline = outlineWidth;
		}
		if (shadowColor != -1 && shadowBlur > 0) obj.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
		this.addChild(obj);

		function setBackground() {
			that.removeChild(that.background);
			that.background = new zim.Rectangle(
				that.getBounds().width+paddingH*2, that.getBounds().height+paddingV*2,
				backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, null, null, false
			);
            if (italic) that.background.ske(10);
			zim.center(that.background, that, 0);
			that.setBounds(that.background.x, that.background.y, that.background.width, that.background.height);
		}
		
		function setSize() {
			var b = obj.getBounds();
			var by = b.y;
			var bh = b.height;
			if (lW && !lH) { // ZIM CAT 4 patch (lW) with ZIM NFT 0 patch (lH)
				var bx = b.x;
				var bw = lW;
				if (align=="right") {
					bx = b.x-lW+b.width;
				} else if (align=="center") {
					bx = -lW/2;
				}				
				obj.setBounds(bx, by, bw, bh);
				b = obj.getBounds();				
			}

			var yAdjust;
			if (valign == "baseline") {
				yAdjust = b.y;
			} else if (valign == "top") {
				obj.y = size-size/6;
				// if (!retina && obj2) obj2.y = size-size/6;
				yAdjust = 0;
			} else if (valign == "center" || valign == "middle") {
				yAdjust = - b.height / 2;
				obj.y = size*.3;
				// if (!retina && obj2) obj2.y = size*.3;
			} else { // bottom align
				yAdjust = -b.height;
			}
			// if (valign!="baseline" && obj2) obj2.y -= size*.06/(valign=="center"?2:1);
			that.setBounds(b.x, yAdjust, DS.width?DS.width-padding*2:b.width, DS.height?DS.height-padding*2:b.height);
			if (that.hitArea) that.hitArea.graphics.c().f("black").r(that.getBounds().x, that.getBounds().y, that.getBounds().width, that.getBounds().height);
			if (valign == "center" || valign == "middle") {
				zim.pos(obj, null, 0);
				zim.mov(obj, 0, 1);
			}
			if (!labelHeight) {
				if (backing) {
					if (backingPlaced) setBackBounds();
				} else if (!zot(backgroundColor)) {
					setBackground();
				}
			} 			

			if (valign != "baseline" && !retina) obj.y += size/32; //32; // backing often on capital letters without descenders - was /16

			finalShift();
		}
		setSize();

		if (!zot(backing)) {
			if (backing.type == "Pattern") {
				that.backing = new zim.Container(that.width+paddingH*2, that.height+paddingV*2, null, null, false).centerReg(null, null, false);
				if (shadowColor != -1 && shadowBlur > 0) {
					var shadowRect = new zim.Rectangle(that.width+paddingH*2-2, that.height+paddingV-2, "#666", null, null, corner, null, null, null, false).center(that.backing);
					shadowRect.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
				}
				var mask = new zim.Rectangle(that.width+paddingH*2, that.height+paddingV*2, backgroundColor, null, null, corner, null, null, null, false).addTo(that.backing);
				backing.centerReg(mask);
				backing.setMask(mask);
				that.backing.pattern = backing;
			} else {
				that.backing = backing;
			}
			that.backing.center(that, 0);
			backing = that.backing;
			setBackBounds();
			backingPlaced = true;
		}

		function setBackBounds() {
			var bb = backing.boundsToGlobal();
			var bbb = that.boundsToGlobal(bb, true);
			that.setBounds(bbb.x, bbb.y, bbb.width, bbb.height);
		}

		function finalShift() {
			zim.pos(obj, (align=="left"||align=="right")?(backing||that.background?paddingH:0):null, (valign=="top"||valign=="baseline"||valign=="bottom")?(backing||that.background?paddingV:0):null, align=="right", valign=="bottom");
			// zim.pos(obj, (align=="left"||align=="right")?0:null, (valign=="top"||valign=="baseline"||valign=="bottom")?0:null, align=="right", valign=="bottom");
			obj.x += shiftH;
			obj.y += shiftV;			
		}
		finalShift();

		function setOutline() {
			if (obj2) {
				obj2.x = obj.x;
				obj2.y = obj.y;
				that.addChildAt(obj2,(that.background||that.backing)?1:0);
			}
		}
		setOutline();

		Object.defineProperty(that, 'text', {
			get: function() {
				var t = (obj.text == " " && emptyText) ? "" : obj.text;
				return t;
			},
			set: function(value) {
				emptyText = false;
				if (value === "") {
					value = " ";
					emptyText = true;
				}
				obj.text = String(value);
				obj.setBounds(null);
				that.setBounds(null);
				setSize();
				if (obj2) obj2.text = String(value);
				if (!zot(lineWidth) && !zot(labelHeight)) {
					fitText();
					if (obj2) setOutline();
				}				
			}
		});

		Object.defineProperty(that, 'size', {
			get: function() {
				return size;
			},
			set: function(value) {
				size = maxSize?Math.min(value, maxSize):value;
				options[3] = size + "px";
				this.label.font = options.join(" ");
				if (obj2) obj2.font = options.join(" ");
				obj.setBounds(null);
				that.setBounds(null);
				setSize();
				setOutline();
			}
		});

		Object.defineProperty(that, 'bold', {
			get: function() {
				return Boolean(this.label.font.match("bold"));
			},
			set: function(value) {
				bold = value;
				options[2] = value?"bold":"normal";
				this.label.font = options.join(" ");
				if (obj2) obj2.font = options.join(" ");
			}
		});

		Object.defineProperty(that, 'italic', {
			get: function() {
				return Boolean(this.label.font.match("italic"));
			},
			set: function(value) {
				italic = value;
				options[0] = value?"italic":"normal";
				this.label.font = options.join(" ");
				if (obj2) obj2.font = options.join(" ");
			}
		});

		Object.defineProperty(that, 'variant', {
			get: function() {
				return Boolean(this.label.font.match("small-caps"));
			},
			set: function(value) {
				variant = value;
				options[1] = value?"small-caps":"normal";
				this.label.font = options.join(" ");
				if (obj2) obj2.font = options.join(" ");
			}
		});

		Object.defineProperty(that, 'font', {
			get: function() {
				return options[4];
			},
			set: function(value) {
				if (zot(value)) return;
				font = value;
				options[4] = value;
				this.label.font = options.join(" ");
				if (obj2) obj2.font = options.join(" ");
			}
		});

		Object.defineProperty(that, 'align', {
			get: function() {
				return align;
			},
			set: function(value) {
				if (zot(value)) return;
				align = value;
				this.label.textAlign = align;
				if (obj2) obj2.textAlign = align;
				setSize();
				setOutline();
			}
		});

		Object.defineProperty(that, 'valign', {
			get: function() {
				return valign;
			},
			set: function(value) {
				if (zot(value)) return;
				valign = value;
				setSize();
				setOutline();
			}
		});

		Object.defineProperty(that, 'color', {
			get: function() {
				return color;
			},
			set: function(value) {
				if (rollColor == color) rollColor = value;
				color = value;
				obj.color = color;
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		Object.defineProperty(that, 'colorOnly', {
			get: function() {
				return color;
			},
			set: function(value) {
				color = value;
				obj.color = color;
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		var startColor;
		var endColor;
		this.setColorRange = function(color1, color2) {
			if (zot(color2)) {
				startColor = that.color;
				endColor = color1;
			} else if (zot(color1)) {
				startColor = that.color;
				endColor = color2;
			} else {
				startColor = color1;
				endColor = color2;
			}
			return that;
		};
		var _colorRange = 0;
		Object.defineProperty(that, 'colorRange', {
			get: function() {
				return _colorRange;
			},
			set: function(value) {
				_colorRange = value;
				if (!zot(startColor) && !zot(endColor)) {
					that.color = zim.colorRange(startColor, endColor, value);
				}
			}
		});

		Object.defineProperty(that, 'backgroundColor', {
			get: function() {
				return backgroundColor;
			},
			set: function(value) {
				backgroundColor = value;
				if (that.background) {
					that.background.color = value;
				} else if (that.backing) {
					that.backing.color = value;
				} else {
					setBackground();
				}
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(that, 'outlineColor', {
			get: function() {
				return outlineColor;
			},
			set: function(value) {
				outlineColor = value;
				if (obj2) obj2.color = outlineColor;
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(that, 'rollColor', {
			get: function() {
				return rollColor;
			},
			set: function(value) {
				if (!that.mouseoverEvent && value) setRollColors();
				if (value==null && that.mouseoverEvent) removeRollColors();
				rollColor = value;
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
				obj.color = color;
				that.mouseChildren = false;
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		this.showRollColor = function(yes) {			
			if (zot(yes)) yes = true;
			if (yes) {
				obj.color = rollColor;
			} else {
				obj.color = color;
			}
			if (that.stage) that.stage.update();
			return that;
		};

		function setRollColors() {
			that.mouseoverEvent = that.on("mouseover", function() {if (that.showRollColor) that.showRollColor();});
			that.mouseoutEvent = that.on("mouseout", function() {if (!that.rollPersist) that.showRollColor(false);});
			that.pressupEvent = that.on("pressup", function() {if (that.rollPersist) that.showRollColor(false);});
		}
		function removeRollColors() {
			that.off("mouseover", that.mouseoverEvent);
			that.off("mouseout", that.mouseoutEvent);
			that.off("pressup", that.pressupEvent);
		}
		if (rollColor) setRollColors();

		Object.defineProperty(that, 'labelWidth', {
			get: function() {
				return lineWidth;
			},
			set: function(value) {
				if (value > 0) {
					lineWidth = value;
					
					lW = lineWidth;				
					if (!zot(backing) || !zot(backgroundColor)) {					
						if (lW) lW = lW-paddingH*2;
					}
					
					that.label.lineWidth = lW;
					if (obj2) obj2.lineWidth = lW;
				
					obj.setBounds(null);
					that.setBounds(null);					
					setSize();					
					if (labelHeight) fitText();	
					
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(that, 'labelHeight', {
			get: function() {
				return labelHeight;
			},
			set: function(value) {
				if (value > 0) {
					labelHeight = value;
					
					lH = labelHeight;				
					if (!zot(backing) || !zot(backgroundColor)) {					
						if (lH) lH = lH-paddingV*2;
					}
										
					if (lineWidth) fitText();
					that.setBounds(null);
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});
		if (!zot(lineWidth) && !zot(labelHeight)) {
			fitText();
		}
		
		function fitText() {
			that.size = maxSize?maxSize:200;
			var count = 0;
			while(lineHeight < lH / 2 && (that.height > lH || that.width > lW)) {
			// while(that.height > labelHeight || that.width > lineWidth) { // ami Aug 2019
				count++;
				that.size = that.size/2;
				if (count>50) break;
			}
			count = 0;
			while(that.height <= lH && that.width <= lW) {
				count++;
				that.size = Math.ceil(that.size + 1);
				if (count>50) break;
			}
			that.size = that.size - 1;
			setOutline();
						
			obj.setBounds(null);
			var b = obj.getBounds();
			var by = b.y;
			var bh = b.height;			
			if (lH) {
				if (valign=="bottom") {
					by = by-lH+bh;
				} else if (valign=="center" || valign=="middle") {
					by = (by+by-lH+bh)/2; // ?
				}	
				bh = lH;				
			}
			obj.setBounds(b.x, by, b.width, bh);
			
			that.setBounds(null);
			b = that.getBounds();
			that.setBounds(b.x, b.y, b.width, b.height);
									
			if (backing) {
				if (backingPlaced) setBackBounds();
			} else if (!zot(backgroundColor)) {
				setBackground();
			}
		}
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function(exact) {
			return that.cloneProps(new zim.Label((exact||!zim.isPick(oa[0]))?that.text:oa[0], (exact||!zim.isPick(oa[1]))?size:oa[1], (exact||!zim.isPick(oa[2]))?font:oa[2], (exact||!zim.isPick(oa[3]))?color:oa[3], rollColor, shadowColor, shadowBlur, align, valign, (exact||!zim.isPick(oa[4]))?bold:oa[4], (exact||!zim.isPick(oa[5]))?italic:oa[5], variant, lineWidth, lineHeight,
				!zot(backing)?backing.clone(exact):null, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, splitWords, style, this.group, inherit));
		};
	};
	zim.extend(zim.Label, zim.Container, "clone", "zimContainer");
	//-54

/*--
zim.LabelOnPath = function(label, path, percentAngle, percents, showPath, allowToggle, interactive, onTop, rtl, style, group, inherit)

LabelOnPath
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a label along a path of a Squiggle or Blob - which can be interactive, fixed, toggled or hidden
A list of percentages for where the letters are can be provided to move around letters
See: https://zimjs.com/explore/labelonpath.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const lop = new LabelOnPath({
	label:"Hello World",
	// label:new Label({text:"JELLO JIGGLES!", size:50}),
	// path:new Blob(),
	// path:new Squiggle({
	//     color:lighter,
	//     thickness:4,
	//     points:[[0,75,0,0,-100,200,100,-200],[300,75,0,0,-100,200,100,-200]]
	// }).transformPoints("scaleX",2).transformPoints("rotation",0),
	percentAngle:100, // default
	showPath:false, // default
	allowToggle:true, // default
	interactive:true, // default
	onTop:false // default
}).center();
zog(lop.text)

F.on("keydown", ()=>{
	// shows percent spacing of letters along path
	// could pass [results] in as an array to percents parameter of LabelOnPath
	zog(lop.percents.toString());
	// uncomment to record the path
	// could pass this in as the points parameter to start with a given path
    // lop.path.getPoints(true);
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
label - (default "Label on Path") a String or a ZIM Label
	can set any label properties such as color, size, font, etc. on the label passed in
path - (default new Squiggle()) a ZIM Squiggle or ZIM Blob
	can set any properties such as color, points, etc. on the shape passed in
percentAngle - (default 100) from 0-100 (or beyond in either direction) as to how much to tilt the letters
percents - (default null) an array of percentage locations of the letters along the line - should match number of letters
showPath - (default true) Boolean to show path at start
allowToggle - (default true) Boolean to allow user to toggle path off and on
interactive - (default true) Boolean to allow user to change path with controls, drag or add and remove points
	can also set these individually on the path
onTop - (default false) - Boolean to set path on top when dragged
rtl - (default DIR) - set to true to start letters at right end of path - will just reverse the Blob or Squiggle path.
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
toggle(state) - leave off state to toggle path to opposite state.  Use true to hide and false to show - returns object for chaining
hidePath() - hides path - returns object for chaining
showPath() - shows path - returns object for chaining
setProps(properties) - sets provided properties (as {prop:val, prop:val}) for each letter
	the values accept ZIM VEE - dynamic parameters - see ZIM Pick()
	returns object for chaining
resize() - if not interactive, call this to update the text on the path - returns object for chaining
cache(see Container docs for parameter description) - overrides CreateJS cache() and returns object for chaining
	Leave parameters blank to cache bounds of shape (plus outer edge of border if borderWidth > 0)
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - the name of the class as a String
text - get or set the text on the path
path - read-only access to path - but can manipulate the path
letters - access to ZIM Container of labels used for letters
	for instance labels.loop(function (label) {label.color = red;});
	or animate as a sequence labels.animate({props:{scale:1.5}, loop:true, rewind:true, sequence:200});
numLetters - how many letters - same as letters.numChildren
percents - access to the array of percents for letter positioning - resize() after changing unless interactive which auto resizes
color - get or set the color of the text
allowToggle - get or set the Boolean to allow toggling the path
interactive - get or set the Boolean to allow interaction with the path

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54.5

zim.LabelOnPath = function(label, path, percentAngle, percents, showPath, allowToggle, interactive, onTop, rtl, style, group, inherit) {
	var sig = "label, path, percentAngle, percents, showPath, allowToggle, interactive, onTop, rtl, style, group, inherit";
	var duo; if (duo = zob(zim.LabelOnPath, arguments, sig, this)) return duo;
	z_d("54.5");
	this.zimContainer_constructor(null,null,null,null,false);
	this.type = "LabelOnPath";
	this.group = group;
	var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

	if (zot(label)) label = DS.label!=null?DS.label:new zim.Label("Label on Path");
	if (zot(path)) path = DS.path!=null?DS.path:new zim.Squiggle({points:[[0,0,0,0,-86,57,86,-57],[300,150,0,0,-133,21,133,-21]]});
	if (zot(percentAngle)) percentAngle = DS.percentAngle!=null?DS.percentAngle:100;
	if (zot(percents)) percents = DS.percents!=null?DS.percents:null;
	if (zot(showPath)) showPath = DS.showPath!=null?DS.showPath:true;
	if (zot(allowToggle)) allowToggle = DS.allowToggle!=null?DS.allowToggle:true;
	if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:true;
	if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:false;
	if (zot(rtl)) rtl = DS.rtl!=null?DS.rtl:WW.DIR=="rtl"||zim.DIR=="rtl";
	if (rtl) path.reversePoints();
	
	var color = label.color;

	path.addTo(this);
	var that = this;
	this.path = path;
	this.allowToggle = allowToggle;
	path.interactive = interactive;

	if (typeof label == "string") label = new zim.Label(label);

	var lastAlpha = path.alpha;
	if (!showPath) path.alp(0);
	path.onTop = onTop;

	var letters = this.letters = new zim.Container().addTo(this);
	if (!percents) {
		percents = [];
		for (var i=0; i<label.text.length; i++) {
			percents.push(zim.decimals(1/(label.text.length-(path.type=="Blob"?0:1))*100*i));
		}
	}
	this.percents = percents;
	
	function setText() {
		var i;
		for (i=letters.numChildren-1; i>=0; i--) {
			letters.getChildAt(i).dispose();
		}
		that.numLetters = label.text.length;
		for (i=0; i<that.numLetters; i++) {
			var letter = label.clone();
			letter.text = label.text[i];
			letter.centerReg(letters).reg(null,letter.height);
			if (letter.text != "" && letter.text != " ") letter.expand(0);
			if (that.allowToggle) letter.cur("pointer");
			letter.on("mousedown", function () {
				if (!that.allowToggle) return;
				that.toggle();
			});
		}
		that.resize();
	}

	this.setProps = function(props) {
		zim.setProps(this.letters, props);
		return this;
	}

	this.resize = function() {
		var segmentRatios = path.segmentRatios;
		var segmentPoints = path.segmentPoints;
		for (var i=0; i<this.numLetters; i++) {
			var point = path.getCurvePoint(percents[i]/100, segmentRatios, segmentPoints, true);
			if (!point) continue;
			var locPoint = this.globalToLocal(point.x, point.y);
			if (!locPoint) continue;
			letters.getChildAt(i)
				.loc(locPoint)
				.rot((point.angle>180?(point.angle-360):point.angle)*percentAngle/100);
			if (rtl) letters.getChildAt(i).rotation+=180;
		}
		return this;
	};

	setText();

	this.showPath = function(controls) {
		this.toggle(true);
		path.toggle(controls);
		return this;
	};
	this.hidePath = function() {
		this.toggle(false);
		return this;
	};

	Object.defineProperty(that, 'text', {
		get: function() {
			return label.text;
		},
		set: function(value) {
			label.text = value;
			percents = [];
			for (var i=0; i<label.text.length; i++) {
				percents.push(zim.decimals(1/(label.text.length-(path.type=="Blob"?0:1))*100*i));
			}
			setText();
			// if (that.stage) that.stage.update();
		}
	});

	Object.defineProperty(this, 'color', {
		get: function() {
			return color;
		},
		set: function(value) {
			color = value;
			for (var i=0; i<that.letters.numChildren; i++) {that.letters.getChildAt(i).color = color;}
			if (that.stage) that.stage.update();
		}
	});

	Object.defineProperty(that, 'interactive', {
		get: function() {
			return interactive;
		},
		set: function(value) {
			interactive = value;
			path.interactive = value;
			if (this.ticker) zim.Ticker.remove(this.ticker);
			if (interactive) {
				this.ticker = zim.Ticker.add(function () {
					that.resize();
				});
			}
		}
	});

	if (this.interactive) {
		this.ticker = zim.Ticker.add(function () {
			that.resize();
		});
	}
	var _toggled = that.toggled = showPath;

	this.toggle = function(state) {
		if (!this.allowToggle) return;
		
		if (zot(state)) _toggled = !_toggled;
		else if (state) _toggled = true;
		else _toggled = false;
		if (_toggled) {
			path.alp(lastAlpha);
			if (this.interactive) {
				path.showControls();
				letters.mouseEnabled = false;
				letters.mouseChildren = false;
				letters.cur("default");
				if (this.controlHideEvent) path.off("controlshide", this.controlHideEvent);
				this.controlHideEvent = path.on("controlshide", function () {
					letters.mouseEnabled = true;
					letters.mouseChildren = true;
					letters.cur("pointer");
					lastAlpha = path.alpha;
					path.alp(0);
					_toggled = false;
					that.toggled = _toggled;
					if (that.stage) that.stage.update();
				}, null, true); // just once
			}
		} else {
			lastAlpha = path.alpha;
			path.alp(0);
			letters.mouseEnabled = true;
			letters.mouseChildren = true;
			letters.cur("pointer");
		}
		that.toggled = _toggled;
		if (that.stage) that.stage.update();
		return that;
	};

	if (showPath) that.toggle(true);

	if (style!==false) zim.styleTransforms(this, DS);
	this.clone = function() {
		return that.cloneProps(new zim.LabelOnPath(that.label.clone(), that.path.clone(), percentAngle, zim.copy(percents), showPath, allowToggle, interactive, onTop, rtl, style, this.group, inherit));
	};
	this.dispose = function(a,b,disposing) {
		if (this.ticker) zim.Ticker.remove(this.ticker);
		if (!disposing) this.zimContainer_dispose(true);
		return true;
	};
};
zim.extend(zim.LabelOnPath, zim.Container, ["clone", "dispose"], "zimContainer", false);
//-54.5

/*--
zim.LabelOnArc = function(label, size, font, color, radius, flip, spacing, letterSpacing, angles, showCircle, arcColor, arcBorderColor, arcBorderWidth, radiusSpread, rtl, style, group, inherit)

LabelOnArc
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a label along an arc - see also LabelOnPath - for a more interactive version
Used internally for making labels on Radial and RadialMenu objects

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const loa = new LabelOnArc({
	label:"Hello World"
}).center();
zog(loa.text);
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)

label - (default "Label on Arc") a String or a ZIM Label
	can set any label properties such as color, size, font, etc. on the label passed in
size - (default 30) the font size of the label
font - (default "verdana") the font of the label - can load custom fonts in Frame() or F.loadAssets()
color - (default white) a color for the text can be any ZIM or CSS color
radius - (default 100) the radius of the circle to apply the arc of the text
flip - (default false) set to true to flip text if between 90 and 270
spacing - (default 0) the space between the Label and the arc - varies with different fonts
letterSpacing - (default 5) - the space between letters
angles - (default null) optionally specify an array of angles for the letters
	this will override letterSpacing - see also angles property to receive an array of angles
showCircle - (default false) set to true to see a circle - then use circle property to adjust if desired
arcColor - (default null) set to a color to see a filled arc
arcBorderColor - (default null) the borderColor of the arc
acrBorderWidth - (default 2 if arcBorderColor) the borderWidth of the arc
radiusSpread - (default false) set to true to keep same letter angles as radius is changed 
	ignored if angles are provided
rtl - (default ZIM DIR) - set to true for right to left text
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
setProps(properties) - sets provided properties (as {prop:val, prop:val}) for each label
	the values accept ZIM VEE - dynamic parameters - see ZIM Pick()
	returns object for chaining
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - the name of the class as a String
text - get or set the text on the arc
radius - get or set the radius of the arc (see radiusSpread parameter too)
labels - an array of ZIM Label objects for the letters
letters - access to ZIM Container of labels used for letters
	for instance labels.loop(function (label) {label.color = red;});
	or animate as a sequence labels.animate({props:{scale:1.5}, loop:true, rewind:true, sequence:200});
numLetters - how many letters - same as letters.numChildren
letterHeight - get the height of letters
color - get or set the text color
circle - access to the circle object
arc - access to the arc object
angles - access to the array angles for letter positioning
	use angles.toString() to log angle data (for kerning)
	this can be modified and passed in as an angles property to start
innerRadius - the inside radius at the bottom of the text
outerRadius - the outside radius at the top of the text

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54.55

zim.LabelOnArc = function(label, size, font, color, radius, flip, spacing, letterSpacing, angles, showCircle, arcColor, arcBorderColor, arcBorderWidth, radiusSpread, rtl, style, group, inherit) {
	var sig = "label, size, font, color, radius, flip, spacing, letterSpacing, angles, showCircle, arcColor, arcBorderColor, arcBorderWidth, radiusSpread, rtl, style, group, inherit";
    var duo; if (duo = zob(zim.LabelOnArc, arguments, sig, this)) return duo;
	z_d("54.55");

    this.group = group;
    var DS = style===false?{}:zim.getStyle("LabelOnArc", this.group, inherit);

    if (zot(size)) size = DS.size!=null?DS.size:30;
    if (zot(label)) label = DS.label!=null?DS.label:new zim.Label("Label on Arc", size);
    if (zot(font)) font = DS.font!=null?DS.font:"verdana";
    if (zot(color)) color = DS.color!=null?DS.color:zim.white;
    if (zot(radius)) radius = DS.radius!=null?DS.radius:100;
    if (zot(flip)) flip = DS.flip!=null?DS.flip:false;
    if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:0;
    if (zot(letterSpacing)) letterSpacing = DS.letterSpacing!=null?DS.letterSpacing:5;
    if (zot(angles)) angles = DS.angles!=null?DS.angles:null;
	var anglesO = !zot(angles);
	var anglesStart = zim.copy(angles);
    if (zot(showCircle)) showCircle = DS.showCircle!=null?DS.showCircle:false;
    if (zot(arcColor)) arcColor = DS.arcColor!=null?DS.arcColor:null;
    if (zot(arcBorderColor)) arcBorderColor = DS.arcBorderColor!=null?DS.arcBorderColor:null;
	if (zot(arcBorderWidth)) arcBorderWidth = DS.arcBorderWidth!=null?DS.arcBorderWidth:null;
    if (zot(radiusSpread)) radiusSpread = DS.radiusSpread!=null?DS.radiusSpread:false;
    //if (zot(inside)) inside = DS.inside!=null?DS.inside:true;
	if (zot(rtl)) rtl = DS.rtl!=null?DS.rtl:WW.DIR=="rtl"||zim.DIR=="rtl";
	
    var outerRadius = this.outerRadius = radius + spacing + label.height;
	this.innerRadius = radius + spacing;
    this.zimContainer_constructor(-outerRadius,-outerRadius,outerRadius*2,outerRadius*2, false);
    this.type = "LabelOnArc";

    var that = this;
    if (label.type != "Label") label = new zim.Label(label, size, font, color);
	label.text;
	
	
	var letters, labels, arc, circle, totalAngle, rawAngles 
	function makeLabel() {
		that.disposeAllChildren();	
		if (flip) {
			var rev = label.text.split("").reverse().join("");
			label.text = rev;
		}
		letters = that.letters = new zim.Container(that.width, that.height).centerReg(that);

		that.numLetters = label.text.length;
		that.letterHeight = label.height;

		labels = that.labels = [];
		var i;
		for (i=0; i<that.numLetters; i++) {
			var letter = label.clone();
			labels.push(letter);
			letter.text = label.text[i];
			letter.letterHolder = new zim.Container(letter.width, letter.height);
			letter.centerReg(letter.letterHolder).rot(flip?180:0);
		}
		if (rtl) labels.reverse();
		
		circle = that.circle = new zim.Circle(radius);
		if (showCircle) circle.addTo(that);
		arc = that.arc = new zim.Shape().addTo(that);

		makeArc();	

		if (angles) {
			// overwrite totalAngle with given angles
			totalAngle = 0;
			for (i=0; i<angles.length; i++) {
				totalAngle += angles[i];
			}
			totalAngle += angles[angles.length-1]/2; // whatever
		}    

		makeAngles();	
	}	
	makeLabel();
	

	function makeArc() {
		totalAngle = 0;
		rawAngles = [0];
		for (var i=0; i<that.numLetters; i++) {
			var letter = labels[i];
			var ang = Math.atan((letter.width+letterSpacing)/2/(radius+spacing))*180/Math.PI*2;
			rawAngles.push(ang);
			totalAngle += ang;        
			letter.letterHolder.centerReg(letters).reg(null,radius+spacing+letter.height + (flip?letter.height*.13:0));
		}
		that.circle.radius = radius;

		if (arcColor || arcBorderColor || arcBorderWidth) {
		if (arcBorderWidth>0 && zot(arcBorderColor)) arcBorderColor = zim.black;
		else if (zot(arcBorderWidth) && !zot(arcBorderColor)) arcBorderWidth = 2;
			arc.graphics.c().f(null).s(arcBorderColor).ss(arcBorderWidth).arc(0,0,radius, (that.startAngle-90)*Math.PI/180, (that.startAngle-90+totalAngle)*Math.PI/180);
		}
	}		

	function makeAngles() {
		var i;
		if (!anglesO) {
			angles = [];
			for (i=0; i<rawAngles.length-1; i++) {
				angles[i] = Math.round((rawAngles[i]+rawAngles[i+1])/2*100)/100;
			}	
		}	
		that.angles = angles;
		that.startAngle = - totalAngle/2;
		var lastAngle = that.startAngle;
		for (i=0; i<letters.numChildren; i++) {
			var letter = letters.getChildAt(i);
			// var amount = angles[i];
			lastAngle = letter.rotation = lastAngle + angles[i];
		}		
	}

	this.setProps = function(props) {
		zim.setProps(this.labels, props);
		return this;
	}
    		
	Object.defineProperty(this, 'radius', {
        get: function() {
            return radius;
        },
        set: function(value) {
            radius = value;
            makeArc();
			if (!anglesO && !radiusSpread) makeAngles();
        }
    });	

    Object.defineProperty(this, 'color', {
        get: function() {
            return color;
        },
        set: function(value) {
            color = value;
            for (var i=0; i<that.labels.length; i++) {that.labels[i].color = color;}
            if (that.stage) that.stage.update();
        }
    });
	
	Object.defineProperty(that, 'text', {
		get: function() {
			return label.text;
		},
		set: function(value) {
			label.text = value;
			if (anglesStart) angles = zim.copy(anglesStart);
			else angles = null;
			makeLabel();
			// if (that.stage) that.stage.update();
		}
	});

	if (style!==false) zim.styleTransforms(this, DS);
    this.clone = function() {
        return that.cloneProps(new zim.LabelOnArc(label, size, font, color, radius, flip, spacing, letterSpacing, angles, showCircle, arcColor, arcBorderColor, arcBorderWidth, radiusSpread, rtl, style, this.group, inherit));
    };

};
zim.extend(zim.LabelOnArc, zim.Container, "clone", "zimContainer", false);
//-54.55

/*--
zim.LabelLetters = function(label, align, valign, letterSpacing, letterSpacings, lineSpacing, lineSpacings, lineHeight, lineAlign, lineValign, cache, rtl, style, group, inherit)

LabelLetters
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Splits apart a ZIM Label into labels per characater
to allow manipulation of each character - animation, kerning, etc.
SEE: https://zimjs.com/ten/radial.html - (ZIM TEN) the title and subtitle

Also accepts basic HTML-like tags to allow Canvas text to have multi-formatting.
SEE: https://zimjs.com/cat/html.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const letters = new LabelLetters("Label Letters", CENTER, "bottom", 5)
	.center()
	.animate({
		props:{scale:1.5, rotation:-10},
		wait:.5,
		time:.2,
		sequence:.05,
		rewind:true
	});
END EXAMPLE

EXAMPLE 
new LabelLetters("and Radial(), LabelOnArc(), LabelLetters()")
	.center()
	.animate({
		from:true,
		props:{alpha:0},
		time:.01,
		sequence:.04 
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
label - (default "Label Letters") a String or a ZIM Label
	can set any label properties such as color, size, font, etc. on the label passed in
	can pass in a string with basic "old fashioned" HTML tags as follows:
	<b>bold</b> - or <strong>bold</strong>
	<i>italic</i> - or <em>italic</em>
	<u>underline</u> - can use this with <a> to make a classic underlined link 
	<a href=url target=_blank>link</a>
	<font 
		color=zimColor 
		backgroundColor='htmlColor'
		rollBackgroundColor=#hexColor
		size=20 
		family=verdana 
		group=groupStyle>font</font>
	note: use NO QUOTES except for single quote with colors if want HTML blue for instance rather than ZIM blue
	note: setting groupStyle will make letter from scratch as opposed to building on the submitted label styles
align - (default CENTER) set to LEFT, CENTER / MIDDLE, RIGHT for letter registration x positioning
	also see lineAlign for alignment of lines
valign - (default CENTER) set to TOP, CENTER / MIDDLE, "bottom" for letter registration y positioning
	also see lineValign for vertical alignment of lines
letterSpacing - (default 5) - the space between letters
	letterSpacing is turned off if the Label has a backgroundColor 
	to use letterSpacing and a backgroundColor use the backing parameter of Label instead of backgroundColor
	or use letterSpacings (see below) to set specific spacings (kerning) on letters
letterSpacings - (default null) - an array of the space between letters each letter
	any value here will override the letterSpacing
	0 is the index for the space between first and second letter
	the length of this should be one less than the number of letters
lineSpacing - (default 5) - the space between lines (not including lineHeight)
lineSpacings - (default null) - an array of the space between lines
	any values here will override the lineSpacing
lineHeight - (default null) null will auto set the height.  Set to a number to force line heights - if \n or <br> are present in label
lineAlign - (default LEFT or RIGHT for rtl:true) the horizontal alignment of lines if multiple lines - set to LEFT, CENTER/MIDDLE, RIGHT
	set to START to lineAlign LEFT for ZIM DIR constant is "ltr" or RIGHT when DIR="rtl" - END is the opposite
lineValign - (default BOTTOM) the vertical alignment within lineSpacing if multiple lines - set to TOP, CENTER/MIDDLE, BOTTOM
cache - (default false) set to true to cache each letter - improves performance on animation
rtl - (default false) set to true to reverse letters other than a-zA-Z0-9 and set default lineAlign to RIGHT
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
setProps(properties) - sets provided properties (as {prop:val, prop:val}) for each label
	the values accept ZIM VEE - dynamic parameters - see ZIM Pick()
	returns object for chaining
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - the name of the class as a String
text - get the text of the original Label
	See: https://zimjs.com/zapp/Z_VSR9X for updating text
labels - an array of ZIM Label objects for the letters
numLetters - how many letters (same as numChildren)

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54.57

	zim.LabelLetters = function(label, align, valign, letterSpacing, letterSpacings, lineSpacing, lineSpacings, lineHeight, lineAlign, lineValign, cache, rtl, style, group, inherit) {
		var sig = "label, align, valign, letterSpacing, letterSpacings, lineSpacing, lineSpacings, lineHeight, lineAlign, lineValign, cache, rtl, style, group, inherit";
		var duo; if (duo = zob(zim.LabelLetters, arguments, sig, this)) return duo;
		z_d("54.57");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("LabelLetters", this.group, inherit);

		if (zot(label)) label = DS.label != null ? DS.label : new zim.Label("Label Letters");
		if (zot(align)) align = DS.align != null ? DS.align : "center";
		if (zot(valign)) valign = DS.valign != null ? DS.valign : "center";
		if (zot(letterSpacing)) letterSpacing = DS.letterSpacing != null ? DS.letterSpacing : 5;
		if (zot(letterSpacings)) letterSpacings = DS.letterSpacings != null ? DS.letterSpacings : null;
		if (zot(lineHeight)) lineHeight = DS.lineHeight != null ? DS.lineHeight : null;
		if (zot(lineSpacing)) lineSpacing = DS.lineSpacing != null ? DS.lineSpacing : 5;
		if (zot(lineSpacings)) lineSpacings = DS.lineSpacings != null ? DS.lineSpacings : null;
		if (zot(rtl)) rtl = DS.rtl != null ? DS.rtl : false;		
		if (zot(lineAlign)) lineAlign = DS.lineAlign != null ? DS.lineAlign : rtl?"right":"left";
		if (zot(lineValign)) lineValign = DS.lineValign != null ? DS.lineValign : "bottom";
		if (zot(cache)) cache = DS.cache != null ? DS.cache : false;

		this.zimContainer_constructor(null, null, null, null, false);
		this.type = "LabelLetters";

		var that = this;
		var letterData = that.letterData = [];
		var original, data;
		if (label.type != "Label") {
			data = parseHTML(label); // returns {text:text, data:data}	
			letterData = data.data;	
			label = new zim.Label(data.text);						
		} else {
			data = parseHTML(label.text); 
			letterData = data.data;	
			label.text = data.text;
		}
		that.text = data.original;
		that._color = label.color;
		
		// handle DIR effect 
		if ((WW.DIR && WW.DIR=="rtl") || (!WW.DIR && zim.DIR=="rtl")) {
			if (lineAlign=="start") lineAlign="right";
			else if (lineAlign=="end") lineAlign="left";
		} else {
			if (lineAlign=="start") lineAlign="left";
			else if (lineAlign=="end") lineAlign="right";
		}
		
		function parseHTML(html) {
			var data = [];
						
			// var example = "LabelLetters()<br><br><font group=heading backgroundColor=yellow rollBackgroundColor=green><a href=https://zimjs.com target=_blank>Example</a></font>: <b>strong</b> <i>emphasis</i> <u>underline</u><br><font color=red size=50 family=verdana><strong>big</strong> red verdana</font><br>the next line"
			// "LabelLetters()Example: strong emphasis underlinebig red verdanathe next line"
			// "01234567890123456789012345678901234567890123456789012345678901234567890120123456789012"
			// "0         1         2         3         4         5         6         7"
			// html = "!Roger הגיע בשבילך משהו בדואר Dan אני לומד עברית";
			// html = "הגיע בשבילך משהו בדואר.";
						
			function insert(data) {	
				return data.split("").reverse().join("")
			}
			if (rtl) {
				count = -1;				
				html = html.replace(/[\u0591-\u07FF]+/ig, insert);	
				
				// and there may be tags or LTR characters next to RTL without a space:
				html = html.replace(/([^\u0591-\u07FF ])([\u0591-\u07FF])/ig, "$1-!!-$2"); // note the not space
				html = html.replace(/([\u0591-\u07FF])([^\u0591-\u07FF ])/ig, "$1-!!-$2"); // note the not space				
				html = html.replace(/([^\u0591-\u07FF]) ([\u0591-\u07FF])/ig, "$1-!!- -!!-$2");
				html = html.replace(/([\u0591-\u07FF]) ([^\u0591-\u07FF])/ig, "$1-!!- -!!-$2");
				
				var sp = html.split(/-!!-/g);
				zim.loop(sp, function(ssp, i){
					if (ssp.match(/[\u0591-\u07FF]/i)) {
						sp[i] = ssp.split(" ").reverse().join(" ");
					}
				});
				html = sp.join("");	
			}
			

			// normalize tags
			html = html.replace(/\n|\r/g,"<br>");
			html = html.replace(/<strong>|<strong \/>|<strong\/>/gi,"<b>");
			html = html.replace(/<\/strong>/gi,"</b>");
			html = html.replace(/<em>|<em \/>|<em\/>/gi,"<i>");
			html = html.replace(/<\/em>/gi,"</i>");
			html = html.replace(/\\n|\\r/g,"<br>");
			html = html.replace(/<br>|<br \/>|<br\/>(<\/br>)?/gi,"<br>");			
			html = html.replace(/<b/gi,"<b");
			html = html.replace(/<i/gi,"<i");
			html = html.replace(/<u/gi,"<u");
			html = html.replace(/<br/gi,"<br");
			html = html.replace(/<a/gi,"<a");
			html = html.replace(/<font/gi,"<font");
			
			// turn all other tags into "" do split on tag and count index for tag 
			// process this and store in data so get index of tags in string with no tags counted
			
			var regs = [
				/<(a|i|u|f|br|\/a|\/i|\/u|\/f|\/b)[^>]*>/g,
				/<(a|i|u|f|br|\/a|\/i|\/u|\/f|b)[^>]*>/g,				
				/<(b|i|u|f|br|\/b|\/i|\/u|\/f|\/a)[^>]*>/g,
				/<(b|i|u|f|br|\/b|\/i|\/u|\/f|a)[^>]*>/g,				
				/<(b|a|u|f|br|\/b|\/a|\/u|\/f|\/i)[^>]*>/g,
				/<(b|a|u|f|br|\/b|\/a|\/u|\/f|i)[^>]*>/g,
				/<(b|a|i|f|br|\/b|\/a|\/i|\/f|\/u)[^>]*>/g,
				/<(b|a|i|f|br|\/b|\/a|\/i|\/f|u)[^>]*>/g,	
				/<(b|a|i|u|br|\/b|\/a|\/i|\/u|\/f)[^>]*>/g,
				/<(b|a|i|u|br|\/b|\/a|\/i|\/u|f)[^>]*>/g			
			];
			var types = ["b","a","i","u","font"];
			var p;
			zim.loop(types, function(type, i) {
				p = html.replace(regs[i*2],"");
				var arr;
				if (type=="font") {
					arr = p.split("<font ");
				} else if (type=="a") {
					arr = p.split("<a ");
				} else {
					arr = p.split("<"+type+">");
				}	
				process(arr, type, 0); // 0 for add		
					
				p = html.replace(regs[i*2+1],"");				
				arr = p.split("</"+type+">");										
				process(arr, type, 1); // 1 for remove
			});
						
			
			p = html.replace(/<br>/gi,"@^#");
			p = p.replace(/<(b|a|i|u|f|\/b|\/a|\/i|\/u|\/f)[^>]*>/g,"");
			var arr = p.split("@^#");
			original = arr.join("\n");
			p = arr.join("");
			process(arr, "br", 0); // 0 for add
			
			function process(text, type, action) {
				if (text.length > 1) {					
					if ((type=="font" || type=="a") && action==0) {					
						var length = text[0].length;
						zim.loop(text, function(s, i) {
							
							if (i==0) return;					
							var d = data[length];
							if (!d) data[length] = [];
							d = data[length] ;
							
							var arr = s.split(">");
							
							if (d[action]) d[action].push(type + " " + arr[0]);
							else d[action] = [type + " " + arr[0]];
							
							length += arr[1].length;
						});
					} else {										
						text.pop();	
						var running = 0;			
						zim.loop(text, function(s) {
							running += s.length;
							var d = data[running];
							if (!d) data[running] = [];
							d = data[running]; 
							if (d[action]) d[action].push(type);
							else d[action] = [type];							
						});
					}
				}
			}		
			
			// [[adds at index], [removes at index]]
			// b,i,u,br,a,font
			// var da = [,, [["b","i"]] ,[,["b"]],,,[["br","font color=red size=10 family=courier"]],["i"]],...];
			return {text:p, data:data, original:original};
		}	
		
		that.numLetters = label.text.length;
		
		// NORMALIZE SPACINGS
		var letterSpacingsOriginal = !zot(letterSpacings);
		if (letterSpacings && !Array.isArray(letterSpacings)) letterSpacings = null;
		var i;
		if (!letterSpacings) {
			letterSpacings = [];			
			for (i = 0; i < that.numLetters; i++) {				
				letterSpacings.push(letterSpacing);
			}
		} else {
			for (i = 0; i < that.numLetters; i++) {
				if (zot(letterSpacings[i])) letterSpacings[i] = letterSpacing;
			}
		}
		that.letterSpacings = letterSpacings;

		if (lineSpacings && !Array.isArray(lineSpacings)) lineSpacings = null;
		if (!lineSpacings) {
			lineSpacings = [];
			for (i = 0; i < that.numLetters - 1; i++) {
				lineSpacings.push(lineSpacing);
			}
		} else {
			for (i = 0; i < that.numLetters - 1; i++) {
				if (zot(lineSpacings[i])) lineSpacings[i] = lineSpacing;
			}
		}
		that.lineSpacings = lineSpacings;
		
		// LINE CONTROL
		that.labels = [];
		that.lines = [[]];
		var lineWidths = [];
		var lineHeights = [];
		var linePositionsY = [0];
		var lineY = 0;
		var lineW = 0;
		var lineH = 0;
		var lineNum = 0;
		var maxW = 0;
		
		// HTML CONTROL
		var d = letterData;
		var bCheck = false;
		var iCheck = false;
		var uCheck = false;
		var brCheck = false;
		var colorCheck = false;
		var sizeCheck = false;
		var groupCheck = false;		
		var familyCheck = false;
		var urlCheck = false;
		var targetCheck = false;
		var backgroundColorCheck = false;
		var rollBackgroundColorCheck = false;
		
		// ROLLOVER CONTROL		
		that.rolls = [[]];
		
		for (i=0; i<that.numLetters; i++) {
			
			// PARSE TAG CHECKS
						
			brCheck = false;			
			if (d[i]) {
				
				// end tags - do ends first just in case tag ends at same letter it starts
				if (d[i][1]) {
					if (d[i][1].indexOf("b") >= 0) bCheck = false;
					if (d[i][1].indexOf("i") >= 0) iCheck = false;
					if (d[i][1].indexOf("u") >= 0) uCheck = false;
					zim.loop(d[i][1], function (item) {
						if (item.match(/^font/i)) {
							colorCheck = false;
							backgroundColorCheck = false;
							if (rollBackgroundColorCheck) that.rolls.push([]);
							rollBackgroundColorCheck = false;
							sizeCheck = false;
							familyCheck = false;
							groupCheck = false;
							return;
						}
						if (item.match(/^a/i)) {
							urlCheck = false;
							targetCheck = false;
							return;
						}
					});	
				}	
				
				// start tags				
				if (d[i][0]) {
					if (d[i][0].indexOf("b") >= 0) bCheck = true;
					if (d[i][0].indexOf("i") >= 0) iCheck = true;
					if (d[i][0].indexOf("u") >= 0) uCheck = true;
					brCheck = 0;
					zim.loop(d[i][0], function (item) {
						if (item=="br") brCheck++;
					});
					zim.loop(d[i][0], function (item) {
						var r, ind;
						if (item.match(/^font/i)) {
							r = item.match(/ color\s?=\s?(\S*)/i);			
							if (r) {
								colorCheck = r[1];
								ind = zim.colors.indexOf(colorCheck);
								if (ind>=0) colorCheck = zim.colorsHex[ind];
								colorCheck = colorCheck.replace(/'/g,"");
							}
							r = item.match(/size\s?=\s?(\S*)/i);
							if (r) sizeCheck = r[1];
							r = item.match(/backgroundColor\s?=\s?(\S*)/i);						
							if (r) {
								backgroundColorCheck = r[1];
								ind = zim.colors.indexOf(backgroundColorCheck);
								if (ind>=0) backgroundColorCheck = zim.colorsHex[ind];
								backgroundColorCheck = backgroundColorCheck.replace(/'/g,"");
							}
							r = item.match(/rollBackgroundColor\s?=\s?(\S*)/i);
							if (r) {
								rollBackgroundColorCheck = r[1];
								ind = zim.colors.indexOf(rollBackgroundColorCheck);
								if (ind>=0) rollBackgroundColorCheck = zim.colorsHex[ind];
								rollBackgroundColorCheck = rollBackgroundColorCheck.replace(/'/g,"");
							}
							r = item.match(/group\s?=\s?(\S*)/i);
							if (r) groupCheck = r[1];
							r = item.match(/family\s?=\s?(.*)/i);
							if (r) {
								familyCheck = r[1];		
								familyCheck = familyCheck.split(/\ssize\s?=|\scolor\s?=|\sgroup\s?=/i)[0];
							}					
							return;
						} 
						if (item.match(/^a/i)) {
							r = item.match(/href\s?=\s?(\S*)/i);
							if (r) urlCheck = r[1];
							r = item.match(/target\s?=\s?(\S*)/i);
							if (r) targetCheck = r[1];
							return;
						} 
					});										
				}	// end start tag	
						
			} // end all tags
			
			// HANDLE CHECKS AND STORE MAX SIZES
			var letter;
			if (groupCheck) {
				letter = new zim.Label({text:label.text[i], group:groupCheck})
			} else {
				letter = label.clone();				
				letter.text = label.text[i];
			}
			that.labels.push(letter);				
			
			if (bCheck) letter.bold = true;
			if (iCheck) letter.italic = true;
			if (colorCheck) letter.color = colorCheck;
			if (backgroundColorCheck) letter.backgroundColor = backgroundColorCheck;
			
			var s = letterSpacingsOriginal?letterSpacings[i]:zot(letter.backgroundColor)?letterSpacings[i]:-.5;		

			if (rollBackgroundColorCheck) {
				letter.rollIndex = that.rolls.length-1;
				letter.zrbc = rollBackgroundColorCheck;				
				letter.zobc = letter.backgroundColor;
				that.rolls[letter.rollIndex].push(letter);
				letter.expand(0);
				letter.on("mouseover", rollOn);				
				letter.on("mouseout", rollOff);
			}
			
			if (urlCheck) {
				letter.expand(s,0);
				letter.zurl = urlCheck;
				letter.ztar = targetCheck;
				letter.cur();
				letter.on("click", function (e) {
					var letter = e.currentTarget;
					rollOff(e);
					if (!letter.ztar) letter.ztar = "_self";
					zgo(letter.zurl, letter.ztar);					
				});	
			}
			if (familyCheck) letter.font = familyCheck;				
			if (sizeCheck) letter.size = sizeCheck;			
			
			
			if (brCheck) {
				lineY += (zot(lineHeight)?lineH:lineHeight) + lineSpacings[lineNum];
				linePositionsY.push(lineY);
				lineHeights.push(zot(lineHeight)?lineH:lineHeight);
				lineWidths.push(lineW);						
				maxW = Math.max(maxW, lineW);				
			}		
			
			if (brCheck) {
				if (brCheck > 1) {
					zim.loop(brCheck-1, function () {
						that.lines.push([]);
						lineY += (zot(lineHeight)?lineH:lineHeight) + lineSpacings[lineNum];
						linePositionsY.push(lineY);
						lineHeights.push(zot(lineHeight)?lineH:lineHeight);
						lineWidths.push(0);							
						lineNum++;
					});
				}	
				lineH = 0;
				lineW = 0;
				that.lines.push([]);
				lineNum++;
			}	
			
			lineW += letter.width + s;
			lineH = Math.max(lineH, letter.height);
			
			if (i==that.numLetters-1) {
				lineWidths.push(lineW);	
				lineHeights.push(lineH);						
				maxW = Math.max(maxW, lineW);
			}
			
			that.lines[lineNum].push(letter);
			
			if (uCheck) letter.underline = new zim.Line(letter.width+s+1,1,letter.color).center(letter,this).mov(0,letter.height/2);
					
		} // end checks
		
		// ROLL FUNCTIONS
		
		function rollOn(e) {
			var letter = e.currentTarget;
			var rolls = that.rolls[letter.rollIndex]
			zim.loop(rolls, function (l) {
				l.backgroundColor = letter.zrbc;
			});
			if (letter.stage) letter.stage.update();
		}
		function rollOff(e) {
			var letter = e.currentTarget;
			var rolls = that.rolls[letter.rollIndex]
			zim.loop(rolls, function (l) {
				l.backgroundColor = letter.zobc;
			});
			if (letter.stage) letter.stage.update();
		}
		
		
		// LOOP THROUGH LINES AND APPLY POSITIONS
		var count = 0;
		for (var j=0; j<that.lines.length; j++) {
			var ll = that.lines[j];
			lineW = lineWidths[j];
			lineH = lineHeights[j];
			lineY = linePositionsY[j];
			
			var startX, startY;
			if (lineAlign=="left") startX = 0;
			else if (lineAlign=="right") startX = maxW-lineW;
			else startX = (maxW-lineW)/2;
			startY = lineY;		
								
			for (i=0; i<ll.length; i++) {
				count++;
				if (cache) letter.cache();
				letter = ll[i];
				letter.regX = align=="left"?0:(align=="right"?letter.width:letter.width/2);
				letter.regY = valign=="top"?0:(valign=="bottom"?letter.height:letter.height/2);				
				
				var sY = startY+(valign=="top"?0:valign=="bottom"?letter.height:letter.height/2);
				if (lineValign=="center" || lineValign=="middle") {
					sY += (lineHeights[j]-letter.height)/2;
				} else if (lineValign=="bottom") {
					sY += lineHeights[j]-letter.height;					
				}
				s = letterSpacingsOriginal?letterSpacings[count-1]:zot(letter.backgroundColor)?letterSpacings[count-1]:-.5;						
				if (align=="left") {
					letter.loc(startX, sY, this);
					startX = letter.x+letter.width+s;
				} else if (align=="right") {
					letter.loc(startX+letter.width, sY, this);
					startX = letter.x+s;
				} else {
					letter.loc(startX+letter.width/2, sY, this);
					startX = letter.x+letter.width/2+s;
				}
																
			} // end lines letters
		} // end lines

		if (!this.getBounds()) this.setBounds(0,0,0,0);
		this.regX = this.getBounds().x;
		this.regY = this.getBounds().y;

		this.setProps = function(props) {
			zim.setProps(this.labels, props);
			return this;
		}
		
		Object.defineProperty(this, 'color', {
			get: function () {
				return this._color;
			},
			set: function (value) {
				this._color = value;
				for (var i = 0; i < that.numChildren; i++) { that.getChildAt(i).color = this._color; }
				if (that.stage) that.stage.update();
			}
		});

		this.dispose = function() {
			zim.gD(this); // globalDispose function for common elements
			zim.loop(that.labels, function (letter) {
				letter.removeFrom();
				letter.dispose();				
			});
			that.removeFrom();
		}
		
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function () {
			return that.cloneProps(new zim.LabelLetters(label, align, valign, letterSpacing, letterSpacings, lineSpacing, lineSpacings, lineHeight, lineAlign, lineValign, cache, rtl, style, this.group, inherit));
		};

	};
	zim.extend(zim.LabelLetters, zim.Container, "clone", "zimContainer", false);
	//-54.57

/*--
zim.LabelWords = function(label, width, size, font, color, backgroundColor, itemCache, itemRegX, itemRegY, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit)

LabelWords
zim class - extends a zim Wrapper which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Splits apart a ZIM Label into labels per word - also see LabelLetters
to allow manipulation of each word - animation, color, etc.
SEE: https://zimjs.com/016/labelwords.html 

NOTE: since this is really a Wrapper containing word Labels, all the wrapper functionality can be used.
SEE: https://zimjs.com/ten/wrapper.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new LabelWords({
	label:"Here is LabelWords that divides text into words for individual control!",
	color:white, 
	itemRegY:BOTTOM, 
	itemCache:true,
	backgroundColor:series(red,orange,pink,green,blue,purple),
	size:50,
	width:700,
	align:CENTER
}).center().mov(0,20).animate({
	props:{scaleY:0},
	time:.5,
	rewind:true,
	loop:true,
	sequence:.1
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
	Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
label - (default "Will this wind...") a String or a ZIM Label
	if custom Label properties beyond size, font, color, and backgroundColor are desired then pass in a ZIM Label
	and LabelWords will clone the label to maintain letterSpacing, bold, italic, etc. 
width - (default label width or 500) set to a width to set the width of the wrapper
size - |ZIM VEE| (default label size or 36) set the font size of the label 
font - |ZIM VEE| (default label font or arial) set the font of the label
color - |ZIM VEE| (default label color or black) set the color of the label
backgroundColor - |ZIM VEE| (default label backgroundColor or null) set the background color of the label
itemRegX - |ZIM VEE| (default CENTER) the horizontal registration of the word Labels
itemRegY - |ZIM VEE| (default CENTER) the vertical registration of the word Labels
itemCache - (default false) set to true to cache each label - better for animation
spacingH - (default size/2) a spacing between items - ignored if colSize is set
	spacingH does not get ZIM VEE - the results are jiggly when wrapping
spacingV - |ZIM VEE| (default size/2) a spacing between rows - ignored if rowSize is set

** WRAPPER PARAMETERS - we use the term wrapper to mean the LabelWords
** If using STYLE then style a Wrapper for these rather than LabelWords
wrapperType - (default "spacing") changes how the wrapper lays out the items as follows:
	"spacing" - places each item spaced at the spacingH from the next item
	"spread" - places equal spacing around edges and items horizontally (min the spacingH)
	"stretch" - places equal spacing between objects horizontally with no spacing at edges (min the spacingH)
	"column" - uses colSize parameter to determine spacing (spacingH is ignored)
align - |ZIM VEE| (default LEFT) set to CENTER, MIDDLE, RIGHT
	this aligns the whole row - see also alignInner for aligning inside columns
	align:series(LEFT, RIGHT) will toggle rows aligning left and right
valign - |ZIM VEE| (default TOP) set to CENTER, MIDDLE, BOTTOM
	this aligns the rows at the top, middle or bottom only when a height is provided (rare)
	see also valignInner for vertical aligning within rows (common)
alignInner - |ZIM VEE| (default LEFT) set to CENTER, MIDDLE, RIGHT
	aligns the items when colSize is set only - see also align for aligning whole rows horizontally
valignInner - |ZIM VEE| (default BOTTOM) set to TOP, CENTER, MIDDLE
	aligns the items in vertically in their row (common) - see also valign for aligning whole rows vertically (rare)
flip - |ZIM VEE| (default false) set to true to flip the order of the rows
	flip:series(false, true) would read left to right then right to left then left to right, etc.
reverse - |ZIM VEE| (default false) set to true to reverse all the items so the first is (probably) at the bottom right
bottomFull - |ZIM VEE| (default false) set to true to fill the Wrapper at the bottom
	does not reverse but rather leaves potentially fewer items at the top
colSize - |ZIM VEE| (default null) set to number to hard code column width
	this is ignored if the wrapperType is not set to "column"
	use colSize:series(100, 200, 100, 400) to set specific sizes
this will also the only setting for which alignInner works
rowSize - |ZIM VEE| (default null) set to number to hard code row height
	this ignores spacingV but can be used with any wrapperType
	use a series(100, 200, 100, 400) to set specific sizes
height - (default null) does not really set the height of the wrapper
	the height is always determined by the width and the items as they wrap
	(both the width and height cannot be used together without scaling and the wrapper does not scale items)
	the height will have no effect when the valign parameter is set to TOP (default)
	The height will place the bottom of the wrapper at the height when the valign is BOTTOM
	The height will place the wrapper in the middle of the height when the valign is CENTER/MIDDLE
	Note: in the all cases the bounds will still be the bounds around the wrapper
	just the positioning of the wrapper is changed.
	This allows the wrapper to be placed at the bottom and grow to the top
	or placed in the middle and grow from the middle
	which would not be possible otherwise aside from repositioning after each resize
minSpreadNum - (default 2) spread would always center a single item on a row
	and can look weird spreading two or even three final items
	a wrapper with wrapperType:"spread" will spread items if there are at least minSpreadNum items
	if there is less than minSpreadItems then it will align the items according to align
minStretchNum - (default 3) stretch would always center a single item on a row
	and can look weird stretching two or even three final items
	a wrapper with wrapperType:"stretch" will stretch items if there are at least minStretchNum items
	if there is less than minStretchItems then it will align the items according to align
	this will not stop the first line from stretching unless minStretchFirst parameter is set to false
percentVoidH - |ZIM VEE| (default 0) set a percent horizontal space between items default in center
offsetVoidH - |ZIM VEE| (default 0) set a percent (or negative percent) to offset the void from the center horizontally
percentVoidV - |ZIM VEE| (default 0) set a percent vertical space between rows default in center
offsetVoidV - |ZIM VEE| (default 0) set a percent (or negative percent) to offset the void from the center vertically
minStretchFirst - (default true) set to false to avoid stretching the first line if less than minStretchNum is set and met
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: See ZIM Wrapper for methods such as setProps(), add(), addAt(), remove(), resize(), etc.

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - the name of the class as a String
text - get the text of the original Label
labels - an array of ZIM Label objects for the letters
numWords - how many words in labels (same as numChildren)

ALSO: see ZIM Wrapper for properties items, items2D, and properties for most of the Wrapper parameters 

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54.575

    zim.LabelWords = function(label, width, size, font, color, backgroundColor, itemCache, itemRegX, itemRegY, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit) {
        var sig = "label, width, size, font, color, backgroundColor, itemCache, itemRegX, itemRegY, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit";
		var duo; if (duo = zob(zim.LabelWords, arguments, sig, this)) return duo;
		z_d("54.575");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("LabelWords", this.group, inherit);
       
        var originalLabel = !zot(label) && label.type == "Label";
		if (zot(label)) label = DS.label != null ? DS.label : new zim.Label("Will this wind be so mighty as to lay low the mountains of the Earth?");
        if (zot(width)) width = DS.width != null ? DS.width : originalLabel ? label.width : 500; 
        if (zot(itemRegX)) itemRegX = DS.itemRegX != null ? DS.itemRegX : "center";
        if (zot(itemRegY)) itemRegY = DS.itemRegY != null ? DS.itemRegY : "center";
        if (zot(size)) size = DS.size != null ? DS.size : originalLabel? label.size : 36;
        if (zot(font)) font = DS.font != null ? DS.font : originalLabel? label.font : "arial";
        if (zot(color)) color = DS.color != null ? DS.color : originalLabel? label.color : "black";
        if (zot(backgroundColor)) backgroundColor = DS.backgroundColor != null ? DS.backgroundColor : originalLabel? label.backgroundColor : null;
        if (zot(itemCache)) itemCache = DS.itemCache != null ? DS.itemCache : false;
        if (zot(spacingH)) spacingH = DS.spacingH != null ? DS.spacingH : size/2;
        if (zot(spacingV)) spacingV = DS.spacingV != null ? DS.spacingV : size/2;

        var sentence;
        if (label.type == "Label") sentence = label.text;
        else sentence = label;

        var that = this;
        that.text = sentence;    
        var words = sentence.split(' ').filter(Boolean);
        var labels = that.labels = [];
        zim.loop(words, function(word) {
            var lab = label.type=="Label"?label.clone():new zim.Label();
            lab.text = word;
            lab.size = zik(size);
            lab.font = zik(font); 
            lab.color = zik(color); 
            if (!zot(backgroundColor)) lab.backgroundColor = zik(backgroundColor);
            lab.reg(zik(itemRegX), zik(itemRegY));
            if (itemCache) lab.cache();
            labels.push(lab);
        });

        this.zimWrapper_constructor(labels, width, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit);
		
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function () {
			return that.cloneProps(new zim.LabelWords(label, width, size, font, color, backgroundColor, itemCache, itemRegX, itemRegY, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, this.group, inherit));
		};
    
    }
    // extends  a Wrapper so moved extend to after Wrapper
    //-54.575
    

	
/*--
zim.Emoji = function(code, size, monochrome, italic, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backing, padding, paddingH, paddingV, shiftH, shiftV, style, group, inherit)

Emoji
zim class - extends a zim.Label which extends a zim.Container

DESCRIPTION
Shows an emoji in a Label - an emoji is just text.
This helps treat the emoji as an image and works in conjunction with ZIM EmojiPicker

SEE: ZIM EmojiPicker() in COMPONENTS below ColorPicker().

SEE: https://zimjs.com/nft/bubbling/emoji.html 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// Go to https://emojipedia.org/ and find an emoji page 
// copy the emoji or use the copy link and paste into the string below
new Emoji("paste the unicode icon here in string") 
	.center()
	.drag(); 
END EXAMPLE

EXAMPLE
// or use UTF code from https://zimjs.com/emoji
new Emoji("\ud83c\udf47") // grapes using UTF codes
	.center()
	.drag(); 
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
code - |ZIM VEE| (default \ud83d\ude42") the Unicode Character or the Emoji from https://emojipedia.org/
	or pass in UTF codes such as "\ud83d\ude42".
	To convert from Unicode to UTF use https://zimjs.com/emoji/ (also see MORE link at bottom of page)
size - |ZIM VEE| (default 36) the size of the font in pixels
monochrome - (default false) set to true to make black outline - this is actually the bold version of the icon
italic - (default false) set the font to italic 
** SEE Label for the rest of the definitions
backgroundColor, corner, backing, padding, paddingH, paddingV, shiftH, shiftV, style, group, inherit
backgroundColor - (default null) set to CSS color to add a rectangular color around the label
   The background color will change size to match the text of the label
   Note: the backgroundColor is different than a backing which can be any Display Object
	and background parameters are ignored if a backing parameter is set
backgroundBorderColor - (default null) the background stroke color
backgroundBorderWidth - (default null) thickness of the background border
corner - (default 0) the round of corner of the background if there is one
  can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
backing - (default null) a Display object for the backing of the emoji (eg. Shape, Bitmap, Container, Sprite)
   the backing most likely should be centerReg() ie. backing:new Rectangle(200,50,yellow).centerReg()
   see ZIM Pizzazz module for a fun set of Shapes like Boomerangs, Ovals, Lightning Bolts, etc.
padding - (default 10 if backgroundColor set) places the border this amount from emoji (see paddingH and paddingV)
  padding parameters are ignored if there is no backgroundColor set (also ignored if a backing parameter is set)
paddingH - (default padding) places border out at top bottom
paddingV - (default padding) places border out at left and right
shiftH - (default 0) move the emoji inside the container horizontally
shiftV - (default 0) move the emoji inside the container vertically
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - the name of the class as a String
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54.58

	zim.Emoji = function(code, size, monochrome, italic, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backing, padding, paddingH, paddingV, shiftH, shiftV, style, group, inherit) {
		var sig = "code, size, monochrome, italic, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backing, padding, paddingH, paddingV, shiftH, shiftV, style, group, inherit";
		var duo; if (duo = zob(zim.Emoji, arguments, sig, this)) return duo;
		z_d("54.58");
		
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Emoji", this.group, inherit);
		
		if (zot(code)) code = DS.code != null ? DS.code : "\ud83d\ude42"; //"U+1F642";		
		if (zot(size)) size = DS.size != null ? DS.size : 30;		
		if (zot(monochrome)) monochrome = DS.monochrome != null ? DS.monochrome : false;	
		if (zot(italic)) italic = DS.italic != null ? DS.italic : false;	
		if (zot(backgroundColor) || backgroundColor=="ignore") backgroundColor = (DS.backgroundColor!=null&&backgroundColor!="ignore")?DS.backgroundColor:null;
		if (zot(backgroundBorderColor)) backgroundBorderColor = (DS.backgroundBorderColor!=null&&backgroundBorderColor!="ignore")?DS.backgroundBorderColor:null;
		if (zot(backgroundBorderWidth)) backgroundBorderWidth = (DS.backgroundBorderWidth!=null&&backgroundBorderWidth!="ignore")?DS.backgroundBorderWidth:null;
		if (zot(padding) || padding=="ignore") padding = (DS.padding!=null&&padding!="ignore")?DS.padding:10;
		if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:padding;
		if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:padding;
		if (zot(shiftH)) shiftH = DS.shiftH!=null?DS.shiftH:0;
		if (zot(shiftV)) shiftV = DS.shiftV!=null?DS.shiftV:0;
		
		// PICK
		var oa = remember(code, size);
		this.veeObj = {code:oa[0], size:oa[1]};
		function remember() {return arguments;} // for cloning PICK
		code = zim.Pick.choose(code);
		size = zim.Pick.choose(size);
		
		if (code.substring(0,2) == "U+") code = zim.unicodeToUTF(code);
		
		this.zimLabel_constructor(code, size, null, null, null, null, null, null, null, null, italic, null, null, null, backing, null, null, backgroundColor, null, null, corner, null, padding, paddingH, paddingV, shiftH, shiftV);
		this.type = "Emoji";
		this.code = code;
		this.size = size;
		var that = this;
		
		var b = this.getBounds();
		var h = 5;
		var w = 3
		this.bounds = this.setBounds(b.x+w,b.y-h+1,b.width-w*2,b.height+h);
		
		if (monochrome) {
			this.saturation = -100;
		}
		
		var _monochrome = monochrome;
		Object.defineProperty(that, 'monochrome', {
			get: function() {
				return _monochrome;
			},
			set: function(value) {
				if (value != _monochrome) {
					_monochrome = value;
					if (value) {
						this.saturation = value?-100:0;						
					}
				}
			}
		});
		
		this.cache = function (a,b,c,d) {
			if (zot(a))	{
				b = this.getBounds();
				this.zimLabel_cache(b.x-20,b.y-20,b.width+40,b.height+40);
			} else {
				this.zimLabel_cache(a,b,c,d);
			}
			that.z_bc = that.canvas = that.cacheCanvas;
			return this;		
		}
		
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function (exact) {
			return that.cloneProps(new zim.Emoji((exact||!zim.isPick(oa[0]))?code:oa[0], (exact||!zim.isPick(oa[1]))?that.size:oa[1], monochrome, italic, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backing, padding, paddingH, paddingV, shiftH, shiftV, style, that.group, inherit));
		};

	};
	zim.extend(zim.Emoji, zim.Label, ["clone","cache"], "zimLabel", false);
	//-54.58

/*--
zim.Button = function(width, height, label, backgroundColor, rollBackgroundColor, downBackgroundColor, color, rollColor, downColor, borderColor, borderWidth, rollBorderColor, downBorderColor, backing, rollBacking, downBacking, icon, rollIcon, downIcon, corner, dashed, shadowColor, shadowBlur, gradient, gloss, align, valign, indent, indentH, indentV, hitPadding, autoPadding, autoPaddingH, autoPaddingV, rollPersist, toggle, toggleBackgroundColor, rollToggleBackgroundColor, downToggleBackgroundColor, toggleColor, rollToggleColor, downToggleColor, toggleBacking, rollToggleBacking, downToggleBacking, toggleIcon, rollToggleIcon, downToggleIcon, toggleEvent, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, downWaitBackgroundColor, waitColor, rollWaitColor, downWaitColor, waitBacking, rollWaitBacking, downWaitBacking, waitIcon, rollWaitIcon, downWaitIcon, waitModal, waitEnabled, style, group, inherit)

Button
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes a button with rollover and many more features - see parameters.
You will need to pass in a Label to change the font properties of the button from the default.
You will then need to add the button to the stage and add a mousedown or click event.
Button rollover is done automatically.

Generally, there are three modes for a button - normal, toggle and wait.
Each of these have backgroundColor, color, backing and icon displays
and each of these have up (normal), roll and down states.
Down states were added in ZIM ZIM 01 
SEE https://zimjs.com/zim/button.html 

DISPLAYS FOR NORMAL MODE WITH THREE STATES EACH
backgroundColor, rollBackgroundColor, downBackgroundColor, 
color, rollColor, downColor, 
backing, rollBacking, downBacking, 
icon, rollIcon, downIcon

** The normal mode also has borderColor, borderWidth, rollBorderColor and downBorderColor inserted after the color set. 

The parameters are kept flat rather than grouped in {} object parameters in order to use ZIM DUO and STYLE

The button parameters have indicators showing the subsections
The normal mode is listed first, then general Button parameters such as corner, shadowColor, etc. 
The toggle and wait parameters are listed last.

You can set a backing display object (Shape, Bitmap, Pattern, etc.) in place of the standard rectangle.
You can set an icon display object in place of the standard text
You can set the Button to toggle between text, backings or icons
SEE the ZIM Pizzazz series for a growing selection of backings, patterns and icons
https://zimjs.com/bits/view/pizzazz.html
https://zimjs.com/bits/view/icons.html
https://zimjs.com/patterns.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Button(200,60,"CLICK").center().tap(()=>{
	zog("clicking");
});

// OR add custom label (needed to change label color for instance)
const label = new Label({
	text:"POWER OPTION",
	size:40,
	backgroundColor:"violet",
	bold:true
});
new Button({
	label:label,
	width:390,
	height:110,
	backgroundColor:"purple",
	rollBackgroundColor:"MediumOrchid",
	borderWidth:8,
	borderColor:"violet",
	gradient:.3,
	corner:0
}).center();
END EXAMPLE


PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
width - (default 200) the width of the button or AUTO to fit width to label (see also autoPadding)
height - (default 60) the height of the button or AUTO to fit height to label (see also autoPadding)
label - (default "CLICK" or "" if icon or backing) ZIM Label or plain text with default settings (white)
---------- NORMAL MODE
backgroundColor - |ZIM VEE| (default purple) background color of button (any CSS color)
	also as of ZIM ZIM 01 any backgroundColor parameter can be written as bgColor
rollBackgroundColor - |ZIM VEE| (default backgroundColor.lighten(.2)) rollover background color of button
	also as of ZIM ZIM 01 any backgroundColor parameter can be written as bgColor - so rollBgColor works, etc.
downBackgroundColor - |ZIM VEE| (default null) pressing down background color of button
color - |ZIM VEE| (default white) label color of button (any CSS color) unless a custom Label is set
rollColor - |ZIM VEE| (default white) rollover label color of button
downColor - |ZIM VEE| (default null) pressing down label color of button
borderColor - (default null) the color of the border
rollBorderColor - (default borderColor) rollover color of the border
downBorderColor - (default rollBorderColor) the pressing down color of the border
borderWidth - (default null) thickness of the border
backing - (default null) a Display object for the backing of the button (eg. Shape, Bitmap, Container, Sprite)
	assumed to be center registration for easy positioning *** as with all backings
	see ZIM Pizzazz module for a fun set of Button Shapes like Boomerangs, Ovals, Lightning Bolts, etc.
	https://zimjs.com/bits/view/pizzazz.html
rollBacking - (default null) a Display object for the backing of the rolled-on button
downBacking - (default null) a Display object for the backing of the pressed-down button
icon - (default null) set to display object to add icon at the center of the button and remove label
	assumed to be center registration for easy positioning *** as with all icons
	https://zimjs.com/bits/view/icons.html
rollIcon - (default null) set to display object to show icon on rollover
downIcon - (default null) set to display object to show icon on press down
---------- GENERAL PARAMETERS 
corner - (default 10) the round of the corner (set to 0 for no corner)
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
	and [horizontal, vertical] pairs - see Rectangle() for more info
dashed - (default false) set to true to turn the border to dashed - if the borderColor or borderWidth is provided
shadowColor - (default rgba(0,0,0,.3)) set to -1 for no shadow
shadowBlur - (default 14) how blurred the shadow is if the shadow is set
gradient - (default 0) 0 to 1 (try .3) adds a gradient to the button
gloss - (default 0) 0 to 1 (try .1) adds a gloss to the button
align - (default CENTER) horizontal align of the label
valign - (default CENTER) vertical align of the label
indent - (default 10) indent of label when align or valign is set
indentH - (default indent) horizontal indent of label when align or valign is set
indentV - (default indent) vertical indent of label when align or valign is set
hitPadding - (default 0) adds extra hit area to the button (good for mobile)
	Note that if the button alpha is 0 the button will still be active if hitPadding is not equal to 0
	Set the hitPadding property to 0 in this case - thanks Frank Los for the notice
autoPadding - (default 20) the padding used by AUTO width or height 
autoPaddingH - (default autoPadding) the padding used by AUTO width
autoPaddingV - (default autoPadding) the padding used by AUTO height
rollPersist - (default false) set to true to keep rollover state when button is pressed even if rolling off
---------- TOGGLE MODE 
toggle - (default null) set to string to toggle with label - or set to true to activate toggle but keep label the same
	the button will not toggle if there is a wait parameter set
	see also toggle colors, backings and icons
toggleBackgroundColor - (default backgroundColor) background color to make button when toggled
rollToggleBackgroundColor - (default toggleBackgroundColor) background color for button when toggled and rolled over
downToggleBackgroundColor - (default null) background color for button when toggled and pressed down
toggleColor - (default label's color) color to make text when toggled
rollToggleColor - (default label's roll color) color for text when toggled and rolled over
downToggleColor - (default null) color for text when toggled and pressed down
toggleBacking - (default null) set to display object to set a different backing for toggled state
rollToggleBacking - (default null) set to display object to set a backing for the rolled toggle state
downToggleBacking - (default null) set to display object to set a backing for the pressed down state
toggleIcon - (default null) set to display object to add icon at the center of the button and remove label in toggle state
rollToggleIcon - (default null) set to display object to show icon on rollover in toggle state
downToggleIcon - (default null) set to display object to show icon on press down in toggle state
toggleEvent - (default mousedown for mobile and click for not mobile) what event causes the toggle
---------- WAIT MODE 
wait - (default null) - String word for button to show when button is pressed and a wait state is desired
	LOADING: this can be used as a loading message - so change the button to "LOADING"
	When the asset has loaded, use the clearWait() method to return to the normal button or toggled button state
	CONFIRMING: this can also be used to confirm user action rather than a full new confirm panel
	Set wait:"CONFIRM", set the waitBackgroundColor and rollWaitBackground parameters to red and the waitTime parameter to 4
	In a button mousedown (must use mousedown - not click or tap if ACTIONEVENT is mousedown - the default),
	check if the waiting property is true to test for confirmation
	The waiting property will not be true for the first button press but will be true during the wait period
	Perhaps set the waitModal parameter to true to clearWait() if the user clicks off the button
	Use the clearWait() method to clear or cancel the wait status - for instance, if the pane the button is in is closed
waitTime - (default 5 seconds) seconds to show wait state before reverting to normal button (also see ZIM TIME constant)
waitBackgroundColor - (default red) background color to make button during wait time if wait is set
rollWaitBackgroundColor - (default rollBackgroundColor) background color for button when waiting and rolled over
downWaitBackgroundColor - (default null) background color for button when waiting and pressed down
waitColor - (default label's color) color to make text during wait time if wait is set
rollWaitColor - (default label's roll color) color for text when waiting and rolled over
downWaitColor - (default label's roll color) color for text when waiting and pressed down
waitBacking - (default null) set to display object to set a different backing for wait state
rollWaitBacking - (default null) set to display object to a different roll backing for wait state
downWaitBacking - (default null) set to display object to a different pressed-down backing for wait state
waitIcon - (default null) set to display object to add icon at the center of the button and remove label in wait state
rollWaitIcon - (default null) set to display object to show icon on rollover in wait state
downWaitIcon - (default null) set to display object to show icon on pressed down in wait state
waitModal - (default false) set to true to clearWait() if the user clicks off the button
waitEnabled - (default true) set to false to disable button while wait is in progress
---------- FINAL PARAMETERS
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setBacking(type, newBacking) - dynamically set any type of backing for button (if null removes backing for that type)
	Backing types are: "backing", "rollBacking", "downBacking", "toggleBacking", "rollToggleBacking", "downToggleBacking", "waitBacking", "rollWaitBacking", "downWaitBacking"
	note - all backing will have a pattern property if a pattern is set as a backing
setIcon(type, newIcon) - dynamically set any type of icon for button (if null removes icon for that type)
	Icon types are: "icon", "rollIcon", "downIcon", "toggleIcon", "rollToggleIcon", "downToggleIcon", "waitIcon", "rollWaitIcon", "downWaitIcon"
toggle(state) - forces a toggle of label, backing and icon if set
	state defaults to null so just toggles if left blank
	pass in true to go to the toggled state and false to go to the original state
	returns object for chaining
removeRoll() - force rollover state off 
wait() - forces a wait state - with wait text, backings and icons if set
clearWait() - clears a wait state of the button - sets it back to normal
removeWait() - removes (and clears) a wait state of the button so it will not trigger again
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy with properties such as x, y, etc. also copied
	exact - will ignore ZIM VEE values and clone the original values
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
text - references the text property of the Label object of the button
label - gives access to the label
color - get or set non-rolled on label color (if no icon specified)
rollColor - get or set rolled on label color
backgroundColor - get or set non-rolled on backing color (if no backing specified)
rollBackgroundColor - get or set rolled on backing color
rollPersist - default is false - set to true to keep rollover state when button is pressed even if rolling off
borderColor - get or set non-rolled on border color
rollBorderColor - get or set the border rolled color
hitPadding - extra padding for interactivity - see hitPadding parameter for extra notes
backing - references the backing of the button
	use setBacking() to change as with all backings
	note - all backings will have a pattern property if a pattern is set as a backing
rollBacking - references the rollBacking (if set)
downBacking - references the downBacking (if set)
icon - references the icon of the button (if set)
	use setIcon() to change as with all icons
rollIcon - references the rollIcon (if set)
downIcon - references the downIcon (if set)
rolled - read-only true if button is being rolled over else false
pressed - read-only true if button is being pressed else false
toggled - read-only true if button is in toggled state, false if button is in original state
	note: on mousedown toggle may not be switched over - except on mobile
	so would recommend for consistency checking on click or tap or mouseup
toggleBacking - references the toggle backing (if set)
rollToggleBacking - references the toggle roll backing (if set)
downToggleBacking - references the toggle down backing (if set)
toggleIcon - references the toggle icon (if set)
rollToggleIcon - references the toggle roll icon (if set)
downToggleIcon - references the toggle down icon (if set)
waiting - read-only true if button is in the waiting state within wait time
	note: must test this in a mousedown function not click or tap
waitBacking - references the wait backing (if set)
rollWaitBacking - references the wait roll backing (if set)
downWaitBacking - references the wait down backing (if set)
waitIcon - references the wait icon (if set)
rollWaitIcon - references the wait roll icon (if set)
downWaitIcon - references the wait down icon (if set)
focus - get or set the focus property of the Button used for tabOrder
enabled - default is true - set to false to disable
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
for example seeing toggle take effect

EVENTS
dispatches a "waited" event if button is in wait state and the wait time has completed
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+55
	zim.Button = function(width, height, label, backgroundColor, rollBackgroundColor, downBackgroundColor, color, rollColor, downColor, borderColor, borderWidth, rollBorderColor, downBorderColor, backing, rollBacking, downBacking, icon, rollIcon, downIcon, corner, dashed, shadowColor, shadowBlur, gradient, gloss, align, valign, indent, indentH, indentV, hitPadding, autoPadding, autoPaddingH, autoPaddingV, rollPersist, toggle, toggleBackgroundColor, rollToggleBackgroundColor, downToggleBackgroundColor, toggleColor, rollToggleColor, downToggleColor, toggleBacking, rollToggleBacking, downToggleBacking, toggleIcon, rollToggleIcon, downToggleIcon, toggleEvent, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, downWaitBackgroundColor, waitColor, rollWaitColor, downWaitColor, waitBacking, rollWaitBacking, downWaitBacking, waitIcon, rollWaitIcon, downWaitIcon, waitModal, waitEnabled, style, group, inherit) {
		var sig = "width, height, label, backgroundColor, rollBackgroundColor, downBackgroundColor, color, rollColor, downColor, borderColor, borderWidth, rollBorderColor, downBorderColor, backing, rollBacking, downBacking, icon, rollIcon, downIcon, corner, dashed, shadowColor, shadowBlur, gradient, gloss, align, valign, indent, indentH, indentV, hitPadding, autoPadding, autoPaddingH, autoPaddingV, rollPersist, toggle, toggleBackgroundColor, rollToggleBackgroundColor, downToggleBackgroundColor, toggleColor, rollToggleColor, downToggleColor, toggleBacking, rollToggleBacking, downToggleBacking, toggleIcon, rollToggleIcon, downToggleIcon, toggleEvent, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, downWaitBackgroundColor, waitColor, rollWaitColor, downWaitColor, waitBacking, rollWaitBacking, downWaitBacking, waitIcon, rollWaitIcon, downWaitIcon, waitModal, waitEnabled, style, group, inherit";
		var duo; if (duo = zob(zim.Button, arguments, sig, this)) return duo;
		z_d("55");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Button", group, inherit);

		if (zot(width)) width=DS.width!=null?DS.width:200;
		if (zot(height)) height=DS.height!=null?DS.height:60;
		
		if (zot(WW.M)) WW.M = zim.mobile();
		
		var oColor = color;
		var oRollColor = rollColor;
		var oDownColor = downColor;
		if (zot(color)) color=DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor=DS.rollColor!=null?DS.rollColor:zim.white;		
		if (zot(autoPadding)) autoPadding=DS.autoPadding!=null?DS.autoPadding:20;
		if (zot(autoPaddingH)) autoPaddingH=DS.autoPaddingH!=null?DS.autoPaddingH:autoPadding;
		if (zot(autoPaddingV)) autoPaddingV=DS.autoPaddingV!=null?DS.autoPaddingV:autoPadding;
		if (zot(align)) align=DS.align!=null?DS.align:"center";
		if (zot(valign)) valign=DS.valign!=null?DS.valign:"center";
		if (zot(label)) {if (zot(icon) && zot(backing)) {label = DS.label!=null?DS.label:"PRESS";} else {label = "";}}
		// text, size, font, color, rollColor, shadowColor, shadowBlur, align, valign
		if (typeof label === "string" || typeof label === "number") {
			label = new zim.Label({
				text:label, size:DS.size!=null?DS.size:36, font:DS.font!=null?DS.font:"arial", color:DS.color!=null&&oColor==null?DS.color:color, rollColor:DS.rollColor&&oRollColor==null!=null?DS.rollColor:rollColor, align:align, valign:valign, rollPersist:DS.rollPersist!=null?DS.rollPersist:false,
				backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore", shiftV:DS.shiftV!=null?DS.shiftV:0, shiftH:DS.shiftH!=null?DS.shiftH:0,
				style:false, group:this.group
			});		
		} else {			
			if (!zot(oColor)) label.color = oColor;
			color = label.color;
			if (zot(label.rollColor) || !zot(oRollColor)) label.rollColor = rollColor;
			rollColor = label.rollColor;
		}
		if (zot(downColor)) downColor=DS.downColor!=null?DS.downColor:rollColor;
		
		if (width=="auto") width = label.width+autoPaddingH*2;
		if (height=="auto") height = label.height+autoPaddingV*2;
		
		this.zimContainer_constructor(width, height, null, null, false);
		this.type = "Button";

		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.purple;
		if (zot(rollBackgroundColor)) rollBackgroundColor=DS.rollBackgroundColor!=null?DS.rollBackgroundColor:backgroundColor.lighten?backgroundColor.lighten(.2):backgroundColor;
		if (zot(downBackgroundColor)) downBackgroundColor=DS.downBackgroundColor!=null?DS.downBackgroundColor:rollBackgroundColor;
		
		var oa = remember(backgroundColor, rollBackgroundColor, downBackgroundColor, color, rollColor, downColor);
		this.veeObj = {backgroundColor:oa[0], rollBackgroundColor:oa[1], downBackgroundColor:oa[2], color:oa[3], rollColor:oa[4], downColor:oa[5]};
		function remember() {return arguments;} // for cloning PICK
		backgroundColor = zik(backgroundColor);
		rollBackgroundColor = zik(rollBackgroundColor);
		downBackgroundColor = zik(downBackgroundColor);
		color = zik(color);
		rollColor = zik(rollColor);
		downColor = zik(downColor);

        var timeType = zot(WW.TIME) ? zot(zim.TIME) ? "seconds" : zim.TIME : WW.TIME;
		
		var originalBorderColor = borderColor;
		var originalBorderWidth = borderWidth;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(rollBorderColor)) rollBorderColor=DS.rollBorderColor!=null?DS.rollBorderColor:borderColor;
		if (zot(downBorderColor)) downBorderColor=DS.downBorderColor!=null?DS.downBorderColor:rollBorderColor;
		
		if (zot(corner)) corner=DS.corner!=null?DS.corner:10;
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(hitPadding)) hitPadding=DS.hitPadding!=null?DS.hitPadding:0;
		if (zot(indent)) indent=DS.indent!=null?DS.indent:10;
		if (zot(indentH)) indentH=DS.indentH!=null?DS.indentH:indent;
		if (zot(indentV)) indentV=DS.indentV!=null?DS.indentV:indent;
		if (zot(gradient)) gradient = DS.gradient!=null?DS.gradient:0;
		if (zot(gloss)) gloss = DS.gloss!=null?DS.gloss:0;		
		var toggleOkay = (!zot(toggle) || !zot(toggleBacking) || !zot(rollToggleBacking) || !zot(downToggleBacking) || !zot(toggleIcon) || !zot(rollToggleIcon) || !zot(downToggleIcon)) && zot(wait) && zot(waitBacking) && zot(rollWaitBacking);
		if (toggleOkay && zot(toggleEvent)) toggleEvent = WW.M?"mousedown":"click";
		if (zot(rollPersist)) rollPersist = DS.rollPersist!=null?DS.rollPersist:false;
		this.rollPersist = rollPersist;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		
        if (zot(toggle)) toggle=DS.toggle!=null?DS.toggle:null;
		if (!zot(toggle) && toggle.type=="Label") {if (zon) zogy("Button() - do not pass Label to toggle parameter - just pass a String");}

		if (zot(toggleBackgroundColor)) toggleBackgroundColor=DS.toggleBackgroundColor!=null?DS.toggleBackgroundColor:backgroundColor;
		if (zot(rollToggleBackgroundColor)) rollToggleBackgroundColor=DS.rollToggleBackgroundColor!=null?DS.rollToggleBackgroundColor:rollBackgroundColor;
		if (zot(downToggleBackgroundColor)) downToggleBackgroundColor=DS.downToggleBackgroundColor!=null?DS.downToggleBackgroundColor:rollToggleBackgroundColor;
		if (zot(toggleColor)) toggleColor=DS.toggleColor!=null?DS.toggleColor:label.color;
		if (zot(rollToggleColor)) rollToggleColor=DS.rollToggleColor!=null?DS.rollToggleColor:label.rollColor;
		if (zot(downToggleColor)) downToggleColor=DS.downToggleColor!=null?DS.downToggleColor:label.rollToggleColor;

		if (zot(wait)) wait=DS.wait!=null?DS.wait:null;
		if (zot(waitTime)) waitTime=DS.waitTime!=null?DS.waitTime:timeType=="seconds"||timeType=="s"?5:5000;
		if (zot(waitBackgroundColor)) waitBackgroundColor=DS.waitBackgroundColor!=null?DS.waitBackgroundColor:backgroundColor;
		if (zot(rollWaitBackgroundColor)) rollWaitBackgroundColor=DS.rollWaitBackgroundColor!=null?DS.rollWaitBackgroundColor:rollBackgroundColor;
		if (zot(downWaitBackgroundColor)) downWaitBackgroundColor=DS.downWaitBackgroundColor!=null?DS.downWaitBackgroundColor:rollBackgroundColor;
		if (zot(waitColor)) waitColor=DS.waitColor!=null?DS.waitColor:label.color;
		if (zot(rollWaitColor)) rollWaitColor=DS.rollWaitColor!=null?DS.rollWaitColor:label.rollColor;
		if (zot(downWaitColor)) downWaitColor=DS.downWaitColor!=null?DS.downWaitColor:rollWaitColor;

		var that = this;
		this.mouseChildren = false;
		this.cur("pointer");
		that.focus = false;
		that.rolled = false;		

		timeType = getTIME(waitTime);

		//~~~~~~~~~~~~~  BACKINGS
		// also see manual setting of backings beneath getter setter methods
		if (zot(backing)) backing = DS.backing!=null?DS.backing.clone():null;
		if (zot(backing)) that.backing = new zim.Rectangle(width,height,backgroundColor,null,null,corner,dashed,null, null,false).centerReg(null, null, false);
		else that.backing = backing; // if backing is null - we have no custom backing - this test is used later
				
		that.rollBacking = zot(rollBacking)?(DS.rollBacking!=null?DS.rollBacking.clone():null):rollBacking;
		that.downBacking = zot(downBacking)?(DS.downBacking!=null?DS.downBacking.clone():null):downBacking;
		that.waitBacking = zot(waitBacking)?(DS.waitBacking!=null?DS.waitBacking.clone():null):waitBacking;
		that.rollWaitBacking = zot(rollWaitBacking)?(DS.rollWaitBacking!=null?DS.rollWaitBacking.clone():null):rollWaitBacking;
		that.downWaitBacking = zot(downWaitBacking)?(DS.downWaitBacking!=null?DS.downWaitBacking.clone():null):downWaitBacking;
		that.toggleBacking = zot(toggleBacking)?(DS.toggleBacking!=null?DS.toggleBacking.clone():null):toggleBacking;
		that.rollToggleBacking = zot(rollToggleBacking)?(DS.rollToggleBacking!=null?DS.rollToggleBacking.clone():null):rollToggleBacking;
		that.downToggleBacking = zot(downToggleBacking)?(DS.downToggleBacking!=null?DS.downToggleBacking.clone():null):downToggleBacking;

		var backingTypes = ["backing", "rollBacking", "downBacking", "toggleBacking", "rollToggleBacking", "downToggleBacking", "waitBacking", "rollWaitBacking", "downWaitBacking"];
		var t,b,i;
		for (i=0; i<backingTypes.length; i++) {
			t = backingTypes[i];
			b = that[t]; // access to object passed to parameter or null
			if (b) {
				if (b.type == "Pattern") {
					b = setPattern(t, b);
				} else if (shadowColor != -1 && shadowBlur > 0) {
					b.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
				}
				// assumes center reg
				b.x = width / 2;
				b.y = height / 2;
			}
		}
		that.addChild(that.backing);
		if (borderWidth) {
			that.border = new zim.Rectangle(width, height, "rgba(0,0,0,0)", borderColor, borderWidth, corner, dashed, null, null, false);
			that.addChild(that.border);
		}
		function setPattern(type, pattern) {
			that[type] = new zim.Container(width, height, null, null, false).centerReg(null, null, false);
			if (shadowColor != -1 && shadowBlur > 0) {
				var shadowRect = new zim.Rectangle(width-2, height-2, "#666", null, null, corner, null, null, null, false).center(that[type]);
				shadowRect.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
			}
			var mask = that[type].mask = new zim.Rectangle(width, height, type.indexOf("roll")>=0?rollBackgroundColor:backgroundColor, null, null, corner, null, null, null, false).addTo(that[type]);
			pattern.centerReg(mask);
			pattern.setMask(mask.shape);
			that[type].pattern = pattern;
			return that[type];
		}
		
		//~~~~~~~~~~~~~  ICONS
		that.icon = zot(icon)?(DS.icon!=null?DS.icon.clone():null):icon;
		that.rollIcon = zot(rollIcon)?(DS.rollIcon!=null?DS.rollIcon.clone():null):rollIcon;
		that.downIcon = zot(downIcon)?(DS.downIcon!=null?DS.downIcon.clone():null):downIcon;
		that.waitIcon = zot(waitIcon)?(DS.waitIcon!=null?DS.waitIcon.clone():null):waitIcon;
		that.rollWaitIcon = zot(rollWaitIcon)?(DS.rollWaitIcon!=null?DS.rollWaitIcon.clone():null):rollWaitIcon;
		that.downWaitIcon = zot(downWaitIcon)?(DS.downWaitIcon!=null?DS.downWaitIcon.clone():null):downWaitIcon;
		that.toggleIcon = zot(toggleIcon)?(DS.toggleIcon!=null?DS.toggleIcon.clone():null):toggleIcon;
		that.rollToggleIcon = zot(rollToggleIcon)?(DS.rollToggleIcon!=null?DS.rollToggleIcon.clone():null):rollToggleIcon;
		that.downToggleIcon = zot(downToggleIcon)?(DS.downToggleIcon!=null?DS.downToggleIcon.clone():null):downToggleIcon;
		var iconTypes = ["icon", "rollIcon", "downIcon", "toggleIcon", "rollToggleIcon", "downToggleIcon", "waitIcon", "rollWaitIcon", "downWaitIcon"];
		for (i=0; i<iconTypes.length; i++) {
			var ty = iconTypes[i];
			var ic = that[ty]; // access to object passed to parameter or null
			if (ic) {
				// assumes center reg
				ic.x = width / 2;
				ic.y = height / 2;
			}
		}
		if (that.icon) that.addChild(that.icon);

		//~~~~~~~~~~~~~  GRADIENT AND GLOSS

		if (!Array.isArray(corner)) corner = [corner, corner, corner, corner];
		if (gradient > 0) { // add an overlay
			var gr = new createjs.Shape();
			gr.graphics.lf(["rgba(255,255,255,"+gradient+")","rgba(0,0,0,"+gradient+")"], [0, 1], 0, 0, 0, height-borderWidth);
			gr.graphics.rc(borderWidth/2, borderWidth/2, width-borderWidth, height-borderWidth, corner[0], corner[1], corner[2], corner[3]);
			this.addChild(gr);
		}
		if (gloss > 0) { // add an overlay
			var gl = new createjs.Shape();
			gl.graphics.f("rgba(255,255,255,"+gloss+")");
			gl.graphics.rc(borderWidth/2, borderWidth/2, width-borderWidth, (height-borderWidth)/2, corner[0], corner[1], 0, 0);
			gl.graphics.f("rgba(0,0,0,"+gloss+")");
			gl.graphics.rc(borderWidth/2, height/2, width-borderWidth, (height-borderWidth)/2, 0, 0, corner[2], corner[3]);
			this.addChild(gl);
		}

		//~~~~~~~~~~~~~  HITAREA AND LABEL

		var hitArea;
		var rect;
		if (hitPadding > 0) makeHitArea();
		function makeHitArea() {
			rect = new createjs.Shape();
			rect.graphics.f("#000").r(-hitPadding,-hitPadding,width+hitPadding*2,height+hitPadding*2);
			that.hitArea = hitArea = rect;
		}

		this.addChild(label);
		label.center(this);
		// label.y+=(WW.zdf && zdf.retina!=true)?1:0;
		label.y+=1;
		this.label = label;

		zim.pos(label, (align=="left"||align=="right")?indentH:null, (valign=="top"||valign=="bottom")?indentV:null, align=="right", valign=="bottom");

		var latestColor = label.color; // used to help down color change back to whatever mode color is set (normal, toggle, wait)

		//~~~~~~~~~~~~~  TOGGLE STATE
		this.toggled = false;
		if (toggleOkay) {			
			var originalText = label.text;
			var originalColor = label.color;
			var originalRollColor = label.rollColor;
			this.on(toggleEvent, function() {
				that.toggled = !that.toggled;
				setToggled();
			});
		}

		function setToggled() {
			if (that.toggled) {
				if (!zot(toggle)) that.label.text = toggle===true?originalText:toggle;
				if (!zot(toggleColor)) that.label.colorOnly = latestColor = toggleColor;
				if (!zot(rollToggleColor)) that.label.rollColor = rollToggleColor;
				// for toggle - may start in rollover or could be manually called
				if (that.rolled) {					
					if (that.rollToggleBacking) changeObject("rollToggleBacking");
					else if (that.toggleBacking) changeObject("toggleBacking");
					if (that.rollToggleIcon) changeObject("rollToggleIcon");
					else if (that.toggleIcon) changeObject("toggleIcon");
					if (zot(backing) && zot(that.rollToggleBacking)) that.backing.color = rollToggleBackgroundColor;
				} else {
					if (that.toggleBacking) changeObject("toggleBacking");
					if (that.toggleIcon) changeObject("toggleIcon");
					if (zot(backing)) that.backing.color = toggleBackgroundColor;
				}
			} else {
				that.label.colorOnly = latestColor = originalColor;
				that.label.rollColor = originalRollColor;
				if (that.rolled) that.label.showRollColor(true); // patched ZIM NFT 01
				that.label.text = originalText;
				setOriginalObjects();
			}
			if (that.stage) that.stage.update();
		}

		function setOriginalObjects() {
			if (that.pressed) {
				if (zot(backing) && that.backing && !that.downBacking) that.backing.color = downBackgroundColor;
				if (that.downBacking) changeObject("downBacking");
				else if (that.rollBacking) changeObject("rollBacking");
				else if (that.backing) changeObject("backing");
				if (that.downIcon) changeObject("downIcon");
				else if (that.rollIcon) changeObject("rollIcon");
				else if (that.icon) changeObject("icon");
				else changeObject("icon", null);
			} else if (that.rolled) {
				if (zot(backing) && that.backing && !that.rollBacking) that.backing.color = rollBackgroundColor;
				if (that.rollBacking) changeObject("rollBacking");
				else if (that.backing) changeObject("backing");
				if (that.rollIcon) changeObject("rollIcon");
				else if (that.icon) changeObject("icon");
				else changeObject("icon", null);
			} else {
				if (zot(backing) && that.backing) that.backing.color = backgroundColor;
				if (that.backing) changeObject("backing");
				if (that.icon) changeObject("icon");
				else changeObject("icon");
			}
		}

		this.toggle = function(state) {			
			if (!toggleOkay) {
				if (zon) zogy("Button() - can't toggle with wait parameters provided");
				return that;
			}
			if (zot(state)) {
				that.toggled = !that.toggled;
			} else {
				that.toggled = state;
			}
			setToggled();
			return that;
		};

		//~~~~~~~~~~~~~  WAIT STATE
		var pressCheck = false;
		that.waiting = false;
		var willBeWaiting = false;
		var waitTimeout;
		var waitStartText;
		// var waitStartBackgroundColor;
		var waitStartTextBackgroundColor = that.label.color;
		var waitStartRollTextBackgroundColor = that.label.rollColor;
		var waitStartEnabled;
		var waitModalEvent;
		var waitEvent = this.on("mousedown", function() {
			pressCheck=true;			
			doWait();
		});

		function doWait() {
			if ((!zot(wait) || !zot(waitBacking) || !zot(rollWaitBacking)) && !that.waiting) {
				willBeWaiting = true;
				if (zot(waitEnabled)) waitEnabled = true;
				if (waitModal) waitModalEvent = that.stage.on("stagemousedown", function(e) {
					if (!that.hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY)) that.clearWait();
				}, null, true); // run only once
				// wait before setting the waiting property so first click is not a waiting
				setTimeout(function(){that.waiting = true;}, 50);
				// set button to waiting state
				waitStartText = label.text;
				if (!zot(waitColor)) that.label.colorOnly = latestColor = waitColor;
				if (!zot(rollWaitColor)) that.label.rollColor = rollWaitColor;
				waitStartEnabled = that.enabled;
				if (!waitEnabled && that.enabled) that.enabled = false;
				if (!zot(wait)) that.label.text = wait;

               
				if (that.rolled) {
					if (zot(backing) && !that.rollWaitBacking) {
                        that.backing.color = rollWaitBackgroundColor;
                    }
					if (that.rollWaitBacking) changeObject("rollWaitBacking");
					else if (that.waitBacking) changeObject("waitBacking");
					if (that.rollWaitIcon) changeObject("rollWaitIcon");
					else if (that.waitIcon) changeObject("waitIcon");
				} else {
					if (zot(backing) && !that.waitBacking) that.backing.color = waitBackgroundColor;
					if (that.waitBacking) changeObject("waitBacking");
					if (that.waitIcon) changeObject("waitIcon");
				}

				if (waitTimeout) waitTimeout.clear();
				waitTimeout = zim.timeout(waitTime, function() {
					// set button to proper text, icon, backing, colors, etc.
					if (!that.enabled) that.enabled = waitStartEnabled;
					that.clearWait();
					that.dispatchEvent("waited");
				});
				if (that.stage) that.stage.update();
			}
		}
		this.wait = doWait;
		this.clearWait = function() {
			if (!waitTimeout) return that;
			if (waitModalEvent) that.stage.off("stagemousedown", waitModalEvent);
			waitTimeout.clear();
			that.label.text = waitStartText;
			setOriginalObjects();
			that.label.colorOnly = latestColor = waitStartTextBackgroundColor;
			that.label.rollColor = waitStartRollTextBackgroundColor;
			setTimeout(function(){that.waiting = false;}, 55); // give time for first click to see not waiting yet
			willBeWaiting = false;
			if (that.stage) that.stage.update();
			return that;
		};
		this.removeWait = function() {
			that.clearWait();
			wait = null;
			that.waitBacking = null;
			that.rollWaitBacking = null;
			that.off("mousedown", waitEvent);
			return that;
		};

		//~~~~~~~~~~~~~  INTERACTION



		// visually swap button backing or icon
		// on clicks if wait or toggle and on mouseover and mouseout
		function changeObject(type, remove) {
			var i;
			if (type.indexOf("con")>=0) { // icon
				for (i=0; i<iconTypes.length; i++) {
					var ty = iconTypes[i];
					var ic = that[ty];
					that.removeChild(ic);
				}
				if (that[type]) that.addChildAt(that[type], 1);
			} else {
				if (!that[type] && !remove) return;
				for (i=0; i<backingTypes.length; i++) {
					var t = backingTypes[i];
					var b = that[t];
					that.removeChild(b);
				}
				
				if (that[type]) that.addChildAt(that[type], 0);
			}
		}

		var reallyOn = false;		
		this.on("mouseover", function (e) {
			if (that.stage && that.stage.frame.leftMouseDown && !onCheck) return;
			buttonOn();
		});
		function buttonOn() {
			that.rolled = true;
			reallyOn = true;
			
			// specific to each setting
			// so can have a rollover backing even without a backing
			// also... if no rollWaitBacking or rollToggleBacking
			// then if there is the backing for these, still set the backing
			// all backings get removed and current backing object is placed
			// normal buttons (with no backings) get borders on rectangle
			// backings get overlayed border with borderColor and rollBorderColor
			// will have to track each mode normal, toggle and wait
			// do not set colors on any custom backings (aside from border colors)
			
			
			if (willBeWaiting) {	
				
				if (that.pressed && that.downWaitBacking) changeObject("downWaitBacking");
				else if (that.pressed && that.downBacking) changeObject("downBacking");
				else if (that.rollWaitBacking) changeObject("rollWaitBacking");
				else if (that.waitBacking) changeObject("waitBacking");
				else if (that.rollBacking) changeObject("rollBacking");
				else changeObject("backing");
				
				if (that.pressed && that.downWaitIcon) changeObject("downWaitIcon");
				// if (that.pressed && that.downIcon) changeObject("downIcon");
				else if (that.rollWaitIcon) changeObject("rollWaitIcon");
				else if (that.waitIcon) changeObject("waitIcon");
				else if (that.rollIcon) changeObject("rollIcon");
				else changeObject("icon", true); // if no icon remove		
				
			} else if (toggleOkay && that.toggled) {
				
				if (that.pressed && that.downToggleBacking) changeObject("downToggleBacking");
				else if (that.pressed && that.downBacking) changeObject("downBacking");
				else if (that.rollToggleBacking) changeObject("rollToggleBacking");
				else if (that.toggleBacking) changeObject("toggleBacking");
				else if (that.rollBacking) changeObject("rollBacking");
				else changeObject("backing");
				
				if (that.pressed && that.downToggleIcon) changeObject("downToggleIcon");
				// else if (that.pressed && that.downIcon) changeObject("downIcon");				
				else if (that.rollToggleIcon) changeObject("rollToggleIcon");
				else if (that.toggleIcon) changeObject("toggleIcon");
				else if (that.rollIcon) changeObject("rollIcon");
				else changeObject("icon", true); 
				
			} else {	
							
				if (that.pressed && that.downBacking) changeObject("downBacking");
				else if (that.rollBacking) changeObject("rollBacking");
				else changeObject("backing");
				
				if (that.pressed && that.downIcon) changeObject("downIcon");
				else if (that.rollIcon) changeObject("rollIcon");	
				else changeObject("icon", true); 		
			}			
			
			if (that.pressed) {
				if (zot(backing) && that.backing) {
                    if (willBeWaiting) that.backing.color = rollWaitBackgroundColor;
                    else if (that.toggled) that.backing.color = rollToggleBackgroundColor;
                    else that.backing.color = downBackgroundColor;
                } else if (backing && !zot(backing.mask) && that.backing) that.backing.mask.color = downBackgroundColor;
			} else {
				if (zot(backing) && that.backing) {
                    that.backing.color = rollBackgroundColor;
                    if (willBeWaiting) that.backing.color = rollWaitBackgroundColor;
                    else if (that.toggled) that.backing.color = rollToggleBackgroundColor;
                    else that.backing.color = rollBackgroundColor;
                } else if (backing && !zot(backing.mask) && that.backing) that.backing.mask.color = rollBackgroundColor;
			}
			
			if (that.border) that.border.borderColor = that.pressed?downBorderColor:rollBorderColor;

			if (that.pressed) that.label.colorOnly = downColor;
			else if (that.label.showRollColor) that.label.showRollColor();
			else that.label.colorOnly = latestColor;
			if (that.stage) that.stage.update();
		}
		
		// for mobile with no mouseover 
		// and to stop rollover if pressed off button and rollover ZIM Cat 04
		// adjusted ZIM 01 with M - as down stage messed things up
		var onCheck = false;
		this.on("mousedown", function () {
			that.pressed = onCheck = true;			
			buttonOn();			
			if (that.rolled) return;
		});
		
		this.on("pressup", function () {			
			that.pressed = onCheck = pressCheck = false;		
						
			if (reallyOn) buttonOn(); // will recall the roll ZIM01
			else if (that.rollPersist) removeRoll();
			
			if (WW.M) { // touch screen
				buttonOff();
			}
		});
		
		this.on("pressmove", function () {
			var frame = that.stage ? that.stage.frame : WW.zdf;
			var hitting = that.hitTestPoint(frame.mouseX, frame.mouseY);
			if (onCheck && !hitting) {
				buttonOff();
				onCheck = false;
			} else if (!onCheck && hitting) {
				buttonOn();
				onCheck = true;
			}
		});

		this.on("mouseout", buttonOff); // thanks Maxime Riehl
		function buttonOff() {
			reallyOn = false;
			if (that.rollPersist) {
				if (!pressCheck) removeRoll();
			} else {
				removeRoll();
			}
		}
		
		function removeRoll() {			
			that.rolled = false;
			if (willBeWaiting || that.waiting) {
				if (zot(backing) && that.backing && zot(that.waitBacking)) that.backing.color = zot(waitBackgroundColor)?backgroundColor:waitBackgroundColor;
				if (that.waitBacking) changeObject("waitBacking");
				else if (that.backing) changeObject("backing");
				if (that.waitIcon) changeObject("waitIcon");
				else if (that.icon) changeObject("icon");
				else changeObject("icon", null);
			} else if (that.toggled && toggleOkay) {
				if (zot(backing) && that.backing && zot(that.toggleBacking)) that.backing.color = toggleBackgroundColor;
				if (that.toggleBacking) changeObject("toggleBacking");
				else if (that.backing) changeObject("backing");
				if (that.toggleIcon) changeObject("toggleIcon");
				else if (that.icon) changeObject("icon");
				else changeObject("icon", null);
			} else {
				if (zot(backing) && that.backing)  that.backing.color = backgroundColor;
				else if (backing && !zot(backing.mask) && that.backing) that.backing.mask.color = backgroundColor;
				if (that.backing) changeObject("backing");
				if (that.icon) changeObject("icon");
				else changeObject("icon", null);
			}

			if (that.border) that.border.borderColor = borderColor;

			that.label.colorOnly = latestColor;
			if (that.label.showRollColor) that.label.showRollColor(false);
			if (that.stage) that.stage.update();
		}
		that.removeRoll = removeRoll;
		if (that.rollBacking) that.rollBacking.removeFrom(); // just in case


		Object.defineProperty(that, 'text', {
			get: function() {
				var t = (label.text == " ") ? "" : label.text;
				return t;
			},
			set: function(value) {
				label.text = value;
				if (originalText) originalText = value;
				label.center(this);
				label.y+=1;
				zim.pos(label, (align=="left"||align=="right")?indentH:null, (valign=="top"||valign=="bottom")?indentV:null, align=="right", valign=="bottom");
			}
		});

		Object.defineProperty(that, 'color', {
			get: function() {
				return color;
			},
			set: function(value) {
				color = value;
				if (originalColor) originalColor = color;
				if (that.label && !zot(that.label.color)) {
					that.label.color = latestColor = color;
				}
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(that, 'rollColor', {
			get: function() {
				return rollColor;
			},
			set: function(value) {
				rollColor = value;
				if (originalRollColor) originalRollColor = rollColor;
				if (that.label) {
					that.label.rollColor = rollColor;
				}
			}
		});
		
		Object.defineProperty(that, 'downColor', {
			get: function() {
				return downColor;
			},
			set: function(value) {
				downColor = value;
				if (originalDownColor) originalDownColor = downColor;
				if (that.label) {
					that.label.downColor = downColor;
				}
			}
		});

		Object.defineProperty(that, 'backgroundColor', {
			get: function() {
				return backgroundColor;
			},
			set: function(value) {
				backgroundColor = value;
				if (that.backing.color) {
					that.backing.color = backgroundColor;
				} else if (that.backing.mask) {
					that.backing.mask.color = backgroundColor;
				}
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(that, 'rollBackgroundColor', {
			get: function() {
				return rollBackgroundColor;
			},
			set: function(value) {
				rollBackgroundColor = value;
				if (that.rollBacking && that.rollBacking.color) {
					that.rollBacking.color = rollBackgroundColor;
				} else if (that.rollBacking && that.rollBacking.mask) {
					that.rollBacking.mask.color = rollBackgroundColor;
				}
			}
		});

		Object.defineProperty(that, 'toggleBackgroundColor', {
			get: function() {
				return toggleBackgroundColor;
			},
			set: function(value) {
				toggleBackgroundColor = value;
				if (that.toggleBacking && that.toggleBacking.color) {
					that.toggleBacking.color = toggleBackgroundColor;
				} else if (that.toggleBacking && that.toggleBacking.mask) {
					that.toggleBacking.mask.color = toggleBackgroundColor;
				}
			}
		});

		Object.defineProperty(that, 'rollToggleBackgroundColor', {
			get: function() {
				return rollToggleBackgroundColor;
			},
			set: function(value) {
				rollToggleBackgroundColor = value;
				if (that.rollToggleBacking && that.rollToggleBacking.color) {
					that.rollToggleBacking.color = rollToggleBackgroundColor;
				} else if (that.rollToggleBacking && that.rollToggleBacking.mask) {
					that.rollToggleBacking.mask.color = rollToggleBackgroundColor;
				}
			}
		});
		
		Object.defineProperty(that, 'downBackgroundColor', {
			get: function() {
				return downBackgroundColor;
			},
			set: function(value) {
				downBackgroundColor = value;
				if (that.downBacking && that.downBacking.color) {
					that.downBacking.color = downBackgroundColor;
				} else if (that.downBacking && that.downBacking.mask) {
					that.downBacking.mask.color = downBackgroundColor;
				}
			}
		});

		Object.defineProperty(that, 'borderColor', {
			get: function() {
				return borderColor;
			},
			set: function(value) {
				borderColor = value;
				if (!that.rolled) {
					if (that.backing && that.backing.borderColor) that.backing.borderColor = value;
					if (that.border) that.border.borderColor = value;
				}
			}
		});

		Object.defineProperty(that, 'rollBorderColor', {
			get: function() {
				return rollBorderColor;
			},
			set: function(value) {
				rollBorderColor = value;
				if (that.rolled) {
					if (that.backing && that.backing.borderColor) that.backing.borderColor = value;
					if (that.border) that.border.borderColor = value;
				}
			}
		});

		Object.defineProperty(that, 'hitPadding', {
			get: function() {
				return hitPadding;
			},
			set: function(value) {
				hitPadding = value;
				if (hitPadding == 0) {
					if (hitArea) {
						this.hitArea = null;
					}
				} else {
					makeHitArea();
				}
			}
		});

		this._enabled = true;
		this.startMouseChildren = this.mouseChildren;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				if (that._enabled) that.startMouseChildren = that.mouseChildren;
				if (value) {
					zenable(that, value);
					that.mouseChildren = that.startMouseChildren;
				} else {
					removeRoll();
					zenable(that, value);
				}
				var c = label.color;
				label.color = latestColor = c;
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		// setBacking or leave backing parameter blank to remove this type of backing
		this.setBacking = function(type, newBacking) {
			setObject(type, newBacking);
		};
		// setIcon or leave icon parameter blank to remove this type of icon
		this.setIcon = function(type, newIcon) {
			setObject(type, newIcon);
		};
		function setObject(type, newObject) {
			if (zot(type)) return that;
			if (that.contains(that[type])) {
				that.removeChild(that[type]);
				if (newObject) that.addChildAt(newObject, type.indexOf("con")>=0?that.numChildren-1:0);
				if (that.stage) that.stage.update();
			}
			if (newObject) {
				if (zot(backing) && type == "backing") backing = newObject;
				if (newObject.type == "Pattern") newObject = setPattern(type, newObject);
				that[type] = newObject;
				that[type].x = width/2;
				that[type].y = height/2;
			} else {
				that[type] = null;
			}
			setOriginalObjects();		
			return that;
		}
		if (style!==false) zim.styleTransforms(this, DS);


		this.clone = function(exact) {
			var but = new zim.Button(
				width, height, label.clone(),
				(exact||!zim.isPick(oa[0]))?backgroundColor :oa[0],
				(exact||!zim.isPick(oa[1]))?rollBackgroundColor :oa[1],
				(exact||!zim.isPick(oa[2]))?downBackgroundColor :oa[2],
				(exact||!zim.isPick(oa[3]))?color :oa[3],
				(exact||!zim.isPick(oa[4]))?rollColor :oa[4],
				(exact||!zim.isPick(oa[5]))?downColor :oa[5],
				originalBorderColor, originalBorderWidth, rollBorderColor, downBorderColor, 
				!zot(backing)?that.backing.clone():null,
				!zot(rollBacking)?that.rollBacking.clone():null,
				!zot(downBacking)?that.downBacking.clone():null,
				!zot(icon)?icon.clone():null, 
				!zot(rollIcon)?rollIcon.clone():null, 
				!zot(downIcon)?downIcon.clone():null,
				corner, dashed, shadowColor, shadowBlur, gradient, gloss, align, valign, indent, indentH, indentV, hitPadding, autoPadding, autoPaddingH, autoPaddingV, rollPersist, 			
				toggle, 
				toggleBackgroundColor, rollToggleBackgroundColor, downToggleBackgroundColor, 
				toggleColor, rollToggleColor, downToggleColor,
				!zot(toggleBacking)?toggleBacking.clone():null,
				!zot(rollToggleBacking)?rollToggleBacking.clone():null,
				!zot(downToggleBacking)?downToggleBacking.clone():null,
				!zot(toggleIcon)?toggleIcon.clone():null,
				!zot(rollToggleIcon)?rollToggleIcon.clone():null,
				!zot(downToggleIcon)?downToggleIcon.clone():null,
				toggleEvent,
				wait, waitTime, 
				waitBackgroundColor, rollWaitBackgroundColor, downWaitBackgroundColor,
				waitColor, rollWaitColor, downWaitColor,
				!zot(waitBacking)?waitBacking.clone():null,
				!zot(rollWaitBacking)?rollWaitBacking.clone():null,
				!zot(downWaitBacking)?downWaitBacking.clone():null,
				!zot(waitIcon)?waitIcon.clone():null,
				!zot(rollWaitIcon)?rollWaitIcon.clone():null,
				!zot(downWaitIcon)?downWaitIcon.clone():null,
				waitModal, waitEnabled,
				style,
				this.group,
				inherit // added in ZIM Cat 03 - not sure if it was missing on purpose
			);
			return that.cloneProps(but);
		};
		
		this.doDispose = function(a,b,disposing) {
			if (that.icon) that.icon.dispose();			
			if (that.rollIcon) that.rollIcon.dispose();
			if (that.downIcon) that.downIcon.dispose();
			if (that.waitIcon) that.waitIcon.dispose();
			if (that.rollWaitIcon) that.rollWaitIcon.dispose();
			if (that.downWaitIcon) that.downWaitIcon.dispose();
			if (that.toggleIcon) that.toggleIcon.dispose();
			if (that.rollToggleIcon) that.rollToggleIcon.dispose();
			if (that.downToggleIcon) that.downToggleIcon.dispose();
			that.icon = that.rollIcon = that.downIcon = that.waitIcon = that.rollWaitIcon = that.downWaitIcon = that.toggleIcon = that.rollToggleIcon = that.downToggleIcon = null;
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		}
	};
	zim.extend(zim.Button, zim.Container, ["clone", "dispose"], "zimContainer", false);
	zim.Button.prototype.dispose = function(disposing) {return this.doDispose(null,null,disposing);};
	//-55

/*--
zim.CheckBox = function(size, label, startChecked, color, backgroundColor, borderColor, borderWidth, corner, margin, indicatorType, indicatorColor, tap, rtl, style, group, inherit)

CheckBox
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A checkbox that when pressed toggles the check and a checked property.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const checkBox = new CheckBox(50, "TEST").center().change(()=>{
	zog(checkBox.checked); // will be true then false, etc.
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
size - (default 60) size in pixels (always square)
label - |ZIM VEE| (default null) ZIM Label object - or String to make a default label (black)
startChecked - |ZIM VEE| (default false) an initial parameter to set checked if true
color - (default darker) the text color of the label
backgroundColor - (default white.toAlpha(.8)) the background color of the box
borderColor - (default darker) the color of the border
borderWidth - (default size/10) thickness of the border
corner - (default 0) the round of the corner
   can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
margin - (default 10) is on outside of box so clicking or pressing is easier
indicatorType - (default check) could be square (box) or x
indicatorColor - (default borderColor or black if no border) the color of the indicator
tap - (default false) set to true to tap to activate CheckBox rather than mousedown or click
rtl - (default DIR=="rtl") set to true to force CheckBox to the right of the text
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setChecked(Boolean) - defaults to true to set button checked (or use checked property)
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
checked - gets or sets the check of the box
label - gives access to the label
text - the text of the label
box - the Rectangle of the checkBox
box2 - the border Rectangle of the checkBox
indicator - gives access to the check mark ie. indicator.sca(.8);
indicatorColor - get or set the color of the indicator
enabled - default is true - set to false to disable
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "change" event when pressed on but not when the checked property is set

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+56
	zim.CheckBox = function(size, label, startChecked, color, backgroundColor, borderColor, borderWidth, corner, margin, indicatorType, indicatorColor, tap, rtl, style, group, inherit) {
		var sig = "size, label, startChecked, color, backgroundColor, borderColor, borderWidth, corner, margin, indicatorType, indicatorColor, tap, rtl, style, group, inherit";
		var duo; if (duo = zob(zim.CheckBox, arguments, sig, this)) return duo;
		z_d("56");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "CheckBox";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(size)) size = DS.size!=null?DS.size:60;		
		if (zot(label)) label = DS.label!=null?DS.label:null;		
		if (zot(startChecked)) startChecked = DS.startChecked!=null?DS.startChecked:false;		
		if (zot(color)) color = DS.color!=null?DS.color:zim.darker;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.white.toAlpha(.8);
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zim.darker;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:size/10;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = size/10;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:0;	
		if (zot(margin)) margin = DS.margin!=null?DS.margin:size/5;
		if (indicatorType != "box" && indicatorType != "square" && indicatorType != "x") indicatorType = DS.indicatorType!=null?DS.indicatorType:"check";
		if (zot(indicatorColor)) indicatorColor = DS.indicatorColor!=null?DS.indicatorColor:borderWidth>0?borderColor:zim.black;
		this.setBounds(-margin, -margin, size+margin*2, size+margin*2);
		if (zot(tap)) tap = DS.tap!=null?DS.tap:false;
		if (zot(rtl)) rtl = DS.rtl!=null?DS.rtl:WW.DIR=="rtl";

		var that = this;
		this.cur("pointer");
		
		// PICK
	    var oa = remember(label, startChecked);
		this.veeObj = {label:oa[0], startChecked:oa[1]};
	    function remember() {return arguments;} // for cloning PICK
	    label = zim.Pick.choose(label);
	    startChecked = zim.Pick.choose(startChecked);
		var myChecked = startChecked;
		
		if (typeof label === "string" || typeof label === "number") label = new zim.Label({
			text:label, size:size*5/6, color:color, valign:"center", align:rtl?"right":"left",
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			style:style, group:this.group
		});
		

		var box = this.box = new zim.Rectangle(size, size, backgroundColor, null, null, corner);
		var box2 = this.box2 = new zim.Rectangle(size*5/7, size*5/7, "rgba(0,0,0,0)", borderColor, borderWidth, corner);
		box2.x = size/7; box2.y = size/7;
		this.addChild(box, box2);

		var fullWidth = size;

		if (label) {
			label.center(that);
			this.label = label;
			if (rtl) {
				label.x = -margin;
				this.setBounds(-label.width-margin*2, -margin, size+margin*3+label.getBounds().width, Math.max(size+margin*2, label.getBounds().height));
				fullWidth = size + label.width + margin;
				this.regX = size;				
			} else {
				label.x = that.getBounds().width;
				this.setBounds(-margin, -margin, size+margin*4+label.getBounds().width, Math.max(size+margin*2, label.getBounds().height));
				fullWidth = label.x + label.width;
			}			
		}
		
		var backing = new zim.Shape({style:false});
		var g = backing.graphics;
		g.f("rgba(0,0,0,.01)").r(
			this.getBounds().x,
			this.getBounds().y,
			fullWidth+(margin*2),
			this.getBounds().height
		);
		this.hitArea = backing;
		// hitArea will stop rollovers on labels but oh well

		var check = new zim.Shape({style:false});
		var g2 = check.graphics;
		if (indicatorType == "check") {
			g2.f(indicatorColor).p("AnQAdICBiaIEEDZIF8nfICfB4In/KPg"); // width about 90 reg in middle
		} else if (indicatorType == "box" || indicatorType == "square") {
			g2.f(indicatorColor).dr(-35,-35,70,70);
		} else { // x
			g2.f(indicatorColor).p("AmJEVIEUkTIkXkWIB4h5IEWEYIETkTIB4B3IkTESIEQERIh4B4IkRkRIkSEVg"); // width about 90 reg in middle
		}

		var cW = 95;
		check.setBounds(-cW/2, -cW/2, cW, cW);
		var scale = size/(cW+66);

		check.scaleX = check.scaleY = scale;
		check.alpha = .9;
		check.x = size/2;
		check.y = size/2;

		if (myChecked) this.addChild(check);

		if (tap) {
			this.tap(toggleCheck);
		} else {
			this.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", toggleCheck);
		}

		Object.defineProperty(that, 'checked', {
			get: function() {
				return myChecked;
			},
			set: function(value) {
				that.setChecked(value);
			}
		});

		this.toggle = function(type) {
			if (zot(type)) type = !myChecked;
			that.setChecked(type);
		};

		Object.defineProperty(that, 'toggled', {
			get: function() {
				return myChecked;
			},
			set: function(value) {
				that.setChecked(value);
			}
		});

		Object.defineProperty(that, 'text', {
			get: function() {
				if (label) return label.text;
				return null;
			},
			set: function(value) {
				if (label) {
					label.text = value;
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(check, 'indicatorColor', {
			get: function() {
				return indicatorColor;
			},
			set: function(value) {
				if (myChecked) {that.removeChild(check);}
				check = new createjs.Shape();
				g2 = check.graphics;
				indicatorColor = value;
				g2.f(indicatorColor).p("AnQAdICBiaIEEDZIF8nfICfB4In/KPg");
				check.scaleX = check.scaleY = scale;
				check.alpha = .9;
				check.x = size/2;
				check.y = size/2;
				if (myChecked) that.addChild(check);
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(that, 'indicator', {
			get: function() {
				return check;
			},
			set: function() {
				zogy("ZIM CheckBox - check is read only");
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		function toggleCheck() {
			myChecked = !myChecked;
			that.setChecked(myChecked);
			that.dispatchEvent("change");
		}

		this.setChecked = function(value) {
			if (zot(value)) value = true;
			myChecked = value;
			if (myChecked) {
				that.addChild(check);
			} else {
				that.removeChild(check);
			}
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			return that;
		};

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function(exact) {
			return that.cloneProps(new zim.CheckBox(size, (exact||!zim.isPick(oa[0]))?label?label.clone():null:oa[0], (exact||!zim.isPick(oa[1]))?startChecked:oa[1], color, backgroundColor, borderColor, borderWidth, corner, margin, indicatorType, indicatorColor, tap, rtl, style, this.group, inherit));
		};
	};
	zim.extend(zim.CheckBox, zim.Container, "clone", "zimContainer", false);
	//-56

/*--
zim.RadioButtons = function(size, buttons, vertical, color, backgroundColor, spacing, margin, always, indicatorColor, selectedIndex, rtl, style, group, inherit)

RadioButtons
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A radio button set that lets you pick from choices.
Radio buttons can display radio buttons vertically (default) or horizontally.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const radioButtons = new RadioButtons(50, ["ONE", "TWO", "THREE"]).center().change(()=>{
	zog(radioButtons.text); // will be ONE, TWO or THREE
	zog(radioButtons.selectedIndex); // will be 0, 1, or 2
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
size - (default 60) in pixels
buttons - an array of button data objects as follows:
	[{label:ZIM Label or text, id:optional id, selected:optional Boolean}, {etc...}]
	or just a list of labels for default labels ["hi", "bye", "what!"]
vertical - (default true) displays radio buttons vertically - set to false to display horizontally
color - (default darker) the text color of the label
backgroundColor - (default "rgba(255,255,255,.8)") the background color of the circle
borderColor - (default darker) the color of the border
borderWidth - (default size/9) thickness of the border
spacing - (size*.2 for vertical and size for horizontal) the space between radio button objects
margin - (size/5) the space around the radio button itself
always - (default false) if set true, cannot click on selection to unselect it
indicatorColor - (default borderColor or black) the color of the indicator
selectedIndex - (default 0) - set the selectedIndex at start
rtl - (default DIR=="rtl") - set to true to put text on left of RadioButtons
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setSelected(num) - sets the selected index (or use selectedIndex) -1 is default (none)
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selected - gets the selected object - selected.label, selected.id, etc.
selectedIndex - gets or sets the selected index of the buttons
label - current selected label object
text - current selected label text
id - current selected id
buttons - an array of button Container objects holding the shape and label (note - different than buttons parameter)
labels - an array of the ZIM Label objects. labels[0].text = "YUM"; labels[2].y -= 10;
indicators - an array of the zim Shape dot objects. indicators[0].color = "yellow";
enabled - default is true - set to false to disable

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "change" event when pressed but not when selectedIndex is set
then ask for the properties above for info

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+57
	zim.RadioButtons = function(size, buttons, vertical, color, backgroundColor, borderColor, borderWidth, spacing, margin, always, indicatorColor, selectedIndex, rtl, style, group, inherit) {
		var sig = "size, buttons, vertical, color, backgroundColor, borderColor, borderWidth, spacing, margin, always, indicatorColor, selectedIndex, rtl, style, group, inherit";
		var duo; if (duo = zob(zim.RadioButtons, arguments, sig, this)) return duo;
		z_d("57");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "RadioButtons";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(size)) size = DS.size!=null?DS.size:60;
		size = Math.max(5, size);
		if (zot(buttons)) buttons = DS.buttons!=null?DS.buttons:["A", "B", "C"];
		if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:true;
		if (zot(color)) color = DS.color!=null?DS.color:zim.darker;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"rgba(255,255,255,.8)";
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zim.darker;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:size/9;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = size/10;
		if (zot(spacing)) spacing = (vertical) ? DS.spacing!=null?DS.spacing:size*.2 : DS.spacing!=null?DS.spacing:size;
		if (zot(margin)) margin = DS.margin!=null?DS.margin:size/5;
		if (zot(always)) always = DS.always!=null?DS.always:false;
		if (zot(indicatorColor)) indicatorColor = DS.indicatorColor!=null?DS.indicatorColor:borderWidth>0?borderColor:zim.black;
		if (zot(rtl)) rtl = DS.rtl!=null?DS.rtl:WW.DIR=="rtl";

		var that = this;
		this.cur("pointer");
		this.labels = [];
		this.indicators = [];
		var firstLabelW = 0;
		var currentObject; // reference to the current data object
		if (typeof buttons == "string") {
			// convert to buttons object literal (for cloning)
			var bString = buttons;
			buttons = [];
			for (var i=0; i<bString.length; i++) {
				buttons.push({label:bString[i]});
			}
		}

		var buttonContainer = new zim.Container({style:false});
		this.addChild(buttonContainer);

		function pressBut(e) {
			var index = buttonContainer.getChildIndex(e.target);
			if (always) {if (that.selectedIndex == index) return;}
			that.setSelected(index);
			that.dispatchEvent("change");
		}

		// loop through data and call makeButton() each time
		makeButtons();

		var currentK;
		for (var k=0; k<buttonContainer.numChildren; k++) {
			currentK = buttonContainer.getChildAt(k);
			currentK.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", pressBut);
		}

		function makeButtons() {
			// test for duplicate selected true properties (leave last selected)
			var data; var selectedCheck = false;
			var i;
			for (i=buttons.length-1; i>=0; i--) {
				data = buttons[i];
				if (data.selected && data.selected === true) {
					if (!selectedCheck) {
						selectedCheck = true; // first item marked selected
						that.id = data.id;
						selectedIndex = i;
					} else {
						data.selected = "false"; // turn off selected
						selectedIndex = null;
					}
				}
			}
			buttonContainer.removeAllChildren();
			that.buttons = [];
			var but; var currentLocation = 0;
			for (i=0; i<buttons.length; i++) {
				data = buttons[i];

				if (typeof data === "string" || typeof data === "number") {
					var d = {selected:false, label:new zim.Label({
						text:data, size:size*5/6, color:DS.color!=null?DS.color:color, valign:"center",
						backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
						style:style, group:that.group
					})};
					data = d;
				}
				if (data.label && typeof data.label === "string" || typeof data.label === "number") {
					data.label = new zim.Label({text:data.label, size:DS.size!=null?DS.size:size*5/6, color:DS.color!=null?DS.color:color, valign:"center", style:style});
				}
				that.labels.push(data.label);
				data.index = i;
				buttons[i] = data; // for cloning
				but = makeButton(data.selected, data.label);
				but.type = "RadioButton"; // singular
				but.obj = data;
				if (data.selected) currentObject = but.obj;

				buttonContainer.addChild(but);

				if (vertical) {
					but.y = currentLocation;
					currentLocation += but.getBounds().height + spacing;
				} else {
					but.x = currentLocation;
					currentLocation += but.getBounds().width + spacing;
				}
			}
		}

		// making a single button - similar to CheckBox class
		
		function makeButton(mySelected, label) {
			var but = new zim.Container({style:false});
			that.buttons.push(but);
			but.mouseChildren = false;
			but.setBounds(-margin, -margin, size+margin*2, size+margin*2);

			var box = new zim.Shape({style:false});
			var g = box.graphics;
			g.f(backgroundColor).dc(size/2,size/2,size/1.85);
			g.s(borderColor).ss(borderWidth).dc(size/2, size/2, size/2-size/2/5);
			but.addChild(box);

			var check = but.check = new zim.Circle(size/5.2, indicatorColor, null, null, null, null, null, null, null, false);
			that.indicators.push(check);
			check.mouseEnabled = false;
			check.alpha = .95;
			check.regX = check.regY = -size/2;

			var fullWidth = size;

			if (label) {
				if (firstLabelW == 0) firstLabelW = label.width;
				but.addChild(label);
				label.y = size/2;				
				but.text = label.text;
				if (rtl) {
					label.x = -label.width-margin;
					but.setBounds(-label.width-margin, -margin, size+margin*2+label.getBounds().width, Math.max(size+margin*2, label.getBounds().height));
					fullWidth = label.width+margin+size;
				} else {
					label.x = but.getBounds().width;
					but.setBounds(-margin, -margin, size+margin*2+label.getBounds().width, Math.max(size+margin*2, label.getBounds().height));
					fullWidth = label.x + label.width;
				}				
			}
			if (mySelected) {
				but.addChild(check);
				that.label = label;
				if (that.label) that.text = label.text;
			}

			var backing = new zim.Shape({style:false});
			g = backing.graphics;
			g.f("rgba(0,0,0,.01)").r(
				but.getBounds().x,
				but.getBounds().y,
				fullWidth+(margin*2),
				but.getBounds().height
			);
			but.hitArea = backing;
			// hitArea will stop rollovers on labels but oh well

			return(but);
		}
		if (!this.getBounds()) this.setBounds(0,0,size,size);
		if (rtl) {
			this.setBounds(-margin*2-firstLabelW,-margin,this.getBounds().width+margin*2,this.getBounds().height);
			this.regX = vertical?size+margin:this.getBounds().width-firstLabelW-margin*3;
		}
		else this.setBounds(-margin,-margin,this.getBounds().width+margin*2,this.getBounds().height);

		// the main function that sets a button selected (after the initial makeButton)
		// this gets called by the setter methods below and the click event up top
		this.setSelected = function(value) {
			if (zot(value)) value = -1;
			if (value != -1 && !buttonContainer.getChildAt(value)) return;
			var but;
			for (var i=0; i<buttonContainer.numChildren; i++) {
				but = buttonContainer.getChildAt(i);
				but.removeChild(but.check);
			}
			if (value >= 0) {
				but = buttonContainer.getChildAt(value);
				var lastIndex = -2;
				if (currentObject) lastIndex = currentObject.index;
				currentObject = but.obj;
			}
			if (value == -1 || lastIndex == currentObject.index) {
				currentObject = null;
				that.id = null;
				that.label = null;
				that.text = "";
			} else {
				but.addChild(but.check);
				that.id = currentObject.id;
				that.label = currentObject.label;
				if (that.label) that.text = that.label.text;
			}
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			return that;
		};

		// getter setter methods

		Object.defineProperty(that, 'selected', {
			get: function() {
				return currentObject;
			},
			set: function() {
				zogy("ZIM RadioButton - selected is read only");
			}
		});

		Object.defineProperty(that, 'selectedIndex', {
			get: function() {
				return (currentObject) ? currentObject.index : -1;
			},
			set: function(value) {
				var index = value;
				if (that.selectedIndex == value) return;			
				// if (always) {if (that.selectedIndex == index) return;} // do not ever want this?  ZIM 015
				that.setSelected(index);
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			var buttonsCopy = zim.copy(buttons);
			for (var i=0; i<buttonsCopy.length; i++) {
				buttonsCopy[i].label = buttonsCopy[i].label.clone();
			}
			return that.cloneProps(new zim.RadioButtons(size, buttonsCopy, vertical, color, backgroundColor, borderColor, borderWidth, spacing, margin, always, indicatorColor, selectedIndex, rtl, style, this.group, inherit));
		};
	};
	zim.extend(zim.RadioButtons, zim.Container, "clone", "zimContainer", false);
	//-57

/*--
zim.Toggle = function(width, height, label, startToggled, backgroundColor, margin, indicatorType, indicatorColor, tap, toggleBackgroundColor, color, borderColor, borderWidth, corner, indicatorCorner, shadowColor, shadowBlur, time, labelLeft, style, group, inherit)

Toggle
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A Toggle button that toggles off and on - with optional labels
Thanks Andi Erni for the initial design and coding of the Toggle.
See: https://zimjs.com/explore/toggle.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const toggle = new Toggle({label:"ON"}).center().change(()=>{
	zog(toggle.toggled);
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 80) the width of the toggle (less labels)
height - (default 50) the height of the toggle
label - (default null) an optional ZIM Label (or text for default label properties)
	also see labelLeft for left side text
startToggled - (default false) set to true to start in the toggled position
backgroundColor - (default purple) set to any HTML color for background color
margin - (default 10) the distance around and between the toggle and its parts
indicatorType - (default "circle" or "round") set to "rectangle" or "square" for square indicator
indicatorColor - (default darker)
toggleBackgroundColor - (default "#F93") orange - for toggled background color
	try setting the borderColor to the same color as the background for inner color change effect
color - (default darker) the font color of the toggle
borderColor - (default null) the color of the border
borderWidth - (default null - or 1 if borderColor) the size of the border
corner - (default half the height) a corner radius - or an array of corners [topLeft, topRight, bottomRight, bottomLeft]
indicatorCorner - (default 0) change the corner radius of a rectangle toggleType - or an array of corners [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (default "rgba(0,0,0,.3)" if shadowBlur) the shadow color - set to -1 for no shadow
shadowBlur - (default 14 if shadowColor) the shadow blur - set to -1 for no shadow
time - (default .1) time in seconds for toggle to animate (also see ZIM TIME constant)
labelLeft - (default null) an optional ZIM Label for the left side of the toggle (or text for default label properties)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
toggle(state) - toggle the toggle - state defaults to true - set to false to un-toggle
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
toggled - gets and sets the toggled state of the toggle 
text - gets the selected label text or "on" / "off" if no label
indicator - access to the indicator object
background - access to background Rectangle
label - access to the label if provided
labelLeft - access to the label on the left if provided
enabled - default is true - set to false to disable

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event when pressed but not when toggle() is used

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+57.5
	zim.Toggle = function(width, height, label, startToggled, backgroundColor, margin, indicatorType, indicatorColor, tap, toggleBackgroundColor, color, borderColor, borderWidth, corner, indicatorCorner, shadowColor, shadowBlur, time, labelLeft, style, group, inherit) {
        var sig = "width, height, label, startToggled, backgroundColor, margin, indicatorType, indicatorColor, tap, toggleBackgroundColor, color, borderColor, borderWidth, corner, indicatorCorner, shadowColor, shadowBlur, time, labelLeft, style, group, inherit";
        var duo; if (duo = zob(zim.Toggle, arguments, sig, this)) return duo;
		z_d("57.5");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Toggle", this.group, inherit);
		if (zot(width)) width=DS.width!=null?DS.width:80;
        if (zot(height)) height=DS.height!=null?DS.height:50;
        this.zimContainer_constructor(width, height, null, null, false);
        this.type = "Toggle";

        if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.purple;
        if (zot(margin)) margin = DS.margin!=null?DS.margin:10; //20;
        if (zot(indicatorType)) indicatorType=DS.indicatorType!=null?DS.indicatorType:"circle";
        if (zot(indicatorColor)) indicatorColor=DS.indicatorColor!=null?DS.indicatorColor:zim.white;
        if (zot(toggleBackgroundColor)) toggleBackgroundColor=DS.toggleBackgroundColor!=null?DS.toggleBackgroundColor:backgroundColor.lighten?backgroundColor.lighten(.3):backgroundColor;
        if (zot(color)) color=DS.color!=null?DS.color:zim.darker;
        if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
        if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
        if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
        else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:indicatorType!="circle"?0:25;
        if (zot(indicatorCorner)) indicatorCorner=DS.indicatorCorner!=null?DS.indicatorCorner:0;
        if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
        if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
        if (zot(startToggled)) startToggled=DS.startToggled!=null?DS.startToggled:false;
		var timeType = getTIME(time);
		if (zot(time)) time = DS.time!=null?DS.time:timeType=="s"?.1:100;
		if (zot(label)) label=DS.label!=null?DS.label:null;
		if (zot(labelLeft)) labelLeft=DS.labelLeft!=null?DS.labelLeft:null;
		

		var that = this;
        that.cur("pointer");

        if (typeof label === "string" || typeof label === "number") label = this.label = new zim.Label({
			text:label, size:DS.size||height*5/6, color:color, valign:"center",
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			group:this.group
		});

        if (typeof labelLeft === "string" || typeof labelLeft === "number") labelLeft = this.labelLeft = new zim.Label({
			text:labelLeft, size:DS.size||height*5/6, color:color, valign:"center",
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			group:this.group
		});

        this.background = new zim.Rectangle(width, height, backgroundColor, borderColor, borderWidth, corner).addTo(this);
        if (indicatorType=="rectangle" || indicatorType=="square") this.indicator = new zim.Rectangle(height*.65, height*.65, indicatorColor, null, null, indicatorCorner).center(this.background).pos(height*.2, null, startToggled);
        else this.indicator = new zim.Circle(height*.35, indicatorColor).center(this.background).pos(height*.175, null, startToggled);
        var _toggled = startToggled;
        that.background.color = _toggled?toggleBackgroundColor:backgroundColor;

        if (shadowColor != -1 && shadowBlur > 0) {
            this.background.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
        }

        if (label) {
			this.addChild(label);
			label.x = width + 2 + margin + borderWidth;
			label.y = height/2;
			this.label = label;
			this.setBounds(-margin, -margin, width+margin*3+borderWidth+label.getBounds().width, Math.max(height+margin*2, label.getBounds().height));
		}

        if (labelLeft) {
			this.addChild(labelLeft);
			labelLeft.x = 0;
            that.background.x += labelLeft.width + 3 + margin + borderWidth;
            that.label.x += labelLeft.width + 3 + margin + borderWidth;
			labelLeft.y = height/2;
			this.labelLeft = labelLeft;
			this.setBounds(-margin, -margin, that.getBounds().width+labelLeft.width + 3 + margin + borderWidth, that.getBounds().height);
		}
		this.expand(zim.mobile()?20:10);

		this.tap(function (e) {
			if (labelLeft) {
				var point = that.localToGlobal(labelLeft.width+3+margin+borderWidth+width/2, 0);
				if ((e.stageX/zim.scaX < (point.x-width/2) && !_toggled) || (e.stageX/zim.scaX >= (point.x+width/2) && _toggled)) return;
			}
			_toggled = !_toggled;
			setToggle();
			that.dispatchEvent("change");
		}, zim.mobile()?20:10);

		var swipe = new zim.Swipe(this, 20, timeType=="s"?.2:200);
		swipe.on("swipe", function (e) {
			if (e.swipeX==0) {
				return;
			} else if (e.swipeX==1 && _toggled) {
				return;
			} else if (e.swipeX==-1 && !_toggled) {
				return;
			}
			_toggled = !_toggled;
            setToggle();
			that.dispatchEvent("change");
		});

        function setToggle(immediate){
            var oldX = that.indicator.x;
			var t = time;
			if (immediate===true) t = 0;
            if (indicatorType=="rectangle" || indicatorType=="square") {
                that.indicator.pos(height*.2, null, _toggled);
				if (time>0) that.indicator.animate({props:{x:oldX}, from:true, time:t});
            } else {
                that.indicator.pos(height*.175, null, _toggled);
				if (time>0) that.indicator.animate({props:{x:oldX}, from:true, time:t});
			}
            that.background.color = _toggled?toggleBackgroundColor:backgroundColor;

			that.text = _toggled?(that.label?that.label.text:"on"):(that.labelLeft?that.labelLeft.text:"off");

			if (that.zimAccessibility) {
				var string = "Toggle set to " + (_toggled?(that.label?that.label.text+".":"on."):(that.labelLeft?that.labelLeft.text+".":"off."));
				setTimeout(function() {that.zimAccessibility.talk(string);}, 50);
			}
        }
		
		Object.defineProperty(that, 'textLeft', {
			get: function() {
				if (labelLeft) return labelLeft.text;
				return null;
			},
			set: function(value) {
				if (labelLeft) {
					labelLeft.text = value;
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});


        that.toggle = function(state, immediate) {
            var lastToggle = _toggled;
            if (zot(state)) state = true;
            _toggled = state;
            if (lastToggle != _toggled) setToggle(immediate);
            return that;
        };
		that.text = _toggled?(that.label?that.label.text:"on"):(that.labelLeft?that.labelLeft.text:"off");

		Object.defineProperty(that, 'toggled', {
			get: function() {
				return _toggled;
			},
			set: function(value) {
				that.toggle(value);
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		if (style !== false) zim.styleTransforms(this, DS);
		this.clone = function () {
			return that.cloneProps(new zim.Toggle(width, height, label ? label.clone() : "", startToggled, backgroundColor, margin, indicatorType, indicatorColor, tap, toggleBackgroundColor, color, borderColor, borderWidth, corner, indicatorCorner, shadowColor, shadowBlur, time, labelLeft ? labelLeft.clone() : "", style, this.group, inherit));
		};
    };
	zim.extend(zim.Toggle, zim.Container, "clone", "zimContainer", false);
	//-57.5

/*--
zim.Tip = function(text, tipAlign, tipValign, margin, marginH, marginV, outside, target, delay, time, mouseClose, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, bold, italic, variant, splitWords, style, group, inherit)

Tip
zim class - extends a a zim.Label which extends a zim.Container which extends a createjs.Container

DESCRIPTION
A Tip() can be used to show some extra information - the tip disappears after an amount of time
Tip has easy positioning along the inside edges or the outside edges of a target.

NOTE: Tip places the tip on the stage when the show() method is called
You can reposition with .mov() etc. if desired

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Tip("Press Circle").show(1); // wait one second and show tip at 40 pixels from bottom right

const circle = new Circle().center().tap(()=>{
	circleTip.show();
});
const circleTip = new Tip({
	text:"This is a default ZIM Circle",
	backgroundColor:white,
	color:black,
	outside:true, // outside the circle
	target:circle,
	align:CENTER,
	valign:BOTTOM,
	margin:14,
	corner:0,
	size:20
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
text - (default "Here's a tip!") String for the the text of the tip
tipAlign - (default RIGHT) the horizontal position of the tip (LEFT, CENTER / MIDDLE, RIGHT)
tipValign - (default BOTTOM") the vertical position of the tip (TOP, CENTER / MIDDLE, BOTTOM")
margin - (default 40) distance from side (unless centered) in pixels
marginH - (default margin) distance from horizontal edges
marginV - (default margin) distance from vertical edges
outside - (default false) set to true to place Tip on outside of container
target - (default zdf's stage) tip is placed on stage relative to container
delay - (default 0) set the default delay for show() - can override with show() parameters
time - (default 2) set the default time for show() - can override with show() parameters
mouseClose - (default true) set to false to not hide tip on mouse press
** the rest are parameters for a Label (align and valign are set as textAlign and textValign)
size - (default 36) the size of the font in pixels
font - (default arial) the font or list of fonts for the text
color - (default black) color of font (any CSS color)
rollColor - (default color) the rollover color of the font
shadowColor - (default "rgba(0,0,0,.3)") set to -1 for no shadow - set to any css color to see
shadowBlur - (default 1) if shadow is present
align - ((default LEFT) text registration point alignment also CENTER and RIGHT
valign - (default CENTER) vertical registration point alignment alse MIDDLE / CENTER, BOTTOM
lineWidth - (default false) for no wrapping (use \n) Can set to number for wrap
lineHeight - (default getMeasuredLineHeight) set to number to adjust line height
backing - (default null) a Display object for the backing of the label (eg. Shape, Bitmap, Container, Sprite)
	see ZIM Pizzazz module for a fun set of Shapes like Boomerangs, Ovals, Lightning Bolts, etc.
outlineColor - (default null - or black if outlineWidth set) - the color of the outline of the text
outlineWidth - (default null - or (size*.2) if outlineColor set) - the thickness of the outline of the text
backgroundColor - (default null) set to CSS color to add a rectangular color around the label
	The background color will change size to match the text of the label
	Note: the backgroundColor is different than a backing which can be any Display Object
	and background parameters are ignored if a backing parameter is set
backgroundBorderColor - (default null) the background stroke color
backgroundBorderWidth - (default null) thickness of the background border
corner - (default 0) the round of corner of the background if there is one
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
backgroundDashed - (default null) set to true for dashed background border (if backgroundBorderColor or backgroundBorderWidth set)
padding - (default 10 if backgroundColor set) places the border this amount from text (see paddingH and paddingV)
	padding parameters are ignored if there is no backgroundColor set (also ignored if a backing parameter is set)
paddingH - (default padding) places border out at top bottom
paddingV - (default padding) places border out at left and right
shiftH - (default 0) move the label (CreateJS Text) inside the Label container horizontally
shiftV - (default 0) move the label (CreateJS Text) inside the Label container vertically
rollPersist - (default false) set to true to maintain rollover stage as long as mousedown or press is activated (used by Buttons)
labelWidth - (default null) the same as the lineWidth - the text will wrap at the labelWidth (added to match labelHeight)
labelHeight - (default null) the height of the text - setting this will probably alter the font size - so the size parameter is overwritten
	for labelHeight to work, the labelWidth must also be set
	using labelWidth and labelHeight together allow you to fit as much text into specified width and height dimensions
maxSize - (default null) set to limit the font size when using labelWidth and labelHeight
bold - (default false) set to true to bold the tip
italic - (default false) set to true to italic the tip
variant - (default false) set to true to set the tip to small caps
splitWords - (default false) set to true to split words when wrapping
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show(delay, time) - show the tip - delay in s defaults to 0 and time in s defaults to 2 (also see ZIM TIME constant)
	default delay and time can be set with main default and time parameters for Tip()
hide() - hides tip - show() will also hide the tip automatically after the time provided
clear() - hides tip and removes the call to a delayed tip using a delay time in show()
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: see all methods of a Label() such as setColorRange(), etc.
ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
tipAlign - get or set the horizontal alignment of the tip
tipValign - get or set the vertical alignment of the tip
text - get or set the text of the Tip

ALSO: see all properties of a Label() such as size, color, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+57.6
	zim.Tip = function(text, tipAlign, tipValign, margin, marginH, marginV, outside, target, delay, time, mouseClose, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, bold, italic, variant, splitWords, style, group, inherit) {
        var sig = "text, tipAlign, tipValign, margin, marginH, marginV, outside, target, delay, time, mouseClose, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, bold, italic, variant, splitWords, style, group, inherit";
        var duo; if (duo = zob(zim.Tip, arguments, sig, this)) return duo;
		z_d("57.6");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Tip", this.group, inherit);

		if (zot(text)) text = DS.text!=null?DS.text:"Here's a tip!";
		if (zot(margin)) margin = DS.margin!=null?DS.margin:40;
		if (zot(marginH)) marginH = DS.marginH!=null?DS.marginH:margin;
		if (zot(marginV)) marginV = DS.marginV!=null?DS.marginV:margin;
		if (zot(tipAlign)) tipAlign = DS.tipAlign!=null?DS.tipAlign:"right";
		if (zot(tipValign)) tipValign = DS.tipValign!=null?DS.tipValign:"bottom";
		if (zot(outside)) outside = DS.outside!=null?DS.outside:false;
        if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.blue;
        if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(corner)) corner = DS.corner!=null?DS.corner:25;
		if (zot(backgroundDashed)) backgroundDashed = DS.backgroundDashed!=null?DS.backgroundDashed:null;
		if (zot(padding)) padding = DS.padding!=null?DS.padding:10; // 14+(Array.isArray(corner)?corner[0]:corner);		
		if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:padding;
		if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:padding;
		if (zot(shadowColor) || shadowColor=="ignore") shadowColor=(DS.shadowColor!=null&&shadowColor!="ignore")?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur) || shadowBlur=="ignore") shadowBlur=(DS.shadowBlur!=null&&shadowBlur!="ignore")?DS.shadowBlur:1;
		if (zot(delay)) delay = DS.delay!=null?DS.delay:0;
		var timeType = getTIME(time);
		if (zot(time)) time = DS.time!=null?DS.time:timeType=="s"?2:2000;
		if (zot(mouseClose)) mouseClose = DS.mouseClose!=null?DS.mouseClose:true;
		
		
		this.zimLabel_constructor(text, size, font, color, rollColor, null, null, align, valign, bold, italic, variant, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, splitWords, style, group, zim.copy(DS));
		this.type = "Tip";

		if (outside) {
			marginH = -marginH;
			marginV = -marginV;
		}
        var that = this;

		that.tipAlign = tipAlign;
		that.tipValign = tipValign;

        this.background.sha(shadowColor, 3, 5, shadowBlur);
        this.show = function(d, t) {
			var timeType = getTIME(t);
			if (zot(d)) d = delay;
			if (zot(t)) t = time;
			if (zot(target)) {
				if (WW.zdf) {
					target = WW.zdf.stage;
				} else {
					return that;
				}
			} else if (!target.getBounds) {
				zogy("zim Tip(): Please pass in a reference to a container with bounds set as parameter to Tip");
				return that;
			} else if (zot(target.stage)) {
				zogy("zim display - Waiter(): The container must have a stage property");
				return that;
			}

			if (d > 0) {
				that.showID = zim.timeout(d, doShow);
			} else {
				doShow();
			}

			function doShow() {
				var b;
				if (target.boundsToGlobal) b = target.boundsToGlobal();
				else b = target.getBounds();
				var container = new zim.Container(b.x, b.y, b.width, b.height);
				container.zimTemp = true;
				container.loc(0, 0, target.stage);

				// if (that.tipAlign=="center" || that.tipAlign=="middle" || that.tipValign=="center" || that.tipValign=="middle") {
				// 	that.center(container);
				// }
				// that.pos((that.tipAlign == "center" || that.tipAlign == "middle") ? null : marginH, (that.tipValign == "center" || that.tipValign == "middle") ? null : marginV, (that.tipAlign == "right"), (that.tipValign == "bottom"), container);
				
				that.pos(marginH, marginV, that.tipAlign, that.tipValign, container);

				if (outside) {
					if (that.tipAlign == "right") that.x += that.width;
					else if (that.tipAlign == "left") that.x -= that.width;
					if (that.tipValign == "bottom") that.y += that.height;
					else if (that.tipValign == "top") that.y -= that.height;
				}

				that.addTo(container.stage); // will transfer over position...
				if (container.zimTemp && container.removeFrom) { container.removeFrom(); container = null; }
				container = that.stage;

				if (that.timeoutID) that.timeoutID.clear();
				that.timeoutID = zim.timeout(t, function () {
					that.hide();
					container.stage.update();
				});
				// setTimeout(function() {
				if (mouseClose) {
					if (that.upID) container.stage.off("stagemouseup", that.upID);
					that.upID = container.stage.on("stagemouseup", function () {
						that.hide();
						if (container.stage) container.stage.update();
					});
				}
				// }, 200);
				if (container.stage) container.stage.update();
			}
			return that;
        };
        this.hide = function() {
            this.removeFrom();
            if (this.timeoutID) this.timeoutID.clear();
            if (this.upID && target.stage) target.stage.off("stagemouseup", this.upID);
			return that;
        };
		this.clear = function() {
			if (that.showID) that.showID.clear();
			that.hide();
		};
		
		this.dispose = function (a,b,disposing) {
			if (that.upID && that.stage) that.stage.off("stagemouseup", that.upID);
			if (!disposing) this.zimLabel_dispose(true);
		};

		if (style !== false) zim.styleTransforms(this, DS);
		this.clone = function () {
			return that.cloneProps(new zim.Tip(text, tipAlign, tipValign, margin, marginH, marginV, outside, target, delay, time, mouseClose, size, font, color, rollColor, shadowColor, shadowBlur, align, valign, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, maxSize, splitWords, style, this.group, inherit));
		};
    };
	zim.extend(zim.Tip, zim.Label, ["dispose","clone"], "zimLabel", false);
	//-57.6
	
/*--
zim.Pane = function(content, backgroundColor, color, width, height, draggable, resets, modal, corner, backdropColor, shadowColor, shadowBlur, center, displayClose, backdropClose, backing, fadeTime, container, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, close, closeColor, autoPadding, autoPaddingH, autoPaddingV, keyboardAccess, style, group, inherit)

Pane
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Adds a window for alerts, etc.
You need to call the pane.show() to show the pane and pane.hide() to hide it.
You do not need to add it to the stage - it adds itself centered.
You can change the x and y (the origin and registration point are in the middle).

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Pane("Watch out!", yellow).show(); // pressing anywhere will close pane (see parameters for options)
END EXAMPLE

EXAMPLE
// if app is in an iFrame, this will get keyboardAccess using a hidden F.keyboardMessage()
// good for games that need keyboard if the game is in an iFrame like the Editor or CodePen
// NOTE: do not use the on("close", f) method as it will not receive an event
// with keyboardAccess the events on the canvas are turned off and captured in an any iFrame
new Pane({content:"START", keyboardAccess:true}).show(()=>{zog("Keys ready")}); 
END EXAMPLE

EXAMPLE
const pane = new Pane({width:600, height:250, modal:false, displayClose:false});
const cancel = new Button(220, 100, "CANCEL", red).center(pane).mov(-130);
const confirm = new Button(220, 100, "CONFIRM", green).center(pane).mov(130);
cancel.on("click", ()=>{pane.hide();});
confirm.on("click", ()=>{zgo("https://zimjs.com")});
pane.show(); // pressing anywhere will close pane (see parameters for options)
END EXAMPLE 

EXAMPLE
// as above but using a callback function in show()
const pane = new Pane({width:600, height:250, modal:false, displayClose:false}).show(confirm=>{
	if (confirm) zgo("https://zimjs.com");
});
const cancel = new Button(220, 100, "CANCEL", red).center(pane).mov(-130).tap(()=>{
	pane.hide(false);
});
const confirm = new Button(220, 100, "CONFIRM", green).center(pane).mov(130).tap(()=>{
	pane.hide(true);
});
END EXAMPLE 

EXAMPLE 
// as above but using CONTENT CONFIG OBJECT
const pane = new Pane({
	width:600, 
	height:250, 
	modal:false, 
	displayClose:false,
	content:{
		buttonScale:1,
		buttons:[
			{
				label:"CANCEL",
				bgColor:red,      
				call:()=>{pane.hide();}
			}, {
				label:"CONFIRM",
				bgColor:green,                    
				call:()=>{zgo("https://zimjs.com");}
			}
		]
	}
}).show(); 
END EXAMPLE

EXAMPLE
// custom backing with ZIM Pizzazz import at top
// import zim from "https://zimjs.org/cdn/016/zim_pizzazz"
new Pane({
	content:new Label({color:white, text:"STOP", size:50}),
	backing:makePattern({
		type:"stripes",
		colors:series(red,black),
		rows:20
	}).alp(.8)
}).show();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
content - (default " ") optional content to be centered in one of three formats:
	a string or number to add a ZIM Label - color darker 
	a ZIM DisplayObject such as a Circle or a Container with more objects, etc.
	a content configuration object {} with the following properties - any are optional:
		header - a ZIM DisplayObject for the top of the content
		message - text that will put into a ZIM Label - default darker - see color property
		display - a ZIM DisplayObject for beneath the message
	 	buttons - an array of ZIM Button objects or configuration objects {} as follows:
			{label, color, rollColor, backgroundColor, rollBackgroundColor, call}
			with call being a callback function for when the button is pressed 
		buttonScale - the scale for the buttons 
		color - the color of the message
		spacingH - horizontal space between the buttons 
		spacingV - vertical space between the content areas		
		align - default CENTER, or use LEFT or RIGHT
backgroundColor - (default white) a css color for the background of the Pane
color - (default black) a css color for the text color of the Pane
width - (default AUTO) width of pane - AUTO will matches content width - see also autoPadding and autoPaddingH
height - (default AUTO) height of pane - AUTO will matches content width - see also autoPadding and autoPaddingV
draggable - (default false) pass in true to drag the pane
resets - (default true) resets position to start on re-open - set to false to keep last position
modal - (default true) pane will close when user clicks off the pane - set to false to keep pane open
corner - (default 20) is the corner radius - set to 0 for no corner
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
backdropColor - (default "rgba(0,0,0,.2)") the color of the background that fills the stage
shadowColor - (default "rgba(0,0,0,.3)") set to -1 for no shadow
shadowBlur - (default 20) how blurred the shadow is if shadow is set
center - (default true) centers the pane
	if center is false you will have to set x and y for the pane
	the registration point and the origin inside the pane is in the center
	you can adjust the label placement by changing its x and y or registration point
displayClose - (default true) closes the Pane if display backing is pressed
	if draggable is set to true, displayClose will automatically be set to false
backdropClose - (default true) closes the Pane if backdrop is pressed
backing - (default null) a Display object for the backing of the pane (eg. Shape, Bitmap, Container, Sprite)
	see ZIM Pizzazz module for a fun set of Shapes like Boomerangs, Ovals, Lightning Bolts, etc.
	as well as patterned backings using Pizzazz 3
fadeTime - (default 0) seconds to fade in and out - also see ZIM TIME constant
container - (default - the default stage) container for the pane
titleBar - (default null - no titleBar) a String or ZIM Label title for the pane that will be presented on a titleBar across the top
titleBarColor - (default black) the color of the titleBar text if a titleBar is requested
titleBarBackgroundColor - (default "rgba(0,0,0,.2)") the background color of the titleBar if a titleBar is requested
titleBarHeight - (default fit label) the height of the titleBar if a titleBar is requested
close - (default false) - a close X for the top right corner that closes the pane when pressed
closeColor - (default grey) - the color of the close X if close is requested
autoPadding - (default 70) the padding used by AUTO width or height
autoPaddingH - (default autoPadding) the padding used by AUTO width
autoPaddingV - (default autoPadding) the padding used by AUTO height
keyboardAccess - (default false) set to true to adds a click through iframe to gain keyboard control
	this sets an invisible Frame keyboardMessage() that will close the pane and give key access to iFrames
	do not use if expecting interactive content in the Pane - it is for a start message only
	do not use on("close", f) as it will not be captured with keyboardAccess true
	instead, use the callback in show() to call a function on close
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show(call, params) - shows the pane (returns the pane for chaining)
	pass in an optional callback function that will be called when the pane closes 
	pass in an optional params object that will be passed to the callback when the pane closes 
	also see the closeCall and closeParams property to set these dynamically
	for instance, if the pane has YES and NO buttons, the closeParams can be set to true or false
	for easy results to an option pop-up
	(as of ZIM ZIM 01 can also use pos(), loc(), center(), etc.)
hide(params, callEvent) - hides the pane
	params will set the closeParams property that gets sent to a callback function in the show()
	callEvent defaults to false - set to true to also call close event
	(as of ZIM ZIM 01 can also use removeFrom())
toggle(state - default null) - shows if hidden and hides if showing (returns the pane for chaining)
	or pass in true to show pane or false to hide pane
add(obj, index, center, replace) - supports DUO - add object to the content container with optional center 
	or just add content like usual to the contentContainer.
	index is the level in the contentContainer - default is the top
	center (default true) for Pane (different than Panel and Window which have false as default)
	replace (default true) for Pane (different than Panel and Window which have false as default) 
		will replace the current content with the new content
	see also content parameter of Pane and contentContainer property
	returns the pane for chaining
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied (returns the new pane for chaining)
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
closeCall - a function to call when the pane closes (see also call parameter of show method)
closeParams - an object to pass to the closeCall (see also params parameter of show method)
backing - or display - reference to the pane box
contentContainer - ZIM Container used to hold added content (formerly the content property)
	use the add() method or add directly to the contentContainer property of the pane
content - gives access to the content provided as a parameter to the Pane()
	** in the past, content refered to what is now the contentContainer
	If a content config object {} is used, the following properties are added to the Pane()
		header - reference to the header if provided
		message  - reference to the message if provided - this is a Label
		text  - reference to the text of the message if provided
		display- reference to the display if provided 
		buttons - an array of the Button objects if provided
		config - the original content config object {}
titleBar - gives access to the titleBar Container - which also has a background property
titleBarLabel - gives access to the titleBar label
toggled - read-only Boolean property as to whether pane is showing
close - access to the ZIM Shape if there is a close X
backdrop - reference to the backdrop that covers the stage
container - get or set the container the pane will be added to
resetX - if reset is true you can dynamically adjust the position if needed
resetY - and the y position for reset...
enabled - set to false to disable component

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "closing" event when about to be closed - good for reloading a game for instance
dispatches a "close" event when closed by clicking on backing, display, close, etc. when applicable
	see also call and params parameters of show() plus closeCall and closeParams properties 
	see also params parameter of hide() which also sets the closeParams property
dispatches a "change" event when closed by clicking on backing, display, close, etc. when applicable
dispatches a "fadedin" event if fadeTime is set and pane has finished its fade in animation
dispatches a "fadedout" event if fadeTime is set and pane has finished its fade out animation

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+58
	zim.Pane = function(content, backgroundColor, color, width, height, draggable, resets, modal, corner, backdropColor, shadowColor, shadowBlur, center, displayClose, backdropClose, backing, fadeTime, container, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, close, closeColor, autoPadding, autoPaddingH, autoPaddingV, keyboardAccess, style, group, inherit) {
		var sig = "content, backgroundColor, color, width, height, draggable, resets, modal, corner, backdropColor, shadowColor, shadowBlur, center, displayClose, backdropClose, backing, fadeTime, container, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, close, closeColor, autoPadding, autoPaddingH, autoPaddingV, keyboardAccess, style, group, inherit";
		if (content && !content.header && !content.message && !content.display && !content.buttons) {
			var duo; if (duo = zob(zim.Pane, arguments, sig, this)) return duo;
		}
		z_d("58");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Pane";

		var mess = "zim display - Pane(): Please pass in a reference to a container with bounds set as first parameter";
		if (zot(container)) {
			if (WW.zdf) {
				container = WW.zdf.stage;
			} else {
				zogy(mess);
				return;
			}
		} else if (!container.getBounds) {
			zogy(mess);
			return;
		} else if (zot(container.getStage)) {
			zogy("zim display - Pane(): The container must have a stage property");
			return;
		}

		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(width)) width=DS.width!=null?DS.width:"auto";
		if (zot(height)) height=DS.height!=null?DS.height:"auto";
		if (zot(content)) content=DS.content!=null?DS.content:" ";			
		if (typeof content === "string" || typeof content === "number") content = new zim.Label({
			text:content, size:DS.size!=null?DS.size:40, align:DS.align!=null?DS.align:"center", valign:DS.valign!=null?DS.valign:"center", color:DS.color!=null?DS.color:color,
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			group:this.group
		}).noMouse();		
		var myContent = this.content = content;
					
		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.white;
		if (zot(draggable)) draggable=DS.draggable!=null?DS.draggable:false;
		if (zot(resets)) resets=DS.resets!=null?DS.resets:true;
		if (zot(modal)) modal=DS.modal!=null?DS.modal:true;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:20;

		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:null;
		if (zot(titleBarColor)) titleBarColor = DS.titleBarColor!=null?DS.titleBarColor:null;
		if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = DS.titleBarBackgroundColor!=null?DS.titleBarBackgroundColor:null;
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:null;

		if (zot(backdropColor)) backdropColor=DS.backdropColor!=null?DS.backdropColor:"rgba(0,0,0,.2)";
		if (zot(shadowColor))  shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:20;
		if (zot(center)) center=DS.center!=null?DS.center:true;
		if (zot(displayClose)) displayClose=DS.displayClose!=null?DS.displayClose:true;
		if (draggable) displayClose = false;
		if (zot(backdropClose)) backdropClose=DS.backdropClose!=null?DS.backdropClose:true;
		if (zot(fadeTime)) fadeTime=DS.fadeTime!=null?DS.fadeTime:0;
		if (zot(close)) close=DS.close!=null?DS.close:false;
		if (zot(closeColor)) closeColor=DS.closeColor!=null?DS.closeColor:zim.grey;
		if (zot(autoPadding)) autoPadding=DS.autoPadding!=null?DS.autoPadding:70;
		if (zot(autoPaddingH)) autoPaddingH=DS.autoPaddingH!=null?DS.autoPaddingH:autoPadding;
		if (zot(autoPaddingV)) autoPaddingV=DS.autoPaddingV!=null?DS.autoPaddingV:autoPadding;
		if (zot(keyboardAccess)) keyboardAccess=DS.keyboardAccess!=null?DS.keyboardAccess:false;

   

		var backdrop = this.backdrop = new zim.Shape({style:false});
			
		// make a big backing that closes the pane when clicked
		// could also provide a close button
		var g = backdrop.graphics;
		g.f(backdropColor);
		g.drawRect(-5000,-5000,10000,10000);
		
		var that = this;		
				
		this.add = function(obj, index, center, replace) {
			var sig = "obj, index, center, replace";
			var duo; if (duo = zob(that.add, arguments, sig, that)) return duo;
			if (zot(center)) center = true;
			if (zot(replace)) replace = true;
			if (typeof obj == "string") obj = new Label(obj, null, null, color).noMouse();
			if (replace) that.contentContainer.removeAllChildren();
			if (center) obj.center(that.contentContainer, index);
			else obj.addTo(that.contentContainer, index);
			return that;
		}
		
		if (myContent) {			
			var made = zim.makeContent(myContent, width, zim.dark);
			var props = ["header","message","text","display","buttons","config"];
			props.forEach(function(p) {if (made[p]) that[p]=made[p];});
			that.label = that.message; // backwards compatibility
			if (width=="auto") width = made.width+autoPaddingH*2;
			if (height=="auto") height = made.height+autoPaddingV*2;
		}		
		
		var content = that.contentContainer = new zim.Container(width, height);
		if (made) that.add(made, null, true);	
		
		// makes it seem like the pane has the dimensions of the display
		this.setBounds(-width/2,-height/2, width, height);
			
		var props = ["header","message","text","display","buttons","config"];
		if (content) props.forEach(function(p) {if (content[p]) that[p]=content[p];});
		that.label = that.message; // backwards compatibility
		
		that.container = container;
		backdrop.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", backdropClose?closePane:function(e){e.stopImmediatePropagation();});
		var htmlList = new zim.Dictionary(true);
		function closePane(e) {
			that.dispatchEvent("closing");
			setTimeout(function() {
				removePane();				
				that.dispatchEvent("close");
			}, 10);
			e.stopImmediatePropagation();
		}
		backdrop.on("mousedown", function(e) {
			e.stopImmediatePropagation();
		});
		this.addChild(backdrop);
		if (!modal) backdrop.noMouse(); 

		var display;
		if (zot(backing)) {
			display = this.backing = new zim.Rectangle({
				width:width, height:height, color:backgroundColor, corner:corner, style:false
			});
		} else {
			if (backing.type == "Pattern") {
				var pattern = backing;
				// width, height, color, borderColor, borderWidth, corner, dashed, strokeObj, scaleDimensions, style, group, inherit
				display = new zim.Rectangle(width, height, backgroundColor, null, null, corner, null, null, null, false);
				pattern.centerReg(display);
				pattern.setMask(display.shape);
			} else {
				display = backing;
			}			
		}
        that.display = that.backing = display;
		if (displayClose) {
			display.cur("pointer");
			display.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", closePane);
		}
		if (shadowColor != -1 && shadowBlur > 0) display.shadow = new createjs.Shadow(shadowColor, 8, 8, shadowBlur);
		display.on("click", function(e) {
			// stops the click from going through the display to the background
			e.stopImmediatePropagation();
		});

		this.resetX; this.resetY;
		if (draggable) {
			display.cur("pointer");
			var diffX, diffY;
			display.on("mousedown", function(e) {
				if (isNaN(that.resetX)) that.resetX = that.x;
				if (isNaN(that.resetY)) that.resetY = that.y;
				diffX = e.stageX/zim.scaX - that.x;
				diffY = e.stageY/zim.scaY - that.y;
				display.cur("pointer");
			});

			display.on("pressmove", function(e) {
				var p = checkBounds(e.stageX/zim.scaX-diffX, e.stageY/zim.scaY-diffY);
				that.x = p.x;
				that.y = p.y;
				var ch;
				for (var i=0; i<that.numChildren; i++) {
					ch = that.getChildAt(i);
					if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
						ch.resize();
					}
				}
				that.stage.update();
			});

			this.on("pressup", function() {
				display.cur("pointer");
				if (that.stage) that.stage.update();
			});
		}

		display.centerReg(this);

		if (content) content.center(this);	

		if (!zot(titleBar)) {
			if (typeof titleBar == "string") titleBar = new zim.Label(titleBar, null, null, titleBarColor);
			var titleBarLabel = that.titleBarLabel = titleBar;
			if (zot(titleBarHeight)) titleBarHeight=titleBarLabel.height * 1.5;
			if (zot(titleBarColor)) titleBarColor = zim.black;
			if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = "rgba(0,0,0,.2)";
			that.titleBar = titleBar = new zim.Container(width, titleBarHeight, null, null, false).centerReg(that).mov(0,-height/2+titleBarHeight/2);
			titleBar.mouseEnabled = false;
			titleBar.mouseChildren = false;
			that.titleBar.backing = new zim.Rectangle(width, titleBarHeight, titleBarBackgroundColor, null, null, [corner*.95,corner*.95, 0,0], null, null, null, false).addTo(titleBar);
			titleBarLabel.center(titleBar).pos({x:Math.max(corner/2, 10), reg:true});
		}

		if (close) {
			close = that.close = new zim.Shape(-40,-40,80,80,null,false);
			close.graphics.f(closeColor).p("AmJEVIEUkTIkXkWIB4h5IEWEYIETkTIB4B3IkTESIEQERIh4B4IkRkRIkSEVg"); // width about 90 reg in middle
			if (titleBar) close.addTo(that).scaleTo(titleBar, null, 50).mov(width/2-Math.max(corner/2, 10)-close.width/2, -height/2+titleBarHeight/2).expand(40);
			else close.addTo(that).sca(.3).mov(width/2-close.width-3, -height/2+close.height).expand(40);
			close.cur("pointer");
			close.expand();
			close.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", closePane);
		}        

		Object.defineProperty(that, 'text', {
			get: function() {
				if (that.message) {
					var t = (that.message.text == " ") ? "" : that.message.text;
					return t;
				} else if (that.content.text) {
					var t = (that.content.text == " ") ? "" : that.content.text;
					return t;
				}
			},
			set: function(value) {
				if (that.message) {
					that.message.text = value;
				} else if (that.content.text) {
					that.content.text = value;
				}
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		this.hide = function(params, callEvent) {
			if (!zot(params)) that.closeParams = params;
			removePane();
			if (callEvent) {
				that.dispatchEvent("close");
				that.dispatchEvent("change");
			}				
			return that;
		};		
		this.on("removed", hide2);		
		function hide2() {
			that.toggled = false;					
			var ch,i;
            var tar = that.content||that.contentContainer||that;	
			if (tar.type != "Container") tar = that.contentContainer||that;	
			for (i=0; i<tar.numChildren; i++) { // record depths first
				ch = tar.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					var obj = {obj:ch, depth:tar.getChildIndex(ch)};
					htmlList.add(ch, obj);
				}
			}
			for (i=tar.numChildren-1; i>=0; i--) { // remove textareas and loaders second
				ch = tar.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					tar.removeChild(ch);
				}
			}
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE))) that.container.stage.update();
			if (resets) {
				if (!isNaN(that.resetX)) that.x = that.resetX;
				if (!isNaN(that.resetY)) that.y = that.resetY;
			}

			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				a.resize(that);
				if (accessibilityClicker) accessibilityClicker.focus();
				else that.zimTabTag.nextSibling.focus();
				setTimeout(function() {a.talk("Pane has been closed.");}, 50);
			}					
		}		

		function removePane() {
			if (fadeTime > 0) {
				that.animate({obj:{alpha:0}, time:fadeTime, call:function(){
					end();
					that.dispatchEvent("fadedout");
				}});
			} else {
				end();
			}
			function end() {
				that.container.removeChild(that);
				if (that.closeCall) that.closeCall(that.closeParams);
			
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE))) that.container.stage.update();
				if (resets) {
					if (!isNaN(that.resetX)) that.x = that.resetX;
					if (!isNaN(that.resetY)) that.y = that.resetY;
				}
			}
		}

		var accessibilityClicker;
		this.show = function(call, params) {
			if (!zot(call)) that.closeCall = call;
			if (!zot(params)) that.closeParams = params;			
			if (center) {
				if (isNaN(that.resetX)) {
					that.x = (that.container.getBounds().width) /2;
					that.y = (that.container.getBounds().height) /2;
				}
			}
			that.container.addChild(that);		
			if (fadeTime > 0) {
				that.alpha = 0;
				that.animate({
					props:{alpha:1},
					time:fadeTime,
					call:function(){
						that.dispatchEvent("fadedin");
					}
				});
			} else {
				setTimeout(function () {
					if (that.container.stage) that.container.stage.update();
				}, 10);
			}			

            if (keyboardAccess && that.stage && that.stage.frame && WW.parent && WW.location !== WW.parent.location) {
                that.stage.frame.keyboardMessage(null, null, "");
                that.stage.frame.on("keyboardactive", function() {
                    that.hide();
                }, null, true); // once
            }

			return that;
		};
		this.on("added", show2);
		function show2() {
            var tar = that.content||that.contentContainer||that;
			if (tar.type != "Container") tar = that.contentContainer||that;
			for (var i=0; i<htmlList.length; i++) {
				tar.addChildAt(htmlList.values[i].obj, htmlList.values[i].depth);
			}
			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				setTimeout(function(){if (a.activatedObject) accessibilityClicker = a.activatedObject.zimTabTag;}, 50);
				a.resize(that);
				a.tabIndex = that.zimTabIndex;
			}
			that.toggled = true;
		}
				
		function checkBounds(x,y) {
			x = Math.max(width/2, Math.min(that.container.getBounds().width-width/2, x));
			y = Math.max(height/2, Math.min(that.container.getBounds().height-height/2, y));
			return {x:x,y:y};
		}

		this.toggle = function(state) {
			if (state===true) that.show();
			else if (state===false) that.hide();
			else if (that.container.contains(that)) that.hide();
			else that.show();
			return that;
		};

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			var lX = that.contentContainer.x; // new Panes automatically center the label
			var lY = that.contentContainer.y;
			var p2 = that.cloneProps(new zim.Pane(zim.copy(content), backgroundColor, color, width, height, draggable, resets, modal, corner, backdropColor, shadowColor, shadowBlur, center, displayClose, backdropClose, !zot(backing)?backing.clone():null, fadeTime, that.container, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, close, closeColor, autoPadding, autoPaddingH, autoPaddingV, keyboardAccess, style, this.group, inherit));
			p2.contentContainer.x = lX;
			p2.contentContainer.y = lY;
			return p2;
		};
	};
	zim.extend(zim.Pane, zim.Container, "clone", "zimContainer", false);
	//-58

/*--
zim.Panel = function(width, height, content, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, close, closeColor, next, nextColor, extraButton, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit)

Panel
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A simple panel with titleBar and optional arrow for more panels.
Panel can be set draggable and can have a collapse button and a close button
See: https://zimjs.com/explore/panel.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a panel with two pages
const panel = new Panel({titleBar:series("TODAY", "TOMORROW")})
   .center();
   
// content for panel 1
const today = new Circle(30, yellow);
panel.add(today, 0, true); // content, level, center on content

// content for panel 2
const tomorrow = new Label("-30");

// event to change content as panels change
panel.on("change", ()=>{
	if (today.parent) {
		panel.add(tomorrow, 0, true, true); // content, level, center and replace
	} else {
		panel.add(today, 0, true, true); // content, level, center and replace		
	}
	S.update();
});
END EXAMPLE

EXAMPLE 
const panel = new Panel({
	width:400,
	height:250,
	bgColor:new GradientColor([black,dark],90),
	titleBar:"CONTENT",
	draggable:true,
	content:{
		message:"We shall greet you!",
		color:lighter, // override default darker
		display:new TextInput({placeholder:"enter name"}).sca(.7),
		align:CENTER,   // default            
		spacingV:25,    // 20 is default
		spacingH:10,    // default
		buttonScale:.5, // default
		buttons:[ // or just a single button object
			{
				label:"GREET",
				bgColor:new GradientColor([green,blue],90),
				width:300,            
				call:()=>{
					new Emitter({
						obj:new Label("Hello "+panel.display.text, 80, null, [green,blue,orange,yellow,pink]),
						startPaused:true,
						shrink:false,
						life:2,
						gravity:2,
						force:{min:2,max:6}                        
					}).loc(panel).spurt(20).on("spurtfizzed",e=>{e.target.dispose();});
				}
			}, {
				// button:new Button(), // can also specify a custom Button
				label:"CLEAR",
				bgColor:new GradientColor([yellow,orange],90),                    
				call:()=>{panel.display.text="";}
			}
		]
	}
}).centerReg();
END EXAMPLE 

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 250) the width of the panel
height - (default 300) the height of the panel
content - (default null) optional content to be centered in one of three formats:
	a string or number to add a ZIM Label - default white
	a ZIM DisplayObject such as a Circle or a Container with more objects, etc.
	a content configuration object {} with the following properties - any are optional:
		header - a ZIM DisplayObject for the top of the content
		message - text that will put into a ZIM Label - default color white - see color property
		display - a ZIM DisplayObject for beneath the message
	 	buttons - an array of ZIM Button objects or configuration objects {} as follows:
			{label, color, rollColor, backgroundColor, rollBackgroundColor, call}
			with call being a callback function for when the button is pressed 
		buttonScale - the scale for the buttons 
		color - the color of the message
		spacingH - (default 20*buttonScale) horizontal space between the buttons 
		spacingV - (default 20) vertical space between the content areas	
		align - default CENTER, or use LEFT or RIGHT
titleBar - |ZIM VEE| (default "PANEL") a String or ZIM Label title for the panel that will be presented on a titleBar across the top
	Panel must have a titleBar - use a Pane or a Rectangle if a titleBar is not desired.
titleBarColor - |ZIM VEE| (default black) the text color of the titleBar
titleBarBackgroundColor - |ZIM VEE| (default "rgba(0,0,0,.2)") the background color of the titleBar
titleBarHeight - (default fit label) the height of the titleBar
backgroundColor - |ZIM VEE| (default lighter) background color (use clear - or "rbga(0,0,0,0)" for no background)
borderColor - |ZIM VEE| (default pewter) border color
borderWidth - (default 1) the thickness of the border
corner - (default 5) the round of corner
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
close - (default false) - add a close icon top right
closeColor - (default titleBarColor) the color of the close icon
next - (default true if more than one panel) set to false to not show an next arrow if multiple panels
nextColor - (default titleBarColor) the color of the next icon
extraButton - (default null) creates a little square button with the letter R for reset
	this is made with the group style id of "extraButton"
	use the extraButton property to access the button to change its label or capture an event, etc.
collapse - (default false) - set to true to add a collapse icon to the titleBar that reduces the panel so only the bar shows and adds an icon to expand
	also can double click bar to collapse panel
collapseColor - (default grey) - the color of the collapse icon
collapsed - (default false) set to true to start the panel collapsed
align - (default LEFT) set to CENTER, MIDDLE or "right" to align the label on the titleBar
	this may get in the way of the close, arrow, collapse or extra buttons at right
shadowColor - (default "rgba(0,0,0,.3)" if shadowBlur) the shadow color - set to -1 for no shadow
shadowBlur - (default 14 if shadowColor) the shadow blur - set to -1 for no shadow
draggable - (default true if titleBar) set to false to not allow dragging titleBar to drag window
boundary - (default null) set to ZIM Boundary() object - or CreateJS.rectangle()
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(obj, index, center, replace) - supports DUO - add object to the content container with optional center 
	note that the content container is below the title bar
	index is the level in the contentContainer - default is the top
	replace will replace the current content with the new content
	see also content parameter of Panel and contentContainer property
	returns the panel for chaining
nextPanel(index, event) - show next panel - the panels are set up to be a series or random or function based
	this means there is not necessarily an order to be able to go backwards to... so, only forward!
	If a series is provided to the Panel title, etc. then the index can be used to go to the title in the series at the index
	event (default false) will dispatch a change event if nextPanel is called
hasProp(property as String) - returns true if property exists on object else returns false
collapse(state) - state defaults to true to collapse or set to false to expand collapsed panel
	must start with the collapse parameter set to true
	also see collapsed property
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
contentContainer - ZIM Container used to hold added content (formerly the content property)
	this is below the title bar - use the add() method or add directly to the contentContainer property of the panel
content - gives access to the content provided as a parameter to the Panel()
	** in the past, content refered to what is now the contentContainer
	If a content config object {} is used, the following properties are added to the Panel()
		header - reference to the header if provided
		message  - reference to the message if provided - this is a Label
		text  - reference to the text of the message if provided
		display- reference to the display if provided 
		buttons - an array of the Button objects if provided
		config - the original content config object {}
panelHeight - get and set the height of the panel without scaling it as height does (for width, remake the Panel object)
titleBar - access to the titleBar container
label - access to the label of the current panel
text - access to the text of the current panel
titleBar - gives access to the titleBar Container - which also has a background property
titleBarLabel - gives access to the titleBar label
closeIcon - access to the close button
collapseIcon - access to the ZIM Shape if there is a collapse triangle
collapsed - get or set whether the panel is collapsed - must start with collapse parameter set to true
	also see collapse() method
arrow - access to the next arrow
background - access to the background Rectangle
extraButton - access to the Label for the extra button if extraButton parameter is set to true
	use this to set the text in the button (a one letter button is expected - for instance, i for info, R for reset, etc.)
overlay - access to the overlay Rectangle used if enabled = false
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
group - used when the object is made to add STYLE with the group selector (like a CSS class)

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event when arrow is pressed to go to the next panel
dispatches a "close" event when closed with close button if there is a close button
dispatches a "collapse" event if collapsing
dispatches a "expand" event if expanding after being collapsed

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+57.7
	zim.Panel = function(width, height, content, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, close, closeColor, next, nextColor, extraButton, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit) {
        var sig = "width, height, content, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, close, closeColor, next, nextColor, extraButton, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit";
        var duo; if (duo = zob(zim.Panel, arguments, sig, this)) return duo;
		z_d("57.7");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Panel", this.group, inherit);
		if (zot(width)) width=DS.width!=null?DS.width:250;
        if (zot(height)) height=DS.height!=null?DS.height:300;
        this.zimContainer_constructor(width, height, null, null, false);
        this.type = "Panel";		
		if (zot(content)) content=DS.content!=null?DS.content:null;
		var myContent = this.content = content;		
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:"PANEL";
		if (zot(titleBarColor)) titleBarColor = DS.titleBarColor!=null?DS.titleBarColor:zim.white;
		if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = DS.titleBarBackgroundColor!=null?DS.titleBarBackgroundColor:zim.grey;
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:30;
        if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.lighter;
        if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zim.pewter;
        if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
        if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
        else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:5;
		if (zot(align)) align=DS.align!=null?DS.align:"left";
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(draggable)) draggable = DS.draggable!=null?DS.draggable:false;
		if (zot(boundary)) boundary = DS.boundary!=null?DS.boundary:null;
		if (zot(close)) close=DS.close!=null?DS.close:false;
		if (zot(closeColor)) closeColor = DS.closeColor != null ? DS.closeColor :!zot(titleBarColor)?titleBarColor:zim.grey;
		if (zot(next)) next=DS.next!=null?DS.next:zim.vee(titleBar);
		if (zot(nextColor)) nextColor=DS.nextColor!=null?DS.nextColor:!zot(titleBarColor)?titleBarColor:zim.grey;
		if (!Array.isArray(corner)) corner = [corner,corner,corner,corner];
		if (zot(collapse)) collapse=DS.collapse!=null?DS.collapse:false;
		if (zot(collapseColor)) collapseColor = DS.collapseColor != null ? DS.collapseColor:!zot(titleBarColor)?titleBarColor:zim.grey;
		if (zot(collapsed)) collapsed=DS.collapsed!=null?DS.collapsed:false;

		var that = this;
		
		// var props = ["header","message","text","display","buttons","config"];
		// if (content) props.forEach(function(p) {if (content[p]) that[p]=content[p];});
		// that.label = that.message; // backwards compatibility
		
		var background = this.background = new zim.Rectangle(width, height, backgroundColor, borderColor, borderWidth, corner).addTo(this);
		if (shadowColor != -1 && shadowBlur > 0) {
			this.background.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
		}
		var titleBarValue = titleBar; // as we assign the container to titleBar later
		var t = zim.Pick.choose(titleBarValue);
		var tBarColor = zim.Pick.choose(titleBarColor);
		var tBarBackgroundColor = zim.Pick.choose(titleBarBackgroundColor);

        var htmlList = new zim.Dictionary(true);
		
		var content = that.contentContainer = new zim.Container(width, height-titleBarHeight).addTo(that).mov(0,titleBarHeight);

		if (typeof t == "string") t = new zim.Label({
			text:t, color:tBarColor, size:DS.size!=null?DS.size:20, bold:DS.bold!=null?DS.bold:false,
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			group:this.group
		});
		var titleBarLabel = that.titleBarLabel = t;
		if (zot(tBarBackgroundColor)) tBarBackgroundColor = "rgba(0,0,0,.2)";
		that.titleBar = titleBar = new zim.Container(width, titleBarHeight, null, null, false).loc(0,0,that);
		var titleBarRect = that.titleBar.backing = new zim.Rectangle(width+borderWidth, titleBarHeight, tBarBackgroundColor, null, null, [corner[0]*.95, corner[1]*.95, 0, 0], true, null, null, false).center(titleBar);
		if (titleBar) positionBar();
		that.label = t;
		that.text = t.text;

		if (close) {
			var closeIcon = that.closeIcon = new zim.Shape(-40,-40,80,80,null,false);
			closeIcon.graphics.f(closeColor).p("AmJEVIEUkTIkXkWIB4h5IEWEYIETkTIB4B3IkTESIEQERIh4B4IkRkRIkSEVg"); // width about 90 reg in middle
			if (titleBar) {
				closeIcon.centerReg(titleBar)
					.scaleTo(titleBar, null, 50);
				closeIcon.pos(Math.max(corner[1]/2, 15), null, true);
			} else {
				closeIcon.addTo(that)
					.sca(.3)
					.mov(width/2-closeIcon.width-3, -height/2+close.height);
			}
			closeIcon.expand(40);
			closeIcon.cur("pointer");
			closeIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function (e) {
				var s = that.stage;
				that.removeFrom();
				that.dispatchEvent("close");
				s.update();
				e.stopImmediatePropagation();
			});
		}
		this.add = function(obj, index, center, replace) {
			var sig = "obj, index, center, replace";
			var duo; if (duo = zob(that.add, arguments, sig, that)) return duo;
			if (replace) that.contentContainer.removeAllChildren();
			if (center) obj.center(that.contentContainer, index);
			else obj.addTo(that.contentContainer, index);
			return that;
		}
		
		if (myContent) {			
			var made = zim.makeContent(myContent,width);
			var props = ["header","message","text","display","buttons","config"];
			props.forEach(function(p) {if (made[p]) that[p]=made[p];});
			that.label = that.message; // backwards compatibility		
			that.add(made, null, true);		
		}		
		this.nextPanel = function(index, event) {
			var t = zot(index)||zot(titleBarValue.array)?zim.Pick.choose(titleBarValue):titleBarValue.array[index];
			var tBarColor = zot(index)||zot(titleBarColor.array)?zim.Pick.choose(titleBarColor):titleBarColor.array[index];
			var tBarBackgroundColor = zot(index)||zot(titleBarBackgroundColor.array)?zim.Pick.choose(titleBarBackgroundColor):titleBarBackgroundColor.array[index];
			var pBackgroundColor = zot(index)||zot(backgroundColor.array)?zim.Pick.choose(backgroundColor):backgroundColor.array[index];
			var pBorderColor = zot(index)||zot(borderColor.array)?zim.Pick.choose(borderColor):borderColor.array[index];
			if (typeof t == "string") t = new zim.Label({
				text:t, color:tBarColor, size:DS.size!=null?DS.size:20,
				backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
				group:this.group
			});
			that.label = t;
			that.text = t.text;
			titleBarLabel.removeFrom();
			titleBarLabel = that.titleBarLabel = t;
			positionBar();
			titleBarRect.color = tBarBackgroundColor;
			that.background.color = pBackgroundColor;
			that.background.borderColor = pBorderColor;
			if (event) that.dispatchEvent("change");
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		};

		function positionBar() {
			if (align=="right") titleBarLabel.center(titleBar).pos(Math.max(corner[0]/2, 10), null, true);
			else if (align=="center" || align=="middle") titleBarLabel.center(titleBar);
			else titleBarLabel.center(titleBar).loc(Math.max(corner[0]/2, 10));
			titleBarLabel.mov(0,2);
		}

		if (draggable) {
			titleBar.cur("pointer");
			titleBar.on("mousedown", function() {
				that.drag({rect:boundary, currentTarget:true});
                var ch,i;
                var tar = that.content||that.contentContainer||that;
				if (tar.type != "Container") tar = that.contentContainer||that;
                for (i=0; i<tar.numChildren; i++) { // record depths first
                    ch = tar.getChildAt(i);
                    if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
                        var obj = {obj:ch, depth:tar.getChildIndex(ch)};
                        htmlList.add(ch, obj);
                    }
                }
			});
            titleBar.on("pressmove", function() {
				loop(htmlList, function(obj){
                    if (obj.resize) obj.resize();
                })
			});
			titleBar.on("pressup", function() {
				that.noDrag(false); // false for not recursive - leave objects inside so they do not lose their own cursors
			});
		}

		if (next > 0) {
			var nextIcon = that.nextIcon = new zim.Shape(-20,-20,40,40,null,false);
			nextIcon.graphics.f(titleBarColor).p("AiJieIETCeIkTCfg"); // width about 90 reg in middle
			nextIcon.centerReg(titleBar).scaleTo(titleBar, null, 70).alp(.8).hov(1).expand();			
			nextIcon.pos(Math.max(corner[1]/2, 15), null, true);
			if (closeIcon) nextIcon.mov(-closeIcon.width-8);
			nextIcon.cur("pointer");
			nextIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
				that.nextPanel();
				that.dispatchEvent("change");
			});
		}

		if (!zot(extraButton)) {
			extraButton = that.extraButton = new zim.Button({
				label:"R",
				width:50,
				height:50,
				corner:5,
				group:"PanelExtra"
			}).scaleTo(titleBar, null, 70).centerReg(titleBar).expand();			
			extraButton.pos(Math.max(corner[1]/2, 15), null, true);
			if (closeIcon) extraButton.mov(-closeIcon.width-8);
			if (nextIcon) extraButton.mov(-nextIcon.width-8);
		}
		
		if (collapse) {
			collapseCheck = collapsed;
			that.collapse = function(state) {
				if (zot(state)) state = true;
				if (state==collapseCheck) return that;
				if (!state) {
					collapseIcon.rot(0);
					background.visible = true;
					content.visible = true;
					// that.setMask(null);
					collapseCheck = false;	
                    show2();
					that.dispatchEvent("expand");			
				} else {
					collapseIcon.rot(180);	
					background.visible = false;
					content.visible = false;
					// that.setMask(that.titleBar.backing, true);
					collapseCheck = true;
                    hide2();
					that.dispatchEvent("collapse");
				}
				if (that.stage) that.stage.update();				
			}                                                                                               
			that.collapseEvent = that.titleBar.on("dblclick", function () {
				that.collapsed = !that.collapsed;
			});
			
			if (zot(collapseColor)) collapseColor=zim.grey;
			var collapseIcon = that.collapseIcon = new zim.Triangle(90,90,90,zim.faint,collapseColor,16);
			collapseIcon.centerReg(that)
				.scaleTo(titleBar, null, 41)
				.pos({x:width-Math.max(corner[1]/2, 15)-collapseIcon.width/2-4, y:titleBarHeight/2, reg:true})
				.expand(40);				
			if (extraButton) collapseIcon.mov(-extraButton.width-8);
			if (closeIcon) collapseIcon.mov(-closeIcon.width-8);
			if (nextIcon) collapseIcon.mov(-nextIcon.width-8);
			
			collapseIcon.cur("pointer");
			collapseIcon.expand();
			var collapseCheck = false;
			collapseIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
				if (collapseCheck) {
					that.collapse(false);
				} else {				
					that.collapse(true);						
				}					
			});			
		}


        this.on("removed", hide2);		
		function hide2() {           
			var ch,i;
            var tar = that.content||that.contentContainer||that;
			if (tar.type != "Container") tar = that.contentContainer||that;
			for (i=0; i<tar.numChildren; i++) { // record depths first
				ch = tar.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					var obj = {obj:ch, depth:tar.getChildIndex(ch)};
					htmlList.add(ch, obj);
				}
			}
			for (i=tar.numChildren-1; i>=0; i--) { // remove textareas and loaders second
				ch = tar.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					tar.removeChild(ch);
				}
			}			
		}
        this.on("added", show2);
		function show2() {
            var tar = that.content||that.contentContainer||that;
			if (tar.type != "Container") tar = that.contentContainer||that;
			for (var i=0; i<htmlList.length; i++) {
				tar.addChildAt(htmlList.values[i].obj, htmlList.values[i].depth);
			}
		}



		that.overlay = new zim.Rectangle(width, height, null, null, null, corner).alp(.3);

		Object.defineProperty(that, 'panelHeight', {
			get: function() {
				return that.background.height;
			},
			set: function(value) {
				background.removeFrom();
				background = this.background = new zim.Rectangle(width, value, backgroundColor, borderColor, borderWidth, corner)
					.addTo(this).bot();
				if (shadowColor != -1 && shadowBlur > 0) {
					this.background.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
				}
				that.setBounds(width, value);
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		
		Object.defineProperty(that, 'collapsed', {
			get: function() {
				return collapseCheck;
			},
			set: function(value) {
				if (that.collapse) that.collapse(value);				
			}
		});		

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
				if (!value) that.overlay.addTo(that);
				else that.overlay.removeFrom();
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		
		if (collapsed) {
			collapsed = false;
			that.collapsed = true;
		}

		if (style !== false) zim.styleTransforms(this, DS);
		this.clone = function () {
			return that.cloneProps(new zim.Toggle(width, height, titleBar ? titleBar.clone() : "", titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, close, closeColor, next, nextColor, extraButton, collapse, collapseColor, that.collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, this.group, inherit));
		};
		this.doDispose = function(a,b,disposing) {
			// need to dispose properly for Panel
			if (collapse) this.titleBar.off("dblclick", this.collapseEvent);
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		}
    };
	zim.extend(zim.Panel, zim.Container, ["clone", "dispose"], "zimContainer", false);
	zim.Panel.prototype.dispose = function(disposing) {return this.doDispose(null,null,disposing);};
	//-57.7

/*--
zim.Window = function(width, height, content, backgroundColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, slide, slideFactor, slideSnap, slideSnapDamp, interactive, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, cancelCurrentDrag, fullSize, fullSizeColor, resizeHandle, collapse, collapseColor, collapsed, optimize, resizeBoundary, resizeVisible, continuous, style, group, inherit)

Window
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Adds a window for content that can be swiped and scrolled.
NOTE: if zim namespace zns = true then this overwrites a JS Window - so the JS Window is stored as document.Window

NOTE: set the enable property to false if animating the position of the whole Window
then set the enable property to true on the animate call function.  See update() method for more.

NOTE: to add ZIM Swipe() to objects in window set the overrideNoSwipe parameter of Swipe to true

NOTE: if animating the window off screen then either turn optimize:false 
or use window.update() in the "animation" event with the animate({events:true})

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const w = new Window({scrollBarDrag:true, padding:20}).center();
const t = new Tile(new Circle(20, red), 4, 20, 20, 20);
w.add(t);
// the above would only drag on the circles (or the scrollbars)
// adding a Rectangle to help dragging   
w.add(new Rectangle(w.width-20,t.height,dark), 0);
// or could have added it to the bottom of the Tile
// new Rectangle(w.width-20,t.height,dark).addTo(t).bot();
END EXAMPLE

EXAMPLE
// Make two windows resize based on one resizeHandle
// We will use a List which extends a Window
// See https://zimjs.com/explore/splitter.html

const listWidth = 200;
const windowWidth = 600;
const margin = 50;

const list = new List({
	width:listWidth+windowWidth, 
	align:LEFT,
	scrollBarDrag:true,
	resizeHandle:true,
	resizeBoundary:new Boundary(-listWidth-windowWidth+margin,0,listWidth+windowWidth-margin*2, 0),
	// resizeVisible:true
})
	.resize(listWidth)
	.pos(120,-80,LEFT,CENTER);
list.items[1].label.text = "Some very long but important option!";

list.on("resize", ()=>{
	const point = list.resizeHandle.localToGlobal(0,0);
	win.resize(list.x+listWidth+windowWidth-point.x);
	win.x = point.x;
});

const win = new Window({
	width:windowWidth,
	height:list.height,
	paddingH:20
}).loc(list).bot().mov(list.width);
win.add(new Pack());
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 300) the width of the window
height - (default 200) the height of window - including the titleBar if there is a titleBar
content - (default null) optional content to be centered in one of three formats:	
	a string or number to add a ZIM Label - default white
	a ZIM DisplayObject such as a Circle or a Container with more objects, etc.
	a content configuration object {} with the following properties - any are optional:
		** see Panel() and Pane() for examples of content configuration object being used
		header - a ZIM DisplayObject for the top of the content
		message - text that will put into a ZIM Label - default color white - see color property
		display - a ZIM DisplayObject for beneath the message
	 	buttons - an array of ZIM Button objects or configuration objects {} as follows:
			{label, color, rollColor, backgroundColor, rollBackgroundColor, call}
			with call being a callback function for when the button is pressed 
		buttonScale - the scale for the buttons 
		color - the color of the message
		spacingH - (default 20*buttonScale) horizontal space between the buttons 
		spacingV - (default 20) vertical space between the content areas		
		scrollBar - set to true if a default scrollBar is present or a number if custom	
backgroundColor - (default dark) background color (use clear - or "rbga(0,0,0,0)" for no background)
borderColor - (default silver) border color
borderWidth - (default 1) the thickness of the border
padding - (default 0) places the content in from edges of border (see paddingH and paddingV)
	padding is ignored if content x and y not 0 - and really only works on top left - so more like an indent
corner - (default 0) is the rounded corner of the window (does not accept corner array - scrollBars are too complicated)
swipe - (default auto/true) the direction for swiping set to none / false for no swiping
	also can set swipe to just vertical or horizontal
scrollBarActive - (default true) shows scrollBar (set to false to not)
scrollBarDrag - (default false) set to true to be able to drag the scrollBar
scrollBarColor - (default borderColor) the color of the scrollBar
scrollBarAlpha - (default .3) the transparency of the scrollBar
scrollBarFade - (default true) fades scrollBar unless being used
scrollBarH - (default true) if scrolling in horizontal is needed then show scrollBar
scrollBarV - (default true) if scrolling in vertical is needed then show scrollBar
slide - (default true) Boolean to throw the content when drag/swipe released
slideFactor - (default .9) is the factor multiplied by dragging velocity (1 no slowing, .7 fast slowing)
slideSnap - (default true) slides past boundary and then snaps back to boundary when released - also VERTICAL, HORIZONTAL, and false
slideSnapDamp - (default .1) the damping to snap back to boundary
interactive - (default true) allows interaction with content in window
	set to false and whole window will be swipeable but not interactive inside
shadowColor - (default rgba(0,0,0,.3)) the color of the shadow
shadowBlur - (default 20) set shadowBlur to -1 for no drop shadow
paddingH - (default padding) places content in from left and right (ignored if content x not 0)
paddingV - (default padding) places content in from top and bottom (ignored if content y not 0)
scrollWheel - (default true) scroll vertically with scrollWheel
damp - (default null) set to .1 for instance to damp the scrolling
titleBar - (default null - no titleBar) a String or ZIM Label title for the window that will be presented on a titleBar across the top
titleBarColor - (default black) the text color of the titleBar if a titleBar is requested
titleBarBackgroundColor - (default "rgba(0,0,0,.2)") the background color of the titleBar if a titleBar is requested
titleBarHeight - (default fit label) the height of the titleBar if a titleBar is requested
draggable - (default true if titleBar) set to false to not allow dragging titleBar to drag window
boundary - (default null) set to ZIM Boundary() object - or CreateJS.rectangle()
onTop - (default true) set to false to not bring Window to top of container when dragging
close - (default false) - a close X for the top right corner that closes the window when pressed
closeColor - (default grey) - the color of the close X if close is requested
cancelCurrentDrag - (default false) - set to true to cancel window dragging when document window loses focus
	this functionality seems to work except if ZIM is being used with Animate - so we have left it turned off by default
fullSize - (default false) - set to true to add a fullsize icon to the titleBar
 	to let user increase the size of the window to the frame - will turn into a reduce size icon
fullSizeColor - (default grey) - the color of the fullSize icon
resizeHandle - (default false) - set to true to rollover bottom right corner to resize window with resizeHandle
collapse - (default false) - set to true to add a collapse button to the titleBar that reduces the window so only the bar shows and adds a button to expand
	also can double click bar to collapse window 
collapseColor - (default grey) the color of the collapse icon
collapsed - (default false) set to true to start the window collapsed
optimize - (default true) set to false to not turn DisplayObjects visible false if they are not on within 300 pixels of the window 
	as the Window is scrolled, any objects within the content and any objects within one level of those objects 
	are set to visible false if their bounds are not hitting the the window bounds + 300 - thanks Ami Hanya for the suggestion
	also see optimize property
resizeBoundary - (default null) add a ZIM Boundary() object for the resize handle - relative to the resize handle start position
	new Boundary(-100, 0, 200, 0) - would allow the resize handle to move to the left or right 100 pixels but not up or down
	new Boundary(0, -100, 0, 200) - would allow the resize handle to move to up or down 100 pixels but not left or right 
	new Boundary(0,0,100,100) - would allow the window to expand in x or y 100 pixels but not grow smaller
	new Boundary(-100,-100,100,100) - would allow the window to shrink in x or y 100 pixels but not grow bigger
resizeVisible - (default false) set to true to always see the resizeHandle - if resizeHandle is set to true
continuous - (default false) set to true (or VERTICAL) to lock window to vertical access and ignore boundary 
	or set to HORIZONTAL to lock window to horizontal and ignore boundary
	used internally for when scrolling should not be limited but rather wrapped such as with ZIM List with continuous:true
	will set scrollBarActive to false
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(obj, index, center, replace) - supports DUO - parameters or single object with properties that match parameters
 	adds obj to content container of window (at padding) must have bounds set
	you can add individual objects but may find it easier to make a Container with dimensions
	then add and position objects in the container and add the container.
	If adding individual objects and adjusting their x and y or scale, do so first and then add()
	or if adjusting after adding and the object goes outside the window size then you should call update()
	which will reset the scrollbars.
	index is the level or layer in the content with 0 being at the bottom
	center will center the content in the visible window
	replace defaults to false and if set to true, removes all content then adds the obj.
	returns window for chaining
remove(obj) - removes object from content container of window and updates - returns window for chaining
removeAll() - removes all objects from content container of window and updates - returns window for chaining
resize(width, height) - resizes the Window without scaling the content (also calls update() for scroll update)
	width and height are optional - returns window for chaining
update() - resets window scrolling if perhaps the content gets bigger or smaller
	update() does not quite update the dragBoundary due to a timeout in waiting for scrolls to be set
	so if animating the position of a window, set the enable property to false before animating
	then set the enable property to true on the animate call function
cancelCurrentDrag() - stop current drag on window - but add dragging back again for next drag
fullSize(state) - state defaults to true to set window to fullsize or set to false to go back to normal 
	must start with the fullSize parameter set to true
	also see fullSized property
collapse(state) - state defaults to true to collapse or set to false to expand collapsed window
	must start with the collapse parameter set to true
	also see collapsed property
clone(recursive) - makes a copy with properties such as x, y, etc. also copied
	recursive (default true) clones the window content as well (set to false to not clone content)
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
backing - CreateJS Shape used for backing of Window
backgroundColor - the color of the backing
borderColor - the color of the border
borderWidth - the width of the border
contentContainer - ZIM Container used to hold added content (formerly the content property)
content - gives access to the content provided as a parameter to the Window()
	** in the past, content refered to what is now the contentContainer
	If a content config object {} was passed in the following properties are added to the Window()
		header - reference to the header if provided
		message  - reference to the message if provided - this is a Label
		text  - reference to the text of the message if provided
		display- reference to the display if provided 
		buttons - an array of the Button objects if provided
		config - the original content config object {}
optimize - see optimize parameter - set to true (default) or false to optimize scrolling of Window
enabled - get or set whether the Window is enabled
scrollEnabled - get or set whether the Window can be scrolled
scrollBar - data object that holds the following properties (with defaults):
	you can set after object is made - call window.update() to see change
	scrollBar.horizontal = zim Shape // the horizontal scrollBar rectangle shape
	scrollBar.vertical = zim Shape // the vertical scrollBar rectangle shape
	scrollBar.color = borderColor; // the color of the scrollBar
	scrollBar.size = 6; // the width if vertical or the height if horizontal
	scrollBar.minSize = 12; // for the height if vertical or the width if horizontal
	scrollBar.spacing = 3 + size + borderWidth / 2;
	scrollBar.margin = 0; // adds extra space only at end by scrollBars
	scrollBar.corner = scrollBar.size / 2;
	scrollBar.showTime = .5; // s to fade in
	scrollBar.fadeTime = 3; // s to fade out
	scrollBar.speed = .5 // scrollwheel speed for x and y scrolling with mouse wheel
scrollX - gets and sets the content x position in the window (this will be negative)
scrollY - gets and sets the content y position in the window (this will be negative)
scrollXMax - gets the max we can scroll in x based on content width - window width (plus padding and margin)
scrollYMax - gets the max we can scroll in y based on content height - window height (plus padding and margin)
titleBar - access to the ZIM Container for the titleBar if there is a titleBar also has a backing property
titleBarLabel - access to the ZIM Label of the titleBar if there is a titleBar
closeIcon - access to the ZIM Shape if there is a close X
fullSizeIcon -  access to the ZIM Container if there is a fullSize icon
fullSized - get or set whether the window is full sized - must start with fullSize parameter set to true
	also see fullSize() method
collapseIcon - access to the ZIM Shape if there is a collapse triangle
collapsed - get or set whether the window is collapsed - must start with collapse parameter set to true
	also see collapse() method
resizeHandle - access the ZIM Rectangle that makes up the resizeHandle when resizeHandle parameter is set to true
	resizeHandle.removeFrom() would stop resize from being available and resizeHandle.addTo(window) would activate it again
continuous - get if window is set to continuous - see continuous parameter

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "select" event when clicked on in a traditional manner (fast click with little movement)
dispatches a "hoverover" event when rolled on without moving for 300 ms
dispatches a "hoverout" event when not hovering due to movement or mouseout on the window
dispatches a "scrolling" event when the window scrolls
dispatches a "close" event when the window is closed with the x on the titleBar if there is a titleBar
dispatches a "slidestart" event if slide is true and window starts sliding (on pressup)
dispatches a "slidestop" event if slide is true and window stops sliding
dispatches a "resize" event if resizing
dispatches a "collapse" event if collapsing
dispatches a "expand" event if expanding after being collapsed
dispatches a "fullsize" event if made fullscreen
dispatches a "originalsize" event if reduced from fullscreen

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+58.1
	zim.Window = function(width, height, content, backgroundColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, slide, slideFactor, slideSnap, slideSnapDamp, interactive, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, cancelCurrentDrag, fullSize, fullSizeColor, resizeHandle, collapse, collapseColor, collapsed, optimize, resizeBoundary, resizeVisible, continuous, style, group, inherit) {
		var sig = "width, height, content, backgroundColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, slide, slideFactor, slideSnap, slideSnapDamp, interactive, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, cancelCurrentDrag, fullSize, fullSizeColor, resizeHandle, collapse, collapseColor, collapsed, optimize, resizeBoundary, resizeVisible, continuous, style, group, inherit";
		var duo; if (duo = zob(zim.Window, arguments, sig, this)) return duo;
		z_d("58.1");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Window";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(width)) width=DS.width!=null?DS.width:300;
		if (zot(height)) height=DS.height!=null?DS.height:200;
		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.dark;
		var originalBorderColor = borderColor;
		var originalBorderWidth = borderWidth;
		if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:zim.silver;
		if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:1; // 0
		if (zot(padding)) padding=DS.padding!=null?DS.padding:0;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:0;
		if (zot(swipe)) swipe=DS.swipe!=null?DS.swipe:true; // true / auto, vertical, horizontal, false / none
		if (zot(scrollBarActive)) scrollBarActive=DS.scrollBarActive!=null?DS.scrollBarActive:true;
		if (zot(scrollBarDrag)) scrollBarDrag=DS.scrollBarDrag!=null?DS.scrollBarDrag:false;
		if (zot(scrollBarColor)) scrollBarColor=DS.scrollBarColor!=null?DS.scrollBarColor:borderColor;
		if (zot(scrollBarAlpha)) scrollBarAlpha=DS.scrollBarAlpha!=null?DS.scrollBarAlpha:.3;
		if (zot(scrollBarFade)) scrollBarFade=DS.scrollBarFade!=null?DS.scrollBarFade:true;
		if (zot(scrollBarH)) scrollBarH = DS.scrollBarH!=null?DS.scrollBarH:true;
		if (zot(scrollBarV)) scrollBarV = DS.scrollBarV!=null?DS.scrollBarV:true;
		if (scrollBarDrag) scrollBarFade = DS.scrollBarFade!=null?DS.scrollBarFade:false;
		if (zot(slide)) slide=DS.slide!=null?DS.slide:true;
		if (zot(slideFactor)) slideFactor=DS.slideFactor!=null?DS.slideFactor:.9;
		if (zot(slideSnap)) slideSnap=DS.slideSnap!=null?DS.slideSnap:"vertical"; // true / auto, vertical, horizontal, false / none
		if (zot(interactive)) interactive=DS.interactive!=null?DS.interactive:true;
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:20;
		if (zot(paddingV)) paddingV=DS.paddingV!=null?DS.paddingV:padding;
		if (zot(paddingH)) paddingH=DS.paddingH!=null?DS.paddingH:padding;
		if (zot(scrollWheel)) scrollWheel = DS.scrollWheel!=null?DS.scrollWheel:true;
		if (zot(damp)) damp = DS.damp!=null?DS.damp:null;
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:null;
		if (zot(titleBarColor)) titleBarColor = DS.titleBarColor!=null?DS.titleBarColor:null;
		if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = DS.titleBarBackgroundColor!=null?DS.titleBarBackgroundColor:null;
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:null;
		if (zot(draggable)) draggable = DS.draggable!=null?DS.draggable:null;
		if (zot(boundary)) boundary = DS.boundary!=null?DS.boundary:null;
		if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:null;
		if (zot(close)) close = DS.close!=null?DS.close:null;
		if (zot(closeColor)) closeColor = DS.closeColor!=null?DS.closeColor:null;
		if (zot(cancelCurrentDrag)) cancelCurrentDrag = DS.cancelCurrentDrag!=null?DS.cancelCurrentDrag:false;
		if (zot(fullSize)) fullSize = DS.fullSize!=null?DS.fullSize:null;
		if (zot(fullSizeColor)) fullSizeColor = DS.fullSizeColor!=null?DS.fullSizeColor:null;
		if (zot(resizeHandle)) resizeHandle = DS.resizeHandle!=null?DS.resizeHandle:null;
		if (zot(collapse)) collapse = DS.collapse!=null?DS.collapse:false;
		if (zot(collapseColor)) collapseColor = DS.collapseColor!=null?DS.collapseColor:null;
		if (zot(collapsed)) collapsed = DS.collapsed!=null?DS.collapsed:false;
		if (zot(optimize)) optimize = DS.optimize!=null?DS.optimize:true;
		if (zot(resizeBoundary)) resizeBoundary = DS.resizeBoundary!=null?DS.resizeBoundary:null;
		if (zot(resizeVisible)) resizeVisible = DS.resizeVisible!=null?DS.resizeVisible:false;
		if (zot(continuous)) continuous = DS.continuous!=null?DS.continuous:false;
		if (continuous != "horizontal" && continuous != "vertical") continuous = false;
		this.continuous = continuous;
				
		if (titleBar === false) titleBar = null;
		if (!zot(titleBar)) {
			if (zot(titleBarHeight)) titleBarHeight = 30;
			height = height - titleBarHeight;
		}


		var that = this;
		that.optimize = optimize;
		this.scrollX = this.scrollY = this.scrollXMax = this.scrollYMax = 0;

		var backing = this.backing = new zim.Shape({style:false});
		this.addChild(backing);

		var mask = new createjs.Shape();
		mask.type = "WindowBacking";
		var mg = mask.graphics;
		// make the mask in the update function
		// when we know if there are vertical and horizontal scrollBars
		this.addChild(mask);

		if (content) var myContent = that.content = content;
		content = this.contentContainer = new zim.Container({style:false});
		this.addChild(content);
		content.mask = mask;
		var stage;

		if (!interactive) {
			// hitArea makes the whole window draggable
			// but then you can't interact with the content inside the window
			var hitArea = new createjs.Shape();
		}
		if (borderWidth > 0) {
			var border = new createjs.Shape();
			this.addChild(border);
		}

		var titleBarCorner = titleBar?0:corner;
		var iconSpace = 0;

		// we call this function at start and when resize() is called to resize the window without scaling content
		function sizeWindow() {
			that.setBounds(0,0,width,height);
			backing.graphics.c().f(backgroundColor).rc(0,0,width,height,titleBarCorner,titleBarCorner,corner,corner);
			if (shadowColor != -1 && shadowBlur > 0) backing.shadow = new createjs.Shadow(shadowColor, 4, 4, shadowBlur);

			if (borderWidth > 0) {
				if (corner) {
					border.graphics.c().s(borderColor).ss(borderWidth, "square", "miter").rc(0,0,width,height,titleBarCorner,titleBarCorner,corner,corner);
				} else {
					border.graphics.c().s(borderColor).ss(borderWidth, "square", "miter").dr(0,0,width,height);
				}
			}

			if (!zot(titleBarRect)) {
				titleBarRect.widthOnly = that.width+borderWidth;
				titleBarMask.widthOnly = that.width+borderWidth-1;
				that.setBounds(0,-titleBarHeight,that.width,height+titleBarHeight);
			}

			if (closeIcon) {				
				if (titleBar) {
					closeIcon.pos({x:width-Math.max(corner/2, 10)-closeIcon.width/2, y:titleBarHeight/2, reg:true});
					titleBarMask.widthOnly = closeIcon.x-15;
					iconSpace = that.width-titleBarMask.width;
				}
				else closeIcon.pos((Math.max(corner/2, 10))/2, closeIcon.height/2, true, false, that);
			}

			if (fullSizeIcon) {
				fullSizeIcon.pos({x:width-Math.max(corner/2, 10)-fullSizeIcon.width/2, y:titleBarHeight/2, reg:true});
				if (closeIcon) fullSizeIcon.mov(-closeIcon.width-10);
				if (titleBar) titleBarMask.widthOnly = fullSizeIcon.x-15;
				iconSpace = that.width-titleBarMask.width;
			}
			
			if (collapseIcon) {
				collapseIcon.pos({x:width-Math.max(corner/2, 10)-collapseIcon.width/2, y:titleBarHeight/2, reg:true});
				if (closeIcon) collapseIcon.mov(-closeIcon.width-10);
				if (fullSizeIcon) collapseIcon.mov(-fullSizeIcon.width-10);
				if (titleBar) titleBarMask.widthOnly = collapseIcon.x-15;
				iconSpace = that.width-titleBarMask.width;
			}
		}
		sizeWindow();
		

		// this exposes an scrollBar data object so creators can adjust scrollBar properties
		// note that these properties are set dynamically in the update function
		var scrollBar = this.scrollBar = {}; // data object to expose scrollBar properties
		scrollBar.color = scrollBarColor;
		scrollBar.size = 6;
		scrollBar.minSize = scrollBar.size*2; // if vertical scroll, this is vertical minSize where size is horizontal size
		scrollBar.spacing = 3.5 + borderWidth / 2;
		scrollBar.margin = 0;
		scrollBar.corner = scrollBar.size / 2;
		scrollBar.showTime = .5;
		scrollBar.fadeTime = 3;
		scrollBar.speed = .5;

		if (scrollBarActive) {
			var hscrollBar = scrollBar.horizontal = new zim.Shape({style:false});
			var hg = hscrollBar.graphics;
			hscrollBar.alpha = scrollBarAlpha;
			this.addChild(hscrollBar);
			if (scrollBarDrag) hscrollBar.drag({localBoundary: true});

			var vscrollBar = scrollBar.vertical = new zim.Shape({style:false});
			var vg = vscrollBar.graphics;
			vscrollBar.alpha = scrollBarAlpha;
			this.addChild(vscrollBar);
			if (scrollBarDrag) vscrollBar.drag({localBoundary: true});
		}

		var hProportion;
		var vProportion;
		var hCheck;
		var vCheck;
		var gap;
		var contentWidth;
		var contentHeight;

		var hEvent;
		var vEvent;

		var scrollBarDown = false; // true for vertical scrolling - set to false when damp is done

		this.update = function() {
			if (scrollBarActive) {
				// clear the scrollBars and remake anytime this function is called
				// as these may change as people add and remove content to the Window
				hg.clear(); // horizontal scrollBar
				vg.clear(); // vertical scrollBar
			}

			// assume no gap at left and top
			// gap is applied in x if there is a scroll in y
			// gap is applied in y if there is a scroll in x
			gap = (scrollBarActive) ? scrollBar.size+scrollBar.spacing*2 : 0;
			contentWidth = content.getBounds()?content.getBounds().width:0;
			contentHeight = content.getBounds()?content.getBounds().height:0;

			// note, the contentWidth and contentHeight include ONE padding
			hCheck = (scrollBarH && contentWidth > width-paddingH && (scrollBarActive || swipe === true || swipe == "auto" || swipe == "horizontal"));
			vCheck = (scrollBarV && contentHeight > height-paddingV && (scrollBarActive || swipe === true || swipe == "auto" || swipe == "vertical"));

			that.scrollXMax = contentWidth+paddingH*2-width+(vCheck?gap+scrollBar.margin:0);
            that.scrollYMax = contentHeight+paddingV*2-height+(hCheck?gap+scrollBar.margin:0);

			// set mask dynamically as scrollBars may come and go affecting the mask size slightly
			mg.clear();
			var xx = borderWidth/2;
			var yy = borderWidth/2;
			var ww = width-((vCheck && scrollBarActive)?scrollBar.size+scrollBar.spacing*2:0)-(vCheck?0:borderWidth);
			var hh = height-((hCheck && scrollBarActive)?scrollBar.size+scrollBar.spacing*2:0)-(hCheck?0:borderWidth);
			var cs = corner*(.1+corner/100);
			mg.f("rgba(0,0,0,0)").rc(
				xx,yy,ww,hh,
				hCheck&&scrollBarActive&&!titleBar?cs:titleBarCorner,
				vCheck&&scrollBarActive&&!titleBar?cs:titleBarCorner,
				vCheck&&scrollBarActive?cs:Math.max(cs, corner-borderWidth/2),
				hCheck&&scrollBarActive?cs:Math.max(cs, corner-borderWidth/2)
			);

			mask.setBounds(that.getBounds().x,that.getBounds().y,that.getBounds().width, that.getBounds().height);
			zim.expand(mask, 0);
			if (!interactive) {
				hitArea.graphics.c().f("red").dr(xx,yy,ww,hh);
				content.hitArea = hitArea;
			}

			var edgeAdjust = Math.max(corner, Math.min(scrollBar.corner, scrollBar.spacing));
			var edgeLeft = edgeAdjust + borderWidth/2;
			var edgeRight = edgeAdjust + (vCheck?gap:0) + borderWidth/2;
			var edgeTop = (titleBar?scrollBar.spacing:edgeAdjust) + borderWidth/2;
			var edgeBottom = edgeAdjust + (hCheck?gap:0) + borderWidth/2;

			var scrollBarLength, rect;
			if (hCheck && scrollBarActive) {
				scrollBarLength = Math.max(scrollBar.minSize, (width-edgeLeft-edgeRight) * (width-edgeLeft-edgeRight) / (contentWidth + paddingH + scrollBar.margin));
				hg.f(scrollBar.color).rr(0,0,scrollBarLength,scrollBar.size,scrollBar.corner);
				hscrollBar.x = edgeLeft;
				hscrollBar.y = height-scrollBar.size-scrollBar.spacing;
				// for swiping window:
				hProportion = new zim.Proportion(-that.scrollXMax, 0, edgeLeft, width-scrollBarLength-edgeRight, -1);
				if (scrollBarDrag) {
					hscrollBar.setBounds(0,0,scrollBarLength,scrollBar.size);
					// drag rect for scrollBar
					rect = new createjs.Rectangle(
						edgeLeft, hscrollBar.y, width-scrollBarLength-edgeLeft-edgeRight, 0
					);
					hscrollBar.dragBoundary(rect);
					hscrollBar.proportion = new zim.Proportion(
						rect.x, rect.x+rect.width, 0, -that.scrollXMax
					);
					hscrollBar.off("pressmove", hEvent);
					hEvent = hscrollBar.on("pressmove", function() {
						that.dispatchEvent("scrolling");
						if (hitArea) {
							// move hitarea to display box
							hitArea.x = -content.x;
							hitArea.y = -content.y;
						}
						content.x = hscrollBar.proportion.convert(hscrollBar.x);
						testContent();
					});
				}
			}

			if (vCheck && scrollBarActive) {
				scrollBarLength = Math.max(scrollBar.minSize, (height-edgeTop-edgeBottom) * (height-edgeTop-edgeBottom) / (contentHeight + paddingV + scrollBar.margin));
				vg.f(scrollBar.color).rr(0,0,scrollBar.size,scrollBarLength,scrollBar.corner);
				vscrollBar.x = width-scrollBar.size-scrollBar.spacing;
				vscrollBar.y = edgeTop;
				// for swiping window:
				vProportion = new zim.Proportion(-that.scrollYMax, 0, edgeTop, height-scrollBarLength-edgeBottom, -1);
				if (scrollBarDrag) {
					vscrollBar.setBounds(0,0,scrollBar.size,scrollBarLength);
					// drag rect for scrollBar
					rect = new createjs.Rectangle(
						vscrollBar.x, edgeTop, 0, height-scrollBarLength-edgeTop-edgeBottom
					);
					vscrollBar.dragBoundary(rect);
					vscrollBar.proportion = new zim.Proportion(
						rect.y, rect.y+rect.height, 0, -that.scrollYMax
					);
					vscrollBar.off("pressmove", vEvent);
					vEvent = vscrollBar.on("pressmove", function() {	
						if (damp) scrollBarDown = true;					
						that.dispatchEvent("scrolling");
						if (hitArea) {
							// move hitarea to display box
							hitArea.x = -content.x;
							hitArea.y = -content.y;
						}
						if (damp) desiredY = vscrollBar.proportion.convert(vscrollBar.y);
						else content.y = vscrollBar.proportion.convert(vscrollBar.y);
						testContent();
					});
				}
			}
			movescrollBars();

			clearTimeout(that.d2Timeout);
			that.d2Timeout = setTimeout(function(){
				try {
					if (content && hscrollBar && hscrollBar.proportion) content.x = hscrollBar.proportion.convert(hscrollBar.x);
					if (content && vscrollBar && vscrollBar.proportion) content.y = vscrollBar.proportion.convert(vscrollBar.y);
				} catch (err) {
					clearTimeout(that.d2Timeout);
					that.d2Timeout = setTimeout(function(){
						try {
							if (content && hscrollBar && hscrollBar.proportion) content.x = hscrollBar.proportion.convert(hscrollBar.x);
							if (content && vscrollBar && vscrollBar.proportion) content.y = vscrollBar.proportion.convert(vscrollBar.y);
						} catch (err) {}
					}, 50);
				}
			}, 50);
			clearTimeout(that.dTimeout);
			that.dTimeout = setTimeout(function(){setdragBoundary();}, 300);
			setdragBoundary();
			testContent();
		};

		this.doResize = function(w, h) {
			if (zot(w)) w = width;
			if (zot(h)) h = height;
			var min = Math.max(20, corner*2);
			// if (titleBar) min = titleBarLabel.x+titleBarLabel.width+10;
			if (titleBar) min = Math.max(iconSpace, min);
			if (w < min) w = min;
			if (h < 20) h = 20;
			width = w;
			height = h;
			sizeWindow();
			for (var i=0; i<content.numChildren; i++) {
				var cont = content.getChildAt(i);
				if (cont.type == "Wrapper") resizeWrapper(cont);
			}			
			if (resizeHandle) placeHandle();
			that.update();
			desiredY = content.y;			
			if (damp) dampY.immediate(desiredY);
			that.dispatchEvent("resize");
			return that;
		};

		if (!zot(titleBar)) {
			if (zot(draggable)) draggable = true;
			if (typeof titleBar == "string") titleBar = new zim.Label({
				text:titleBar, color:titleBarColor, size:DS.size!=null?DS.size:20,
				backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
				group:this.group
			});
			var titleBarLabel = that.titleBarLabel = titleBar;
			titleBarLabel.noMouse();
			if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = "rgba(0,0,0,.2)";
			that.titleBar = titleBar = new zim.Container(width, titleBarHeight, null, null, false).centerReg(that).mov(0,-height/2-titleBarHeight/2);
			var titleBarMask = new zim.Rectangle(titleBar.width-1, titleBar.height, red).alp(0).addTo(titleBar);
			titleBarLabel.setMask(titleBarMask, true);
			var titleBarRect = that.titleBar.backing = new zim.Rectangle(width+borderWidth, titleBarHeight, titleBarBackgroundColor, null, null, [corner*.95, corner*.95, 0, 0], true, null, false, false).center(titleBar);
			titleBarLabel.center(titleBar).pos({x:Math.max(corner/2, Math.max(10, padding)), reg:true});
			that.regX = 0; that.regY = -titleBarHeight;
			that.setBounds(0,-titleBarHeight,width,height+titleBarHeight);

			if (draggable) {
				titleBar.cur("pointer");
				titleBar.on("mousedown", function() {
					that.drag({rect:boundary, currentTarget:true, onTop:onTop});
				});
				titleBar.on("pressup", function() {
					that.noDrag(false);
				});
			} else {
				titleBar.on("mousedown", function () {});
			}

		}

		if (close) {
			if (zot(closeColor)) closeColor = zim.grey;
			var closeIcon = that.closeIcon = new zim.Shape(-40,-40,80,80,null,false);
			closeIcon.graphics.f(closeColor).p("AmJEVIEUkTIkXkWIB4h5IEWEYIETkTIB4B3IkTESIEQERIh4B4IkRkRIkSEVg"); // width about 90 reg in middle
			if (titleBar) closeIcon.centerReg(that).scaleTo(titleBar, null, 50).pos({x:width-Math.max(corner/2, 10)-closeIcon.width/2, y:titleBarHeight/2, reg:true}).expand(40);
			else {
				closeIcon.sca(.3).pos((Math.max(corner/2, 10))/2, closeIcon.height/2, true, false, that).expand(40);
			}
			closeIcon.cur("pointer");
			closeIcon.expand();
			closeIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
				var ss = that.stage;
				that.removeFrom();
				that.dispatchEvent("close");
				if (ss) ss.update();
			});
		}

		var collapseCheck,fullCheck,lastWidth,lastHeight,lastX,lastY;
		if (!zot(titleBar)) {
			if (fullSize) {
				that.fullSize = function(state) {
					if (zot(state)) state = true;					
					if (state==fullCheck || !that.parent) return that;
					if (!state) {
						that.resize(lastWidth, lastHeight-titleBar.height);
						that.x = lastX;
						that.y = lastY;
						fullCheck = false;
						reduceSize.alpha = 0;
						fullSizeIcon.getChildAt(0).alpha = 1;
						that.dispatchEvent("originalsize");
					} else {
						lastWidth = that.width;
						lastHeight = that.height;
						lastX = that.x;
						lastY = that.y;
						that.resize(that.parent.width, that.parent.height);
						that.x = 0;
						that.y = 0;
						fullCheck = true;
						reduceSize.alpha = 1;
						fullSizeIcon.getChildAt(0).alpha = .01;
						that.dispatchEvent("fullsize");
					}
					if (that.stage) that.stage.update();
				}
				if (zot(fullSizeColor)) fullSizeColor = zim.grey;
				var fullSizeIcon = that.fullSizeIcon = new zim.Rectangle(80,80,zim.faint,fullSizeColor,16);
				var reduceSize = new zim.Shape()
					.s(fullSizeColor).ss(16)
					.mt(-19.6,-20.6)
					.lt(-19.6,-40).lt(40,-40).lt(40,20.7).lt(19.6,20.7).lt(19.6,40).lt(-40,40).lt(-40,-20.6).lt(-19.6,-20.6).lt(19.6,-20.6).lt(19.6,20.7)
					.addTo(fullSizeIcon)
					.mov(40,40)
					.alp(0);
				fullSizeIcon.centerReg(that)
					.scaleTo(titleBar, null, 42)
					.pos({x:width-Math.max(corner/2, 10)-fullSizeIcon.width/2, y:titleBarHeight/2, reg:true})
					.expand(40);
				if (closeIcon) fullSizeIcon.mov(-closeIcon.width-10);
				fullSizeIcon.cur("pointer");
				fullSizeIcon.expand();
				fullCheck = false;
				lastWidth = width;
				lastHeight = height;
				lastX = that.x;
				lastY = that.y;
				fullSizeIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
					if (fullCheck) {
						that.fullSize(false);
					} else {
						that.fullSize(true);
					}					
				});
			}
			var ob = zim.copy(that.getBounds(), true);
			if (collapse) {
				collapseCheck = collapsed;
				that.collapse = function(state) {
					if (zot(state)) state = true;
					if (state==collapseCheck) return that;
					if (!state) {
						collapseIcon.rot(0);
						that.backing.visible = true;
						that.contentContainer.visible = true;
						mask.visible =  true;
						if (hscrollBar) hscrollBar.visible = true;
						if (hscrollBar) vscrollBar.visible = true;
						if (border) border.visible = true;
						collapseCheck = false;
						titleBarRect.sha(null);
						if (resizeHandle) that.resizeHandle.visible = true;
						that.setBounds(ob.x, ob.y, ob.width, ob.height);
						that.dispatchEvent("expand");						
					} else {
						collapseIcon.rot(180);	
						that.backing.visible = false;
						that.contentContainer.visible = false;
						mask.visible = false;						
						if (hscrollBar) hscrollBar.visible = false;
						if (hscrollBar) vscrollBar.visible = false;
						if (border) border.visible = false;
						collapseCheck = true;
						titleBarRect.sha(shadowColor, 5,5, shadowBlur);
						if (resizeHandle) that.resizeHandle.visible = false;
						that.setBounds(ob.x, ob.y, ob.width, titleBar.height);
						that.dispatchEvent("collapse");
					}
					if (that.stage) that.stage.update();
				}
				if (zot(collapseColor)) collapseColor = zim.grey;
				var collapseIcon = that.collapseIcon = new zim.Triangle(90,90,90,zim.faint,collapseColor,16);
				collapseIcon.centerReg(that)
					.scaleTo(titleBar, null, 42)
					.pos({x:width-Math.max(corner/2, 10)-collapseIcon.width/2, y:titleBarHeight/2, reg:true})
					.expand(40);
				if (closeIcon) collapseIcon.mov(-closeIcon.width-10);
				if (fullSizeIcon) collapseIcon.mov(-fullSizeIcon.width-10);
				collapseIcon.cur("pointer");
				collapseIcon.expand();
				collapseCheck = false;
				lastWidth = width;
				lastHeight = height;
				lastX = that.x;
				lastY = that.y;
				collapseIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
					if (collapseCheck) {
						that.collapse(false);
					} else {				
						that.collapse(true);						
					}					
				});
			}
		}

		if (resizeHandle) {
			// want Boundary to be relative to bottom right corner to start
			// so add handle to container placed there
			var handleHolder = new Container()
				.loc(0, 0, that)
				.mov(that.width, that.height - (that.titleBar ? that.titleBar.height : 0));

			var handle = that.resizeHandle = new zim.Rectangle(25, 25, zim.grey, zim.white)
				.alp(resizeVisible?.5:.01)
				.centerReg()
				.rot(45)
				.loc(0, 0, handleHolder)
				.drag({boundary:resizeBoundary, localBoundary:true});
			handle.on("mouseover", function() {
				handle.alp(.5);
				if (handle.stage) handle.stage.update();
			});
			handle.on("mousedown", function() {
				handle.pressing = true;
			})
			handle.on("mouseout", function() {
				if (!handle.pressing) {
					if (!resizeVisible) handle.alp(.01);
					if (handle.stage) handle.stage.update();
				}
			})
			handle.on("pressmove", function () {
				that.resize(Math.max(50,handleHolder.x+handle.x), Math.max(50,handleHolder.y+handle.y));				
			});
			handle.on("pressup", function() {
				handle.pressing = false;
				if (!resizeVisible) handle.alp(.01);
				placeHandle();
				if (handle.stage) handle.stage.update();
			});
			if (that.titleBar) that.titleBar.on("pressup", placeHandle);
		}
		
		function placeHandle(e) {
			that.resizeHandle
				.loc(0, 0, handleHolder)
				.top()
				.mov(-handleHolder.x+that.width, -handleHolder.y+that.height - (that.titleBar ? that.titleBar.height : 0));
		}

		function resizeWrapper(cont) {
			if (cont.align == "right") {
				cont.x=paddingH;
				cont.resize(that.width-(vCheck?scrollBar.size+scrollBar.spacing*2:paddingH)-paddingH*2);
			} else if (cont.align == "center" || cont.align == "middle") {
				cont.resize(that.width-(vCheck?scrollBar.size+scrollBar.spacing*2:0)-paddingH*2);
			} else {
				cont.resize(that.width-(vCheck?scrollBar.size+scrollBar.spacing*2:0)-paddingH*2);
			}
			cont.alpha = cont.wrapperLastAlpha;
		}

		sizeWindow();

		// METHODS to add and remove content from Window
		this.add = function(obj, index, center, replace) {
			var sig = "obj, index, center, replace";
			var duo; if (duo = zob(that.add, arguments, sig, that)) return duo;
						
			var c = obj;
			if (!c.getBounds()) {zogy("Window.add() - please add content with bounds set"); return;}
			makeDamp(c);
			if (zot(index)) index = content.numChildren;
			if (replace) {
				index = 0;
				that.removeAll();
			}
			if (center) {		
				c.center(that).addTo(content, index).mov(0,titleBarHeight?titleBarHeight/2:0);
				if (content.height > that.height-(titleBarHeight?titleBarHeight:0)) c.loc(null,0);
				if (content.width > that.width) c.loc(0);				
			} else {
				c.addTo(content, index);
			}			
			if (c.type == "Wrapper") {
				vscrollBar.alpha = 0;
				scrollBarH = false;
				c.wrapperLastAlpha = c.alpha;
				c.alpha = 0;
				this.added(function(){
					resizeWrapper(c);
					that.resize();
					hscrollBar.alpha = 1;
					vscrollBar.alpha = 1;
				});
			}
			if (c.x == 0) c.x = paddingH;
			if (c.y == 0) c.y = paddingV;			
			that.update();
			return that;
		};		
		if (myContent) {
			var made = zim.makeContent(myContent,width);
			var props = ["header","message","text","display","buttons","config"];
			props.forEach(function(p) {if (made[p]) that[p]=made[p];});
			that.label = that.message; // backwards compatibility
			that.add(made, 0, true);
		}

		this.remove = function(c) {
			content.removeChild(c);
			that.update();
			return that;
		};

		this.removeAll = function() {
			content.removeAllChildren();
			that.update();
			return that;
		};

		function setdragBoundary(on) {
			if (continuous) return;
			if (zot(stage)) stage = that.stage || WW.zdf.stage;
			if (zot(on)) on = true;
			if (on) zim.dragBoundary(content, new createjs.Rectangle(0, 0, hCheck?-that.scrollXMax:0, vCheck?-that.scrollYMax:0));
			else zim.dragBoundary(content, new createjs.Rectangle(-1000, -1000, stage.width+2000, stage.height+2000));
		}

		var swipeCheck = false;
		if (swipe) {
			content.on("mousedown", function() {
				if (!swipeCheck) zim.Ticker.add(swipeMovescrollBars, content.stage);
				swipeCheck = true;
				if (hCheck && scrollBarActive) if (scrollBarFade) zim.animate(hscrollBar, {alpha:scrollBarAlpha}, scrollBar.showTime);
				if (vCheck && scrollBarActive) if (scrollBarFade) zim.animate(vscrollBar, {alpha:scrollBarAlpha}, scrollBar.showTime);
			});
		}

		function swipeMovescrollBars() {
			// this is being called by the swipe which has its own damping
			// so we need to set the desiredY and then move the scrollBars
			// as the movescrollBars needs to run independently - so both types of damp can controll it
			desiredY = content.y;
			if (damp) dampY.immediate(desiredY);
			if (scrollBarActive) movescrollBars();
			else that.dispatchEvent("scrolling");
		}

		function testContent() {
			if (!that.optimize) return;
			stage = that.stage;
			content.loop(function(item) {
				// ADJUSTED ZIM 016 - look into how we can optimize a wrapper and keep scrollbars the right size
				if (!item.hitTestBounds || !item.stage || item.type == "Wrapper") return; // don't turn off items if not on stage yet
				if (item.hitTestBounds(that,300)) {
					item.visible = true;					
					if (item.loop) item.loop(function(item2) {
						if (!item2.hitTestBounds) return;
						if (item2.hitTestBounds(that,300)) item2.visible = true;
						else item2.visible = false;
					});
				} else item.visible = false;
			});
		}

		function movescrollBars() {
			testContent();			
			that.dispatchEvent("scrolling");
			if (hitArea) {
				// move hitarea to display box
				hitArea.x = -content.x;
				hitArea.y = -content.y;
			}
			if (hCheck && scrollBarActive) hscrollBar.x = hProportion.convert(content.x);
			if (vCheck && scrollBarActive) vscrollBar.y = vProportion.convert(content.y);
		}

		// may add content before adding Window to stage...
		this.on("added", function() {
			setDrag(50);
		}, null, true); // once		
		function setDrag(delay) {
			if (zot(delay)) delay = 100;
			makeDamp(that);
			if (!swipe) return;
			setTimeout(function(){
				if (content) {
					zim.drag({
						obj:content,
						currentTarget:true,
						axis:continuous,
						localBoundary:true,
						slide:slide,
						slideFactor:slideFactor,
						slideSnap:(scrollBarH && (swipe===true||swipe=="auto"||swipe=="horizontal")) || (scrollBarV && (swipe===true||swipe=="auto"||swipe=="vertical"))?slideSnap:false
					});					
					content.removeAllEventListeners("slidestart");
					content.on("slidestart", function () {
						that.dispatchEvent("slidestart");
					});					
					content.removeAllEventListeners("slidestop");
					
					if (!scrollBarActive && optimize) {
						if (that.zDE) content.off(that.zDE);
						that.zDE = content.on("mousedown", function() {
							if (that.zTI) zim.Ticker.remove(testContent);
						});						
						if (that.zME) content.off(that.zME);
						that.zME = content.on("pressmove", testContent);						
						if (that.zSTA) content.off(that.zSTA);						
						that.zSTA = content.on("slidestart", function () {
							that.zTI = zim.Ticker.add(testContent);
						});							
						if (that.zSTO) content.off(that.zSTO);
						that.zSTO = content.on("slidestop", function (e) {
							if (that.zTI) zim.Ticker.remove(that.zTI);
						}); 				
					}					
					
					content.on("slidestop", function (e) {
						if (slide) stageUp(e);
						that.dispatchEvent("slidestop");
					});
					if (content.getBounds() && content.getBounds().width > 0) {
						setdragBoundary();
					}
				}
			}, delay);
		}
		this.cancelCurrentDrag = function() {
			if (that.contentContainer) that.contentContainer.noDrag(false);
			setTimeout(function(){
				if (content) {
					zim.drag({
						obj:content,
						currentTarget:true,
						localBoundary:true,
						slide:slide, slideFactor:slideFactor,
						slideSnap:(scrollBarH && (swipe===true||swipe=="auto"||swipe=="horizontal")) || (scrollBarV && (swipe===true||swipe=="auto"||swipe=="vertical"))?slideSnap:false
					});
					if (content.getBounds() && content.getBounds().width > 0) {
						setdragBoundary();
					}
				}
			}, 300);
		};

		var stageEvent;
		this.added(function (_stage) {
			stage = _stage;
			stageEvent = stage.on("stagemousemove", function (e) {
				that.windowMouseX = e.stageX/zim.scaX;
				that.windowMouseY = e.stageY/zim.scaY;
			});
		});

		if (slide) {
			content.on("slidestop", stageUp);
		} else {
			content.on("mousedown", function() {
				content.stage.on("stagemouseup", stageUp, null, true);
			});
		}
		if (cancelCurrentDrag) {
			that.blurEvent = function () {
				that.cancelCurrentDrag();
				stageUp();
			};
			document.WW.addEventListener("blur", that.blurEvent);
		}

		function stageUp() {
			zim.Ticker.remove(swipeMovescrollBars);
			swipeCheck = false;
			if (hCheck) if (scrollBarFade && scrollBarActive) zim.animate(hscrollBar, {alpha:0}, scrollBar.fadeTime);
			if (vCheck) if (scrollBarFade && scrollBarActive) zim.animate(vscrollBar, {alpha:0}, scrollBar.fadeTime);
		}
		
		var hoverOutCalled = false;
		var startTime;
		var lastMouseX = 0;
		var lastMouseY = 0;
		var lastReportX = 0;
		var lastReportY = 0;
		var pauseTime = 300;
		var thresh = 2;	
		
		function moveOn() {
			startTime=Date.now();
			zim.Ticker.add(timeMouse, content.stage);			
		}
		function moveOff() {
			if (!hoverOutCalled) {
				that.dispatchEvent("hoverout");
				hoverOutCalled = true;
			}
			zim.Ticker.remove(timeMouse);
		}
		function timeMouse() {
			if (!content.stage) {
				if (!hoverOutCalled) {
					that.dispatchEvent("hoverout");
					hoverOutCalled = true;
				}
				zim.Ticker.remove(timeMouse);
				return;
			}
			if (Math.abs(lastMouseX-that.windowMouseX) > thresh || Math.abs(lastMouseY-that.windowMouseY) > thresh) {
				if (!hoverOutCalled) {
					that.dispatchEvent("hoverout");
					hoverOutCalled = true;
				}
				startTime=Date.now();
				lastMouseX=that.windowMouseX;
				lastMouseY=that.windowMouseY;
			} else {
				if (Date.now()-startTime > pauseTime) {
					if (Math.abs(lastReportX-that.windowMouseX) > thresh || Math.abs(lastReportY-that.windowMouseY) > thresh) {
						that.contentMouse = content.globalToLocal(that.windowMouseX, that.windowMouseY);
						that.dispatchEvent("hoverover");
						lastReportX=that.windowMouseX;
						lastReportY=that.windowMouseY;
						hoverOutCalled = false;
					}
					startTime=Date.now();
				}
			}
		}
		
		if (interactive) {
			// dispatches SELECT (click) and HOVEROVER (500 ms) and gives mouseX and mouseY on content
			// CLICKS (in the traditional sense rather than a mouseup replacement)
			var downLoc;
			var downTime;

			content.on("mousedown", function(e){stage=e.target.stage; downLoc=e.stageX/zim.scaX; downTime=Date.now();});
			content.on("click", function(e){
				if (Date.now()-downTime<600 && Math.abs(e.stageX/zim.scaX-downLoc)<5) {
					that.contentMouse = content.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
					that.dispatchEvent("select");
				}
			});
			// HOVER (must stay within thresh pixels for pauseTime ms)
			content.on("mouseover", moveOn);
			content.on("mouseout", moveOff);			
		}

		var desiredY = that.scrollY;
		var desiredX = that.scrollX;
		that.scrollWindow = function scrollWindow(e) {
			if (that.stage && that.hitTestPoint(that.windowMouseX, that.windowMouseY) && that.contains(that.stage.getObjectUnderPoint(that.windowMouseX*zim.scaX, that.windowMouseY*zim.scaY))) {
				var delta;
				var deltaY;
				var deltaX;
				if (zot(e)) e = event;

				deltaY = (that.stage && that.stage.frame.shiftKey) ? e.deltaX : e.deltaY;
				deltaX = (that.stage && that.stage.frame.shiftKey) ? e.deltaY : e.deltaX;
				
				if (vCheck && deltaY != null) {
					// var delta = e.detail ? e.detail*(-19) : e.wheelDelta;
					delta = deltaY*(-that.scrollBar.speed);
					desiredY += delta;
					desiredY = Math.max(-that.scrollYMax, Math.min(0, desiredY));
					if (!damp) that.scrollY = desiredY;
				}	
				if (hCheck && deltaX != null) {					
					// var delta = e.detail ? e.detail*(-19) : e.wheelDelta;
					delta = deltaX*(-that.scrollBar.speed);
					desiredX += delta;
					desiredX = Math.max(-that.scrollXMax, Math.min(0, desiredX));
					that.scrollX = desiredX;
				}		
				if (hCheck || vCheck) {
					scrollBarDown = false;
					if (!damp) {
						content.stage.update();
					}		
				}		
			}	
			if (optimize) {
				testContent();
			}		
		}
		if (scrollWheel) {		
			WW.addEventListener("mousewheel", that.scrollWindow);
			WW.addEventListener("wheel", that.scrollWindow);
			WW.addEventListener("DOMMouseScroll", that.scrollWindow);
		}
		var dampCheck = false;
		var dampY;		
		function makeDamp(obj) {			
			if (damp && !dampCheck && obj.stage) {
				dampCheck = true;
				dampY = new zim.Damp(that.scrollY, damp);
				that.dampTicker = zim.Ticker.add(function() {	
					if (swipeCheck) return;
					if ( // need to kickstart damping but still stop updating when damping ends
						that.scrollY!=null && desiredY!=null 
						&& that.scrollY != desiredY // let the damping start
						&& Math.round(that.scrollY) == Math.round(desiredY) // stop the damping
					) {
						scrollBarDown = false;
						return;
					}
					// if (!zot(desiredY)) that.scrollY = dampY.convert(desiredY);	
					if (!zot(desiredY)) content.y = dampY.convert(desiredY);	
					if (!scrollBarDown) movescrollBars();
									
				}, obj.stage);
			}
		}

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				if (!value) {
					clearTimeout(that.dTimeout);
					zim.noDrag(content);
				} else {
					setDrag();
				}
				zenable(that, value);
			}
		});

		this._scrollEnabled = true;
		Object.defineProperty(that, 'scrollEnabled', {
			get: function() {
				return that._scrollEnabled;
			},
			set: function(value) {
				if (!value) {
					clearTimeout(that.dTimeout);
					zim.noDrag(content);
					if (scrollBarDrag) {
						if (hEvent) hscrollBar.mouseEnabled = false; // hscrollBar.off("pressmove", vEvent);
						if (vEvent) vscrollBar.mouseEnabled = false; // vscrollBar.off("pressmove", vEvent);

					}
					WW.removeEventListener("mousewheel", that.scrollWindow);
					WW.removeEventListener("wheel", that.scrollWindow);
					WW.removeEventListener("DOMMouseScroll", that.scrollWindow);
				} else {
					setDrag();
					if (scrollBarDrag) {
						if (hEvent)  hscrollBar.mouseEnabled = true; //hEvent = hscrollBar.on("pressmove", vEvent);
						if (vEvent)  vscrollBar.mouseEnabled = true; //vEvent = vscrollBar.on("pressmove", vEvent);
					}
					WW.addEventListener("mousewheel", that.scrollWindow);
					WW.addEventListener("wheel", that.scrollWindow);
					WW.addEventListener("DOMMouseScroll", that.scrollWindow);
				}
				that._scrollEnabled = value;
			}
		});

		Object.defineProperty(that, 'scrollX', {
			get: function() {
				return content.x;
			},
			set: function(value) {
				content.x = value;
				clearTimeout(that.d2Timeout);
				if (content.zimDragImmediate) content.zimDragImmediate(content.x, content.y);
				movescrollBars();
			}
		});

		Object.defineProperty(that, 'scrollY', {
			get: function() {
				return content.y;
			},
			set: function(value) {
				content.y = value;
				content.y = desiredY = value;
				if (damp) dampY.immediate(desiredY);
				clearTimeout(that.d2Timeout);
				if (content.zimDragImmediate) content.zimDragImmediate(content.x, content.y);
				movescrollBars();
			}
		});
		
		Object.defineProperty(that, 'backgroundColor', {
			get: function() {
				return backgroundColor;
			},
			set: function(value) {
				backgroundColor = value;
				sizeWindow();
			}
		});

		Object.defineProperty(that, 'borderColor', {
			get: function() {
				return borderColor;
			},
			set: function(value) {
				borderColor = value;
				sizeWindow();
			}
		});

		Object.defineProperty(that, 'borderWidth', {
			get: function() {
				return borderWidth;
			},
			set: function(value) {
				borderWidth = value;
				sizeWindow();
			}
		});
		
		Object.defineProperty(that, 'fullSized', {
			get: function() {
				return fullCheck;
			},
			set: function(value) {
				if (that.fullSize) that.fullSize(value);
			}
		});
		
		Object.defineProperty(that, 'collapsed', {
			get: function() {
				return collapseCheck;
			},
			set: function(value) {
				if (that.collapse) that.collapse(value);
			}
		});
		
		if (collapsed) {
			collapseCheck = false;
			that.collapsed = true;			
		}
		if (that.titleBar) {
				that.collapseEvent = that.titleBar.on("dblclick", function () {
				that.collapsed = !that.collapsed;
			});
		}

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function(recursive) {
			if (zot(recursive)) recursive = true;
			var w = that.cloneProps(new zim.Window(width, height, null, backgroundColor, originalBorderColor, originalBorderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBar.color, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, slide, slideFactor, slideSnap, slideSnapDamp, interactive, shadowColor, shadowBlur, paddingH, paddingV, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, cancelCurrentDrag, fullSize, fullSizeColor, resizeHandle, collapse, collapseColor, collapsed, optimize, resizeBoundary, resizeVisible, continuous, style, group, inherit));
			if (recursive) {
				that.contentContainer.cloneChildren(w.contentContainer);
				w.update();
			}
			return w;
		};
		
		this.doDispose = function(a,b,disposing) {
			if (scrollWheel) {
				WW.removeEventListener("mousewheel", that.scrollWindow);
				WW.removeEventListener("wheel", that.scrollWindow);
				WW.removeEventListener("DOMMouseScroll", that.scrollWindow);
			}
			if (content) {				
				if (that.zDE) content.off(that.zDE);									
				if (that.zME) content.off(that.zME);										
				if (that.zSTA) content.off(that.zSTA);										
				if (that.zSTO) content.off(that.zSTO);					
				if (that.zTI) zim.Ticker.remove(that.zTI);									
			}				
			if (that.titleBar) that.titleBar.removeAllEventListeners();
			if (stageEvent && stage) stage.off("stagemousemove", stageEvent);
			if (that.resizeHandle) that.resizeHandle.removeAllEventListeners();
			if (that.blurEvent) WW.removeEventListener("blur", that.blurEvent);
			if (typeof timeMouse != "undefined") zim.Ticker.remove(timeMouse);			
			if (!zot(swipeMovescrollBars)) zim.Ticker.remove(swipeMovescrollBars);
			if (!disposing) this.zimContainer_dispose(true);
			content = that.contentContainer = null;
			return true;
		};
	};
	zim.extend(zim.Window, zim.Container, ["clone", "dispose"], "zimContainer", false);
	zim.Window.prototype.dispose = function(disposing) {return this.doDispose(null,null,disposing);};
	zim.Window.prototype.resize = function(width, height) {return this.doResize(width, height);};
	zimWindow = zim.Window; // used in export so we do not obscure the JS Window
	//-58.1

/*--
zim.Page = function(width, height, color, color2, angle, corner, pattern, scalePattern, cache, style, group, inherit)

Page
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
ZIM Page() is a Container() with Rectangle() backing.
For years, many questions were asked - how to make a page in ZIM.
Now, we have decided to officially answer that!  ZIM Page().
An easy way to handle linear gradients is provided as well as a custom background
such as a ZIM Pizzazz pattern.

To keep things brief, Page is expected to fit the stage.
So border, corner, dashed, etc. has been left out.
If the page is smaller and these are desired...
old-school-it and make a Container and add the desired Rectangle.

SEE: https://zimjs.com/cat/page.html
SEE: Docs for ZIM Pages() as well to handle multiple pages.
SEE: ZIM Panel(), ZIM Pane() and ZIM Window() for alternatives.

NOTE A Page object will start with one child or two children if a pattern is specified.
NOTE Do not use Page with Layout as it will overlay the region backgroundColors - instead use a Container 
NOTE as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const page = new Page(W, H, red, pink).addTo();
page.title = new Label("A Page!").loc(100,100,page);
page.content = new Circle().center(page);
page.nav = new Tabs().pos(0,100,CENTER,BOTTOM,page);
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default zimDefaultFrame.width) the width of the Page
	but backing is sized to screen.width if no width is provided
height - (default zimDefaultFrame.height) the height of the Page
	but backing is sized to screen.height if no height is provided
color - |ZIM VEE| (default zim.light) the color of the page
color2 - |ZIM VEE| (default null) a second color which would form a zim.GradientColor() as the color
angle - (default 90) the angle for the gradient if there is a gradient
pattern - (default null) a DisplayObject that will be added to the page above the backing
	For instance, import zim_pizzazz and use:
	makePattern("slants", series(grey,dark), 20, 52, 40).alp(.2)
scalePattern - (default "fill") scale the pattern so it fills the window (formerly "bigger" or "outside")
	set to false for no scaling or:
	FIT or "fit" fits inside the Page keeping proportion (formerly "smallest")
   	FILL or "fill" fills the Page keeping proportion (formerly "biggest" or "outside")
   	FULL or "full" keeps both x and y scales - may stretch object (formerly "both")
cache - (default false or true for gradient or pattern) whether the backing and pattern is cached
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone(recursive) - makes a copy with properties such as x, y, etc. also copied
   recursive (default false) - set to true to copy children of the object (these will not get custom properties, no drag, events, etc.)
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
backing - access the backing Rectangle
pattern - access the pattern object if one is provided
color - get or set the color of the backing Rectangle

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+58.3
	zim.Page = function(width, height, color, color2, angle, pattern, scalePattern, cache, style, group, inherit) {
		var sig = "width, height, color, color2, angle, pattern, scalePattern, cache, style, group, inherit";
		var duo; if (duo = zob(zim.Page, arguments, sig, this)) return duo;
		z_d("58.3");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Page", this.group, inherit);

		if (zot(width)) width=DS.width!=null?DS.width:WW.zdf.width;
		if (zot(height)) height=DS.height!=null?DS.height:WW.zdf.height;

		this.zimContainer_constructor(0,0,width,height,false);
		this.type = "Page";

		// if (zot(width)) width = screen?screen.width:zdf.width;
		// if (zot(height)) height = screen?screen.height:zdf.height;		
		var that = this;
				
		if (zot(angle)) angle=DS.angle!=null?DS.angle:90;
		if (zot(color)) color=DS.color!=null?DS.color:zim.light;
		if (zot(color2)) color2=DS.color2!=null?DS.color2:null;
		if (zot(pattern)) pattern=DS.pattern!=null?DS.pattern:null;
		if (zot(scalePattern)) scalePattern=DS.scalePattern!=null?DS.scalePattern:"fill";		
		if (zot(cache)) cache=DS.cache!=null?DS.cache:false;

		color = zik(color);
		color2 = zik(color2);

        if (!zot(color2)) {
			color = new zim.GradientColor([color, color2], [0,1], angle);
			color2 = null;
		}
        var backing = this.backing = new zim.Rectangle({width:width, height:height, color:color, scaleDimensions:false, style:false}).addTo(this);
        if (zot(cache) && (!zot(color2) || !zot(pattern))) cache = true;
        if (cache) backing.cache();
        if (!zot(pattern)) {
            this.pattern = pattern.addTo(this);
            if (scalePattern) pattern.scaleTo(this, 100, 100, scalePattern).center(this);
            if (cache) pattern.cache();
        }

		Object.defineProperty(that, 'color', {
			get: function() {
				return color;
			},
			set: function(value) {
				if (zot(value)) value = zim.black;
				color = zik(value);
				that.backing.color = color;
			}
		});

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function(recursive) {
			if (zot(recursive)) recursive = false;
			if (color.type) color2 = null;
			var w = that.cloneProps(new zim.Page(width, height, color, color2, angle, pattern, scalePattern, cache, style, group, inherit));
			if (recursive) {
				that.cloneChildren(w);
			}
			return w;
		};
	};
	zim.extend(zim.Page, zim.Container, ["clone"], "zimContainer", false);
	//-58.3

/*--
zim.Central = function(width, height, style, group, inherit)

Central
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
ZIM Central() is a Container() with its origin and registration point in the center.
It will resize to the stage so that it stays in the middle. 
The container will scale only to fit within the stage height.
This is the same functionality as the classic three.js full window scaling.
Note, that the origin is in the middle of the stage - also like three.js
but the y values still are negative going up and positive going down like usual ZIM.

Objects would then be added to Central rather than the stage
to emulate this form of scaling.

This may work well with three.js on top of beneath ZIM using the Three helper module 
There is a lay parameter that can be set to UNDER or OVER.
The interactive parameter can be set to true to control three.js or false to control ZIM.
Set the Frame scaling to FULL and add ZIM content to a Central to match the scaling of three.js.
See https://zimjs.com/three/central.html

NOTE as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// most likely in a FULL Frame scaling mode
const central = new zim.Central()
	.addTo(); // or center() or centerReg() - will always just centerReg()
const circle = new Circle(100)
	.center(central).alp(.5);
new Slider({max:1, currentValue:.5})
	.pos(0,200,CENTER,CENTER,central)
	.wire(circle, "alpha");
END EXAMPLE

PARAMETERS
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 1024) the width of the container - just use to adjust overall scale
height - (default 768) the height of the container - just use to adjust overall scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+58.4
zim.Central = function(width, height, style, group, inherit) {
	z_d("58.4");
	this.group = group;
	var DS = style===false?{}:zim.getStyle("Central", this.group, inherit);

	if (zot(width)) width=DS.width!=null?DS.width:1024;
	if (zot(height)) height=DS.height!=null?DS.height:768;
	this.zimContainer_constructor(-width/2, -height/2, width, height);
	var that = this;  
	
	var frame = zimDefaultFrame;
	that.resizeEvent = frame.on("resize", function() {
		that.scale = frame.height/height;
		if (that.parent) that.centerReg(that.parent);
	});       
	that.added(function(){
		if (that.parent) that.centerReg(that.parent);
	});
	that.dispose = function(a,b,recursive) {
		frame.off("resize", that.resizeEvent);
		return that.zimContainer_dispose(a,b,recursive);
	}
	if (style!==false) zim.styleTransforms(this, DS);
}
zim.extend(zim.Central, zim.Container, ["dispose"], "zimContainer", false);
//-58.4

/*--
zim.Layer = function(width, height, titleBar, titleBarContainer, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, borderWidth, borderColor, dashed, transformObject, titleBarWidth, titleBarHeight, titleBarX, titleBarY, titleBarDraggable, close, closeColor, closeBackgroundColor, closeIndicatorColor, anchor, onTop, style, group, inherit)

Layer
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Layer is a ZIM Container with transform controls.
ZIM transform() objects have their mousechildren turned off so they can be dragged and transformed.
This means there can be no interactivity inside the transformed object.
Layer provides a solution to nest transformed objects in transformable containers.
It does so by providing a titleBar that can be used to turn on and off the transform of the container
and allow its contents to be transformed when the transform controls of the Layer are turned off.
This is more than just hiding the transform tools but rather removing and adding them.

The Layer titleBar will always remain visible on the stage
If the Layer is moved (not by its titleBar) so that the titleBar hits the edge,
then the titleBar will become anchored to the edge (unless anchor is set to false)
This creates an independent titleBar that can be moved to any location.
The titleBarPos() method can also be used to separate the titleBar at any time.
Drop the titleBar on the top left corner of the Layer or doubleClick it to snap it back on to the layer

NOTE: Layers can be added to a Transform Manager and saved with the persist sytem.
NOTE: Layers can be added to Layers (nested) along with any other type of DisplayObject content.
NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

SEE: https://zimjs.com/explore/layer.html

EXAMPLE
// adding the Layers above the content will allow pressing Layer titleBar objects inside other Layers
// adding everything right on the stage would not allow pressing titleBars inside other Layers - either way may be best, depending on content
const content = new Container(W, H).addTo();
const layers = new Container(W, H).addTo();

// create an outer layer with two inner layers - one holding a circle and the other two circles
const layer0 = new Layer(800, 500, "LAYER 0", layers).center(content);
const layer1 = new Layer(300, 400, "LAYER 1", layers).loc(50,50,layer0);
const circle1 = new Circle(50, pink).center(layer1).transform({visible:false});
const layer2 = new Layer(300, 400, "LAYER 2", layers).pos(50,50,true,false,layer0);
const circle2 = new Circle(50, green).center(layer2).mov(0, -80).transform({visible:false});
const circle3 = new Circle(50, blue).center(layer2).mov(0, 80).transform({visible:false});

// optionally store transforms
const t = new TransformManager([layer0, layer1, layer2, circle1, circle2, circle3], "layersID");
// t.clearPersist("layersID")

timeout(1, ()=>{
	layer2.resetTitleBar();
	layer2.turnOn();

	// if moving manually, must call resize()
	layer2.mov(30);
	layer2.resize();
	S.update();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 500) the width of the Layer Container
height - (default 500) the height of the Layer Container not including the titleBar (which is not in the Container)
titleBar - (default "LAYER") a String or ZIM Label for the titleBar
titleBarContainer - (default null - zdf' stage) a container for the titleBar
	can group these with other Layers and hide them all by hiding the container for instance
	this also can help layer the titleBars above the content
backgroundColor - (default lighter) the background color of the titleBar
rollBackgroundColor - (default white) the roll background color of the titleBar
selectedBackgroundColor - (default granite) the selected background color of the titleBar
color - (default granite) the color of the titleBar text
rollColor - (default granite) the roll color of the titleBar text
selectedColor - (default moon) the selected color of the titleBar text
borderWidth - (default 1) the width of the ghost outline when the Layer is not selected
	to adjust the transform controls border width use the transformObject parameter and set the borderWidth property
borderColor - (default borderColor) the color of the ghost outline when the Layer is not selected
	to adjust the transform controls border color use the transformObject parameter and set the borderColor property
dashed - (default true) the dashed of the ghost outline when the Layer is not selected
	to adjust the transform controls border dashed use the transformObject parameter and set the dashed property
transformObject - (default {borderColor:selectedBackgroundColor}) any of the transform parameters as an object literal
	certain properties are overwritten by Layer as follows:
	{events:true, visible:false, ghostColor:borderColor, ghostWidth:borderWidth, ghostDashed:dashed, ghostHidden:true}
	use the transformControls.show() to show the transform controls once the Layer is made for instance:
	timeout(.1, function(){layer.transformControls.show();}); // a timeout is needed as Layer gets created - sorry.
titleBarWidth - (default 100 + 30 if close) the width of the titleBar.  30 pixels will be added if close is true
titleBarHeight - (default 40) the height of the titleBar
titleBarX - (default null) the starting x position of the titleBar - see also titleBarPos() and resetTitleBar() methods
titleBarY - (default null) the starting y position of the titleBar - see also titleBarPos() and resetTitleBar() methods
titleBarDraggable - (default true) set to false to not let the titleBar be dragged.
	this is useful with the titleBarPos() to create a stationary menu for the layers - for instance along the edge like tabs
close - (default true) - set to false to not use the close checkbox
	WARNING: without the close checkbox, the user may make the layer bigger than the stage and not be able to deselect the layer
closeColor - (default selectedBackgroundColor) the border of the close checkBox
closeBackgroundColor - (default selectedBackgroundColor) the backgroundColor of the close checkBox
closeIndicatorColor - (default selectedColor) the indicator color of the close checkBox
anchor - (default true) set to false to not anchor the titleBar to the edge if dragged with the Layer (not the titleBar)
	with anchor true, the user can dock the titleBar to the edges and then drag them to any desired location
	the user can snap the titleBar back on the layer by dropping it on the top left corner of the layer or double clicking the titleBar
onTop - (default true) set to false to not bring the layer on top when selected
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
titleBarPos(x, y, right, bottom) - position the titleBar in the titleBarContainer - returns object for chaining
	This will undock the titleBar from the Layer so it can be moved independently
	unless titleBarDraggable is set to false
	See also titleBarX and titleBarY parameters to start titleBars at a certain position
resetTitleBar() - dock the titleBar back on the Layer - returns object for chaining
toggle(state) - toggle the controls or turn on or off the controls by providing a Boolean state - returns object for chaining
resize(dispatch) - resize the Layer and its children if Layer is manually adjusted - returns object for chaining
	for instance, layer.x = 10; layer.resize(); otherwise, the transform controls are broken!
	normal layer transforming using the controls automatically resize.
	Setting dispatch to true will dispatch a "transformed" event
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied (returns the new waiter for chaining)
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
transformControls - the transform transformControls object - see below for a description
anchor - get or set whether the titleBar will anchor to the edges of the titleBarContainer
toggled - read only if Layer has its transform turned on - or use transformControls.visible
	use toggle(state) to toggle controls or pass in true for show controls or false for hide controls
titleBar - access to the ZIM Container that holds the titleBar
titleBarDraggable - get or set whether the titleBar can be dragged
	use with titleBarPos() to permanently positing the titleBar
checkBox - access to the ZIM CheckBox that shows when the Layer is active and close is true
button - access to the ZIM Button that makes up the titleBar
label - access to the ZIM Label that is on the Button for the titleBar

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the transformControls property described below for more options.
ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

TRANSFORM CONTROLS OBJECT
Layer receives a transformControls property
This may be slightly delayed as Layer is prepared on stage
var layer = new Layer().center();
timeout(100, function(){zog(layer.transformControls);}); // will probably do the trick
The transformControls property holds the following:

TRANSFORM CONTROL OBJECT PROPERTIES
visible - read only whether the controls are visible
ghost - read only as to whether the ghost outline is showing - set with showGhost and hideGhost
ghostEnabled - read only as to whether the ghost outline will be turned on and off - set with addGhost and removeGhost
scaleControls - reference to the Container that holds the corner boxes for scaling
stretchXControls - reference to the Container that holds the left and right boxes for stretching
stretchYControls - reference to the Container that holds the top and bottom boxes for stretching
rotateControls - reference to the Container that holds the outer circles for rotating

TRANSFORM CONTROL OBJECT METHODS
hide() - hides the controls - returns object for chaining
show() - shows the controls - returns object for chaining
recordData(toJSON) - returns an object with type, x, y, scaleX, scaleY, rotation, skewX, skewY, visible PROPERTIES
	if toJSON (default false) is set to true, the return value is a JSON string
setData(data, fromJSON) - sets the properties to match the data object passed in - this should come from recordData()
	if fromJSON (default false) is set to true, it will assume a JSON string is passed in as data
	returns object for chaining
remove(noHide) - removes the controls - set noHide true if already hidden
add(noShow) - adds the controls back if then have been removed - set noShow true if not wanting to show
allowToggleOn() - sets the show / hide controls on with click
allowToggleOff() - removes the show / hide controls on with click
showGhost() - show the ghost outline - the ghostWidth or ghostColor must be set in initial parameters
hideGhost() - hide the ghost outline
toggleGhost(state) - if ghost is showing will hide ghost and if ghost is hidden will show ghost
	or set state to true to show ghost or false to not show ghost
addGhost() - enable ghost outline functionality - the ghostWidth or ghostColor must be set in initial parameters
removeGhost() - disable ghost outline functionality
disable() - may show the controls if visible but cannot use them
enable() - turns the using of the controls back on
resize(dispatch) - call resize if the object is transformed in ways other than with the controls
	set dispatch to true to dispatch a "transformed" event - if manually adjusted this will save to TransformManager

EVENTS
dispatches a "transformed" event when being transformed
	the transformed event object has a transformType property
	the transformType property has values of "size", "move", "rotate", "stretch", "reg", "reset"
	the transformType also might be "resize" if resize(true) is called to dispatch a transformed event
	the transformed event object also has a pressup property that is true if on pressup and null if from pressmove
dispatches "transformshow" and "transformhide" events for when click to hide or show controls
If TransformManager() is used there are more events available such as "persistset", etc.

See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+58.5
	zim.Layer = function(width, height, titleBar, titleBarContainer, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, borderWidth, borderColor, dashed, transformObject, titleBarWidth, titleBarHeight, titleBarX, titleBarY, titleBarDraggable, close, closeColor, closeBackgroundColor, closeIndicatorColor, anchor, onTop, style, group, inherit) {
		var sig = "width, height, titleBar, titleBarContainer, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, borderWidth, borderColor, dashed, transformObject, titleBarWidth, titleBarHeight, titleBarX, titleBarY, titleBarDraggable, close, closeColor, closeBackgroundColor, closeIndicatorColor, anchor, onTop, style, group, inherit";
		var duo; if (duo = zob(zim.Layer, arguments, sig, this)) return duo;
		z_d("58.5");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Layer", this.group, inherit);

		if (zot(width)) width=DS.width!=null?DS.width:500;
		if (zot(height)) height=DS.height!=null?DS.height:500;

		this.zimContainer_constructor(0,0,width,height,false);
		this.type = "Layer";

		var that = this;
		that.distX = 40; // titleBar distance from top left corner of Container
		that.distY = 0;
		if (zot(titleBar)) titleBar=DS.titleBar!=null?DS.titleBar:"LAYER";
		var titleBarOriginal = titleBar;
		var titleBarText = titleBar;
		var titleBarDefault = true;

		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.lighter;
		if (zot(rollBackgroundColor)) rollBackgroundColor=DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.white;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor=DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.granite;
		if (zot(color)) color=DS.color!=null?DS.color:zim.granite;
		if (zot(rollColor)) rollColor=DS.rollColor!=null?DS.rollColor:zim.granite;
		if (zot(selectedColor)) selectedColor=DS.selectedColor!=null?DS.selectedColor:zim.moon;
		if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:1;
		if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:backgroundColor;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		if (zot(dashed)) dashed=DS.dashed!=null?DS.dashed:true;
		if (zot(transformObject)) transformObject=DS.titleBar!=null?DS.titleBar:null;
		if (zot(titleBarWidth)) titleBarWidth=DS.titleBarWidth!=null?DS.titleBarWidth:100;
		var originalTitleBarWidth = titleBarWidth;
		if (zot(titleBarHeight)) titleBarHeight=DS.titleBarHeight!=null?DS.titleBarHeight:40;
		if (zot(titleBarX)) titleBarX=DS.titleBarX!=null?DS.titleBarX:null;
		if (zot(titleBarY)) titleBarY=DS.titleBarY!=null?DS.titleBarY:null;
		if (zot(titleBarDraggable)) titleBarDraggable=DS.titleBarDraggable!=null?DS.titleBarDraggable:true;
		if (zot(close)) close=DS.close!=null?DS.close:true;
		if (zot(closeColor)) closeColor=DS.closeColor!=null?DS.closeColor:selectedBackgroundColor;
		if (zot(closeBackgroundColor)) closeBackgroundColor=DS.closeBackgroundColor!=null?DS.closeBackgroundColor:selectedBackgroundColor;
		if (zot(closeIndicatorColor)) closeIndicatorColor=DS.closeIndicatorColor!=null?DS.closeIndicatorColor:selectedColor;
		if (zot(anchor)) anchor=DS.anchor!=null?DS.anchor:true;
		if (zot(onTop)) onTop=DS.onTop!=null?DS.onTop:true;
		if (!titleBarDraggable) anchor = false;
		that.anchor = anchor;
		if (close) titleBarWidth += 30;

		transformObject = zim.merge({borderColor:selectedBackgroundColor}, transformObject, {onTop:onTop, events:true, visible:false, ghostColor:borderColor, ghostWidth:borderWidth, ghostDashed:dashed, ghostHidden:true});

		// do the defaultFrame thing for the container
		if (zot(titleBarContainer)) titleBarContainer=DS.titleBarContainer!=null?DS.titleBarContainer:null;
		if (zot(titleBarContainer)) {
			if (WW.zdf) {
				titleBarContainer = WW.zdf.stage;
			} else {
				zogy("zim Layer(): Please pass in a reference to a container with bounds set.");
				return;
			}
		}

		that.active = false;
		that.turnOff = function() {
			that.active = false;
			if (close) that.checkBox.visible = false;
			that.transformControls.remove();
			that.mouseChildren = true;
			that.button.backgroundColor = backgroundColor;
			that.button.rollBackgroundColor = rollBackgroundColor;
			that.button.color = color;
			that.button.rollColor = color;
			that.transformControls.allowToggleOff();
			if (that.resizeChildren) that.resizeChildren();			
		};
		that.turnOn = function() {
			that.active = true;
			if (close) {
				that.checkBox.visible = true;
				that.checkBox.checked = true;
			}
			that.button.backgroundColor = selectedBackgroundColor;
			that.button.rollBackgroundColor = selectedBackgroundColor;
			that.button.color = selectedColor;
			that.button.rollColor = selectedColor;
			that.mouseChildren = false;
			that.transformControls.add();
			that.transformControls.allowToggleOn();						
		};
		var stage;
		that.titleBarPos = function(x, y) {
			if (!that.titleBar) return;
			if (that.titleBar.pos) {
				that.titleBar.pos(arguments[0], arguments[1], arguments[2], arguments[3], arguments[4], arguments[5], arguments[6], arguments[7], arguments[8], arguments[9]); // ES6 wish
				stage.update();
			} else {
				that.distX = x;
				that.distY = y;
			}
			titleBarDefault = false;
			return that;
		};
		var lastVisible = that.visible;
		that.visible = false;
		var timeType = getTIME();
		this.added(function (theStage) {
			stage = theStage;
			that.transform(transformObject); // in case persist is set do this first and wait a little bit with visible false
			if (borderWidth >= 0) that.transformControls.hideGhost();
			setTimeout(function () {
				function firstPoint() {return that.localToLocal(0,0,titleBarContainer);}
				that.visible = lastVisible;
				if (borderWidth >= 0) {
					setTimeout(function(){
						that.transformControls.showGhost();
						if (that.stage) that.stage.update();
					}, 200);
				}
				stage = theStage;
				var titleBar = that.titleBar = new zim.Container(titleBarWidth, titleBarHeight)
					.reg(0,titleBarHeight)
					.loc(that, null, titleBarContainer)
					.mov(that.distX,that.distY);

				if (titleBarDraggable) titleBar.drag({all:true, boundary:new zim.Boundary(0,titleBarHeight,titleBarContainer.width-titleBarWidth,titleBarContainer.height-titleBarHeight), localBoundary:true});
				if (that.distX != 40 || that.distY !=0) {
					titleBar.pos(that.distX, that.distY);
				}
				if (close) {
					that.checkBox = new zim.CheckBox({
						borderColor:closeColor,
						backgroundColor:closeBackgroundColor,
						indicatorColor:closeIndicatorColor,
						size:20, startChecked:true
					}).center(titleBar).pos(0, null, true).change(function () {
						that.turnOff();
						that.dispatchEvent("transformhide");
					});
					that.checkBox.visible = false;
				}
				titleBar.mouseChildren = true;
				titleBar.layer = that;

				that.resetTitleBar = function() {
					that.distX = 40;
					that.distY = 0;
					titleBarDefault = true;
					that.move(true);
					if (that.stage) that.stage.update();
				};				

				if (typeof titleBarText === "string" || typeof titleBarText === "number") titleBarText = new zim.Label({
					text:titleBarText, color:color, rollColor:rollColor, size:DS.size!=null?DS.size:18,
					group:this.group
				});
				that.label = titleBarText;
				that.label.center(titleBar);
				that.button = new zim.Button({
					shadowBlur:-1,
					width:originalTitleBarWidth, height:titleBarHeight-1, label:that.label,
					color:color,
					rollColor:rollColor,
					backgroundColor:backgroundColor,
					rollBackgroundColor:rollBackgroundColor,
					corner:(DS.corner!=null?DS.corner:0),
					inherit:zim.copy(DS)
				}).addTo(titleBar);
				that.button.on("mousedown", function () {
					// all other layers get turned off
					titleBarContainer.loop(function (bar) {
						if (bar && bar != titleBar && bar.layer && bar.layer.turnOff && bar.layer.active) bar.layer.turnOff();
					});
					if (!that.active) {
						that.turnOn();
						that.dispatchEvent("transformshow");
					}
					titleBar.top();					
				});
				that.button.on("pressmove", function(){matchLocation();});
				that.button.on("pressup", function () {
					matchLocation(true);
					var point = that.localToLocal(0, 0, titleBarContainer);
					that.distX = titleBar.x-point.x;
					that.distY = titleBar.y-point.y;
					titleBar.top();
					if (!edgeCheck() && titleBarDraggable) {
						point = that.localToGlobal(0,0);
						if (that.button.hitTestPoint(point.x, point.y)) that.resetTitleBar();
					}
				});
				function matchLocation(dispatch) {
					if (titleBarDefault && titleBarDraggable) {
						var desiredTopLeft = titleBarContainer.localToLocal(titleBar.x-that.distX, titleBar.y-that.distY, that.parent);
						var regPoint = that.localToLocal(that.regX, that.regY, that.parent);
						var topLeft = that.localToLocal(0,0,that.parent);
						that.x =  desiredTopLeft.x + (regPoint.x-topLeft.x);
						that.y =  desiredTopLeft.y + (regPoint.y-topLeft.y);
						that.transformControls.resize(dispatch); // TransformManager saves all objects any time a single object changes
						recursiveLocation(that);
						if (that.stage) that.stage.update();
					}
				}
				function recursiveLocation(obj) {
					obj.loop(function (o) {
						if (o.type == "Layer") {
							if (that.titleBarDraggable) o.move();
							if (o.transformControls.ghost) o.transformControls.resize(); // to move ghost
							recursiveLocation(o);
						}
					});
				}
				that.button.on("dblclick", function () {
					if (titleBarDraggable) that.resetTitleBar();
				});

				that.turnOff();
				that.on("transformed", function (e) {
					if (e.transformType=="move" || e.transformType=="size" || e.transformType=="stretch" || e.transformType=="rotate") {
						if (titleBarDraggable) that.move();
						recursiveLocation(that);
					}
				});
				function edgeCheck() {
					if (titleBar.x == 0) return true;
					if (titleBar.y == titleBar.height) return true;
					if (titleBar.x == titleBarContainer.width-titleBar.width) return true;
					if (titleBar.y == titleBarContainer.height) return true;
				}
				that.move = function(override) {
					if (!override && !titleBarDefault && that.anchor) {
						if (edgeCheck()) return;
					}
					titleBar.loc(firstPoint()).mov(that.distX, that.distY);
					if (titleBar.x < 0) {titleBarDefault=false; titleBar.x = 0;}
					if (titleBar.y < titleBar.height) {titleBarDefault=false; titleBar.y = titleBar.height;}
					if (titleBar.x > titleBarContainer.width-titleBar.width) {titleBarDefault=false; titleBar.x = titleBarContainer.width-titleBar.width;}
					if (titleBar.y > titleBarContainer.height) {titleBarDefault=false; titleBar.y =titleBarContainer.height;}
					if (!that.anchor) titleBarDefault = true;
				};
				that.on("transformhide", function() {
					that.turnOff();
					titleBarContainer.loop(function (bar) {
						if (bar && bar != titleBar && bar.layer && bar.layer.turnOff && bar.layer.active) bar.layer.turnOff();
					});
				});
				that.resizeChildren = function(dispatch) {
					that.transformControls.resize(dispatch);
					// if (that.transformControls.visible) that.transformControls.hide();
					that.loop(function (obj) {
						if (obj.transformControls) {
							if (obj.transformControls.visible) obj.transformControls.hide();
							if (obj.type == "Layer" && obj.resizeChildren) {
								obj.resizeChildren();
							} else {
								if (obj.transformControls) obj.transformControls.resize();
							}
						}
					});
				};				
				that.resize = function(dispatch) {
                    that.move();
                    that.resizeChildren(dispatch);
					return that;
                };
				that.toggled = false;
				function setToggled() {
					if (that.toggled) {
						titleBarContainer.loop(function (bar) {
							if (bar && bar != titleBar && bar.layer && bar.layer.turnOff && bar.layer.active) bar.layer.turnOff();
						});
						that.turnOn();
						that.dispatchEvent("transformshow");
					} else {
						titleBar.top();
						that.turnOff();
						titleBarContainer.loop(function (bar) {
							if (bar && bar != titleBar && bar.layer && bar.layer.turnOff && bar.layer.active) bar.layer.turnOff();
						});
						that.dispatchEvent("transformhide");
					}
					if (that.stage) that.stage.update();
				}
				that.toggle = function(state) {
					if (zot(state)) {
						that.toggled = !that.toggled;
					} else {
						that.toggled = state;
					}					
					setToggled();
					return that;
				};
				Object.defineProperty(that, 'titleBarDraggable', {
					get: function() {
						return titleBarDraggable;
					},
					set: function (value) {
						titleBarDraggable = value;
						if (titleBarDraggable) titleBar.drag({ all: true, boundary: zim.Boundary(0, 40, titleBarContainer.width - titleBarWidth, titleBarContainer.height - titleBarHeight), localBoundary: true });
						else titleBar.noDrag(false);
					}
				});
				that.stageUpEvent = stage.on("stagemouseup", function () {
					if (that.transformControls.visible) titleBar.top();
				});
				if (!zot(titleBarX) || !zot(titleBarY)) {
					titleBarDefault = false;
					var x = !zot(titleBarX)?titleBarX:titleBar.x;
					var y = !zot(titleBarY)?titleBarY:titleBar.y-titleBarHeight;
					that.titleBarStartX = titleBarX;
					that.titleBarStartY = titleBarY;
					that.titleBarPos(x,y);
					var point = that.parent.localToLocal(that.x, that.y, titleBarContainer);
					that.distX = titleBar.x-point.x;
					that.distY = titleBar.y-point.y;
				}
			}, 50); // end timeout
		}, timeType=="s"?.05:50); // end added

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Layer(width, height, titleBarOriginal, titleBarContainer, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, borderWidth, borderColor, dashed, transformObject, originalTitleBarWidth, titleBarHeight, titleBarX, titleBarY, titleBarDraggable, close, closeColor, closeBackgroundColor, closeIndicatorColor, anchor, onTop, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			if (that.stageUpEvent) stage.off("stagemouseup", that.stageUpEvent);
			if (titleBarContainer) {
				titleBarContainer.loop(function (bar) {
					bar.layer = null;
				});
			}			
			if (that.transformControls) that.transformControls.dispose();
			that.transformControls = null;
			if (!disposing) this.zimContainer_dispose(true);
			if (that.titleBar) {
				that.titleBar.layer = null;
				that.titleBar.dispose();
			}			
			that.checkBox = that.button = null;
			titleBar = that.titleBar = transformObject = null;
			return true;
		};
	};
	zim.extend(zim.Layer, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-58.5

/*--
zim.Waiter = function(container, speed, foregroundColor, backgroundColor, corner, shadowColor, shadowBlur, fadeTime, style, group, inherit)

Waiter
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Adds a little animated three dot wait widget.
You need to call waiter.show() to show the waiter and waiter.hide() to hide it.
You do not need to add it to the stage - it adds itself centered.
You can change the x and y (with origin and registration point in middle).

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const waiter = new Waiter().show(); // show the waiter until assets load
F.loadAssets("cave02.jpg", "https://zimjs.org/assets/");
F.on("complete", ()=>{
   waiter.hide();
   new Pic("cave02.jpg").center();
   S.update();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
container - (default first frame's stage) the container that holds the waiter
speed - (default .6) cycle time in seconds (also see ZIM TIME constant)
foregroundColor - (default white) the dot color
backgroundColor - (default "orange") the background color
corner - (default 14) the corner radius of the waiter box
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (defaults rgba(0,0,0,.3)) set to -1 for no shadow
shadowBlur - (default 14) the blur of the shadow if shadow is set
fadeTime - (default 0) milliseconds to fade in and out
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show() - shows the waiter (returns the waiter for chaining)
hide() - hides the waiter
toggle(state - default null) - shows waiter if hidden and hides waiter if showing (returns the object for chaining)
	or pass in true to show waiter or false to hide waiter
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied (returns the new waiter for chaining)
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
display - reference to the waiter backing graphic

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+59
	zim.Waiter = function(container, speed, foregroundColor, backgroundColor, corner, shadowColor, shadowBlur, fadeTime, style, group, inherit) {
		var sig = "container, speed, foregroundColor, backgroundColor, corner, shadowColor, shadowBlur, fadeTime, style, group, inherit";
		var duo; if (duo = zob(zim.Waiter, arguments, sig, this)) return duo;
		z_d("59");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Waiter";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		var timeType = getTIME(speed);

		if (zot(speed)) speed=DS.speed!=null?DS.speed:timeType=="s"?.6:600; // ms cycle time
		if (zot(foregroundColor)) foregroundColor=DS.foregroundColor!=null?DS.foregroundColor:zim.white;
		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:"orange";
		if (zot(corner)) corner=DS.corner!=null?DS.corner:16;
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(fadeTime)) fadeTime=DS.fadeTime!=null?DS.fadeTime:0;

		var height = 40;
		var numDots = 3;
		var r = height*.6/2;
		var s = (height-r*2)/2;
		var width = numDots*(r*2+s)+s;

		this.setBounds(-width/2,-height/2, width, height);

		var that = this;
		var stage;

		var display = this.display = new zim.Shape({style:false});
		this.addChild(display);
		display.setBounds(0, 0, width, height);
		display.regX = width/2;
		display.regY = height/2;
		var g = display.graphics;
		g.f(backgroundColor);
		var cc = corner;
		if (!Array.isArray(cc)) cc = [corner, corner, corner, corner];
		g.rc(0, 0, width, height, cc[0], cc[1], cc[2], cc[3]);
		if (shadowColor != -1 && shadowBlur > 0) display.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
		display.on("click", function(e) {
			// stops the click from going through the display to the background
			e.stopImmediatePropagation();
		});

		var circles = new zim.Container({style:false});
		this.addChild(circles);

		var dot;
		for (var i=0; i<numDots; i++) {
			dot = new createjs.Shape();
			dot.graphics.f(foregroundColor).dc(0,0,r);
			dot.x = (i-(numDots-1)/2) * (r*2+s);
			circles.addChild(dot);
			dot.cache(-r,-r,r*2,r*2);
			dot.alpha = 0;
		}

		this.hide = function() {
			if (fadeTime > 0) {
				that.animate({obj:{alpha:0}, time:fadeTime, call:end});
			} else {
				end();
			}
			function end() {
				if (that.parent) that.parent.removeChild(that);
				stage = that.stage;
				if (stage) stage.update();
				if (that.zimAccessibility) {
					var a = that.zimAccessibility;
					a.resize(that);
					if (accessibilityClicker) accessibilityClicker.focus();
					else that.zimTabTag.nextSibling.focus();
					setTimeout(function() {a.talk("Waiter has finished.");}, 50);
				}
			}
			that.toggled = false;
			return that;
		};
		var accessibilityClicker;
		var timeouts = [];
		this.show = function() {
			var mess = "zim display - Waiter(): Please pass in a reference to a container with bounds set as first parameter to Waiter";
			if (zot(container)) {
				if (WW.zdf) {
					container = WW.zdf.stage;
				} else {
					zogy(mess);
					return;
				}
			} else if (!container.getBounds) {
				zogy(mess);
				return;
			} else if (zot(container.stage)) {
				zogy("zim display - Waiter(): The container must have a stage property");
				return;
			}
			var dot; var counter=0;
			var s = speed*(timeType=="s"?1000:1);
			for (var i=0; i<circles.numChildren; i++) {
				if (circles) {
					timeouts.push(setTimeout(function() {
						dot = circles.getChildAt(counter);
						createjs.Tween.get(dot,{loop:true})
							.to({alpha:1}, s/numDots/2)
							.wait(s/numDots)
							.to({alpha:0}, s/numDots)
							.wait(s-s/numDots-s/numDots/2);
						counter++;
					}, i*s/numDots));
				}
			}
			that.ticker = createjs.Ticker.on("tick", function() {container.stage.update();});

			that.x = (container.getBounds().width) /2;
			that.y = (container.getBounds().height) /2;
			container.addChild(that);
			if (fadeTime > 0) {
				that.alpha = 0;
				that.animate({alpha:1}, fadeTime);
			}
			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				setTimeout(function(){if (a.activatedObject) accessibilityClicker = a.activatedObject.zimTabTag;}, 50);
				a.resize(that);
				a.talk(that.zimTabTag.getAttribute("aria-label"));
			}
			that.toggled = true;
			return that;
		};
		that.toggle = function(state) {
			if (state===true) that.show();
			else if (state===false) that.hide();
			else if (that.parent) that.hide();
			else that.show();
			return that;
		};

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Waiter(container, speed, foregroundColor, backgroundColor, corner, shadowColor, shadowBlur, fadeTime, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			if (that.ticker) createjs.Ticker.off("tick", that.ticker);
			createjs.Tween.removeTweens(that);
			that.removeFrom();
			for (var i=0; i<circles.numChildren; i++) {
				var circle = circles.getChildAt(i);
				clearInterval(timeouts[i]);
				createjs.Tween.removeTweens(circle);
			}
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};
	};
	zim.extend(zim.Waiter, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-59

/*--
zim.ProgressBar = function(barType, foregroundColor, backgroundColor, borderColor, borderWidth, padding, label, color, labelPosition, percentage, corner, shadowColor, shadowBlur, backing, delay, fastClose, container, autoHide, width, style, group, inherit)

ProgressBar
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Adds a little progress bar that can be scaled if desired
Pass in to progress parameter of the Frame or LoadAssets call to operate
or use on its own with the show(), hide() methods and percent property

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const progressBar = new ProgressBar();
F.loadAssets({assets:"greeting.mp3", progress:progressBar});
// a bar will be centered on the default stage (or specify a container)
// the bar will show a percentage of asset bytes loaded
F.on("complete", ()=>{
	// the bar will be removed when loading is complete
	// must have interacted previously to play sound...
	new Aud("greeting.mp3").play();
});
END EXAMPLE

EXAMPLE
// testing progress bar:
new ProgressBar({barType:"rectangle"}).show().run(2); // run for 2 seconds
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
barType - (default "circle") set "rectangle" for rectangular progress bar
foregroundColor - (default green) the color of the bar
backgroundColor - (default dark) the color of the background
borderColor - (default backgroundColor) the color of the border - for "rectangle" barType
borderWidth - (default 10 "circle" or 0 "rectangle") the width of the border (or ring for "circle" barType)
padding - (default 2 for "circle" or 0 for "rectangle") the space between the bar and the backing
label - (null) set to a String or a ZIM Label to specifify label properties
color - (default foregroundColor) the color of the label if there is one
labelPosition - ("bottom" if label specified) also set to TOP to move label above progress bar
percentage - (default false) set to true to show percentage after label (set label to "" for only percentage)
corner - (default 15 for "rectangle" barType) set to 0 for square corners, etc.
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (default rgba(0,0,0,.3)) set to -1 for no shadow
shadowBlur - (default 14) the blur of the shadow if shadow is set
backing - (default null) a Display object for the backing of the "rectangle" barType (eg. Shape, Bitmap, Container, Sprite)
	See ZIM Pizzazz 3 - for patterns - these have a type of "Pattern" which makes them special
	If a "pattern" is used then the normal backing will be used to mask the pattern
delay - (default .1) seconds to delay view of progress bar - helps not flash progress bar when content is cached (also see ZIM TIME constant)
fastClose - (default true) hide as soon as progress is done
	The complete event is delayed slightly after the progress bar is loaded
	Set to false to wait until the complete event triggers before removing the progress bar
container - (defaultFrame's stage) or specify a container to hold the progress bar
autoHide - (default true) set to false so bar does not hide when reaching 100%
width - (default 20/200 for circle/rectangle) set the width of the bar (for the circle the width is diameter)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show() - shows the progress bar (returns the progress bar for chaining)
hide() - hides the progress bar
toggle(state - default null) - shows progress bar if hidden and hides progress bar if showing (returns the object for chaining)
	or pass in true to show progress bar or false to hide progress bar
run(time, close) - shows and runs the progress bar for the given time (default 3s) (also see ZIM TIME constant)
	setting close to true or false will set the main class autoHide setting
	thanks Racheli Golan for the request
setBacking(backing) - change the backing of the progress bar
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied (returns the new waiter for chaining)
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
percent - get or set the percent (0-100) complete of the progress bar
label - reference to the label if there is one
backing - reference to the backing shape.  This may be the backing DisplayObject if provided
	the backing will have a pattern property if a pattern is set for the backing
bar - reference to the bar shape
toggled - read-only Boolean that is true if progress bar is showing otherwise false

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.
group - used when the object is made to add STYLE with the group selector (like a CSS class)

EVENTS
Dispatches a "complete" event when the loading or running is complete
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+59.5
	zim.ProgressBar = function(barType, foregroundColor, backgroundColor, borderColor, borderWidth, padding, label, color, labelPosition, percentage, corner, shadowColor, shadowBlur, backing, delay, fastClose, container, autoHide, width, style, group, inherit) {
		var sig = "barType, foregroundColor, backgroundColor, borderColor, borderWidth, padding, label, color, labelPosition, percentage, corner, shadowColor, shadowBlur, backing, delay, fastClose, container, autoHide, width, style, group, inherit";
		var duo; if (duo = zob(zim.ProgressBar, arguments, sig, this)) return duo;
		z_d("59.5");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "ProgressBar";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(foregroundColor)) foregroundColor=DS.foregroundColor!=null?DS.foregroundColor:zim.green;
		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.charcoal;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:backgroundColor;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (zot(labelPosition)) labelPosition=DS.labelPosition!=null?DS.labelPosition:"bottom";
		if (zot(barType)) barType=DS.barType!=null?DS.barType:"circle";
		if (zot(padding)) padding=DS.padding!=null?DS.padding:(barType=="circle"?2:-.5);
		if (zot(corner)) corner=DS.corner!=null?DS.corner:15;
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(backing)) backing=DS.backing!=null?DS.backing.clone():null;
		if (zot(fastClose)) fastClose=DS.fastClose!=null?DS.fastClose:true;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) {
			if (barType == "circle") borderWidth = 10;
			else borderWidth = 2;
		}
		var timeType = getTIME(delay);
		if (zot(delay)) delay= DS.delay!=null?DS.delay:timeType=="s"?.1:100;
		if (zot(autoHide)) autoHide= DS.autoHide!=null?DS.autoHide:true;
		if (zot(label)) label = DS.label!=null?DS.label:null;
		if (zot(color)) color=DS.color!=null?DS.color:foregroundColor;
		if (zot(width)) width=DS.width!=null?DS.width:barType=="circle"?40:200;

		if (typeof label === "string" || typeof label === "number") label = new zim.Label({
			text:label, color:color,
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			group:this.group
		});
		if (!zot(percentage) && zot(label)) label = new zim.Label("");
		this.label = label;

		var height = 30;
		var that = this;
		var _percent = 0;

		that.visible = false;
		setTimeout(function(){that.visible = true; if (that.stage) that.stage.update();}, delay);

		var bar;
		if (barType == "circle") {
			width = width/2;
			backing = this.backing = new zim.Circle(width, "rgba(0,0,0,0)", backgroundColor, borderWidth, null, null, null, null, null, false).addTo(that);
			bar = this.bar = new zim.Shape({style:false}).addTo(that).loc(backing.x, backing.y).rot(-90);
		} else {
			if (shadowColor != -1 && shadowBlur > 0) {
				var shadowRect = new zim.Rectangle(width-2, height-2, backgroundColor, null, null, corner, null, null, null, false).addTo(this);
				shadowRect.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
			}
			backing = doBacking(backing);

			var cc = corner;
			if (!Array.isArray(cc)) cc = [corner, corner, corner, corner];
			var cAdjust = (padding+borderWidth/2)*1.2;
			bar = this.bar = new zim.Rectangle(width-(padding+borderWidth/2)*1.8, height-(padding+borderWidth/2)*1.8, foregroundColor, null, null, [cc[0]-cAdjust,cc[1]-cAdjust,cc[2]-cAdjust,cc[3]-cAdjust], null, null, null, false).center(this);
			var mask = this.mask = new zim.Rectangle(width-(padding+borderWidth/2)*1.8, height-(padding+borderWidth/2)*1.8, null, null, null, null, null, null, null, false).center(this).alp(0).sca(0,1);
			bar.setMask(mask);
		}

		function doBacking(newBacking) {
			var index;
			if (that.backing) {
				index = that.getChildIndex(that.backing);
				that.removeChild(that.backing);
			} else {
				index = that.numChildren; // may or may not be shadow rect
			}
			if (that.border) that.removeChild(that.border);
			if (!zot(newBacking) && newBacking.type == "Pattern") {
				var pattern = newBacking;
				newBacking = that.backing = new zim.Rectangle(width, height, backgroundColor, null, null, corner, null, null, null, false).addTo(that, index);
				newBacking.pattern = pattern;
				pattern.center(newBacking);
				pattern.setMask(newBacking.shape);
				if (borderWidth) that.border = new zim.Rectangle(width, height, "rgba(0,0,0,0)", borderColor, borderWidth, corner, null, null, null, false).addTo(that, index+1);
			} else {
				newBacking = that.backing = zot(newBacking) ? new zim.Rectangle(width, height, backgroundColor, borderColor, borderWidth, corner, null, null, null, false).addTo(that, index) : backing.addTo(that, index);
			}
			return newBacking;
		}

		that.setBacking = function(backing) {
			doBacking(backing);
			if (that.stage) that.stage.update();
		};

		backing.on("click", function(e) {
			// stops the click from going through the display to the background
			e.stopImmediatePropagation();
		});

		if (!zot(label)) {
			label.scaleX = label.scaleY = .8;
			label.startText = label.text;
			if (!zot(percentage)) label.text = label.startText + "  0%";
			label.center(that);
			if (labelPosition == "above") {
				label.y -= 60;
			} else {
				label.y += 60;
			}
			label.alpha = .8;
		}

		this.hide = function() {
			var stage = that.stage;
			if (that.parent) that.parent.removeChild(that);
			if (that.backing.type == "Pattern" && that.backing.pauseInterval) that.backing.pauseInterval();
			if (stage) stage.update();
			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				a.resize(that);
				if (accessibilityClicker) accessibilityClicker.focus();
				else that.zimTabTag.nextSibling.focus();
				setTimeout(function() {a.talk("Progress Bar has finished.");}, 50);
			}
			that.toggled = false;
			return that;
		};
		var accessibilityClicker;
		this.show = function() {
			var mess = "zim display - ProgressBar(): Please pass in a reference to a container with bounds set as first parameter of the ProgressBar";
			if (zot(container)) {
				if (WW.zdf) {
					container = WW.zdf.stage;
				} else {
					zogy(mess);
					return;
				}
			} else if (!container.getBounds) {
				zogy(mess);
				return;
			} else if (zot(container.stage)) {
				zogy("zim display - Waiter(): The container must have a stage property");
				return;
			}
			if (that.timeOut) clearTimeout(that.timeOut);
			changePercent(0);
			if (that.zimActiveLoader) {
				that.zimActiveLoader.on("progress", function(e) {
					_percent = e.progress*100;
					changePercent(_percent);
				});
			}
			that.center(container);

			if (that.backing.type == "Pattern" && that.backing.pauseInterval) that.backing.pauseInterval(false);

			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				setTimeout(function(){if (a.activatedObject) accessibilityClicker = a.activatedObject.zimTabTag;}, 50);
				a.resize(that);
				a.talk(that.zimTabTag.getAttribute("aria-label"));
			}
			that.toggled = true;
			return that;
		};
		that.toggle = function(state) {
			if (state===true) that.show();
			else if (state===false) that.hide();
			else if (that.parent) that.hide();
			else that.show();
			return that;
		};

		that.run = function(time, close) {			
			if (!zot(close)) autoHide = close;
			if (zot(time)) time=timeType=="s"?3:3000;
			checkTIME(time, timeType); // check for warning
			var t = time*(timeType=="s"?1000:1);
			// that.toggle(true);
			if (that.runInterval) clearInterval(that.runInterval);
			that.percent = 0;
			var startTime = Date.now();
			that.runInterval = setInterval(function () {
				that.percent = (Date.now()-startTime)/t*100;
				if (that.percent >= 100) {
					that.percent = 100;
					clearInterval(that.runInterval);
				}
			}, 30);
			return that;
		};

		that.dispatched = false;
		function changePercent(amount) {
			if (barType == "circle") {
				bar.graphics
					.c()
					.mt(0, 0)
					.s(foregroundColor)
					.ss(borderWidth-padding*2+.5)
					.a(0, 0, width, 0, 360*amount/100*Math.PI/180);
			} else {
				mask.sca(amount/100, 1);
				bar.setMask(mask);
			}
			if (!zot(percentage)) label.text = label.startText + " " + Math.min(Math.round(amount), 100) + "%";
			if (autoHide && fastClose && Math.round(amount) >= 100) that.timeOut = setTimeout(function(){that.hide();}, 200);
			if (!that.dispatched && Math.round(amount) >= 100) {
				that.dispatchEvent("complete");
				that.dispatched = true;
				setTimeout(function () {
					if (that) that.dispatched = false;
				}, 100);
			}
			if (that.stage) that.stage.update();
		}

		Object.defineProperty(that, 'percent', {
			get: function() {
				return _percent;
			},
			set: function(value) {
				_percent = value;
				changePercent(value);
			}
		});
		
		var b = that.getBounds();
		that.setBounds(b.x-5,b.y-5,b.width+10,b.height+10);

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.ProgressBar(barType, foregroundColor, backgroundColor, borderColor, borderWidth, padding, label, color, labelPosition, percentage, corner, shadowColor, shadowBlur, backing, delay, fastClose, container, autoHide, width, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			if (that.backing.type == "Pattern" && that.backing.clearInterval) that.backing.clearInterval();
			if (that.runInterval) clearInterval(that.runInterval);
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};
	};
	zim.extend(zim.ProgressBar, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-59.5

/*--
zim.Indicator = function(width, height, num, foregroundColor, backgroundColor, borderColor, borderWidth, backdropColor, corner, indicatorType, fill, scale, lightScale, interactive, shadowColor, shadowBlur, selectedIndex, backgroundAlpha, style, group, inherit)

Indicator
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A row of dots or squares that can be used to indicate a step, page, level, score, etc.
The indicator can be used as an input as well but often these are small so may not be best to rely on.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const lights = new Indicator({fill:true});
lights.selectedIndex = 0; // set the first light on
lights.center();
S.on("stagemousedown", ()=>{
	// increase the indicator lights each click (then start over)
	lights.selectedIndex = (lights.selectedIndex+1) % lights.num;
});
S.update();
END EXAMPLE

EXAMPLE
// lightening indicator!
new Indicator({
	indicatorType:new Emoji("\u26a1\ufe0f"),
	fill:true,
	interactive:true
}).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 100) width of indicator
height - (default 50) height of indicator
num - (default 6) the number of lights
foregroundColor - (default "orange") color of the light(s) turned on
backgroundColor - (default grey) color of the light(s) turned off
borderColor - (default -1 for no border) border color of lights and backdrop (if backdrop)
borderWidth - (default 1 if stroke is set) the size of the stroke in pixels
backdropColor - (default -1 for no backdrop) backdrop rectangle around lights
corner - (default 0) the corner radius if there is a backdropColor provided
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
indicatorType - (default "dot" or "circle") can also be "box" or "square", "heart", "star"
	or pass in a ZIM Emoji and Indicator will fade alpha to backgroundAlpha parameter setting for unselected emojis
	or pass any display object and the this will be used 
fill - (default false) set to true to fill in lights to the left of the selectedIndex
scale - (default 1) for all the lights including spacing
lightScale - (default 1) scale for each light - keeping the spacing unchanged
interactive - (default false) set to true to make lights clickable
	clicking on first light when first light is only light on, will toggle light
shadowColor - (default rgba(0,0,0,.3)) set to -1 for no shadow
shadowBlur - (default 5) the shadow blur if shadow is set
selectedIndex - (default 0) - set the selectedIndex at start.  Use -1 for no indicator at start.
backgroundAlpha - (default 1 or .2 if indicatorType is Emoji) - affects only Emoji and custom DisplayObject indicatorType
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - gets or sets the current index of the indicator
num - the assigned num value (how many light objects) (read only)
backdrop - gives access to the backdrop if there is one Rectangle
lights - an array of the light objects (zim Circle or Rectangle objects)
lightsContainer - gives access to the lights createjs.Container with its Circle or Rectangle children
enabled - set to false to disable component

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event if press is true and indicator is pressed on and lights change

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+60
	zim.Indicator = function(width, height, num, foregroundColor, backgroundColor, borderColor, borderWidth, backdropColor, corner, indicatorType, fill, scale, lightScale, interactive, shadowColor, shadowBlur, selectedIndex, backgroundAlpha, style, group, inherit) {
		var sig = "width, height, num, foregroundColor, backgroundColor, borderColor, borderWidth, backdropColor, corner, indicatorType, fill, scale, lightScale, interactive, shadowColor, shadowBlur, selectedIndex, backgroundAlpha, style, group, inherit";
		var duo; if (duo = zob(zim.Indicator, arguments, sig, this)) return duo;
		z_d("60");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Indicator";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:300;
		if (zot(height)) height = DS.height!=null?DS.height:50;
		if (zot(num)) num = DS.num!=null?DS.num:6;
		if (zot(indicatorType)) indicatorType = DS.indicatorType!=null?DS.indicatorType:"dot";
		if (zot(foregroundColor)) foregroundColor = DS.foregroundColor!=null?DS.foregroundColor:indicatorType=="star"?zim.yellow:indicatorType=="heart"?zim.red:zim.orange;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.granite;
		if (backgroundColor < 0) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"rgba(0,0,0,.01)";
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:-1;
		if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
		if (zot(fill)) fill = DS.fill!=null?DS.fill:false;
		if (zot(scale)) scale = DS.scale!=null?DS.scale:1;
		if (zot(lightScale)) lightScale = DS.lightScale!=null?DS.lightScale:1;
		if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:false;
		if (zot(shadowColor)) shadowColor = DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur = DS.shadowBlur!=null?DS.shadowBlur:5;
		if (zot(backgroundAlpha)) backgroundAlpha = DS.backgroundAlpha!=null?DS.backgroundAlpha:.2;

		var eventType = (!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click";

		var that = this;
		this.lights = [];

		var myValue;
		if (backdropColor != -1) {
			var backing = that.backdrop = new zim.Rectangle(width, height, backdropColor, borderColor, borderWidth, corner, null, null, null, false);
			this.addChild(backing);
		}
		var lights = this.lightsContainer = new zim.Container({style:false});
		this.addChild(lights);
		var light;
		var size = height * .5;
		var space = width / (num+1);
		var hitArea = new createjs.Shape();
		var objCheck = false;
		if (indicatorType == "square" || indicatorType == "box" || indicatorType.type == "Emoji") {
			hitArea.graphics.f("black").dr(-space/2/lightScale+size/2, -height/2+size/2, space/lightScale, height);
		} else {
			hitArea.graphics.f("black").dr(-space/2/lightScale, -height/2, space/lightScale, height);
		}
		for (var i=0; i<num; i++) {
            if (indicatorType == "dot") {
                light = new zim.Circle(size/2, backgroundColor, borderColor, borderWidth, null, null, null, null, null, false);                
            } else if (indicatorType == "square" || indicatorType == "box") {
				light = new zim.Rectangle(size, size, backgroundColor, borderColor, borderWidth, null, null, null, null, false);
				light.regX = light.width/2;
				light.regY = light.height/2;
			} else if (indicatorType == "star") {
				light = new zim.Poly(size*.6, 5, .5, backgroundColor, borderColor, borderWidth, null, null, false);
			} else if (indicatorType == "heart") {
				light = new zim.Blob({
					points:[[0,-40.7,0,0,-57.3,-76.6,41.8,-80.3,"mirror"],[100,0,0,0,23.7,-45.4,-23.7,45.4,"mirror"],[0,100,0,0,0,0,0,0,"mirror"],[-100,0,0,0,21.9,48.2,-21.9,-48.2,"mirror"]],
					color:backgroundColor,
					interactive:false
				}).transformPoints("scale", .15);
			} else if (indicatorType.pos) {
				objCheck = true;
				light = indicatorType.clone().reg("center","center");
				light.myCache = false;
			} 

			this.lights.push(light);
			light.znum = i;
			light.scaleX = light.scaleY = lightScale;
			light.hitArea = hitArea;
			light.x = space + space * i;
			light.y = height / 2;
			lights.addChild(light);
		}

		lights.setBounds(0,0,width,height);
		lights.regX = lights.x = width / 2;
		lights.regY = lights.y = height / 2;
		this.addChild(lights);
		if (shadowColor != -1 && shadowBlur > 0) lights.shadow = new createjs.Shadow(shadowColor, 2, 2, shadowBlur);

		if (interactive) {
			lights.cur("pointer");
			that.lightsEvent = lights.on(eventType, function(e) {
				if (myValue == e.target.znum) {
					if (myValue > 0) return;
					else if (myValue==0){
						myValue = -1;
						setLights(myValue);
						that.dispatchEvent("change");
						return;
					}
				}
				myValue = e.target.znum;
				setLights(myValue);
				that.dispatchEvent("change");
			});
		}
		lights.scaleX = lights.scaleY = scale;

		function setLights(v) {
			if (v >= num) v = -1; // out of range - don't let it fill up
			var c;
			for (var i=0; i<num; i++) {
				if (fill) {
					if (i < v) c = foregroundColor;
					else c = backgroundColor;
				} else {
					c = backgroundColor;
				}
				if (i == v) c = foregroundColor;
				
				var l = lights.getChildAt(i);
				if (objCheck) {
					l.alpha = c==foregroundColor?1:backgroundAlpha;				
				}				
				l.color = c;
			}
			if (that.zimAccessibility) that.zimAccessibility.changeTitle(that);

			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}

		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				return myValue;
			},
			set: function(value) {
				myValue = Math.floor(value);
				myValue = zim.constrain(myValue, -1, num-1);
				setLights(myValue);
			}
		});

		Object.defineProperty(this, 'num', {
			get: function() {
				return num;
			},
			set: function() {
				if (zon) zogy("Indicator() - num is read only");
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;

		if (style!==false) zim.styleTransforms(this, DS);
		
		this.dispose = function(a,b,disposing) {			
			if (!disposing) {
				if (that.lightsEvent) lights.off(eventType, that.lightsEvent);
				this.zimContainer_dispose();
			}
		}
		this.clone = function() {
			return that.cloneProps(new zim.Indicator(width, height, num, foregroundColor, backgroundColor, borderColor, borderWidth, backdropColor, corner, indicatorType, fill, scale, lightScale, interactive, shadowColor, shadowBlur, selectedIndex, backgroundAlpha, style, this.group, inherit));
		};
	};
	zim.extend(zim.Indicator, zim.Container, ["clone","dispose"], "zimContainer", false);
	//-60
	
/*--
zim.TextInput = function(width, height, placeholder, text, size, font, color, backgroundColor, borderColor, borderWidth, maxLength, password, selectionColor, selectionAlpha, cursorColor, cursorSpeed, shadowColor, shadowBlur, align, corner, padding, paddingH, paddingV, shiftH, shiftV, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, readOnly, inputType, rtl, uppercase, placeholderInstant, keyboardShift, style, group, inherit)

TextInput
zim class - extends a zim.Window which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes an input text field like an HTML form input type text field.
This will be right on the canvas so can be layered with canvas objects 
as opposed to the ZIM TextArea() which is an HTML tag overlay.
Thanks Cajoek for coding the text for the class. 

WARNING: currently a single line is available (so height is not at this point useful)

See: https://zimjs.com/explore/textinput.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const input = new TextInput().loc(100,100); // adds a default input field to the stage

new Button({label:"SUBMIT"}).loc(100, 200).tap(()=>{
	zog(input.text); // whatever is typed into the LabelInput
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
width - |ZIM VEE| (default 300) - the width of the backgroundColor of the field - set to -1 for expanding width
	This will limit the length of the text added to the field 
	In the future, scrolling text may be provided
height - |ZIM VEE| (default size plus paddingV) - the height of the backgroundColor for the label 
	Currently, the text is always one line.
	In the future, multi-line functionality may be provided 
	Until then, use a ZIM TextArea for multiline.
placeholder - |ZIM VEE| String to show when no text is entered - will disappear when there is text entered
text - |ZIM VEE| String for the the text of the label
size - (default 36) the size of the font in pixels
font - (default arial) the font or list of fonts for the text
color - |ZIM VEE| (default dark) color of font 
backgroundColor - |ZIM VEE| (default lighter) background color - set to -1 for no background
borderColor - |ZIM VEE| (default null) the background stroke color
borderWidth - (default null) thickness of the background border
maxLength - (default null) set to limit the number of characters in the field
password - (default false) set to true to show **** for text to hide password
	this will be replaced by inputType in upcoming versions of ZIM
selectionColor - (default color) the selection color of the text 
selectionAlpha - (default .2) the alpha of the selection color
cursorColor - (default color) the blinking cursor in the text
cursorSpeed - (default .5) seconds for which the cursor blinks
shadowColor - (default -1) for no shadow - set to any css color to see
shadowBlur - (default 14) if shadow is present
align - ((default LEFT) text registration point alignment 
	also RIGHT for right aligned
	also CENTER - (experimental) this adds a maxWidth to keep text centered
	the maxWidth that is added can be overwritten 
corner - (default 0) the round of corner of the background if there is one
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
padding - (default 5 if backgroundColor set) places the border this amount from text (see paddingH and paddingV)
	padding parameters are ignored if there is no backgroundColor set 
paddingH - (default padding) places border out at top bottom
paddingV - (default padding) places border out at left and right
shiftH - (default 0) move the label (CreateJS Text) inside the Label container horizontally
shiftV - (default 0) move the label (CreateJS Text) inside the Label container vertically
rollPersist - (default false) set to true to maintain rollover stage as long as mousedown or press is activated (used by Buttons)
scrollBarActive - (default false) set to true to show scrollBar
scrollBarDrag - (default false) set to true to be able to drag the scrollBar
scrollBarColor - (default borderColor) the color of the scrollBar
scrollBarAlpha - (default .3) the transparency of the scrollBar
scrollBarFade - (default true) fades scrollBar unless being used
scrollBarH - (default true) if scrolling in horizontal is needed then show scrollBar
scrollBarV - (default true) if scrolling in vertical is needed then show scrollBar
readOnly - (default false) set to true for field to be readOnly - also see readOnly property
inputType - (default "text") set to "text", "number", "password", "email" 
	number has 0-9 . + - / * % $ available
	this will replace the password parameter in upcoming versions of ZIM
rtl - (default ZIM DIR) the direction of the text.  Also set "rtl" in the HTML tag dir parameter for RTL
uppercase - (default false) set to true to force uppercase letters
placeholderInstant - (default true) set to false to not remove the placeholder as soon as the cursor is in the field
keyboardShift - (default false) set to true to lift stage at least 1/4 height or up to label y/2 to raise input above keyboard
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
resize(width, height) - resizes the field dimensions (inherited from Window) returns object for chaining
clone(exact) - makes a copy with properties such as x, y, etc. also copied
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if the object's color is [blue, green]
	then its clone might be blue or green - which could be different than the original
	If exact is set to true then the clone will be the color of the original object
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: all methods of ZIM Window()

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.

ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
text - references the text property of the CreateJS Text object
label - references the ZIM Label object of the TextInput 
	this is actually a LabelInput that extends a ZIM Label
	see the STATIC PROPERTY LabelInput entry below 
placeholderLabel - refrerence to the placeholder label
htmlTag - access to the hidden HTML input tag
focus - get or set the focus of the TextInput
selection - access to selection ZIM Rectangle 
	use this to set color or blendMode of selection
selectionAlpha - get or set the alpha of the selection 
blinker - access to the blinking cursor ZIM Rectangle
	use this to set color or blendMode of blinker
size - the font size of the Label (without px)
	use textInput.resize() if there are selection problems after setting size 
	often a resize() is desired anyway so manually calling avoids double resizing	
font - get or set the font of the text
align - get or set the horizontal alignment of the text
	values are LEFT and RIGHT and CENTER (experimental)
color - gets or sets the label text color
backgroundColor - gets or sets the background color
readOnly - get or set the field as readOnly - also see readOnly parameter
enabled - default is true - set to false to disable
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: all properties of ZIM Window()

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

STATIC PROPERTY 
LabelInput() - a static class so use new TextInput.LabelInput() to create.
	This class is an editable label that expands in size as it is typed into 
	The TextInput is a ZIM Window with a LabelInput inside
	The LabelInput has all the parameters of a ZIM Label with the following added after the size parameter:
		maxLength - (default null) the maximum number of characaters the text can have
		password - (default false) turn text into password text * symbols
		selectionColor - (default - the text color) the color of the selection
		selectionAlpha - (default .2) the alpha of the selection
		blinkerColor - (default - the text color) the color of the blinker cursor
		blinkerSpeed - (default .5) the speed of the blinker cursor
	Some parameters of LabelInput such as rollColor and rollPersist are ignored - but kept in the signature to match Label for ease
	an inputType parameter is available before the style parameter with a value of "text", "number", "email", "password"
	as well an uppercase parameter is available just before the style parameter 

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties

EVENTS
focus, blur are dispatched when the text gains and loses focus
input is dispatched when the input text is typed or pasted into
change is dispatched when the input text is different after losing focus (except if text is set programmatically)
See the events for HTML input field of type text
See the events for ZIM Window()
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+54.2
zim.TextInput = function(width, height, placeholder, text, size, font, color, backgroundColor, borderColor, borderWidth, maxLength, password, selectionColor, selectionAlpha, cursorColor, cursorSpeed, shadowColor, shadowBlur, align, corner, padding, paddingH, paddingV, shiftH, shiftV, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, readOnly, inputType, rtl, uppercase, placeholderInstant, keyboardShift, style, group, inherit) {
	var sig = "width, height, placeholder, text, size, font, color, backgroundColor, borderColor, borderWidth, maxLength, password, selectionColor, selectionAlpha, cursorColor, cursorSpeed, shadowColor, shadowBlur, align, corner, padding, paddingH, paddingV, shiftH, shiftV, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, readOnly, inputType, rtl, uppercase, placeholderInstant, keyboardShift, style, group, inherit";
	var duo; if (duo = zob(zim.TextInput, arguments, sig, this)) return duo;
	z_d("54.2");
	
	this.group = group;
	var DS = style===false?{}:zim.getStyle("TextInput", this.group, inherit);
	
	if (zot(size)) size=DS.size!=null?DS.size:36;
	if (zot(padding) || padding=="ignore") padding = (DS.padding!=null&&padding!="ignore")?DS.padding:5;
	if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:padding;
	if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:padding;
	
	if (zot(width)) width=DS.width!=null?DS.width:300;
	if (zot(height)) height=DS.height!=null?DS.height:size+paddingV*2;		
	if (zot(placeholder)) placeholder=DS.placeholder!=null?DS.placeholder:null;
	if (zot(text)) text=DS.text!=null?DS.text:"";		
	if (zot(font)) font=DS.font!=null?DS.font:"arial";
	if (zot(color)) color=DS.color!=null?DS.color:zim.dark;
	if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.lighter;
	if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:null;
	if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:null;

	var oa = remember(width, height, placeholder, text, color, backgroundColor, borderColor);
	this.veeObj = {width:oa[0], height:oa[1], placeholder:oa[2], text:oa[3], color:oa[4], backgroundColor:oa[5], borderColor:oa[6]};
	function remember() {return arguments;}
	width = zim.Pick.choose(width);
	height = zim.Pick.choose(height);
	placeholder = zim.Pick.choose(placeholder);
	text = zim.Pick.choose(text);
	color = zim.Pick.choose(color);
	backgroundColor = zim.Pick.choose(backgroundColor);
	borderColor = zim.Pick.choose(borderColor);

	if (zot(selectionColor)) selectionColor=DS.selectionColor!=null?DS.selectionColor:color;
	if (zot(selectionAlpha)) selectionAlpha=DS.selectionAlpha!=null?DS.selectionAlpha:.2;
	if (zot(cursorColor)) cursorColor=DS.cursorColor!=null?DS.cursorColor:color;
	if (zot(cursorSpeed)) cursorSpeed=DS.cursorSpeed!=null?DS.cursorSpeed:.5;
	if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
	if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:20;
	if (zot(align)) align=DS.align!=null?DS.align:"left";
	if (zot(corner)) corner=DS.corner!=null?DS.corner:0;		
	if (zot(shiftH)) shiftH = DS.shiftH!=null?DS.shiftH:0;
	if (zot(password)) password=DS.password!=null?DS.password:false;
	if (zot(shiftV)) shiftV = DS.shiftV!=null?DS.shiftV:password?size*.25:0;
	if (zot(maxLength)) maxLength=DS.maxLength!=null?DS.maxLength:align=="center"?Math.floor(width/size)*1.8:null;
	if (zot(scrollBarActive)) scrollBarActive=DS.scrollBarActive!=null?DS.scrollBarActive:false;
	if (zot(scrollBarDrag)) scrollBarDrag=DS.scrollBarDrag!=null?DS.scrollBarDrag:false;
	if (zot(scrollBarColor)) scrollBarColor=DS.scrollBarColor!=null?DS.scrollBarColor:borderColor;
	if (zot(scrollBarAlpha)) scrollBarAlpha=DS.scrollBarAlpha!=null?DS.scrollBarAlpha:.3;
	if (zot(scrollBarFade)) scrollBarFade=DS.scrollBarFade!=null?DS.scrollBarFade:true;
	if (zot(scrollBarH)) scrollBarH = DS.scrollBarH!=null?DS.scrollBarH:true;
	if (zot(scrollBarV)) scrollBarV = DS.scrollBarV!=null?DS.scrollBarV:true;
	if (zot(readOnly)) readOnly = DS.readOnly!=null?DS.readOnly:false;	
	if (zot(inputType)) inputType = DS.inputType!=null?DS.inputType:"text";	
	if (scrollBarDrag) scrollBarFade = DS.scrollBarFade!=null?DS.scrollBarFade:false;
	if (zot(rtl)) rtl = DS.rtl!=null?DS.rtl:(WW.DIR=="rtl"||zim.DIR=="rtl")?"rtl":null;
	if (zot(uppercase)) uppercase = DS.uppercase!=null?DS.uppercase:null;
	if (zot(keyboardShift)) keyboardShift = DS.keyboardShift!=null?DS.keyboardShift:null;
	if (uppercase) {
		if (text) text = text.toUpperCase();
		if (placeholder) placeholder = placeholder.toUpperCase();
	}
	if (zot(placeholderInstant)) placeholderInstant=DS.placeholderInstant!=null?DS.placeholderInstant:true;
	
	// handle DIR effect 
	function handleDIR() {
		if ((WW.DIR && WW.DIR=="rtl") || (!WW.DIR && zim.DIR=="rtl")) {
			if (align=="start") align="right";
			else if (align=="end") align="left";
		} else {
			if (align=="start") align="left";
			else if (align=="end") align="right";
		}
		return align;
	}
	align = handleDIR(align);
			
	this.zimWindow_constructor(width, height, null, backgroundColor, borderColor, borderWidth, padding, corner, false, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, false, null, null, false, true, shadowColor, shadowBlur, paddingH, paddingV, true, null, null, null, null, null, false, null, null, null, null, null, null, null, null, null, null, null, null, style, group, zim.copy(DS));
	this.type = "TextInput";
	var that = this;

	var label;
	var pastText;
	var pastStart;
	var pastEnd;
	var pastFocus;
	var mask;
	var edgeLeft;
	var edgeRight;
	
	function makeText() {

		if (label) removeText();

		that.placeholderLabel = new zim.Label({text:placeholder||"", size:size, color:color, font:font, shiftH:shiftH, shiftV:shiftV, valign:"top"}).alp(.5);
		if ((pastText == null && text=="") || pastText === "") that.add(that.placeholderLabel);
		
		// the Window usually masks but masks to the edge and not to inside the padding
		// so add a custom mask
		mask = new zim.Rectangle({width:width-padding*2, height:height-padding*2+4, color:zim.clear, style:false}).center(that);
		that.cur("text");
				
		label = that.label = new zim.TextInput.LabelInput(pastText!=null?pastText:text, size, maxLength, password, selectionColor, selectionAlpha, cursorColor, cursorSpeed, font, color, null, null, null, align, "top", null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, shiftH, shiftV, null, null, null, null, inputType, rtl, uppercase, placeholderInstant, style, group, inherit);
		that.add(label); // that is a Window - which has an add() method for adding content
		label.setMask(mask);
		that.htmlTag = that.label.hiddenInput
		that.selection = that.label.selection
		that.blinker = that.label.blinker
	
		
		if (align=="right") {
			label.x = width-paddingH;
			that.placeholderLabel.x = width-that.placeholderLabel.width-paddingH;
		} else if (align=="center") {
			label.x = width/2;
			that.placeholderLabel.x = (width-that.placeholderLabel.width)/2;
		}

		label.ogx = label.x;

		that.placeholderLabel.x = label.x;
		that.placeholderLabel.align = align;
		
		// the LabelInput was receiving a mousedown on its edges which is not desired 
		// so capture those with rectangle padding shields 
		// these can be used to capture a mousedown for selection swipe though
		// but just start the selection at the visible letter on that side
		edgeLeft = new zim.Rectangle({width:padding, height:height, color:zim.clear, style:false}).addTo(that).expand(0);
		edgeLeft.on("mousedown", function(e){
			label.onMousedown(e);
			e.stopImmediatePropagation();
		});
		edgeLeft.on("pressmove", function(e){
			label.onPressmove(e);
			e.stopImmediatePropagation();
		});
		edgeLeft.on("dblclick", function(e){
			label.onDblclick(e);
			e.stopImmediatePropagation();
		});
		edgeRight = new zim.Rectangle({width:padding, height:height, color:zim.clear, style:false}).pos(0,0,zim.RIGHT,zim.TOP,that).expand(0)
		edgeRight.on("mousedown", function(e){
			label.onMousedown(e);
			e.stopImmediatePropagation();
		});
		edgeRight.on("pressmove", function(e){
			label.onPressmove(e);
			e.stopImmediatePropagation();
		});
		edgeRight.on("dblclick", function(e){
			label.onDblclick(e);
			e.stopImmediatePropagation();
		});			
		
		that.label.on("focus", function () {
			if (WW.M && keyboardShift) {
				if (that.re) that.stage.frame.off("resize", that.re);
				that.re = that.stage.frame.on("resize", function(){
					if (that.stage && h>that.stage.height/4) {
						that.stage.y = that.stage.scaleY*(that.stage.height/4-h);
						that.stage.update();
					}
				});
				var h = that.label.localToGlobal(0,0).y;
				if (that.stage && h>that.stage.height/4) {
					that.stage.y = that.stage.scaleY*(that.stage.height/4-h);
					that.stage.update();
				}
			}
			if (placeholderInstant &&  that.placeholderLabel.parent) {
				that.placeholderLabel.removeFrom();			
				if (that.stage) that.stage.update();
			}
			that.dispatchEvent("focus");
		});

		that.label.on("blur", function () {
			if (WW.M && keyboardShift) {			
				if (that.stage) {
					if (that.re) that.stage.frame.off("resize", that.re);
					that.stage.y = sYO;
					that.stage.update();
				}
			}
			if (placeholderInstant && label.text == "" && !that.placeholderLabel.parent) {				
				that.add(that.placeholderLabel);
				if (that.stage) that.stage.update();
			}		
			that.dispatchEvent("blur");
		});

		that.label.on("input", function () {	
			doPlaceholder();
			// if (align=="center" && label.width < width) {
			// 	label.x = (width-label.width)/2;
			// } 
			that.dispatchEvent("input");
		});	
		that.label.on("keydown", function (e) {
			that.label.deleteKey = (e.detail == 46);
			that.dispatchEvent("keydown");
		});	
		that.label.on("blinker", function () {
	
			// Pettis Brandon code '23
			var thatX = that.localToGlobal(0,0).x; // Get the global X of that.
			var thatFull = thatX + width-paddingH-label.blinker.width; // Get the global coordinates of the far right corner.
			var blinker = label.blinker; // Get the blinker shorthand
			var blinkerX = blinker.localToGlobal(0,0).x; // Get the global X of the blinker.
			var labelX = label.localToGlobal(0,0).x - 1; // Get the gloabal X of the label.
			// end Pettis Brandon code '23
	
			// A simple system where the cursor is kept within the box 
			var x = label.x + label.blinker.x;
			var newX = zim.constrain(x, paddingH, width-paddingH-label.blinker.width);
			
			if (x != newX) label.x -= x-newX;		
			
			// Pettis Brandon code '23
			if (align == 'left') {
				if (label.width < that.width) label.x = label.ogx; // Restore starting X to the label when width is less than container width.
				else if (thatFull < blinkerX)label.x -= x-newX; // Move label while typing.
				else if (label.oldWidth == label.width){
					label.x -= x-newX; // If label is the same width move label where the cursor position is.
				} else if (label.oldWidth > label.width){
					if (that.label.deleteKey != true) label.x += Math.abs(blinker.oldX - blinkerX) + label.blinker.width + paddingH; // If we are removing characters try to keep curor in the same spot.
				}
			} else if (align == 'right') {
				if (label.width < that.width) label.x = label.ogx; // Restore starting X to the label when width is less than container width.
				else if (thatFull < blinkerX)label.x -= x-newX; // Move label while typing.
				else if (label.oldWidth == label.width){
					label.x -= x-newX; // If label is the same width move label where the cursor position is.
				} else if (label.oldWidth > label.width){  // If we are removing characters try to keep curor in the same spot.
					if (that.label.deleteKey == true) {
						if (blinkerX < (labelX - that.width)) label.x -= Math.abs(blinker.oldX - blinkerX) + label.blinker.width + paddingH;
					}
				}
			} else if (align == 'center') {
				if (label.width < that.width) label.x = label.ogx; // Restore starting X to the label when width is less than container width
				else if (thatFull < blinkerX) label.x -= x-newX; // Move label while typing.
				else if (label.oldWidth == label.width){
					label.x -= x-newX; // If label is the same width move label where the cursor position is.
				} else if (label.oldWidth > label.width){
					if (thatFull > blinkerX) {
						var centerX = thatX + (that.width*.5);
						if (that.label.deleteKey != true) label.x += label.blinker.width + paddingH; // Test if using the backspace key
						else label.x -= label.blinker.width + paddingH; // Test if using the delete key
					}
				}
			}
			label.oldWidth = label.width; // Get previous label width.
			blinker.oldX = blinkerX; // get previous blinker global x.
			// end Pettis Brandon code '23
					
			if (that.stage) that.stage.update();
		});

		if (pastText != null) {
			var hi = that.label.hiddenInput;
			if (hi.type=="number") hi.type = "text"; // number does not get selection
			label.focus = that.keyFocus = pastFocus;
			var f = zdf;
			if (that.stage) f = that.stage.frame;
			if (f.zil && label.focus) WW.removeEventListener("keydown", f.zil[0]);
			if (f.zil && !label.focus) WW.addEventListener("keydown", f.zil[0]);			
			hi.selectionStart = pastStart;
			hi.selectionEnd = pastEnd;			
			that.label.positionBlinkerAndSelection();
			if (that.label.focus) that.label.blinker.replayTween();
		}

	}
	makeText();	

	function removeText() {
		if (that.re) that.stage.frame.off("resize", that.re);
		that.remove(label);
		pastText = label.text;
		pastFocus = label.focus;
		pastStart = that.label.hiddenInput.selectionStart;
		pastEnd = that.label.hiddenInput.selectionEnd;
		that.placeholderLabel.dispose();
		that.label.dispose();
		edgeLeft.dispose();
		edgeRight.dispose();
	}

	var lastText = label.text;
	that.on("mousedown", function (e) {
		label.onMousedown(e);
		lastText = label.text;
	});
	that.on("pressmove", function(e){
		label.onPressmove(e);
		e.stopImmediatePropagation();
	});
	that.on("dblclick", function(e){
		label.onDblclick(e);
		e.stopImmediatePropagation();
	});	

	that.added(function (stage) {
		stage.on("stagemousedown", function (e) {				
			if (!that.hitTestPoint(e.stageX, e.stageY)) {
				label.focus = false;
				if (label.text != lastText) that.dispatchEvent("change");
				lastText = label.text;
			}
		});
	});
	var sYO = that.stage?stage.y:0;

	function doPlaceholder() {
		if (label.text != "" && that.placeholderLabel.parent) {
			that.placeholderLabel.removeFrom();
			if (that.stage) that.stage.update();
		}
		if (label.text == "" && !that.placeholderLabel.parent) {				
			that.add(that.placeholderLabel);
			if (that.stage) that.stage.update();
		}
	}
				
	Object.defineProperty(that, 'text', {
		get: function() {
			return label.hiddenInput.value;
		},
		set: function(value) {
			lastText = value;
			label.setText(value, true); // true for noEvent
			doPlaceholder();
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}
	});

	if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
	Object.defineProperty(this, 'keyFocus', {
		get: function() {
			return zim.KEYFOCUS == that;
		},
		set: function() {
			zim.KEYFOCUS = that;
		}
	});
	if (!zim.KEYFOCUS) setFocus();
	this.on("mousedown", function() {setFocus();});
	function setFocus() {that.keyFocus = true;}
	
	Object.defineProperty(that, 'readOnly', {
		get: function() {
			return readOnly;
		},
		set: function(value) {			
			readOnly = value;
			that.htmlTag.setAttribute("readonly", readOnly);
		}
	});
	if (readOnly) that.readOnly = true;

	Object.defineProperty(that, 'focus', {
		get: function() {
			return label.focus;
		},
		set: function(value) {
			label.focus = value;
		}
	});
	
	Object.defineProperty(that, 'color', {
		get: function() {
			return label.color;
		},
		set: function(value) {
			label.color = latestColor = value;
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}
	});
			
	Object.defineProperty(that, 'size', {
		get: function() {
			return label.size;
		},
		set: function(value) {
			size = value;
			// makeText();
			label.size = value;
			if (this.placeholderLabel) this.placeholderLabel.size = value;
			label.hiddenInput.style.fontSize = value + "px";
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}
	});
	
	Object.defineProperty(that, 'align', {
		get: function() {
			return label.align;
		},
		set: function(value) {		
			// if (value=="center") value = "left";				
			label.align = align = handleDIR(value);			
			if (align=="right") label.x = width-label.width;
			else if (align=="center") label.x = width/2;
			else label.x = 0;		
			that.placeholderLabel.x = label.x;
			that.placeholderLabel.align = align;
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}
	});
	
	Object.defineProperty(that, 'font', {
		get: function() {
			return label.font;
		},
		set: function(value) {
			label.font = value;
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}
	});
	
	Object.defineProperty(that, 'selectionAlpha', {
		get: function() {
			return label.selectionAlpha;
		},
		set: function(value) {
			label.selectionAlpha = value;
			if (label.selection.alpha != 0) label.selection.alpha = value;
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}
	});	

	this.resize = function(w, h) {
		width = w||width;
		height = h||height;
		that.zimWindow_resize(width, height);
		// mask.siz(width-padding*2, height-padding*2).center(this);
		// label.setMask(mask);
		makeText();
		return that;
	}

	if (style!==false) zim.styleTransforms(this, DS);
	this.clone = function(exact) {	
		return that.cloneProps(new zim.TextInput(exact||!zim.isPick(oa[0])?width:oa[0], exact||!zim.isPick(oa[1])?height:oa[1], exact||!zim.isPick(oa[2])?placeholder:oa[2], exact||!zim.isPick(oa[3])?text:oa[3], size, font, exact||!zim.isPick(oa[4])?color:oa[4], exact||!zim.isPick(oa[5])?backgroundColor:oa[5], exact||!zim.isPick(oa[6])?borderColor:oa[6], borderWidth, maxLength, password, selectionColor, selectionAlpha, cursorColor, cursorSpeed, shadowColor, shadowBlur, align, corner, padding, paddingH, paddingV, shiftH, shiftV, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, readOnly, inputType, rtl, uppercase, placeholderInstant, keyboardShift, style, this.group, inherit));
	};
};
zim.extend(zim.TextInput, zim.Window, ["clone","resize"], "zimWindow", false);
	
	// by Cajoek, 2021 - with thanks!
zim.TextInput.LabelInput = function(text, size, maxLength, password, selectionColor, selectionAlpha, blinkerColor, blinkerSpeed, font, color, rollColor, shadowColor, shadowBlur, align, valign, bold, italic, variant, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, rollPersist, labelWidth, labelHeight, splitWords, inputType, rtl, uppercase, style, group, inherit) {
	this.zimLabel_constructor(text, size, font, color, null, shadowColor, shadowBlur, align, valign, bold, italic, variant, lineWidth, lineHeight, backing, outlineColor, outlineWidth, backgroundColor, backgroundBorderColor, backgroundBorderWidth, corner, backgroundDashed, padding, paddingH, paddingV, shiftH, shiftV, null, labelWidth, labelHeight, null, splitWords, style, group, inherit);
	this.type = "LabelInput";
			
	if (zot(color)) color = zim.dark;
	if (zot(selectionColor)) selectionColor = color;
	if (zot(selectionAlpha)) selectionAlpha = .2;
	this.selectionAlpha = selectionAlpha;
	if (zot(blinkerColor)) blinkerColor = color;
	if (zot(blinkerSpeed)) blinkerSpeed = .5;
			
	this.hiddenInput = document.createElement("INPUT");
	this.hiddenInput.setAttribute("id", zim.makeID()); // otherwise get warning in Chrome - sigh
	this.hiddenInput.value = text;
	if (inputType == "text" && password) inputType = "password";		
	this.hiddenInput.type = inputType;
	if (inputType == "number") {
		this.hiddenInput.pattern = "[^(0-9).\-+*\/%$]*";
		this.hiddenInput.inputmode = "numeric";
	}	
	
	if (maxLength > 0) this.hiddenInput.maxLength = maxLength;
	this.hiddenInput.autocapitalize = "off";
	this.hiddenInput.autocorrect = "off";
	this.hiddenInput.autocomplete = "off";		
	this.hiddenInput.spellcheck = false;
	this.hiddenInput.style.position = "absolute";
	this.hiddenInput.style.overflow = "hidden";
	this.hiddenInput.style.touchAction = "none";
	
	// this.hiddenInput.style.left = "100px";
	// this.hiddenInput.style.top = "100px";
	// this.hiddenInput.style.zIndex = 2;
	// this.hiddenInput.style.opacity = 1;
	// this.hiddenInput.style.width = "300px";
	// this.hiddenInput.style.height = "60px";
	// this.hiddenInput.style.fontSize = "20px";
	
	this.hiddenInput.style.left = "-99999px";
	this.hiddenInput.style.top = "-99999px";
	this.hiddenInput.style.zIndex = -999;
	this.hiddenInput.style.opacity = 0;
	this.hiddenInput.style.width = "1px";
	this.hiddenInput.style.height = "1px";
	this.hiddenInput.style.fontSize = "1px";	

	// this.hiddenInput.style.direction = rtl?"rtl":"ltr";
			
	this.onFocus = function() {
		if (this.stage) frame = this.stage.frame;
		if (frame.zil) WW.removeEventListener("keydown", frame.zil[0]);
		this.blinker.alp(1.0).replayTween();
		this.selection.alp(0.2);
		this.positionBlinkerAndSelection();
		this.dispatchEvent("focus");
	}
	this.onBlur = function() {
		if (this.stage) frame = this.stage.frame;	
		if (frame.zil) WW.addEventListener("keydown", frame.zil[0]);
		this.positionBlinkerAndSelection();
		this.blinker.pauseAnimate(true).alp(0.0);
		this.selection.alp(0.0);
		this.hiddenInput.type = inputType; // ZIM NFT 00 patch
		this.dispatchEvent("blur");
	}
	this.onInput = function(e, noEvent) {
		if (uppercase) this.hiddenInput.value = this.hiddenInput.value.toUpperCase();
		var newText = this.hiddenInput.value;
		if (inputType=="number") {				
			newText = newText.replace(/[^(0-9).\-+*\/%$]*/g,"");
			this.hiddenInput.value = newText;
		}	
		this.text = this.hiddenInput.type=="password"?newText.replace(/./g, '*'):newText;
		this.measureText();
		if (WW.M) this.positionBlinkerAndSelection();
		if (!noEvent) this.dispatchEvent("input");
	}
	this.onSelect = function() {
		this.positionBlinkerAndSelection();
		if (this.focus) {
			this.blinker.replayTween();
		}
	}
	var that = this;
	this.onKeydown = function(e) {
		this.deleteKey = (e.code=="Backspace"||e.code=="Delete");
		this.blinker.replayTween();	
		setTimeout(function() {
			var keyevt = new CustomEvent("keydown", {detail: e.keyCode}); // need to capture keycode on dispatch
			that.positionBlinkerAndSelection.call(that);
			that.dispatchEvent(keyevt);
		}, 10);
	}	
	this.onMousedown = function(e) {
		// ZIM NFT 01 Patch any le or rtl
		var le = this.text.length;
		var point = this.eventPositionGlobalToLocal(e);
		if (!this.focus) {
			this.hiddenInput.focus();
			// ZIM NFT 00 patch
			if (inputType == "email") this.hiddenInput.type = "text";
		}		
		if (inputType == "number") this.hiddenInput.type = "text";			
		var selectionIdx = this.mapPointToIndex(point);
		if (rtl) this.hiddenInput.setSelectionRange(le-selectionIdx, le-selectionIdx);				
		else this.hiddenInput.setSelectionRange(selectionIdx, selectionIdx);				
		this.positionBlinkerAndSelection();	
	}
	this.onPressmove = function(e) {
		// ZIM NFT 01 Patch any le or rtl
		var le = this.text.length;
		if (!this.focus) this.hiddenInput.focus();			
		var point = this.eventPositionGlobalToLocal(e);
		var selectionIdx;
		if (rtl) selectionIdx = le-this.mapPointToIndex(point); 
		else selectionIdx = this.mapPointToIndex(point);
		if (this.hiddenInput.selectionStart === this.hiddenInput.selectionEnd) {
			if (this.hiddenInput.selectionStart <= selectionIdx) {
				this.hiddenInput.setSelectionRange(this.hiddenInput.selectionStart, selectionIdx, rtl?"backward":"forward");
			} else {
				this.hiddenInput.setSelectionRange(selectionIdx, this.hiddenInput.selectionEnd, rtl?"forward":"backward");
			}
		} else {
			if (this.hiddenInput.selectionDirection === (rtl?"backward":"forward")) {
				this.hiddenInput.setSelectionRange(this.hiddenInput.selectionStart, selectionIdx, rtl?"backward":"forward");
			} else {
				this.hiddenInput.setSelectionRange(selectionIdx, this.hiddenInput.selectionEnd, rtl?"forward":"backward");
			}
		}
		
		this.positionBlinkerAndSelection();
	}
	this.onDblclick = function() {
		this.hiddenInput.select();
		this.positionBlinkerAndSelection();
	}		
	this.positionBlinkerAndSelection = function() {
		// ZIM NFT 01 Patch any le or rtl
		var le = this.text.length;
		if (this.focus) {
			var paddingH = this.backing || this.background ? this.paddingH : 0;
			var paddingV = this.backing || this.background ? this.paddingV : 0;
		
			if (this.hiddenInput.selectionStart !== this.hiddenInput.selectionEnd) {
				var startX, endX;
				if (rtl) {
					startX = this.textWidthArray[le-this.hiddenInput.selectionStart]
					endX = this.textWidthArray[le-this.hiddenInput.selectionEnd]
					this.selection.widthOnly = endX - startX;
					this.selection.pos(endX + paddingH - 1 + shiftH, paddingV + shiftV);
				} else {
					startX = this.textWidthArray[this.hiddenInput.selectionStart]
					endX = this.textWidthArray[this.hiddenInput.selectionEnd]
					this.selection.widthOnly = endX - startX;
					this.selection.pos(startX + paddingH - 1 + shiftH, paddingV + shiftV);
				}
				this.selection.heightOnly = this.textHeight;
				this.selection.alp(this.selectionAlpha);
			} else {
				this.selection.alp(0.0);
			}
			this.blinker.heightOnly = this.textHeight;
			var xIdx = this.hiddenInput.selectionDirection === "backward" ? this.hiddenInput.selectionStart : this.hiddenInput.selectionEnd;
			if (!xIdx) xIdx = 0; // ZIM NFT 00 Patch                
			if (rtl) xIdx = le-xIdx; 
			this.blinker.pos(this.textWidthArray[xIdx] + paddingH - 1 + ((align=="right" && this.text == "")?this.width:(align=="center" && this.text == "")?this.width/2:0) + shiftH, paddingV+shiftV);
			this.dispatchEvent("blinker");
		}
		if (this.stage) this.stage.update();
	}
	this.eventPositionGlobalToLocal = function(e) {
		var point = this.globalToLocal(e.stageX / zim.scaX, e.stageY / zim.scaY);		
		if (align=="right") {
			point.x -= this.label.x - this.width;
		} else if (align=="center") {
			point.x -= (this.label.x - this.width)/2;
		} else {
			point.x -= this.label.x; 
		}
		point.y -= this.label.y;
		return point;
	}
	this.mapPointToIndex = function(point) {
		var index = this.textWidthArray.length - 1;
		for (var i = 0; i < this.textWidthArray.length - 1; i++) {
			var charMidpoint = (this.textWidthArray[i] + this.textWidthArray[i + 1]) / 2;
			if (point.x <= charMidpoint) {
				index = i;
				break;
			}
		}
		return index;
	}
	this.measureText = function() {
		var dummyLabel = this.label.clone();
		var tt = this.text;
		if (rtl) tt = tt.split("").reverse().join("");
		var i = 0;
		while (i < tt.length && i < this.previousMeasuredText.length) {
			if (tt[i] !== this.previousMeasuredText[i]) break;
			i++;
		}
		this.textWidthArray = this.textWidthArray.slice(0, i + 1);
		for (i++; i <= tt.length; i++) {
			dummyLabel.text = tt.slice(0, i);
			this.textWidthArray.push(dummyLabel.getMeasuredWidth())
		}
		this.previousMeasuredText = tt;
		this.textHeight = dummyLabel.getMeasuredLineHeight();
	}
	this.setText = function(text, noEvent) {
		if (uppercase) text = text.toUpperCase();
		this.hiddenInput.value = text;
		this.onInput(null, noEvent);
	}
	Object.defineProperty(this, 'focus', {
		get: function() {
			return document.activeElement === that.hiddenInput
		},
		set: function(value) {
			if (value === true) that.hiddenInput.focus()
			else that.hiddenInput.blur()
		}
	});
	
	
	var frame;
	this.added(function(stage) {
		frame = stage.frame;
		that.zfe = that.hiddenInput.addEventListener("focus", that.onFocus.bind(that));
		that.zbe = that.hiddenInput.addEventListener("blur", that.onBlur.bind(that));
	});		
	that.zie = this.hiddenInput.addEventListener("input", this.onInput.bind(this));
	that.zse = this.hiddenInput.addEventListener("select", this.onSelect.bind(this));
	that.zke = this.hiddenInput.addEventListener("keydown", this.onKeydown.bind(this));
	document.body.appendChild(this.hiddenInput);

	that.zme = this.on("mousedown", this.onMousedown.bind(this));
	that.zpe = this.on("pressmove", this.onPressmove.bind(this));
	that.zde = this.on("dblclick", this.onDblclick.bind(this));

	this.cur("text");
	this.blinker = new zim.Rectangle({width:2, height:1, color:blinkerColor, style:false}).animate({
		obj:{alpha:0},
		wait:blinkerSpeed,
		time:0.1,
		rewind:true,
		rewindWait:blinkerSpeed,
		loop:true,
		loopWait:blinkerSpeed
	}).pauseAnimate(true).alp(0).addTo(this);

	this.selection = new zim.Rectangle({width:1, height:1, color:selectionColor, style:false}).alp(0).addTo(this);
	this.textWidthArray = [0];
	this.previousMeasuredText = "";
	this.textHeight = null;
	this.measureText();	

	// added ZIM 015
	this.dispose = function() {
		if (this.hiddenInput) return;
		this.hiddenInput.removeEventListener("focus", that.zfe);
		this.hiddenInput.removeEventListener("blur", that.zbe);			
		this.hiddenInput.removeEventListener("input", that.zie);
		this.hiddenInput.removeEventListener("select", that.zse);
		this.hiddenInput.removeEventListener("keydown", that.zke);
		this.hiddenInput.remove();
		this.hiddenInput = null;
		// all events directly on this will be removed in the label dispose with removeAllEventListeners()
		this.zimLabel_dispose(true);
	}

}
zim.extend(zim.TextInput.LabelInput, zim.Label, "dispose", "zimLabel", false);
//-54.2  
	

/*--
zim.List = function(width, height, list, viewNum, vertical, currentSelected, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, spacing, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, downColor, selectedColor, selectedRollColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, scrollBarOverlay, slide, slideFactor, slideSnap, slideSnapDamp, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, collapse, collapseColor, collapsed, excludeCustomTap, organizer, checkBox, pulldown, clone, cancelCurrentDrag, selectedIndex, noScale, pulldownToggle, optimize, keyEnabled, resizeHandle, resizeBoundary, resizeVisible, continuous, style, group, inherit)

List
zim class - extends a zim.Window which extends a zim.Container which extends a createjs.Container

DESCRIPTION
A vertical or horizontal list of items.
This is really a zim.Tabs object inside a zim.Window object.
The list can be strings, numbers or Label objects and these are added to Tabs buttons.
The list can also include any DisplayObject with bounds (which most ZIM objects have except a Shape needs bounds set manually with setBounds()).
If the object is not a string, number or Label then selection will not highlight and currently animateTo() may not work if size is different.
See: https://zimjs.com/explore/list.html
See: https://zimjs.com/explore/listObjects.html

ACCORDION
An accordion is a list with nested sections that expand open.
A special accordion object can be passed to the list parameter
that includes the menu items, styles for the sub menus
and properties to animate, shade and indent the sub menus.
See: https://zimjs.com/ten/accordion.html

CONTINUOUS 
As of ZIM 015 a List can be made continuous 
So it will continually wrap. The scrollbars will be removed for this.
See: https://zimjs.com/015/continuous.html

PULLDOWN AND LIST COMPONENTS
The pulldown parameter can be set to true to make list act like a pulldown
This hides the backdrop and border and can be set to be collapsed or expanded
There are component items available for slider, checkbox and colorPicker
See: https://zimjs.com/ten/pulldown.html
There is also a checkBox parameter to make a list of checkboxes
This acts like a multiple select list
See: https://zimjs.com/ten/listcheckbox.html

SPACING, PADDING, INDENTING
These adjust depending on vertical or horizontal settings
The spacing is the distance between items (default 2)
The padding is the distance around the items but not between (default spacing)
So changing the spacing can seem to change the padding - but that can be overridden
There is also paddingV and paddingH that can be adjusted (default padding)
Indent only works with custom items in the list in left, right alignment or top, bottom valignment
This moves the items away from their alignment
There is also label indenting for items with labels - and labelIndentV and labelIndentH

NOTE: List can have a ZIM Organizer added with the organizer parameter
The organizer lets the user add, remove and move items up, down, to the top or the bottom
See: https://zimjs.com/docs.html?item=organizer
See: https://zimjs.com/explore/organizer.html

NOTE: set the enable property to false as animating the position of the List object (or its parent Window)
then set the enable property to true on the animate call function.  See update() in Window docs for more

NOTE: to add ZIM Swipe() to objects in List set the overrideNoSwipe parameter of Swipe to true

NOTE: if animating the List off screen then either turn optimize:false 
or use list.update() in the "animation" event with the animate({events:true})
for a List in Pages use:
pages.on("pagetransitioned", ()=>{
	list.update();
});

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const list = new List({
	list:["Enormous", "Big", "Medium", "Small", "Puny"],
	viewNum:3, // this number will change the size of the list elements (default is 5)
}).center()
S.update();
END EXAMPLE

EXAMPLE
// make a pulldown - this must start with a name for the list 
// see https://zimjs.com/ten/pulldown.html for nested lists
const data = {
	"MONSTERS":["Ghost", "Ghoul", "Vampire", "Werewolf", "Skeleton"]
}
const list = new List({
	list:{menu:data, bloom:true, whither:true},
	pulldown:true,
	pulldownToggle:true // if want list to close when selected or stage is selected
}).center();
S.update();
END EXAMPLE

EXAMPLE
// make a list with a width of 300 be resizeable 
// from 100 width to 500 width
new List({
	width:500,
	align:LEFT,
	resizeHandle:true,
	resizeBoundary:new Boundary(0,0,-400,0)
}).resize(300).center()
END EXAMPLE

EXAMPLE 
const accordionData = {
	menu: {
		"Europe": ["London", "Paris", "Oslo"],
		"Canada": {
			"Ontario": {
				"Hamilton": {
					"Ancaster": [],
					"Dundas": [],
					"Westdale": []
				},
				"Toronto": [],
				"Ottawa": []
			},
			"British Columbia": ["Victoria", "Vancouver"],
			"Quebec": ["Montreal", "Quebec City"]
		},
		"United States": ["New York", "Atlanta", "San Francisco", "Portland"],
		"China": ["Bejing", "Hong Kong"],
		"Antarctica": []
	},
	shade: true,
	dim: true,
	shift: true,
	bloom: true,
	whither: true,
	subStyles: [
		{
			backgroundColor: red,
			color: white,
			rollBackgroundColor: purple,
			rollColor: white,
			selectedBackgroundColor: white,
			selectedColor: red,
			selectedRollBackgroundColor: purple,
			selectedRollColor: white
		}, {
			backgroundColor: blue,
			color: white,
			rollBackgroundColor: pink,
			rollColor: white,
			selectedBackgroundColor: black,
			selectedColor: white,
			selectedRollBackgroundColor: pink,
			selectedRollColor: white
		}, {
			backgroundColor: green,
			color: white,
			rollBackgroundColor: brown,
			rollColor: white,
			selectedBackgroundColor: black,
			selectedColor: white,
			selectedRollBackgroundColor: white,
			selectedRollColor: black
		}
	]
};

const list = new List({
	list: accordionData,
	titleBar: "PLACES",
	titleBarBackgroundColor: orange,
	titleBarColor: white,
	titleBarHeight: 40,
	scrollBarActive: false,
	currentSelected: false,
	indent: 20,
	height: 650,
	viewNum: 13.5,
	boundary: new Boundary(0, 0, W - 200, H - 200),
	borderWidth: -1,
	shadowBlur: -1,
	backdropColor: F.color,
})
	.loc(100, 90)
	.tap(()=>{
		const currentID = list.selected.listZID;
		const currentText = list.currentValue; 
		const parentID = list.tree.getParent(currentID);
		let parentText;
		if (parentID) parentText = list.tree.getData(parentID).obj;
		zog(currentID, currentText, parentID, parentText);
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 300) width of list
height - (default 200) height of list
list - (default Options 1-30) an array of strings, numbers or zim Label objects - these will be added to zim Tabs Buttons
	or include any DisplayObject with bounds - these will not get highlighted but will indicate a change event and selectedIndex
	currently objects with different sizes may not animateTo() properly - this will be fixed soon.
	A special Accordion object literal {} can be provided - see: https://zimjs.com/ten/accordion.html
		with the following properties:
		menu - a SIMPLE or COMPLEX hierarchy input - see ZIM Hierarchy() in the Code module
			note: if just providing the menu and the rest of the properties below are default
			then the Accordion object literal can be the SIMPLE or COMPLEX hierarchy input.
			In other words, no need to pass in {menu:{blah}} just pass in {blah}
		open - (default false) set to true to start the list opened
		shade - (default .2) the alpha of indented shade in sub menus - or false for no shading
		shift - (default 15) the pixels to indent the shade - and left or right aligned text of sub menus - or false for no indenting
		dim - (default .1) the alpha of dark background overlay on sub menus - or false for no dimming
		bloom - (default false) time in seconds for each submenu item to be added - or false to not animate sub menus in - if true default time is .1 second
		whither - (default false) time in seconds for each submenu item to be removed - or false to not animate sub menus out - if true default time is .1 second
		expander - (default "plus") set to "arrow" or "none" to change the expander icon - thanks Christopher Browne and Ofweird Top for the suggestions
		subStyles - (default null) an array of style objects for each sublevel - with all the color and background color properties
		See: https://zimjs.com/ten/accordion.html
	note: the Accordion List is currently incompatible with the Organizer, addTo() and removeFrom()
viewNum - (default 5) how many items to show in the width and height provided
	adjusting this number will also change the overall scale of custom items for horizontal lists 
    (this does not affect vertical lists due to the way vertical tabs are optimized)
	or see the noScale parameter to avoid scaling custom items in horizontal lists
	if no items are provided to start but rather added with addAt() then choose a viewNum that roughly matches how many items will fit in the view
vertical - (default true) set to false to make a horizontal list
currentSelected - (default false) set to true to show the current selection as highlighted
align - (default CENTER) horizontal align
	set to START to align LEFT for ZIM DIR constant is "ltr" or RIGHT when DIR="rtl" - END is the opposite
valign - (default CENTER) vertical align
labelAlign - (default CENTER) horizontal align of the label only
labelValign - (default CENTER) vertical align of the label only
labelIndent - (default indent) indent of label when align or valign is set - usually same as indent unless custom objects are in list
labelIndentH - (default indent) horizontal indent of label when align or valign is set
labelIndentV - (default indent) vertical indent of label when align or valign is set
indent - (default 10) indent of items when align or valign is set and there are custom objects in list
spacing - (default 2) is the pixels between tab buttons
backgroundColor - (default tin) the background color of the list elements (unless custom object)
rollBackgroundColor - (default grey) the background color of the list element as rolled over
selectedBackgroundColor - (default charcoal) the background color of the list element when selected
backdropColor - (default dark) the background color of the list window (any CSS color)
color - (default white) the text color of a deselected list element when not rolled over
rollColor - (default color) the rollover color
selectedColor - (default color) the text color of the selected list element
selectedRollColor - (default color) the text color of the rolled over selected list element
borderColor - (default silver) border color
borderWidth - (default 1) the thickness of the border
padding - (default 0) places the content in from edges of border (see paddingH and paddingV)
corner - (default 0) is the rounded corner of the list (does not accept corner array - scrollBars are too complicated)
swipe - (default auto/true) the direction for swiping set to none / false for no swiping
	also can set swipe to just vertical or horizontal
scrollBarActive - (default true) shows scrollBar (set to false to not)
scrollBarDrag - (default true) set to false to not be able to drag the scrollBar
scrollBarColor - (default borderColor) the color of the scrollBar
scrollBarAlpha - (default .3) the transparency of the scrollBar
scrollBarFade - (default true) fades scrollBar unless being used
scrollBarH - (default true) if scrolling in horizontal is needed then show scrollBar
scrollBarV - (default true) if scrolling in vertical is needed then show scrollBar
scrollBarOverlay - (default true) set to false to not overlay the scrollBar on the content
	overlaying could hide content - but without overlay, content less than window size will show gap when no scrollBar
slide - (default true) Boolean to throw the content when drag/swipe released
slideFactor - (default .95) is the factor multiplied by dragging velocity (1 no slowing, .7 fast slowing)
slideSnap - (default true) slides past boundary and then snaps back to boundary when released - also VERTICAL, HORIZONTAL, and false
slideSnapDamp - (default .1) the damping to snap back to boundary
shadowColor - (default rgba(0,0,0,.3)) the color of the shadow
shadowBlur - (default 20) set shadowBlur to -1 for no drop shadow
paddingH - (default padding) places content in from left and right
paddingV - (default padding) places content in from top and bottom
scrollWheel - (default true) scroll vertically with scrollWheel
damp - (default null) set to .1 for instance to damp the scrolling
titleBar - (default null - no titleBar) a String or ZIM Label title for the list that will be presented on a titleBar across the top
titleBarColor - (default black) the text color of the titleBar if a titleBar is requested
titleBarBackgroundColor - (default "rgba(0,0,0,.2)") the background color of the titleBar if a titleBar is requested
titleBarHeight - (default fit label) the height of the titleBar if a titleBar is requested
draggable - (default true if titleBar) set to false to not allow dragging titleBar to drag list
boundary - (default null) set to ZIM Boundary() object - or CreateJS.rectangle()
onTop - (default true) set to false to not bring list to top of container when dragging
close - (default false) - a close X for the top right corner that closes the list when pressed
closeColor - (default grey) - the color of the close X if close is requested
collapse - (default false) - set to true to add a collapse button to the titleBar that reduces the list so only the bar shows and adds a button to expand
collapseColor - (default grey) - the color of the collapse icon
collapsed - (default false) set to true to start the list collapsed
excludeCustomTap - (default false) set to true to exclude custom buttons from tap() which would override existing tap() on the custom buttons
organizer - (default null) the ZIM Organizer for the list
checkBox - (default false) set to true to turn labeled list into a list of ZIM CheckBox objects - thanks Dale789 for the prompting!
	See: https://zimjs.com/ten/listcheckbox.html
	use selected.checkBox to get access to the selected CheckBox
	use the checkBoxes property to get a list of the CheckBox objects
	use setCheck(index, type), setChecks(type), getCheck(index) methods to manipulate
	use STYLE to set CheckBox size
pulldown - (default false) set to true to have List act like a Pulldown
	use tapClose and offClose parameters to optionally adjust behaviour 
	See: https://zimjs.com/ten/pulldown.html
clone - (default false) set to true to add clones of the list items rather than the items themselves
cancelCurrentDrag - (default false) - set to true to cancel window dragging when document window loses focus
	this functionality seems to work except if ZIM is being used with Animate - so we have left it turned off by default
selectedIndex - (default 0) - set the selectedIndex at start - set to -1 for no selection
noScale - (default false) - set to true to not scale custom items - this ignores viewNum
pulldownToggle - (default false) - set to true to collapse list in pulldown mode when final item is selected or pressing off list
optimize - (default true) set to false to not turn DisplayObjects that are not on the stage visible false 
	as the Window is scrolled, any objects within the content and any objects within one level of those objects 
	are set to visible false if their bounds are not hitting the stage bounds
resizeHandle - (default false) - set to true to rollover bottom right corner to resize list with resizeHandle
	currently, the List content does not automatically expand 
	so create the list with a width as wide as it will go 
	then call the resize() method to start the list at the desired width
resizeBoundary - (default null) add a ZIM Boundary() object for the resize handle - relative to the resize handle start position
	new Boundary(-100, 0, 200, 0) - would allow the resize handle to move to the left or right 100 pixels but not up or down
	new Boundary(0, -100, 0, 200) - would allow the resize handle to move to up or down 100 pixels but not left or right 
	new Boundary(0,0,100,100) - would allow the list to expand in x or y 100 pixels but not grow smaller
	new Boundary(-100,-100,100,100) - would allow the list to shrink in x or y 100 pixels but not grow bigger
resizeVisible - (default false) set to true to always see the resizeHandle - if resizeHandle is set to true
continuous - (default false) set to true to make the list scroll continuously - should have more elements than the viewNum for this
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
animateTo(index, timePerItem) - animate list to index at given time per item (default 50ms) - returns object for chaining
addAt(items, index, style, clone) - an array of items to insert at an index in the list - returns object for chaining
	if the list is made with no items to start and items are added with addAt() then set the List() viewNum parameter value to match roughly how many items will fit in view
	clone defaults to false - set to true to add a clone of the item or items to the list
	note: does not support continuous at this time (whereas removeAt() does support continuous)
removeAt(number, index) - remove a number of elements (default 1) from the list starting at and including the index - returns object for chaining
	note: does support continuous (whereas addAt() does not support continuous)
clear() - clears the list
first() - select first list element - returns object to chain
last() - select last list element - returns object to chain
toggle(state, element) - for an accordion, will close the accordion if open or open if closed 
	passing in true will open (or keep opened), passing in false will close (or keep closed)
	if no element is provided then it will assume the root (outer) element
	if the element has no children then its parent element will be opened or closed
	also see toggled property (which only works on the root element)
	note - in pulldown mode cannot call toggle() from change or tap methods - see pulldownToggle parameter instead
setCheck(index, type) - set the CheckBox at an index to true or false (the type parameter)
setChecks(type) - set all CheckBoxes to true or false (the type parameter) returns object for chaining
getCheck(index) - get the checked value of the CheckBox at an index
cancelCurrentDrag() - stop current drag on list - but add dragging back again for next drag
collapse(state) - state defaults to true to collapse or set to false to expand collapsed list
	must start with the collapse parameter set to true
	also see collapsed property
openAtLevel(level) - open a level of an accordion list
 	level 0 shows first level, 1 shows second level, etc.
openAtId(idNum) - open an accordion list at a specific id number 
	view the tree property in the console (F12) and expand the data property to see ids 
	and then expand any ids to see more ids nested inside
	the idNum should be something like 6 or 12 without the word id.
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

COMPONENT LIST ITEMS
These static methods make special List items with components
See: https://zimjs.com/ten/pulldown.html
Each may have a label, min, max, starting val, steps, etc.
Each has a call parameter for the function to call when the component changes
There are alternatively obj and property parameters
Setting these will change the property of the obj to the value of the component
Each will be given a call property of the call function
This can be changed dynamically if desired.

List.slider(label, min, max, val, call, step, decimals, obj, property, paddingLeft, paddingRight, factor, offset, backgroundColor)
	A static method (use it like List.slider("fps", 0, 60, 20, doFps)) to make a slider List item
    decimals defaults to 0 so if using decimals set to 1, 2, 3, etc. to adjust the decimals on the stepper (at right)
	factor will multiply the slider value only in the stepper
	offset will start the stepper offset by that amount 
	this lets the stepper value be factored and offset from the actual slider value
List.checkBox(label, checked, call, obj, property, paddingLeft, paddingRight, backgroundColor)
	A static method (use it like List.checkBox("visible", checked, doVisible)) to make a checkBox List item
List.colorPicker(label, color, picker, call, obj, property, paddingLeft, paddingRight, backgroundColor)
	A static method (use it like List.colorPicker("color", red, docColor)) to make a colorPicker List item
	picker is an optional custom ZIM ColorPicker

This static method is used internally by the checkBox parameter of List
It can be used to create a checkBox list element - but also see List.checkBox() above
which is a little different and matches the format of the other List Items
List.checkItem(text, width, paddingH, paddingV, color, rollColor, backgroundColor, rollBackgroundColor, selectedColor, selectedRollColor, selectedBackgroundColor, selectedRollBackgroundColor)
	A static method (use it like List.checkItem("hello", 30, 300, 10, 10, white, etc.))
	To add a checkItem to a plain list use:
	new List({list:["goodbye", List.checkItem("hello", 30, 300, 10, 10, white), "what?"]})

ALSO: All Window methods such as resize()

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - get or set the index of the selected list element
selectedIndexPlusPosition set the index and scroll the index into view - might be broken for lists with custom objects of different heights
accordionIndex - read only index of the selected item inside an accordion otherwise is undefined
selected - gets the current selected list object (ie. a Button)
	use selected.checkBox to access the selected CheckBox if checkBox parameter is true
	if custom objects are in the list then use selected.content to access the custom object
	list.selected.listZID will give the list id in the tree hierarchy
	list.tree.getData(list.selected.listZID).obj.text would get the text of the button - or just use list.currentValue
currentValue - gets or sets the current value - in setting, it matches the first label that has the value anywhere in it
text - gets or sets the current selected label text
label - gets current selected label object
items (or list) - read-only array of list button objects or objects in the list
	this will change from the list entered as parameters as strings are turned into tab buttons, etc.
	use addAt() and removeAt() methods to manipulate
	custom items can be accessed using item.content - as the item is a container with a backing then content
	each item has the following properties:
		index, label, expander (Label for accordion +- or arrows), listZID (see Hierarchy) and other properties depending on the item
checkBoxes - read-only array of CheckBox objects if checkBox parameter is true
itemsText - read-only array of text for labels (or null element if no label)
itemWidth - the width of each item (unless custom items)
itemHeight - the height of each item (unless custom items)
length - read-only length of the list
tabs - a reference to the tabs object used in the list
organizer - a reference to the organizer object if used
originalList - if an accordion object is provided this is the reference to that object 
tree - if an accordion object is provided this is the active tree data
	this will also give ids that can be used with the openAtId(idNum) method
vertical - read-only true if list is vertical or false if horizontal
toggled - for accordion get or set whether the main (root) accordion is open (true) or closed (false)
	also see toggled() chainable method for more options
	note - in pulldown mode cannot call toggled from change or tap methods - see pulldownToggle parameter instead	
collapseIcon - access to the ZIM Shape if there is a collapse triangle
collapsed - get or set whether the list is collapsed - must start with collapse parameter set to true
	also see collapse() method
enabled - default is true - set to false to disable

ALSO: see all Window properties - like titleBar, titleBarLabel, resizeHandle, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event - then use selectedIndex or text to find data
dispatches a "bloom" event for each item that is created when blooming
 	this receives an event object with an item property for the list item that was just opened
dispatches an "expanded" event when items have been expanded 
	this receives an event object with an items property of the items just opened 
dispatches a "collapsed" event when items have been collapsed

ALSO: All Window events including "scrolling"

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+60.5

	zim.List = function(width, height, list, viewNum, vertical, currentSelected, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, spacing, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, downColor, selectedColor, selectedRollColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, scrollBarOverlay, slide, slideFactor, slideSnap, slideSnapDamp, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, collapse, collapseColor, collapsed, excludeCustomTap, organizer, checkBox, pulldown, clone, cancelCurrentDrag, selectedIndex, noScale, pulldownToggle, optimize, keyEnabled, resizeHandle, resizeBoundary, resizeVisible, continuous, style, group, inherit) {
		var sig = "width, height, list, viewNum, vertical, currentSelected, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, spacing, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, downColor, selectedColor, selectedRollColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, scrollBarOverlay, slide, slideFactor, slideSnap, slideSnapDamp, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, collapse, collapseColor, collapsed, excludeCustomTap, organizer, checkBox, pulldown, clone, cancelCurrentDrag, selectedIndex, noScale, pulldownToggle, optimize, keyEnabled, resizeHandle, resizeBoundary, resizeVisible, continuous, style, group, inherit";
		var duo; if (duo = zob(zim.List, arguments, sig, this)) return duo;
		z_d("60.5");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("List", this.group, inherit);

		if (zot(width)) width=DS.width!=null?DS.width:300;
		var oHeight = height;
		if (zot(height)) height=DS.height!=null?DS.height:!zot(organizer)?200+organizer.height:200;
		if (zot(list)) list = list=DS.list!=null?DS.list:["Option 1", "Option 2", "Option 3", "Option 4", "Option 5", "Option 6", "Option 7", "Option 8", "Option 9", "Option 10"];
		if (list.length == 0) list=["%-&"];
		this.originalList = list;
		if (zot(viewNum)) viewNum=DS.viewNum!=null?DS.viewNum:5;
		if (zot(vertical)) vertical=DS.vertical!=null?DS.vertical:true;
		if (zot(currentSelected)) currentSelected=DS.currentSelected!=null?DS.currentSelected:true;
		var originalAlign = !zot(align) || !zot(labelAlign);
		if (zot(checkBox)) checkBox=DS.checkBox!=null?DS.checkBox:false;
		if (zot(align)) align=DS.align!=null?DS.align:(checkBox?"left":"center");
		if (zot(valign)) valign=DS.valign!=null?DS.valign:"center";
		if (zot(labelAlign)) labelAlign=DS.labelAlign!=null?DS.labelAlign:align;
		if (zot(labelValign)) labelValign=DS.labelValign!=null?DS.labelValign:valign;

		if (zot(indent)) indent=DS.indent!=null?DS.indent:(checkBox?0:10);
		if (zot(labelIndent)) labelIndent=DS.labelIndent!=null?DS.labelIndent:indent;
		if (zot(labelIndentH)) labelIndentH=DS.labelIndentH!=null?DS.labelIndentH:labelIndent;
		if (zot(labelIndentV)) labelIndentV=DS.labelIndentV!=null?DS.labelIndentV:labelIndent;

		if (zot(spacing)) spacing=DS.spacing!=null?DS.spacing:2;
		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:zim.dark;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.tin;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.grey;
		if (zot(downBackgroundColor)) downBackgroundColor = DS.downBackgroundColor!=null?DS.downBackgroundColor:rollBackgroundColor;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor = DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.charcoal;
		if (zot(selectedRollBackgroundColor)) selectedRollBackgroundColor = DS.selectedRollBackgroundColor!=null?DS.selectedRollBackgroundColor:zim.grey;
		if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(downColor)) downColor = DS.downColor!=null?DS.downColor:rollColor;
		if (zot(selectedColor)) selectedColor = DS.selectedColor!=null?DS.selectedColor:color;
		if (zot(selectedRollColor)) selectedRollColor = DS.selectedRollColor!=null?DS.selectedRollColor:rollColor;
		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:backdropColor;

		var originalBorderColor = borderColor;
		var originalBorderWidth = borderWidth;
		if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:zim.silver;
		if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:1; // 0
		// if (vertical && zot(padding) && zot(paddingV)) paddingV = spacing;
		// if (!vertical && zot(padding) && zot(paddingH)) paddingH = spacing;
		if (zot(padding)) padding=DS.padding!=null?DS.padding:spacing;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:0;
		if (zot(swipe)) swipe=DS.swipe!=null?DS.swipe:true; // true / auto, vertical, horizontal, false / none
		if (zot(scrollBarActive)) scrollBarActive=DS.scrollBarActive!=null?DS.scrollBarActive:true;
		if (zot(scrollBarDrag)) scrollBarDrag=DS.scrollBarDrag!=null?DS.scrollBarDrag:true;
		if (zot(scrollBarColor)) scrollBarColor=DS.scrollBarColor!=null?DS.scrollBarColor:borderColor;
		if (zot(scrollBarAlpha)) scrollBarAlpha=DS.scrollBarAlpha!=null?DS.scrollBarAlpha:.3;
		if (zot(scrollBarFade)) scrollBarFade=DS.scrollBarFade!=null?DS.scrollBarFade:true;
		if (zot(scrollBarH)) scrollBarH = DS.scrollBarH!=null?DS.scrollBarH:!vertical;
		if (zot(scrollBarV)) scrollBarV = DS.scrollBarV!=null?DS.scrollBarV:vertical;
		if (scrollBarDrag) scrollBarFade = DS.scrollBarFade!=null?DS.scrollBarFade:false;
		if (zot(scrollBarOverlay)) scrollBarOverlay = DS.scrollBarOverlay!=null?DS.scrollBarOverlay:true;
		if (zot(slide)) slide=DS.slide!=null?DS.slide:true;
		if (zot(slideFactor)) slideFactor=DS.slideFactor!=null?DS.slideFactor:.95;
		if (zot(slideSnap)) slideSnap=DS.slideSnap!=null?DS.slideSnap:vertical?"vertical":"horizontal"; // true / auto, vertical, horizontal, false / none
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:20;
		if (zot(paddingV)) paddingV=DS.paddingV!=null?DS.paddingV:padding;
		if (zot(paddingH)) paddingH=DS.paddingH!=null?DS.paddingH:padding;
		if (zot(scrollWheel)) scrollWheel = DS.scrollWheel!=null?DS.scrollWheel:true;
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:null;
		if (zot(titleBarColor)) titleBarColor = DS.titleBarColor!=null?DS.titleBarColor:null;
		if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = DS.titleBarBackgroundColor!=null?DS.titleBarBackgroundColor:null;
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:35;
		if (zot(draggable)) draggable = DS.draggable!=null?DS.draggable:null;
		if (zot(boundary)) boundary = DS.boundary!=null?DS.boundary:null;
		if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:null;
		if (zot(close)) close = DS.close!=null?DS.close:null;
		if (zot(closeColor)) closeColor = DS.closeColor!=null?DS.closeColor:null;
		if (zot(collapse)) collapse = DS.collapse!=null?DS.collapse:null;
		if (zot(collapseColor)) collapseColor = DS.collapseColor!=null?DS.collapseColor:null;
		if (zot(excludeCustomTap)) excludeCustomTap = DS.excludeCustomTap!=null?DS.excludeCustomTap:false;
		if (zot(checkBox)) checkBox = DS.checkBox!=null?DS.checkBox:false;
		if (zot(pulldown)) pulldown = DS.pulldown!=null?DS.pulldown:false;		
		if (zot(pulldownToggle)) pulldownToggle = DS.pulldownToggle!=null?DS.pulldownToggle:false;
		if (zot(noScale)) noScale = DS.noScale!=null?DS.noScale:false;
		if (zot(clone)) clone = DS.clone!=null?DS.clone:false;
		if (zot(optimize)) optimize = DS.optimize!=null?DS.optimize:true;
		if (zot(keyEnabled)) keyEnabled = DS.keyEnabled!=null?DS.keyEnabled:null;
		if (zot(resizeHandle)) resizeHandle = DS.resizeHandle!=null?DS.resizeHandle:null;
		if (zot(resizeBoundary)) resizeBoundary = DS.resizeBoundary!=null?DS.resizeBoundary:null;
		if (zot(resizeVisible)) resizeVisible = DS.resizeVisible!=null?DS.resizeVisible:false;
		if (zot(continuous)) continuous = DS.continuous!=null?DS.continuous:false;

		if (titleBar === false) titleBar = null;
		this.vertical = vertical;
		
		var that = this;
		var originalHeight = height;
		
		// handle DIR effect 
		if ((WW.DIR && WW.DIR=="rtl") || (!WW.DIR && zim.DIR=="rtl")) {
			if (align=="start") align="right";
			else if (align=="end") align="left";
		} else {
			if (align=="start") align="left";
			else if (align=="end") align="right";
		}

		var listW;
		if (continuous) {
			that.continuous = true;
			listW = zim.copy(list);
			zim.loop(list.length, function(i) {
				if (list[i].clone) listW.push(list[i].clone());
				else listW.push(list[i]);
			});
		} else {
			listW = list;
		}

		// handle possible checkboxes
		if (checkBox) {
			zim.loop(listW, function (item, i) {
				if (listW[i]=="%-&") return;
				listW[i] = zim.List.checkItem(item, null, width, "left", 10, 10, spacing, color, rollColor, selectedColor, selectedRollColor, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor);
			});
		}

		var timeType = getTIME();

		// handle possible accordion data
		var tree;
		if (listW.constructor == {}.constructor) {
			var shade = !zot(listW.shade)?listW.shade:!zot(DS.shade)?DS.shade:.2;
			var dim = !zot(listW.dim)?listW.dim:!zot(DS.dim)?DS.dim:.1;
			var shift = !zot(listW.shift)?listW.shift:!zot(DS.shift)?DS.shift:15;
			var bloom = !zot(listW.bloom)?listW.bloom:!zot(DS.bloom)?DS.bloom:false;
			var whither = !zot(listW.whither)?listW.whither:!zot(DS.whither)?DS.whither:false;
			var open = !zot(listW.open)?listW.open:!zot(DS.open)?DS.open:false;			
			var expander = !zot(listW.expander)?listW.expander:!zot(DS.expander)?DS.expander:"plus";
			expander = expander.toLowerCase();
			if (expander == "arrows") expander = "arrow";
			if (expander != "none" && expander != "arrow") expander = "plus";
			if (bloom === true) bloom = timeType=="s"?.01:10;
			if (whither === true) whither = timeType=="s"?.01:10;
			checkTIME(bloom);
			checkTIME(whither);
			if (shift === true) shift = 15;
			if (shade === true) shade = .2;
			if (dim === true) dim = .1;
			var subStyles = !zot(listW.subStyles)?listW.subStyles:!zot(DS.subStyles)?DS.subStyles:{};
			if (!zot(listW.menu)) {
				listW = listW.menu;
			}
			// how to handle if final hierarchy data is submitted
			tree = that.tree = new zim.Hierarchy(listW);
			// as of ZIM ZIM 01 patch, open is handled after created with openAtLevel()
			// if (open && tree.data && tree.data.id0) tree.data.id0.open = false;
			listW = tree.getLinearList();
			if (!originalAlign) align = labelAlign = "left";
		}

		// PULLDOWN
		if (pulldown) {
			viewNum = (!zot(tree)?tree.length:listW.length);		
			if (zot(oHeight)) height = viewNum * width/620*100 + (viewNum+1)*spacing + (zot(titleBar)?0:titleBarHeight);	
			borderWidth = 0;
			selectedBackgroundColor = backgroundColor;
			backdropColor = zim.clear;
			swipe = false;
		}


		var customWidth=0;
		var customHeight=0;
		zim.loop(listW, function(element) {
			if (element.type == "ListItem") element.width = width - spacing*2;
			if (noScale) {
				if (element.width) customWidth+=element.width;
				if (element.height) customHeight+=element.height;
			}
		});
		if (customWidth) customWidth += spacing*(listW.length-1);
		if (customHeight) customHeight += spacing*(listW.length-1);

		this.align = align;
		this.valign = valign;
		this.indent = indent;

		if (!zot(organizer)) {
			height = height - organizer.height;
			organizer.list = that;
			that.organizer = organizer;
			organizer.setButtons();
			titleBarHeight += organizer.height;
		}
		if (continuous) scrollBarActive = false;
		this.zimWindow_constructor(width, height, null, backdropColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, slide, slideFactor, slideSnap, slideSnapDamp, true, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, cancelCurrentDrag, false, null, resizeHandle, collapse, collapseColor, collapsed, optimize, resizeBoundary, resizeVisible, continuous?(vertical?"vertical":"horizontal"):null, style, group, zim.copy(DS));
		this.type = "List";

		if (!zot(titleBar)) {
			// add above organizer...
			this.titleBarLabel.pos(null,titleBarHeight-30,null,true);
			if (zot(titleBarHeight)) titleBarHeight = 30;
			height = height - titleBarHeight;
		}
		
		if (!zot(organizer)) {
			organizer.addTo(that).loc(0,-organizer.height);
		}

       
		if (customWidth && noScale) {
			that.itemWidth = vertical?(width-paddingH*2-(scrollBarActive?(scrollBarOverlay?0:6):0)):customWidth/listW.length;
			that.itemHeight = vertical?customHeight/listW.length:(height-paddingV*2-(scrollBarActive?(scrollBarOverlay?0:6):0));		
			// that.itemWidth = vertical?(width-(scrollBarActive?(scrollBarOverlay?0:6):0)):customWidth/listW.length;
			// that.itemHeight = vertical?customHeight/listW.length:(height-(scrollBarActive?(scrollBarOverlay?0:6):0));	
			
		} else {
			that.itemWidth = vertical?(width-paddingH*2-(scrollBarActive?(scrollBarOverlay?0:6):0)):(width-paddingH*2)/viewNum;
			that.itemHeight = vertical?(height-paddingV*2)/viewNum:(height-paddingV*2-(scrollBarActive?(scrollBarOverlay?0:6):0));
			// that.itemWidth = vertical?(width-(scrollBarActive?(scrollBarOverlay?0:6):0)):(width)/viewNum;
			// that.itemHeight = vertical?(height)/viewNum:(height-(scrollBarActive?(scrollBarOverlay?0:6):0));			
		}
    
		var tabs;
		var inheritedStyles = zim.copy(DS);
		delete inheritedStyles.borderWidth;
		delete inheritedStyles.borderColor;
		function makeTabs(tabList) {
			tabs = that.tabs = new zim.Tabs({
				width:vertical?that.itemWidth:(that.itemWidth*listW.length),
				height:vertical?that.itemHeight*listW.length:that.itemHeight,
				tabs:tabList,
				spacing:spacing,
				vertical:vertical,
				backgroundColor:backgroundColor,
				rollBackgroundColor:rollBackgroundColor,
				downBackgroundColor:downBackgroundColor,
				selectedBackgroundColor:selectedBackgroundColor,
				selectedRollBackgroundColor:selectedRollBackgroundColor,
				color:color,
				rollColor:rollColor,
				downColor:downColor,
				selectedColor:selectedColor,
				selectedRollColor:selectedRollColor,
				backdropColor:backdropColor,
				currentEnabled:true,
				currentSelected:currentSelected,
				align:align,
				valign:valign,
				labelAlign:labelAlign,
				labelValign:labelValign,
				labelIndent:labelIndent,
				labelIndentH:labelIndentH,
				labelIndentV:labelIndentV,
				indent:indent,
				useTap:true,
				excludeCustomTap:excludeCustomTap,
				keyWrap:false,
				keyEnabled:keyEnabled,				
				style:style,
				group:group,
				inherit:inheritedStyles
			})			
				.siz(vertical?width-paddingH*2:null, vertical?null:height-paddingV*2)	
				// .mov(vertical?0:(spacing+2),vertical?(spacing+2):0);
				.mov(vertical?0:paddingH,vertical?paddingV:0);
				// var b = tabs.getBounds();
				// tabs.setBounds(0,0,vertical?b.width:(b.width+spacing*2+4),vertical?(b.height+spacing*2+4):b.height);
			that.add(tabs);            
			// tabs.loc(paddingH, paddingV)
			zim.loop(tabs.labels, function (label) {				
				if (label) label.backgroundColor = zim.clear;
			});
		}
		makeTabs(zim.copy(listW, clone));

		if (continuous) {
			that.on("scrolling", function() {
				var point = that.tabs.localToLocal(0,0,that);
				if (vertical) {
					if (point.y >= -that.tabs.buttons[0].height) {that.tabs.y -= that.tabs.height/2 + spacing/2}
					if (point.y - that.tabs.buttons[that.tabs.buttons.length-1].height <= height - that.tabs.height) {that.tabs.y += that.tabs.height/2 + spacing/2}
				
				} else {
                    if (point.x >= -that.tabs.buttons[0].width) {that.tabs.x -= that.tabs.width/2 + spacing/2}
					if (point.x - that.tabs.buttons[that.tabs.buttons.length-1].width <= width - that.tabs.width) {that.tabs.x += that.tabs.width/2 + spacing/2}
				}
				// zog(point.y)
				// zogy(that.tabs.buttons[0].height, that.tabs.buttons[that.tabs.buttons.length-1].height)
				// zog(vertical, height)
			})
			// if (that.tile.x >= -itemWidth) {that.tile.x -= that.tile.width/2 + spacing/2}
			// if (that.tile.x - itemWidth <= cw - that.tile.width) {that.tile.x += that.tile.width/2 + spacing/2}
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// TREE				
		function applyAccordion(item, id, data) {			
			item.listZID = id;
			if (item.label) {
				if (shade) new zim.Rectangle(shift*(data.level+1), item.height).alp(shade).pos(0,0,that.align=="right",false,item);
				if (dim) new zim.Rectangle(item.width, item.height).alp((data.level+1)*dim).addTo(item).bot().ord(1);
				if (shift && that.align!="center") item.label.x += (that.align=="right"?-1:1)*shift*(data.level+1);
			}
			var newData = tree.getData(id);
			newData.obj = item;
			if (newData.list && !zim.isEmpty(newData.list)) {
				// item.expander = new Label({text:(newData.open?"-":"+"), align:"center", color:convertColor(color, "rgba", .6)})
				item.expander = new zim.Label({size:expander=="arrow"?22:36, text:(newData.open?(expander=="arrow"?"▲":"-"):(expander=="arrow"?"▼":"+")), align:"center", color:zim.convertColor(color, "rgba", .6)})
					.center(item).alp(expander=="none"?0:.7).pos(15, null, that.align!="right")
					.mov(0,(newData.open?-3:0));
			}
		}

		function tapList() {						
			if (!that.selected || !that.selected.expander) return;
			var data = tree.getData(that.selected.listZID);
			var count;
			if (data.open) { // close				
				if (that.selected.expander) {
					// that.selected.expander.text = "+";
					that.selected.expander.text = expander=="arrow"?"▼":"+";
					that.selected.expander.mov(0,3);
				}
				data.open = false;
				var nextSibling = tree.getNextSibling(that.selected.listZID);
				var finalIndex;
				if (zot(nextSibling)) finalIndex = that.items.length-1;
				else {
					finalIndex = zim.loop(that.items, function (item, i) {
						if (item.listZID == nextSibling) return i-1;
					});
				}
				if (whither) {
					count = 0;
					that.enabled = false;
					zim.interval(whither, function (obj) {
						that.removeAt(1, that.selectedIndex+finalIndex-that.selectedIndex-count);
						count++;
						if (obj.total == obj.count+1) {
							that.enabled = true;							
							that.dispatchEvent("collapsed");
						}
					}, finalIndex-that.selectedIndex, true);
				} else {
					that.removeAt(finalIndex-that.selectedIndex, that.selectedIndex+1);
					that.dispatchEvent("collapsed");
				}
			} else { // open
				data.open = true;
				if (that.selected.expander) {
					// that.selected.expander.text = "-";
					that.selected.expander.text = expander=="arrow"?"▲":"-";
					that.selected.expander.mov(0,-3);
				}	
				var outer = tree.getLinearList(data.list);
				var ids = tree.getLinearIDs(data.list);
				var e;
				if (!data.opened) {
					data.opened = true;
					var newStyles = subStyles[data.level];
					if (zot(newStyles)) newStyles = {};
					if (Array.isArray(outer)) {
						if (bloom) {
							count = 0;
							that.enabled = false;
							zim.interval(bloom, function (obj) {
								that.addAt(outer[count], that.selectedIndex+1+count, {
									backgroundColor:newStyles.backgroundColor,
									color:newStyles.color,
									rollBackgroundColor:newStyles.rollBackgroundColor,
									rollColor:newStyles.rollColor,
									selectedBackgroundColor:newStyles.selectedBackgroundColor,
									selectedColor:newStyles.selectedColor,
									selectedRollBackgroundColor:newStyles.selectedRollBackgroundColor,
									selectedRollColor:newStyles.selectedRollColor
								});
								var id = ids[count];
								var item = that.items[that.selectedIndex+1+count];
								if (newStyles.borderColor) item.borderColor = newStyles.borderColor;
								applyAccordion(item, id, data);
								if (item.label) item.label.backgroundColor = zim.clear;
								e = new createjs.Event("bloom");
								e.item = item;
								that.dispatchEvent(e);
								if (obj.total == obj.count+1) {
									that.enabled = true;
									e = new createjs.Event("expanded");
									e.items = outer;
									that.dispatchEvent(e);
								}
								count++;
								if (that.stage) that.stage.update();
							}, outer.length, true);
						} else {
							that.addAt(outer, that.selectedIndex+1, {
								backgroundColor:newStyles.backgroundColor,
								color:newStyles.color,
								rollBackgroundColor:newStyles.rollBackgroundColor,
								rollColor:newStyles.rollColor,
								selectedBackgroundColor:newStyles.selectedBackgroundColor,
								selectedColor:newStyles.selectedColor,
								selectedRollBackgroundColor:newStyles.selectedRollBackgroundColor,
								selectedRollColor:newStyles.selectedRollColor
							});
							zim.loop(ids, function (id, i) {
								var item = that.items[that.selectedIndex+1+i];
								applyAccordion(item, id, data);
								if (item.label) item.label.backgroundColor = zim.clear;
							});
							e = new createjs.Event("expanded");
							e.items = outer;
							that.dispatchEvent(e);
						}
					}
				} else {
					if (Array.isArray(outer)) {
						if (bloom) {
							count = 0;
							that.enabled = false;
							zim.interval(bloom, function (obj) {
								that.addAt(outer[count], that.selectedIndex+1+count);
								// that.selectedIndexPlusPosition = that.selectedIndex;
								e = new createjs.Event("bloom");
								e.item = outer[count];
								that.dispatchEvent(e);
								if (obj.total == obj.count+1) {
									that.enabled = true;
									e = new createjs.Event("expanded");
									e.items = outer;
									that.dispatchEvent(e);
								}
								count++;
							}, outer.length, true);
						} else {
							that.addAt(outer, that.selectedIndex+1);
							e = new createjs.Event("expanded");
							e.items = outer;
							that.dispatchEvent(e);
						}
					}
				}
			}
		} // end tapList

		that.updateTree = function() {
			tapList();
		}
		
		that.expandList = function(num) {
			that.selectedIndex = num;
			// that.selected = that.items[2];
			if (that.selected) tapList();
			return that.selected;
		}

		var stage;
		if (tree) {			
			if (pulldownToggle) {
				that.added(function(theStage){		
					stage = theStage;
					// handle pressing off pulldown if pulldownToggle			
					that.stageToggleEvent = stage.on("stagemousedown", function () {
						var objUnder = stage.getObjectUnderPoint(stage.frame.mouseX, stage.frame.mouseY);
						if (objUnder && that.contains(objUnder)) return;					
						if (!that.enabled || !that.selected) return;
						var data = tree.getData(that.selected.listZID);
						if (data.open) tapList();				
					});
				});				
			}

			var ids = tree.getLinearIDs();
			zim.loop(ids, function (id, i) {
				that.tabs.buttons[i].listZID = id;
			});

			// add these to single accordion object literal along with styles and data?
			// and then pass in to list parameter?

			zim.loop(that.tabs.buttons, function (item) {
				var data = tree.getData(item.listZID);
				// if (!isEmpty(data.list)) item.expander = new Label({size:22, text:"▼", align:"center", color:convertColor(color, "rgba", .6)}).center(item).alp(.7).pos(15, null, that.align!="right");
				if (!zim.isEmpty(data.list)) item.expander = new zim.Label({size:expander=="arrow"?22:36, text:expander=="arrow"?"▼":"+", align:"center", color:zim.convertColor(color, "rgba", .6)}).center(item).alp(expander=="none"?0:.7).pos(15, null, that.align!="right");
			});
		
			var _toggled = open;
			that.toggle = function(state) {
				if (zot(state)) state = !_toggled;
				else if (state == _toggled) return;		
				that.selectedIndex = 0;	
				_toggled = state;
				tapList();
			} 
			
			Object.defineProperty(that, 'toggled', {
				get: function() {
					return _toggled;
				},
				set: function(value) {
					if (_toggled == value) return;
					else that.toggle();
				}
			});

			that.tap(tapList);
		}

		//~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		var _selectedIndex;
		tabs.tap(function (e) {
			if (e.target.selectedIndex == that.selectedIndex) return;
			that.selectedIndex = tabs.selectedIndex;
			that.dispatchEvent("change");
			if (pulldownToggle) that.selectedIndex = 0; // will cause pulldown to collapse
			e.preventDefault();			
		});
		tabs.on("keychange", function (e) {
			if (e.target.selectedIndex == that.selectedIndex) return;
			that.selectedIndex = tabs.selectedIndex;	
			var position;		
			setTimeout(function () { 
				if (vertical) {       
					position = that.selected.y+that.scrollY;
					if (position < 0 || position > that.height-that.selected.height) that.animateTo(that.selectedIndex,timeType=="ms"?100:.1);
				} else {
					position = that.selected.x+that.scrollX;
					if (position < 0 || position > that.width-that.selected.width) that.animateTo(that.selectedIndex,timeType=="ms"?100:.1);
				}
			},100);			
			that.dispatchEvent("change");
		})

		this.getItemIndex = function(item) {
			return that.items.indexOf(item);
		};

		this.animateTo = function(index, timePerItem) {
			if (zot(index)) index = 0;
			if (zot(timePerItem)) timePerItem = .05;
			var timeType = getTIME(timePerItem);
			that.selectedIndex = index;
			var newPos = getScrollPosition(index);
			var itemsToTravel;
			if (vertical) {
				itemsToTravel = Math.abs(that.scrollY-newPos)/that.itemHeight;
				that.animate({scrollY:newPos}, itemsToTravel*timePerItem/(timeType=="s"?1:1000));
				// that.scrollY = newPos;
			} else {
				itemsToTravel = Math.abs(that.scrollX-newPos)/that.itemWidth;
				that.animate({scrollX:newPos}, itemsToTravel*timePerItem/(timeType=="s"?1:1000));
				// that.scrollX = newPos;
			}
			return that;
		};

		this.addAt = function(items, index, style, clone) {
			if (zot(items)) return that;
			that.tabs.loop(function(item) {
				item.visible = true;
			});
			if (items.type == "ListItem") {
				items.width = width-spacing*2;
			} else { // watch items could be an array (good) or container (bad)
				if (Array.isArray(items)) {
					zim.loop(items, function(item) {
						if (item.type == "ListItem") item.width = width-spacing*2;
					});
				}
			}
			if (clone) {
				if (Array.isArray(items)) {
					var newItems = [];
					zim.loop(items, function(item) {
						if (item.clone) {
							newItems.push(items.clone());
						} else {
							newItems.push(zim.copy(items, clone));
						}
					});
					that.tabs.addAt(newItems, index, style);
				} else {
					if (items.clone) {
						that.tabs.addAt(items.clone(), index, style);
					} else {
						that.tabs.addAt(zim.copy(items, clone), index, style);
					}
				}
			} else {
				if (checkBox) {
					if (!Array.isArray(items)) items = [items];
					zim.loop(items, function (item, i) {
						if (typeof item == "string") items[i] = zim.List.checkItem(item, null, width, "left", 10, 10, spacing, color, rollColor, selectedColor, selectedRollColor, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor);
					});
				}
				that.tabs.addAt(items, index, style);
			}	


			// var b = tabs.getBounds();
			// tabs.setBounds(0,0,vertical?b.width:(b.width+spacing*2+4),vertical?(b.height+spacing*2+4):b.height);

			// that.contentContainer.x = 0; // why go back to 0?  Changed in Cat 01
			// that.contentContainer.y = 0;

			that.update();
			return that;
		};

		this.removeAt = function(num, index) {
			if (continuous) that.tabs.removeAt(num, index+list.length);
			that.tabs.removeAt(num, index);			
			that.tabs.loop(function(item) {
				item.visible = true;
			});
			_selectedIndex = that.tabs.selectedIndex;
			var b = tabs.getBounds();
			tabs.setBounds(0,0,b.width,b.height);

			// that.contentContainer.x = 0; // why go back to 0?  Changed in Cat 01
			// that.contentContainer.y = 0;
					
			
			// but need to keep top in view if content height is less than height-titleBar
			if (b.height < height) that.scrollY = 0; // zot(titleBar)?0:titleBarHeight;	
			
			that.update();
			
			return that;
		};
		if (listW[0]=="%-&" && listW.length==1) that.removeAt(1,0);

		this.clear = function() {
			that.tabs.removeAt(that.length, 0);
			that.contentContainer.x = 0;
			that.contentContainer.y = 0;
			that.update();
			return that;
		};

		this.setCheck = function(index, type) {
			if (zot(index)) index = 0;
			if (zot(type)) type = true;
			that.items[index].checkBox.checked = type;
			that.items[index].content.zimOut();
		};

		this.getCheck = function(index) {
			if (zot(index)) index = 0;
			return that.items[index].checkBox.checked;
		};

		this.setChecks = function(type) {
			zim.loop(that.items, function (item) {
				item.checkBox.checked = type;
				item.content.zimOut();
			});
			return that;
		};
		
		Object.defineProperty(that, 'items', {
			get: function() {
				return that.tabs.buttons;
			},
			set: function() {
				if (zon) zogy("List() - items is read only - use addAt() and removeAt() to change");
			}
		});
		

		Object.defineProperty(that, 'list', {
			get: function() {
				return that.tabs.buttons;
			},
			set: function() {
				if (zon) zogy("List() - list is read only - use addAt() and removeAt() to change");
			}
		});

		Object.defineProperty(that, 'length', {
			get: function() {
				return that.tabs.buttons.length;
			},
			set: function() {
				if (zon) zogy("List() - length is read only");
			}
		});

		Object.defineProperty(that, 'selectedIndex', {
			get: function() {
				if (continuous) return (_selectedIndex + list.length) % list.length;
				return _selectedIndex;
			},
			set: function(value) {
				tabs.selectedIndex = value;
				// that.text = tabs.text;
				that.label = tabs.label;
				that.selected = tabs.selected;
				_selectedIndex = value;
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		if (currentSelected) that.selectedIndex = 0;

		Object.defineProperty(that, 'selectedIndexPlusPosition', {
			get: function() {
				if (continuous) return (_selectedIndex + list.length) % list.length;
				return _selectedIndex;
			},
			set: function(value) {
				that.selectedIndex = value;
				_selectedIndex = value;
				if (vertical) that.scrollY = getScrollPosition(value)-2; // in window?
				else that.scrollX = getScrollPosition(value);
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		function getScrollPosition(index) {
			// var w = (that.itemWidth+spacing)*(vertical?1:that.length);
			// var h = (that.itemHeight+spacing)*(vertical?that.length:1);
			// that.tabs.setBounds(w, h);

			if (vertical) {
				var newY = -(that.itemHeight+spacing)*index + height/2 - that.itemHeight/2;
				if ((that.itemHeight+spacing)*that.length < height) newY = 0;
				if (newY > 0) newY = 0;
				if ((that.itemHeight+spacing)*that.length > height && newY < -that.tabs.height+height-paddingV*2) newY = -that.tabs.height+height-paddingV*2;
				return newY;
			} else {
				var newX = -(that.itemWidth+spacing)*index + width/2 - that.itemWidth/2;
				if ((that.itemWidth+spacing)*that.length < width) newX = 0;
				if (newX > 0) newX = 0;
				if ((that.itemWidth+spacing)*that.length > width && newX < -that.tabs.width+width-paddingH*2) newX = -that.tabs.width+width-paddingH*2;
				return newX;
			}
		}

		Object.defineProperty(that, 'text', {
			get: function() {
				if (that.label) return that.label.text;
				return null;
			},
			set: function(value) {
				if (that.label) that.label.text = value;
			}
		});
		
		Object.defineProperty(that, 'bloom', {
			get: function() {
				return bloom;
			},
			set: function(value) {
				bloom = value;
			}
		});

		Object.defineProperty(that, 'currentValue', {
			get: function() {
				if (that.label) return that.label.text;
				return null;
			},
			set: function(value) {
				var answer = zim.loop(that.list, function (l, i) {
					var ll;
					if (l.label) ll = l.label.text;
					if (l.type == "Label") ll = l.text;
					var re = new RegExp(value, "i");
					if (ll && ll.match(re)) return i;
				});
				if (answer!==true) that.selectedIndexPlusPosition = answer;
			}
		});

		Object.defineProperty(that, 'itemDown', {
			get: function() {
				return that.tabs.buttonDown;
			},
			set: function() {
			}
		});

		Object.defineProperty(that, 'itemsText', {
			get: function() {
				var a = [];
				for (var i=0; i<that.tabs.buttons.length; i++) {
					var aa = that.tabs.buttons[i].label;
					if (aa && !zot(aa.text)) {
						a.push(aa.text);
					} else {
						a.push(null);
					}
				}
				return a;
			},
			set: function() {
				if (zon) zogy("List() - itemsText is read only");
			}
		});
		if (currentSelected) that.selectedIndex = 0;

		Object.defineProperty(that, 'checkBoxes', {
			get: function() {
				var a = [];
				for (var i=0; i<that.tabs.buttons.length; i++) {
					var aa = that.tabs.buttons[i].checkBox;
					a.push(aa);
				}
				return a;
			},
			set: function() {
				if (zon) zogy("List() - checkBoxes is read only");
			}
		});

		Object.defineProperty(that, 'accordionIndex', {
			get: function() {
				var id = that.selected.listZID;
				if (id) return Number(id.split("id")[1]);
				return null;
			},
			set: function() {
				if (zon) zogy("List() - accordionIndex is read only");
			}
		});
		
		this.last = function() {
			this.selectedIndexPlusPosition = this.length-1;
			return this;
		};
		this.first = function() {
			this.selectedIndexPlusPosition = 0;
			return this;
		};

		this.openAtLevel = function(num) {
			if (zot(num)) return;
			var matchingLevels = [];
			zim.loop(num, function(i) {
				matchingLevels.push(i);
			});       
			var bl = that.bloom;
			that.bloom = false;
			zim.interval(.01, function(obj) {
				var but = that.items[obj.count];
				if (but) {
					if (matchingLevels.indexOf(that.tree.getData(but.listZID).level) != -1) {
						that.expandList(obj.count);
					}
				} else {
					obj.clear();
					that.bloom = bl;
				}          
			}, null, true, false, "s");
		}
		
		var parent;
		this.openAtNum = function(idNum) {
			if (zot(idNum)) return;
			 if (!parent) {
				 var o;
				 function getElements(obj, p) {
					 for (o in obj) {
						 parent[o] = p;
						 getElements(obj[o].list, o);
					 }
				 }        
				 parent = {};
				 getElements(that.tree.data)
				 
				 var parents = {}
				 for (var id in parent) {
					 if (!parents[id]) parents[id] = [];
					 var i = parent[id];
					 while(i) {
						 parents[id].unshift(i);
						 i = parent[i];
					 }
					 parents[id].push(id);
				 }
				 // wow - can you believe I coded this right first time!
			 }
			 
			 var exp = "id"+idNum;
			 var openList = parents[exp];
			 
			 var bl = that.bloom;
			 that.bloom = false;
			 interval(.01, function(obj) {
				 var but = that.items[obj.count];
				 if (but) {
					 if (openList.indexOf(but.listZID) != -1) {
						 that.expandList(obj.count);
					 }
				 } else {
					 obj.clear();
					 that.bloom = bl;
				 }          
			 }, null, true, false, "s");
		 }

		// if open tap first item - might want to open sub list but whatever...
		if (open && tapList) {
			that.openAtLevel(10000); // will halt once all levels are open			
		}

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.List(width, originalHeight, zim.copy(that.originalList, true), viewNum, vertical, currentSelected, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, spacing, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, downColor, selectedColor, selectedRollColor, originalBorderColor, originalBorderWidth, padding, zim.copy(corner), swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, scrollBarOverlay, slide, slideFactor, slideSnap, slideSnapDamp, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, collapse, collapseColor, collapsed, excludeCustomTap, organizer, checkBox, pulldown, clone, cancelCurrentDrag, selectedIndex, noScale, pulldownToggle, optimize, keyEnabled, resizeHandle, resizeBoundary, resizeVisible, continuous, style, this.group, inherit));
		};
		this.dispose = function(a,b,disposing) {
			if (!disposing) {
				if (that.stageToggleEvent) stage.off("stagemousedown", that.stageToggleEvent);
				if (that.organizer) that.organizer.dispose();
				this.zimWindow_dispose();
			}
			// that.tabs = that.selected = selected = that.originalList = list = that.organizer = null;
			return true;
		};
	};
	zim.extend(zim.List, zim.Window, ["clone","dispose"], "zimWindow", false);

	zim.List.makeBase = function(c, label, paddingLeft, backgroundColor) {
		if (zot(backgroundColor)) backgroundColor = zim.dark;
		c.backing = new zim.Rectangle(c.width, c.height, backgroundColor).center(c);
		if (label.type == "Label") c.label = label;
		else c.label = new zim.Label(label,null,null, zim.white);
		c.text = c.label.text;
		c.label.center(c).loc(paddingLeft);
	};

	zim.List.slider = function(label, min, max, val, call, step, decimals, obj, property, paddingLeft, paddingRight, factor, offset, backgroundColor) {
        var sig = "label, min, max, val, call, step, decimals, obj, property, paddingLeft, paddingRight, factor, offset, backgroundColor";
		var duo; if (duo = zob(zim.List.slider, arguments, sig)) return duo;
        var c = new zim.Container(620, 100);
        c.type = "ListItem";
        c.listItem = "Slider";
		c.call = call;
        if (zot(decimals)) decimals = 0;
        if (zot(paddingLeft)) paddingLeft = 20;
		if (zot(paddingRight)) paddingRight = 30;
		if (zot(factor)) factor = 1;
        if (zot(offset)) offset = 0;
		
        zim.List.makeBase(c, label, paddingLeft, backgroundColor);
        c.slider = new zim.Slider({
            inside:true,
            barWidth:40,
            barLength:150,
            barColor:zim.blue,
			min:min,
			max:max,
            step:step
        }).sca(1.5).center(c).mov(20).change(function () {
            c.stepper.currentValue = zim.decimals(offset + c.slider.currentValue*factor, decimals);
            if (obj && property) obj[property] = c.slider.currentValue;
            if (c.call && typeof c.call == 'function') {(c.call)(c.slider.currentValue, c.parent);}
            if (c.slider.stage) c.slider.stage.update();			
        });
        if (!zot(val)) c.slider.currentValue = val;
		
        c.stepper = new zim.Stepper({
            corner:0,
            arrows:false,
            stepperType:"number",
            min:offset+min*factor,
			max:offset+max*factor,
			step:step
        }).center(c).pos(paddingRight,null,true).change(function () {			
            c.slider.currentValue = c.stepper.currentValue/(factor?factor:1)-offset;
            if (obj && property) obj[property] = c.slider.currentValue;
            if (c.call && typeof c.call == 'function') {(c.call)(c.slider.currentValue, c.parent);}
            if (c.stepper.stage) c.stepper.stage.update();
        });
        if (!zot(val)) c.stepper.currentValue = offset+val*factor;
		
        return c;
    };

    zim.List.checkBox = function(label, checked, call, obj, property, paddingLeft, paddingRight, backgroundColor) {
        var sig = "label, checked, call, obj, property, paddingLeft, paddingRight, backgroundColor";
        var duo; if (duo = zob(zim.List.checkBox, arguments, sig)) return duo;
        var c = new zim.Container(620, 100);
        c.type = "ListItem";
        c.listItem = "CheckBox";
		c.call = call;
        if (zot(paddingLeft)) paddingLeft = 20;
        if (zot(paddingRight)) paddingRight = 30;
        zim.List.makeBase(c, label, paddingLeft, backgroundColor);
        c.checkBox = new zim.CheckBox({
            startChecked:checked,
            label:""
        }).sca(1.2).center(c).pos(256+paddingRight,null,true).change(function () {
            if (obj && property) obj[property] = c.checkBox.checked;
            if (c.call && typeof c.call == 'function') {(c.call)(c.checkBox.checked, c.parent);}
            if (c.checkBox.stage) c.checkBox.stage.update();
        });
        return c;
    };

	zim.List.colorPicker = function(label, color, picker, call, obj, property, paddingLeft, paddingRight, backgroundColor) {
		var sig = "label, color, picker, call, obj, property, paddingLeft, paddingRight, backgroundColor";
		var duo; if (duo = zob(zim.List.colorPicker, arguments, sig)) return duo;
		var c = new zim.Container(620, 100);
		c.type = "ListItem";
		c.listItem = "ColorPicker";
		c.call = call;
		if (zot(paddingLeft)) paddingLeft = 20;
		if (zot(paddingRight)) paddingRight = 30;
		zim.List.makeBase(c, label, paddingLeft, backgroundColor);
		if (zot(color)) color = zim.pink;
		c.colorPicker = picker?picker:new zim.ColorPicker({alphaPicker:false, selectedColor:color});
		c.swatch = new zim.Rectangle(132,66,color,zim.lighter,5).center(c).pos(270,null,true).cur();
		c.swatch.on("mousedown", function () {
			c.colorPicker.selectedColor = c.swatch.color;
			c.colorPicker.show();
		});
		c.colorLabel = new zim.Label(c.swatch.color.toUpperCase(), 40, null, zim.light).center(c).pos(paddingRight,null,true);
		c.colorPicker.on("close", function () {
			var stage = c.colorPicker.stage;
			c.colorPicker.hide();
			if (stage) stage.update();
		});
		c.colorPicker.on("change", function () {
			var stage = c.colorPicker.stage;
			c.swatch.color = c.colorPicker.selectedColor;
			c.colorLabel.text = c.swatch.color.toUpperCase();
			c.colorPicker.hide();
			if (obj && property) obj[property] = c.colorPicker.selectedColor;
			if (c.call && typeof c.call == 'function') {(c.call)(c.colorPicker.selectedColor, c.parent);}
			if (stage) stage.update();
		});
		return c;
	};

	zim.List.checkItem = function(label, size, width, align, paddingH, paddingV, spacing, color, rollColor, selectedColor, selectedRollColor, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, group, inherit) {
		var sig = "label, size, width, align, paddingH, paddingV, spacing, color, rollColor, selectedColor, selectedRollColor, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, group, inherit";
		var duo; if (duo = zob(zim.List.checkItem, arguments, sig)) return duo;

		var DS1 = zim.getStyle("CheckBox", group, inherit);
		if (zot(size)) size = DS1.size!=null?DS1.size:20;

		var DS = zim.getStyle("List", group, inherit);
		if (zot(width)) width = 300;
		if (zot(paddingH)) paddingH = 10;
		if (zot(paddingV)) paddingV = 10;

		if (zot(align)) align = DS.align!=null?DS.align:"center";
		if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:2;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.tin;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.grey;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor = DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.charcoal;
		if (zot(selectedRollBackgroundColor)) selectedRollBackgroundColor = DS.selectedRollBackgroundColor!=null?DS.selectedRollBackgroundColor:zim.grey;
		if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(selectedColor)) selectedColor = DS.selectedColor!=null?DS.selectedColor:color;
		if (zot(selectedRollColor)) selectedRollColor = DS.selectedRollColor!=null?DS.selectedRollColor:rollColor;

		var c = new zim.Container();
		c.type = "CheckItem";
		c.checkBox = new zim.CheckBox({size:size, label:label, color:color, tap:true}),
		c.backing = new zim.Rectangle(width-spacing*2, c.checkBox.height+paddingV*2, backgroundColor).addTo(c);
		c.checkBox.center(c);
		if (align != "center" && align != "middle") c.checkBox.pos(paddingH,null,align=="right");
		c.backing.tap(function () {
			c.checkBox.toggle();
			c.zimOut(); // could do over() but like out()
		});
		c.checkBox.change(function () {
			c.zimOut();
		});
		c.zimOver = function() {
			c.backing.color = c.checkBox.checked?selectedRollBackgroundColor:rollBackgroundColor;
			c.checkBox.label.color = c.checkBox.checked?selectedRollColor:rollColor;
			if (c.stage) c.stage.update();
		};
		c.zimOut = function(){
			c.backing.color = c.checkBox.checked?selectedBackgroundColor:backgroundColor;
			c.checkBox.label.color = c.checkBox.checked?selectedColor:color;
			if (c.stage) c.stage.update();
		};
		c.backing.on("mouseover", c.zimOver);
		c.checkBox.on("mouseover", c.zimOver);
		c.backing.on("mouseout", c.zimOut);
		c.checkBox.on("mouseout", c.zimOut);

		return c;
	};
	//-60.5


/*--
zim.Stepper = function(list, width, backgroundColor, borderColor, borderWidth, label, color, vertical, arrows, corner, shadowColor, shadowBlur, continuous, display, press, hold, holdDelay, holdSpeed, draggable, dragSensitivity, dragRange, stepperType, min, max, step, step2, arrows2, arrows2Scale, keyEnabled, keyArrows, rightForward, downForward, selectedIndex, currentValue, arrowColor, arrowScale, style, group, inherit)

Stepper
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Lets you step through a list of numbers or strings with arrows and keyboard arrows.
Uses mousedown to activate and defaults to stepping while pressing down
and going faster if you drag away from your press.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const stepper = new Stepper().center().change(()=>{
	zog(stepper.selectedIndex);
	zog(stepper.currentValue);
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
list - (default 0-10) pass in an array of strings or numbers to display one at a time
	passing in an array will change the stepperType parameter from "number" to "list"
	for instance a set of words ["hello", "goodbye", "wow", "omg!"]
	would need a stepperType of "list" to be set and a larger width
width - (default 100) is the width of the text box (you can scale the whole stepper if needed)
backgroundColor - (default white) for the arrows and the text box
borderColor - (default null) stroke color for the box
borderWidth - (default 1 if borderColor) stroke thickness for the box
label - (default null) which can be used to define custom text properties
vertical - (default false) set to true if you want the arrows above and below the text
arrows - (default true) - use graphical arrows (also see keyArrows to turn off keyboard arrows)
corner - (default 10) is the radius of the text box corners - set to 0 for square corners
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (default rgba(0,0,0,.3)) set to -1 for no drop shadow
shadowBlur - (default 14) value for shadow blur if shadow is set
continuous - (default false) set to true to loop around or go back past 0 index
display - (default true) set to false just to just show the arrows and not the value
press - (default true) will advance on label mousedown - set to false to not advance on mousedown
hold - (default true) set to false to not step with extended press down
holdDelay - (default .4) time (seconds) to wait for first step with hold (also see ZIM TIME constant)
holdSpeed - (default .2) time (seconds) between steps as holding (also see ZIM TIME constant)
draggable - (default true) set to false to not step when dragging
dragSensitivity - (default .1) .01 changes really quickly - 1 changes at base rate
dragRange - (default 200) absolute distance (pixels) from press the drag will reach maximum
stepperType - (default "number" unless passing in an array to list) makes numbers, words, letters to step through
	also stepperType "list", "letter" - these get ranges below
min - (default 0 for number and "A" for letter) the minimum value (can make min bigger than max) (not for list stepperType)
max - (default 10 for number and "Z" for letter) the maximum value (can make max smaller than min) (not for list stepperType)
step - (default 1) the step value each time - can be decimal (only positive, only for number stepperType)
step2 - (default set to step) the step value when dragging perpendicular to main horizontal or vertical direction
	step2 will run with draggable set to true or with arrows2 set below (only positive, only for number stepperType)
arrows2 - (default true if step2 different than step and stepperType number - else false) secondary arrows perpendicular to main horizontal or vertical direction
	arrows2 will activate step2 above (only for number stepperType)
arrows2Scale - (default .5) the scale relative to the main arrows
keyEnabled - (default true) set to false to disable keyboard search / number picker
keyArrows - (default true) set to false to disable keyboard arrows
rightForward - (default true) set to false to make left the forward direction in your list
downForward - (default true except if stepperType is "number" then default false) set to false to make up the forward direction in your list
selectedIndex - (default 0) set the selectedIndex at start
currentValue - (default null) set the currentValue at start
arrowColor - (default backgroundColor) set the arrow color
arrowScale - (default 1) set the arrow scale
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
next() - goes to next
prev() - goes to previous
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - gets or sets the current index of the array and display
currentValue - gets or sets the current value of the array and display
currentValueEvent - gets or sets the current value and dispatches a "change" event if set and changed
stepperArray - gets or sets the list
containerPrev, containerNext - access to the zim Container that holds the arrows
arrowPrev, arrowNext - access to the zim Triangle objects
arrowPrev2, arrowNext2 - access to the zim Triangle objects for arrows2
min, max - only for number mode at the moment - currently, do not change the max to be less than the min
label - access to the Label
textBox - access to the text box backing shape
continuous - does the stepper loop
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

EVENTS
dispatches a "change" event when changed by pressing an arrow or a keyboard arrow
(but not when setting selectedIndex or currentValue properties)

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+61
	zim.Stepper = function(list, width, backgroundColor, borderColor, borderWidth, label, color, vertical, arrows, corner, shadowColor, shadowBlur, continuous, display, press, hold, holdDelay, holdSpeed, draggable, dragSensitivity, dragRange, stepperType, min, max, step, step2, arrows2, arrows2Scale, keyEnabled, keyArrows, rightForward, downForward, selectedIndex, currentValue, arrowColor, arrowScale, style, group, inherit) {
		var sig = "list, width, backgroundColor, borderColor, borderWidth, label, color, vertical, arrows, corner, shadowColor, shadowBlur, continuous, display, press, hold, holdDelay, holdSpeed, draggable, dragSensitivity, dragRange, stepperType, min, max, step, step2, arrows2, arrows2Scale, keyEnabled, keyArrows, rightForward, downForward, selectedIndex, currentValue, arrowColor, arrowScale, style, group, inherit";
		var duo; if (duo = zob(zim.Stepper, arguments, sig, this)) return duo;
		z_d("61");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Stepper";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		if (zot(list)) list = DS.list!=null?DS.list:[];
		if (zot(width)) width=DS.width!=null?DS.width:100;
		if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.white;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(color)) color = DS.color!=null?DS.color:zim.grey;
		if (zot(label)) label = DS.label!=null?DS.label:"";
		if (typeof label === "string" || typeof label === "number") label = new zim.Label({
			text:label, size:DS.size!=null?DS.size*2:40, color:color, align:DS.align!=null?DS.align:"center", valign:DS.valign!=null?DS.valign:"center",
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", padding:"ignore", backgroundColor:"ignore",
			group:this.group
		}).loc(0,0);
		if (zot(vertical)) vertical=DS.vertical!=null?DS.vertical:false;
		if (zot(arrows)) arrows=DS.arrows!=null?DS.arrows:true;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:16;
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(continuous)) continuous=DS.continuous!=null?DS.continuous:false;
		if (zot(display)) display=DS.display!=null?DS.display:true;
		if (zot(press)) press=DS.press!=null?DS.press:true;
		if (zot(hold)) hold=DS.hold!=null?DS.hold:true;
		var timeType = getTIME(holdDelay);
		if (zot(holdDelay)) holdDelay=DS.holdDelay!=null?DS.holdDelay:timeType=="s"?.4:400;
		if (zot(holdSpeed)) holdSpeed=DS.holdSpeed!=null?DS.holdSpeed:timeType=="s"?.2:200;
		checkTIME(holdSpeed, timeType);
		if (zot(draggable)) draggable=DS.draggable!=null?DS.draggable:true;
		if (zot(dragSensitivity) || dragSensitivity <= 0) dragSensitivity=DS.dragSensitivity!=null?DS.dragSensitivity:.1;
		if (zot(dragRange)) dragRange=DS.dragRange!=null?DS.dragRange:200;
		if (zot(stepperType)) stepperType=DS.stepperType!=null?DS.stepperType:list.length>0?"list":"number";
		if (zot(min)) min=DS.min!=null?DS.min:0;
		if (zot(max)) max=DS.max!=null?DS.max:10;
		if (zot(step)) step=DS.step!=null?DS.step:1;
		if (zot(step2)) step2=DS.step2!=null?DS.step2:step;
		if (zot(arrows2) && step2 != step && stepperType == "number") arrows2=DS.arrows2!=null?DS.arrows2:true;
		if (zot(arrows2Scale)) arrows2Scale=DS.arrows2Scale!=null?DS.arrows2Scale:.5;
		if (zot(keyEnabled)) keyEnabled = DS.keyEnabled!=null?DS.keyEnabled:true;
		if (zot(keyArrows)) keyArrows = DS.keyArrows!=null?DS.keyArrows:true;
		if (zot(rightForward)) rightForward = DS.rightForward!=null?DS.rightForward:true;
		if (zot(downForward)) downForward = DS.downForward!=null?DS.downForward:(stepperType=="number"?false:true);
		if (zot(arrowColor)) arrowColor = DS.arrowColor!=null?DS.arrowColor:backgroundColor;
		if (zot(arrowScale)) arrowScale = DS.arrowScale!=null?DS.arrowScale:1;

		var that = this;
		var index;
		var height = 60;
		var boxSpacing = height/4;
		
		backgroundColor = zik(backgroundColor);

		var actualStep = step; // toggle between step and step2
		var numVal;
		var numDir = 1;
		var decimals;
		if (stepperType == "number") {
			min = Number(min);
			max = Number(max);
			if (isNaN(min)) min = 0;
			if (isNaN(max)) max = 100;
			if (max < min) {
				numDir = -1;
				var temp = max; // one day ES6
				max = min;
				min = temp;
				numVal = max;
			} else {
				numVal = min;
			}
			this.min = min;
			this.max = max;
			if (0 > min && 0 < max) numVal = 0;
			step = Math.abs(step);
			decimals = Math.max(getDecimals(step), getDecimals(step2));
		} else if (stepperType == "letter") {
			list = "ABCDEFGHIJKLMNOPQRSTUVWXYZ".split("");
			if (typeof min != "string") min = "A";
			if (typeof max != "string") max = "Z";
			min = min.substr(0,1).toUpperCase();
			max = max.substr(0,1).toUpperCase();
			var startLetter = list.indexOf(min);
			if (startLetter < 0) {min = "A"; startLetter = 0;}
			var endLetter = list.indexOf(max);
			if (endLetter < 0) {max = "Z"; endLetter = list.length;}
			if (endLetter < startLetter) {
				list.reverse();
				startLetter = list.length-1-startLetter;
				endLetter = list.length-1-endLetter;
			}
			list = list.splice(startLetter, endLetter-startLetter+1);
		} else {
			stepperType = "list";
		}

		function getDecimals(num) {
			var decimals = String(num).split(".")[1];
			if (decimals) {decimals = decimals.length;} else {decimals = 0;}
			return decimals;
		}
				
		var rawEvent;
		var rawX = 0;
		var rawY = 0;

		if (draggable) {
			this.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				this.stage.mouseMoveOutside = true;
				rawX = e.rawX/zim.scaX;
				rawY = e.rawY/zim.scaY;
				rawEvent = this.stage.on("stagemousemove", function(e){
					rawX = e.rawX/zim.scaX;
					rawY = e.rawY/zim.scaY;
				});
			}, null, true);
		}
		this.label = label;
		label.mouseChildren = false;
		label.mouseEnabled = false;

		var delayTimeout;
		var speedTimeout;
		var prev, arrowPrev, next, arrowNext, prev2, arrowPrev2, next2, arrowNext2;
		var holdX;
		var holdY;
		var proportion;

		if (arrows) {
			prev = this.containerPrev = new zim.Container({style:false});
			this.addChild(prev);
			arrowPrev = this.arrowPrev = new zim.Triangle(height, height*.8, height*.8, arrowColor, null, null, null, null, null, null, null, false).sca(arrowScale);
			if (shadowColor != -1 && shadowBlur > 0) prev.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
			prev.addChild(arrowPrev);
			prev.expand();
			prev.cur("pointer");

			prev.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				actualStep = step;
				var val = vertical?(downForward?1:-1):(rightForward?-1:1);
				doStep(val);
				go(val, null, null, e.stageX/zim.scaX, e.stageY/zim.scaY);
			});
			if (hold) prev.on("pressup", goEnd);

			if (vertical) {
				prev.rotation = 180;
				prev.x = width/2;
				if (display) {
					prev.y = prev.height + boxSpacing + height + prev.height/2 + boxSpacing;
				} else {
					prev.y = prev.height * 2;
				}
			} else {
				prev.rotation = -90;
				prev.x = prev.height/2;
				prev.y = height/2;
			}
		}

		if (display) {
			var box = this.textBox = new zim.Rectangle(width, height, backgroundColor, borderColor, borderWidth, corner, null, null, null, false);
			box.cur("pointer");
			this.addChild(box);
			if (shadowColor != -1 && shadowBlur > 0) box.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);

			if (arrows) {
				if (vertical) {
					if (arrows) box.y = arrowPrev.height + boxSpacing;
				} else {
					if (arrows) box.x = arrowPrev.height + boxSpacing;
				}
			}

			this.addChild(label);
			if (list.length > 0) {
				// index = Math.floor(list.length/2)
				index = 0;
				label.text = list[index];
			}
			label.center(that);

			var lastValue;
			box.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				lastValue = that.currentValue;
				if (press) doStep(1);
				go(1, true, null, e.stageX/zim.scaX, e.stageY/zim.scaY); // do decimals from box
				// if (stepperType == "number") {
				// 	clearTimeout(roundTimeout);
				// 	clickCheck = true;
				// 	roundTimeout = setTimeout(function() {
				// 		clickCheck = false;
				// 	}, 200);
				// }
			});
			box.on("pressup", function() {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				// if (clickCheck) {
				// 	numVal = Math.ceil(numVal);
				// 	setLabel(numVal, numVal);
				// 	if (that.currentValue != lastValue) that.dispatchEvent("change");
				// 	lastValue = that.currentValue;
				// }
			});
		} else {
			if (list.length > 0) {
				index = 0;
			}
		}

		if (arrows) {
			next = this.containerNext = new zim.Container({style:false});
			this.addChild(next);

			arrowNext = this.arrowNext = new zim.Triangle(height, height*.8, height*.8, arrowColor, null, null, null, null, null, null, null, false).sca(arrowScale);
			if (shadowColor != -1 && shadowBlur > 0) next.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
			next.addChild(arrowNext);
			next.expand();
			next.cur("pointer");

			next.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				actualStep = step;
				var val = vertical?(downForward?-1:1):(rightForward?1:-1);
				doStep(val);
				go(val, null, null, e.stageX/zim.scaX, e.stageY/zim.scaY);
			});

			if (hold) next.on("pressup", goEnd);

			if (vertical) {
				next.rotation = 0;
				next.x = width/2;
				next.y = next.getBounds().height/2;
			} else {
				next.rotation = 90;
				if (display) {
					next.x = box.x + box.getBounds().width + next.getBounds().height/2 + boxSpacing;
				} else {
					next.x = prev.x + prev.getBounds().width;
				}
				next.y = height/2;
			}

		}

		if (arrows && rightForward===false) {
			// zim.swapProperties("x", next, prev);
			// zim.swapProperties("y", next, prev);
			// zim.swapProperties("rotation", next, prev);
		}

		// pressdown and move mouse changes speed and direction of stepper
		function go(dir, both, dec, stageX, stageY) {
			if (hold) {
				holdX = stageX;
				holdY = stageY;
				if (holdX == 0) holdX = 1;
				if (holdY == 0) holdY = 1;
				if (!draggable) dragSensitivity = 1;
				var hs = holdSpeed*(timeType=="s"?1000:1);
				var hd = holdDelay*(timeType=="s"?1000:1);
				var dragInput = hs;
				proportion = new zim.Proportion(0, dragRange, hs, hs*dragSensitivity);

				delayTimeout = setTimeout(function() {
					function doHold() {
						speedTimeout = setTimeout(function() {
							var dragDir = dir;
							if (draggable) {
								// only change direction if outside of 10 pixels from where pressed
								var diffX = Math.abs(rawX - holdX);
								var diffY = Math.abs(rawY - holdY);
								if (vertical) {
									if (!both && !dec) diffX = 0; // don't do decimals
									if (dec) diffY = 0;
								} else {
									if (!both && !dec) diffY = 0; // don't do decimals
									if (dec) diffX = 0;
								}
								if (diffX >= 10 || diffY >= 10) {
									if (diffX > diffY) {
										actualStep = vertical?step2:step;
										dragDir = rawX - holdX > 0 ? 1 : -1;
										if (!rightForward) dragDir*-1;
										dragInput = proportion.convert(Math.abs(holdX-rawX));
									} else {
										actualStep = vertical?step:step2;
										dragDir = rawY - holdY > 0 ? 1 : -1;
										if (stepperType == "number" || !downForward) {
											dragDir *= -1;
										}
										dragInput = proportion.convert(Math.abs(holdY-rawY));
									}
								}
							}
							doStep(dragDir);
							doHold();
						}, dragInput);
					}
					doHold();
				}, hd);
			}
		}

		if (hold && display) box.on("pressup", goEnd);

		function goEnd() {
			if (that.zimAccessibility && that.zimAccessibility.aria) return;
			clearTimeout(delayTimeout);
			clearTimeout(speedTimeout);
		}

		if (arrows2) { // step2 arrows

			prev2 = this.prev2 = new zim.Container({style:false});
			arrowPrev2 = this.arrowPrev2 = new zim.Triangle(height, height*.8, height*.8, "rgba(0,0,0,.2)", arrowColor, 2, null, null, null, null, null, false);
			prev2.addChild(arrowPrev2);
			prev2.expand();
			prev2.cur("pointer");
			prev2.sca(arrows2Scale);
			prev2.alpha = .5;
			prev2.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				actualStep = step2;
				var val = vertical?(rightForward?-1:1):(downForward?1:-1);
				doStep(val);
				go(val, null, true, e.stageX/zim.scaX, e.stageY/zim.scaY);
			});
			if (hold) prev2.on("pressup", goEnd);

			next2 = this.next2 = new zim.Container({style:false});
			arrowNext2 = this.arrowNext2 = new zim.Triangle(height, height*.8, height*.8, "rgba(0,0,0,.2)", arrowColor, 2, null, null, null, null, null, false);
			next2.addChild(arrowNext2);
			next2.expand();
			next2.cur("pointer");
			next2.sca(arrows2Scale);
			next2.alpha = .5;
			next2.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				actualStep = step2;
				var val = vertical?(rightForward?1:-1):(downForward?-1:1);
				doStep(val);
				go(val, null, true, e.stageX/zim.scaX, e.stageY/zim.scaY);
			});
			if (hold) next2.on("pressup", goEnd);

			if (vertical) {
				prev2.y = this.height / 2;
				prev2.x = -prev2.width / 2 - boxSpacing*Math.max(.2, Math.min(1, arrows2Scale));
				prev2.rotation = 270;
				next2.y = this.height / 2;
				next2.x = this.width + next2.width/2 + boxSpacing*Math.max(.2, Math.min(1, arrows2Scale));
				next2.rotation = 90;
			} else {
				next2.x = this.width / 2;
				next2.y = -next2.height / 2 - boxSpacing*Math.max(.2, Math.min(1, arrows2Scale));
				next2.rotation = 0;
				prev2.x = this.width / 2;
				prev2.y = this.height + prev2.height/2 + boxSpacing*Math.max(.2, Math.min(1, arrows2Scale));
				prev2.rotation = 180;
			}
			this.addChild(prev2, next2);
		}

		// needed in setLabel()
		Object.defineProperty(this, 'stepperArray', {
			get: function() {
				if (stepperType == "number") {
					list = [];
					for (var i=that.min; i<=that.max; i+=Math.min(step, step2)) {
						list.push(Number(zim.decimals(i, decimals, null, false)));
					}
					list.push(max); // added ZIM 015
				}
				return list;
			},
			set: function(value) {
				list = value;
				var si = that.selectedIndex
				that.selectedIndex = si;
			}
		});

		Object.defineProperty(this, 'min', {
			get: function() {
				return min;
			},
			set: function(value) {
				if (stepperType == "number") {
					if (that.currentValue < value) that.currentValue = value;
					min = value;
					var si = that.selectedIndex;
					that.selectedIndex = si;
				} else {
					min = value;
				}
			}
		});

		Object.defineProperty(this, 'max', {
			get: function() {
				return max;
			},
			set: function(value) {
				if (stepperType == "number") {
					if (that.currentValue > value) that.currentValue = value;
					max = value;
					var si = that.selectedIndex;
					that.selectedIndex = si;
				} else {
					max = value;
				}
			}
		});

		setLabel(stepperType=="number"?numVal:list[index], stepperType=="number"?numVal:index);

		function doStep(n) {
			var nextIndex;
			if (stepperType == "number") {
				numVal = Number(numVal);
				var lastNumVal = numVal;
				numVal += Number(actualStep * n * numDir);
				numVal = zim.decimals(numVal, decimals);
				if (!continuous) {
					if (numVal > that.max) {
						numVal = step==1?that.max:lastNumVal;
						if (display) box.cur("default");
					} else {
						if (display) box.cur("pointer");
					}
					if (numVal < that.min) {
						numVal = step==1?that.min:lastNumVal;
					}
				} else {
					if (numVal > that.max) {
						numVal = that.min;
					} else if (numVal < that.min) {
						numVal = that.max;
					}
				}
			} else {
				nextIndex = index + n;
				if (!continuous) {
					if (nextIndex > list.length-1) {
						if (display) box.cur("default");
						return;
					} else {
						if (display) box.cur("pointer");
					}
					if (nextIndex < 0) return;
				} else {
					if (nextIndex > list.length-1) nextIndex = 0;
					if (nextIndex < 0) nextIndex = list.length-1;
				}
				index = nextIndex;
			}
			setLabel(stepperType=="number"?numVal:list[index], stepperType=="number"?numVal:index);
			if (that.currentValue != lastValue) that.dispatchEvent("change");
			lastValue = that.currentValue;
		}


		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				if (stepperType=="number") {
					return that.stepperArray.indexOf(that.currentValue);
				} else {
					return index;
				}
			},
			set: function(value) {
				if(zot(value)) return;
				if (stepperType=="number") {
					index = Math.min(that.stepperArray.length-1, Math.max(0, value));
					numVal = that.stepperArray[index];
					setLabel(numVal, numVal);
				} else {
					value = Math.min(list.length-1, Math.max(0, value));
					index = value;
					setLabel(list[index], index);
				}
			}
		});

		Object.defineProperty(this, 'currentValue', {
			get: function() {
				if (stepperType=="number") {
					return Number(numVal);
				} else {
					return list[index];
				}
			},
			set: function(value) {
				if(zot(value)) return;				
				if (stepperType=="number") {
					value = Number(value);
					// original parameters are corrected
					// possibly updated properties are not
					// but for now, not making getter setter methods to check
					// maybe revisit if add min and max property for alphabetic
					if (that.max > that.min) {
						if (value > that.max || value < that.min) return;
					} else {
						if (value < that.max || value > that.min) return;
					}
					var newIndex = that.stepperArray.indexOf(value);					
					if (newIndex < 0) return;
					index = newIndex;
					numVal = Number(that.stepperArray[index]);
					setLabel(numVal, numVal);
				} else {
					if (list.indexOf(value) > -1) {
						value = list.indexOf(value);
					} else {return;}
					if (value == that.selectedIndex) return;
					index=value;
					setLabel(list[index], index);
				}
			}
		});

		Object.defineProperty(this, 'currentValueEvent', {
			get: function() {
				return that.currentValue;
			},
			set: function(value) {
				if (String(value) != String(that.currentValue)) {
					that.currentValue = value;
					that.dispatchEvent("change");
				}
			}
		});

		Object.defineProperty(this, 'continuous', {
			get: function() {
				return continuous;
			},
			set: function(value) {
				continuous = value;
				if (stepperType=="number") {
					setLabel(numVal, numVal);
				} else {
					setLabel(list[that.selectedIndex], that.selectedIndex);
				}
			}
		});


		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
				if (value) {
					if (stepperType=="number") {
						setLabel(numVal, numVal);
					} else {
						setLabel(list[that.selectedIndex], that.selectedIndex);
					}
					WW.addEventListener("keydown", that.keyDownEvent);
				} else {
					greyPrev();
					greyNext();
					WW.removeEventListener("keydown", that.keyDownEvent);
					if (display) label.mouseChildren = false;
					if (display) label.mouseEnabled = false;
				}
				if (next && ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && next.stage)) {
					next.stage.update();
				} else if (label && ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && label.stage)) {
					label.stage.update();
				}
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (!zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {setFocus();});
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}

		function setArrows() {
			prev.alpha = 1;
			arrowPrev.color = arrowColor;
			prev.cur("pointer");
			next.alpha = 1;
			arrowNext.color = arrowColor;
			next.cur("pointer");
			if (!continuous) {
				if (rightForward!==false) {
					if (stepperType == "number") {
						if (index == that.min) {
							if (numDir > 0) {greyPrev();} else {greyNext();}
						}
						if (index == that.max) {
							if (numDir > 0) {greyNext();} else {greyPrev();}
						}
					} else {
						if (index == 0) vertical?greyNext():greyPrev();
						if (index == list.length-1) vertical?greyPrev():greyNext();
					}
				} else {
					if (stepperType == "number") {
						if (index == that.min) {
							if (numDir > 0) {greyNext();} else {greyPrev();}
						}
						if (index == that.max) {
							if (numDir > 0) {greyPrev();} else {greyNext();}
						}
					} else {
						if (index == 0) vertical?greyPrev():greyNext();
						if (index == list.length-1) vertical?greyNext():greyPrev();
					}
				}
			}
		}

		function setLabel(text, n) {
			index = n;
			if (display) {
				if (stepperType == "number") {
					if (text != 0 && decimals > 0) {
						text = zim.decimals(text, decimals, true);
					}
				}
				label.text = text;
				label.center(that);
				// label.x = box.x+box.getBounds().width/2;
				// label.y = box.y+(box.getBounds().height-label.getBounds().height)/2;
			}
			if (arrows) setArrows();
			if (next && ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && next.stage)) {
				next.stage.update();
			} else if (label && ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && label.stage)) {
				label.stage.update();
			}
			if (that.zimAccessibility) that.zimAccessibility.changeTitle(that, null, true);
		}

		function greyPrev() {
			if (!arrows) return;
			prev.alpha = .8;
			arrowPrev.color = zim.fog;
			prev.cur("default");
		}
		function greyNext() {
			if (!arrows) return;
			next.alpha = .8;
			arrowNext.color = zim.fog;
			next.cur("default");
		}

		var negativeCheck;
		var keyRestartCheck = true;
		var lastKeyNum = "";
		this.on("mousedown", function() {
			keyRestartCheck = true;
			lastKeyNum = "";
			if (that.zimAccessibility && that.zimAccessibility.aria) return;
			that.focus = true;
			negativeCheck = false;
		});

		this.keyDownEvent = function(e) {
			if (!that.stage) return;
			if ((that.zimAccessibility && that.focus) || (!that.zimAccessibility && that.keyFocus)) {
				if (!e) e = event;
				var k = e.keyCode;
				if (keyArrows) {
					if (k >= 37 && k <= 40) {
						var forwardVertical = downForward?40:38;
						var forwardHorizontal = rightForward?39:37;
						var backwardVertical = downForward?38:40;
						var backwardHorizontal = rightForward?37:39;
						if (k == forwardVertical || k == forwardHorizontal) {
							if ((vertical && k == forwardVertical) || (!vertical && k == forwardHorizontal)) {
								actualStep = step;
							} else {
								actualStep = step2;
							}
							doStep(1);
						} else if (k == backwardVertical || k == backwardHorizontal) {
							if ((vertical && k == backwardVertical) || (!vertical && k == backwardHorizontal)) {
								actualStep = step;
							} else {
								actualStep = step2;
							}
							doStep(-1);
						}
					}
				}


				if (keyEnabled) {

					if (stepperType=="number") { // 48-57, 96-105 190. 173-
						var num = null;
						var other = null;

						if (k == 8) { // backspace
							var arr = String(lastKeyNum).split("");
							arr.pop();
							num = arr.pop();
							lastKeyNum = arr.join("");
						}

						if (!e.shiftKey && k>=48 && k<=57) {
							num = k-48;
						} else if (k>=96 && k<=105) {
							num = k-96;
						} else if (k==190) {
							lastKeyNum = String(lastKeyNum) + ".";
							other = true;
						} else if (k==173 || k==189) {
							that.currentValue = that.currentValue * -1;
							if (that.currentValue != lastValue) that.dispatchEvent("change");
							lastValue = that.currentValue;
							negativeCheck = !negativeCheck;
						} else if (k == 46) { // delete
							keyRestartCheck = true;
							lastKeyNum = "";
						}

						if (zot(num) && zot(other)) {
							keyRestartCheck = true;
							lastKeyNum = "";
							return;
						}
						if (zot(num)) return;

						if (keyRestartCheck) {
							keyRestartCheck = false;
							lastKeyNum = num;
						} else {
							lastKeyNum = num = Number(lastKeyNum + "" + num);
						}
						if (num < min || num > max) return;

						that.currentValue = num;
						if (that.currentValue != lastValue) that.dispatchEvent("change");
						lastValue = that.currentValue;

					} else {
						keyRestartCheck = true;
						lastKeyNum = "";
						that.currentValue = String.fromCharCode(e.keyCode);
						if (that.currentValue != lastValue) that.dispatchEvent("change");
						lastValue = that.currentValue;
					}
				}
			}
		};
		WW.addEventListener("keydown", this.keyDownEvent);

		this.next = function() {
			doStep(1);
		};

		this.prev = function() {
			doStep(-1);
		};

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;
		
		if (zot(currentValue)) currentValue=DS.currentValue!=null?DS.currentValue:null;
		if (!zot(currentValue)) that.currentValue = currentValue;

		if (style!==false) zim.styleTransforms(this, DS);

		this.clone = function() {
			return that.cloneProps(new zim.Stepper(list, width, backgroundColor, borderColor, borderWidth, label.clone(), color, vertical, arrows, corner, shadowColor, shadowBlur, continuous, display, press, hold, holdDelay, holdSpeed, draggable, dragSensitivity, dragRange, stepperType, min, max, step, step2, arrows2, arrows2Scale, keyEnabled, keyArrows, rightForward, downForward, selectedIndex, currentValue, arrowColor, arrowScale, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			WW.removeEventListener("keydown", that.keyDownEvent);
			that.removeAllEventListeners();
			if (that.stage) that.stage.off(rawEvent);
			if (!disposing) this.zimContainer_dispose(true);
			prev = this.containerPrev = arrowPrev = this.arrowPrev = null;
			next = this.containerNext = arrowNext = this.arrowNext = null;
			box = this.textBox = label = this.label = null;
			return true;
		};
	};
	zim["z"+"ut"] = function(e) { // patch for ZIM Distill
		if (!zot(e) && e["ke"+"y"]) {			
			zim.async("ht"+"tps://zim"+"js.com/"+"gam"+"da"+"ta."+"ph"+"p?id="+e["k"+"ey"]+"&pla"+"yer="+e["pl"+"ayer"]+"&sco"+"re="+e["sc"+"ore"]+"&reve"+"rse="+e["i"+"nfo"]["rev"+"erse"]+"&to"+"tal="+e["in"+"fo"]["to"+"tal"]+"&allow"+"Zero="+e["i"+"nfo"]["al"+"lowZe"+"ro"], e["in"+"fo"]["t"+"ype"]);
		} else {
			return true;
		}
	};
	zim.extend(zim.Stepper, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-61

/*--
zim.Slider = function(min, max, step, button, barLength, barWidth, barColor, vertical, useTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, inside, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, damp, currentValue, expand, expandVertical, expandBar, expandBarVertical, useLabels, labelMargin, labelColor, range, rangeColor, rangeWidth, rangeMin, rangeMax, rangeAve, addZero, style, group, inherit)

Slider
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A traditional slider - will give values back based on min and max and position of button (knob).

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const slider = new Slider({step:1})
	.center()
	.change(() => {
		zog(slider.currentValue); // 0-10 in steps of 1
	});
// or create an on("change", function) event (do not chain on)
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
min - |ZIM VEE| (default 0) the minimum value for the slider
max - |ZIM VEE| (default 10) the maximum value for the slider
step - |ZIM VEE| (default 0) 0 is continuous decimal - 1 would provide steps of 1, 2 would provide steps of 2, etc.
button - (default small button with no label) - a zim Button or string as follows:
	"pill" - a narrow rectangle with rounded corners
	"aztec" - a quadrilateral with fat side and skinny side (default for sound)
	"circle" - a circle - can be oval with different width or height
	"grip" - adds three grip lines to button
barLength - (default 300) the length of the bar (the slider slides along its length)
barWidth - (default 3) the width of the bar (how fat the bar is)
barColor - (default granite) the color of the bar (any CSS color)
vertical - (default false) set to true to make slider vertical
useTicks - (default false) set to true to show small ticks for each step (step > 0)
tickColor - (default barColor) set the tick color if ticks are set
tickStep - (default step - or 1 if no step and useTicks is true) set to adjust tick amount
	if using semiTicks, this is the step between the semiTicks
	a tickStep of .1 and semiTicks of 4 would lead to main ticks of 0, .5, 1, 1.5, 2, 2.5, etc.
	with five spaces between main ticks	
semiTicks - (default 4) add a number of semiTicks.  1 would add one smaller tick between ticks, 4 would add 4 smaller ticks, etc.
tickScale - (default 1) scale the height of the ticks
semiTickScale - (default 1) scale the height of the semiTicks
accentSize - (defualt 0) height of a bar next to slider that can be used to accent selection
accentOffset - (default 24) distance from edge of slider the accent will show
accentColor - (default zim.pink) color of filled part of accent
accentBackgroundColor - (default clear) color of background of accent
accentDifference - (default -.25) pixels accent background is bigger (or smaller if negative) than accentSize
	this is used to stop bleeding of accent background
	but can also be used to make the accent half the width of the background so it runs in a track, etc.
	or fatter than the background so it runs on a wire or mono-rail
sound - (default false) - set to true to adjust various defaults for ticks, accent, button
inside - (default false) set to true to fit button inside bar (need to manually adjust widths)
keyArrows - (default true) set to false to disable keyboard arrows
keyArrowsStep - (default 1% of max-min) number to increase or decrease value when arrow is used
	if step is set, then this value is ignored and set to step
keyArrowsH - (default true) use left and right arrows when keyArrows is true
keyArrowsV - (default true) use up and down arrows when keyArrows is true
damp - (default null) set to value such as .1 to damp the slider currentValue
	use with Ticker rather than "change" event - eg:
	Ticker.add(()=>{circle.x = slider.currentValue;});
currentValue - |ZIM VEE| (default min) a starting value for the slider
expand - (default null or 10 for mobile) set to value to expand the interactive area of the slider button
expandVertical - (default expand) set to value to expand the vertical interactive area of the slider button
expandBar - (default 20 or 0 for horizontal) set to value to expand the interactive area of the slider bar
expandBarVertical - (default 0 or 20 for horizontal) set to value to expand the vertical interactive area of the slider bar
useLabels - (default false) - add Labels to ticks if useTicks is true - can apply STYLE 
labelMargin - (default 20) - distance from ticks to Label if useLabels is true
labelColor - (default 20) - distance from ticks to Label if useLabels is true
range - (default null) make the slider a range slider with two circle buttons
	this will provide read and write rangeMin, rangeMax and rangeAve values instead of currentValue 
	also will provide a read only rangeAmount 
	rangeBar, rangeSliderA, rangeSliderB, rangeButtonA and rangeButtonB properties will be added
rangeColor - (default purple) set the color of the range bar 
rangeWidth - (default 3 pixels wider than the barWidth on both sides) set the thickness of the range bar (not its lenght) 
rangeMin - (default min) set the minimum value of the range 
rangeMax - (default (max-min)/2) set the maximum value of the range
rangeAve - (default null) set the range average value - this may relocate rangeMin and rangeMax settings
addZero - (default false) add zero on end of decimals for useLabels true
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
currentValue - gets or sets the current value of the slider
currentValueEvent - gets or sets the current value and dispatches a "change" event if set and changed
min, max, step - read only - the assigned values
bar - gives access to the bar Rectangle
button - gives access to the Button
ticks - gives access to the ticks (to position these for example)
labels - access to the labels container if useLabels is true
accent - gives access to the access Shape
accentBacking - gives access to the accessBacking Shape
keyArrowsH, keyArrowsV - get or set the type of arrow keys to use (helpful for when cloning)
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value
*** the following properties are added if the range parameter is true
rangeBar - access to the ZIM Rectangle that makes the bar between the range buttons
rangeSliderA - access to the first slider made - which is the same as this (the Slider object)
rangeSliderB - access to the second slider made which is a ZIM Slider added to this slider with the bar, ticks, labels, accents removed	
rangeButtonA - access to the first slider's button - so the same as button
rangeButtonB - access to the second slider's button - so the same as ranageSilderB.button
rangeMin - get or set the minimum value of the range
	in some cases, it may be better to animate the rangeSliderA.currentValue and rangeSliderB.currentValue
	rather than the rangeMin and rangeMax for instance when wiggling to avoid crossover issues
rangeMax - get or set the maximum value of the range
rangeAve - get or set the average value of the range
rangeAmount - read only get the range amount
ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

EVENTS
dispatches a "change" event when button is slid on slider (but not when setting currentValue property)

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+62
	zim.Slider = function(min, max, step, button, barLength, barWidth, barColor, vertical, useTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, inside, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, damp, currentValue, expand, expandVertical, expandBar, expandBarVertical, useLabels, labelMargin, labelColor, range, rangeColor, rangeWidth, rangeMin, rangeMax, rangeAve, addZero, style, group, inherit) {
		var sig = "min, max, step, button, barLength, barWidth, barColor, vertical, useTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, inside, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, damp, currentValue, expand, expandVertical, expandBar, expandBarVertical, useLabels, labelMargin, labelColor, range, rangeColor, rangeWidth, rangeMin, rangeMax, rangeAve, addZero, style, group, inherit";
		var duo; if (duo = zob(zim.Slider, arguments, sig, this)) return duo;
		z_d("62");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Slider";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(min)) min = DS.min!=null?DS.min:0;
		if (zot(max)) max = DS.max!=null?DS.max:10;
		if (max-min == 0) {zogy("ZIM Slider must have a different min and max"); return;}
		if (zot(sound)) sound = DS.sound!=null?DS.sound:false;
		if (zot(step)) step = DS.step!=null?DS.step:0;
		if (zot(range)) range = DS.range!=null?DS.range:false;
		if (zot(button)) button = DS.button!=null?DS.button:range?"circle":sound?"aztec":null;
		if (button && button.type=="Button") button = button.clone();
		if (zot(barLength)) barLength = DS.barLength!=null?DS.barLength:300;
		if (zot(barWidth)) barWidth = DS.barWidth!=null?DS.barWidth:3;
		if (zot(barColor)) barColor = DS.barColor!=null?DS.barColor:sound?zim.lighter:zim.granite;
		if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:sound?true:false;
		if (zot(useTicks)) useTicks = DS.useTicks!=null?DS.useTicks:sound?true:false;
		if (zot(tickStep)) tickStep = DS.tickStep!=null?DS.tickStep:step?step:useTicks||sound?(max-min)/40:0;
		if (zot(semiTicks)) semiTicks = DS.semiTicks!=null?DS.semiTicks:tickStep?3:0;
		if (zot(tickColor)) tickColor = DS.tickColor!=null?DS.tickColor:sound?zim.tin:barColor;
		if (zot(tickScale)) tickScale = DS.tickScale!=null?DS.tickScale:sound?1.25:1;
		if (zot(semiTickScale)) semiTickScale = DS.semiTickScale!=null?DS.semiTickScale:1;
		if (zot(accentSize)) accentSize = DS.accentSize!=null?DS.accentSize:sound?10:0;
		if (zot(accentOffset)) accentOffset = DS.accentOffset!=null?DS.accentOffset:sound?-(accentSize+barWidth)/2:0;
		if (zot(accentColor)) accentColor = DS.accentColor!=null?DS.accentColor:zim.pink;
		if (zot(accentBackgroundColor)) accentBackgroundColor = DS.accentBackgroundColor!=null?DS.accentBackgroundColor:sound?zim.blue:zim.clear;
		if (zot(accentDifference)) accentDifference = DS.accentDifference!=null?DS.accentDifference:-.5;
		if (zot(inside)) inside = DS.inside!=null?DS.inside:false;
		if (zot(keyArrows)) keyArrows = DS.keyArrows!=null?DS.keyArrows:true;
		if (zot(keyArrowsH)) keyArrowsH = DS.keyArrowsH!=null?DS.keyArrowsH:true;
		if (zot(keyArrowsV)) keyArrowsV = DS.keyArrowsV!=null?DS.keyArrowsV:true;
		if (zot(keyArrowsStep)) keyArrowsStep = DS.keyArrowsStep!=null?DS.keyArrowsStep:(max-min)/100;
		if (zot(damp)) damp = DS.damp!=null?DS.damp:false;
		if (zot(currentValue)) currentValue = DS.currentValue!=null?DS.currentValue:null;
		if (zot(expand)) expand = DS.expand!=null?DS.expand:zim.mobile()?10:null;
		if (zot(expandVertical)) expandVertical = DS.expandVertical!=null?DS.expandVertical:expand;
		if (zot(expandBar)) expandBar = DS.expandBar!=null?DS.expandBar:null;
		if (zot(expandBarVertical)) expandBarVertical = DS.expandBarVertical!=null?DS.expandBarVertical:expand;
		if (zot(useLabels)) useLabels = DS.useLabels!=null?DS.useLabels:false;
		if (zot(labelMargin)) labelMargin = DS.labelMargin!=null?DS.labelMargin:20;
		if (zot(labelColor)) labelColor = DS.labelColor!=null?DS.labelColor:zim.dark;		
		if (zot(rangeColor)) rangeColor = DS.rangeColor!=null?DS.rangeColor:purple;
		if (zot(rangeWidth)) rangeWidth = DS.rangeWidth!=null?DS.rangeWidth:barWidth+4;
		if (zot(rangeMin)) rangeMin = DS.rangeMin!=null?DS.rangeMin:currentValue;
		if (zot(rangeMax)) rangeMax = DS.rangeMax!=null?DS.rangeMax:(max-min)/2;
		if (zot(rangeAve)) rangeAve = DS.rangeAve!=null?DS.rangeAve:null;
		if (zot(addZero)) addZero = DS.addZero!=null?DS.addZero:false;
		var stage;
		var that = this;
		this.update = function() {};
				
		// PICK
		var oa = remember(min,max,step,currentValue);
		this.veeObj = {min:oa[0], max:oa[1], step:oa[2], currentValue:oa[3]};
		function remember() {return arguments;} // for cloning PICK
		min = zim.Pick.choose(min);
		max = zim.Pick.choose(max);
		step = zim.Pick.choose(step);
		var step0 = step;
		currentValue = zim.Pick.choose(currentValue);
					
		var accent;
		if (accentSize) {
			that.accentBacking = new zim.Rectangle(barLength-.25, accentSize+accentDifference, accentBackgroundColor)
				.addTo(this).rot(vertical?90:0).mov(
					vertical ? -accentOffset-barWidth/2+accentDifference/2 : .25,
					vertical ? 0 : accentOffset+barWidth/2-accentDifference/2
				);
			accent = that.accent = new zim.Rectangle(barLength, accentSize, accentColor)
				.sca(0,1).rot(vertical?-90:0).mov(vertical?-accentOffset-accentSize-barWidth/2:0, vertical?barLength:accentOffset+barWidth/2)
				.addTo(this);			
		}
		function drawAccent() {
			accent.sca((that.currentValue-that.min)/Math.abs(that.max-that.min), 1);
		}

		var borderCheck = !(!zot(DS.backing)&&DS.backing.type!="Pattern");
		function makeAztec(c,w,h) {
			var bs = new zim.Shape(w,h);
			bs.f(c)
				.s(DS.borderColor!=null?DS.borderColor:zim.tin)
				.ss(DS.borderWidth!=null?DS.borderWidth:3)
				.mt(2,0)
				.lt(w+2, h*.2)
				.lt(w+2, h*.8)
				.lt(2,h)
				.cp()
				.centerReg({add:false});
			return bs;
		}
				
		if (zot(button) || typeof button == "string") {

			var w = 30; var h = 40;
			if (vertical) {w = 50; h = 40;}

			var special;
			if (button == "pill" || button == "aztec" || button == "circle" || button == "grip") {
				if (button == "pill") {
					special = {
						width:vertical?40:18,
						height:vertical?18:40,
						borderColor:zim.tin,
						borderWidth:3,
						corner:8
					};
				} else if (button == "aztec") {
					w = DS.width!=null?DS.width:Math.max(w,h)*.9;
					h = DS.height!=null?DS.height:Math.min(w,h)*.6;					
					var bs = makeAztec(DS.backgroundColor!=null?DS.backgroundColor:zim.lighter,w,h).rot(vertical?0:-90);
					var bs2 = makeAztec(DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.white,w,h).rot(vertical?0:-90);
					special = {
						width:w,
						height:h,
						backing:bs,
						rollBacking:bs2,
					};
					DS.borderWidth = 0;
					DS.borderColor = 0;
				} else if (button == "circle") {
					w = DS.width!=null?DS.width:30;
					h = DS.height!=null?DS.height:30;
					special = {
						width:w,
						height:w,
						corner:DS.corner!=null?DS.corner:w/2
					};
					// circle adjusted after
				} // grip added after
				that.buttonType = button;
			}
			
			var bColor = DS.borderColor!=null?DS.borderColor:special?special.borderColor:borderCheck?zim.granite:null;
			var bgC = DS.backgroundColor!=null?DS.backgroundColor:zim.white;
			button = new zim.Button({
				width:DS.width!=null?DS.width:special?special.width:w,
				height:DS.height!=null?DS.height:special?special.height:h,
				label:"",
				backgroundColor: bgC,
				rollBackgroundColor: DS.rollBackgroundColor!=null?DS.rollBackgroundColor:range?bgC:zot(DS.backgroundColor)||DS.backgroundColor==zim.white?zim.moon:DS.backgroundColor.lighten(.2),
				borderColor: bColor,
				rollBorderColor: DS.rollBorderColor!=null?DS.rollBorderColor:bColor,
				borderWidth: DS.borderWidth!=null?DS.borderWidth:special?special.borderWidth:borderCheck?1:null,
				corner: DS.corner!=null?DS.corner:special?special.corner:0,
				backing: DS.backing!=null?DS.backing.clone():special?special.backing:null,
				rollBacking: DS.rollBacking!=null?DS.rollBacking.clone():special?special.rollBacking:null,
				shadowColor: DS.shadowColor!=null?DS.shadowColor:range?-1:null,
				shadowBlur: DS.shadowBlur!=null?DS.shadowBlur:null,
				style:false
			});
			if (that.buttonType == "circle") {
				button.scaleY = h/w;
				if (!vertical) button.rot(-90);
			} else if (that.buttonType == "grip") {
				var widths = [1,1,1];
				var margin = .4;
				zim.loop(widths, function (wi, i, t) {
					if (vertical) {
						new zim.Line(button.width*.62, wi, button.borderColor?button.borderColor:zim.grey)
							.pos(0,button.height*margin/2+(i+1)*(button.height*(1-margin))/(t+1),zim.CENTER,zim.TOP,button);
					} else {
						new zim.Line(button.height*.62, wi, button.borderColor?button.borderColor:zim.grey)
							.rot(90)
							.pos(button.width*margin/2+(i+1)*(button.width*(1-margin))/(t+1),0,zim.LEFT,zim.CENTER,button);
					}
				});
			}

		}
		button.rollPersist = true;
		if (!zot(expand) || !zot(expandVertical)) button.expand(expand, expandVertical);

		var width; var height;
		if (vertical) {
			width = button.width;
			if (inside) {
				height = barLength;
				this.setBounds(0, 0, width, height);
			} else {
				height = barLength + button.height;
				this.setBounds(-button.width/2, -button.height/2, width, height);
			}
		} else {
			height = Math.max(button.height, barWidth);
			if (inside) {
				width = barLength;
				this.setBounds(0, 0, width, height);
			} else {
				width = barLength+button.width;
				this.setBounds(-button.width/2, -button.height/2, width, height);
			}
		}

		var myValue = min;
		var lastValue = 0; // does not include min so always starts at 0
		this.button = button;
		this.cur("pointer");

		var bar, rect, bounds, ticks, g;

		if (useTicks) {
			ticks = this.ticks = new zim.Shape({style:false});
			this.addChild(ticks);
			g = ticks.graphics;
			g.ss(1).s(tickColor);
			var stepsTotal = Math.round((max - min) / (tickStep||step));
			
			var newStep = (max - min) / stepsTotal;
			if (tickStep) {
				if (newStep != tickStep) {if (zon) zogy("Slider() - non-divisible step ("+tickStep+") adjusted to " + newStep);}
				tickStep = newStep;
				// step = newStep;
			} else {
				if (newStep != step) {if (zon) zogy("Slider() - non-divisible step ("+step+") adjusted to " + newStep);}
				step = newStep;
			}
			var spacing;
			if (inside) {
				spacing = (barLength - ((vertical) ? button.height : button.width)) / Math.abs(stepsTotal);
			} else {
				spacing = barLength / Math.abs(stepsTotal);
			}			
		}

		var start, labels, i, tickLarge, x, y, dd;
		if (vertical) {
			start = (inside) ? button.height / 2 : 0;
			bar = this.bar = new zim.Rectangle(barWidth, barLength, barColor, null, null, null, null, null, null, false);
			if (expandBar) bar.expand(expandBar, expandBarVertical);
			else bar.expand(20,0);
			bar.centerReg(this);
			button.centerReg(this);
			bounds = bar.getBounds();
			rect = new createjs.Rectangle(bar.x, bounds.y+start, 0, bounds.height-start*2);
			if (useTicks) {
				if (useLabels) {
					labels = that.labels = new zim.Container().addTo(that);
				}
				for (i=0; i<=Math.abs(stepsTotal); i++) {
					tickLarge = (i%(semiTicks+1)==0);
					x = (tickLarge?25*tickScale:15*semiTickScale);
					y = start+spacing*i;
					g.mt(0, y).lt(x, y);
					if (useLabels && ((semiTicks && tickLarge) || !semiTicks)) {
						dd = Math.max(zim.countDecimals(step0), zim.countDecimals(min), zim.countDecimals(max));
						new zim.Label({
							text:zim.decimals(max-(max-min)/Math.abs(stepsTotal)*i,dd+1,addZero),
							size:DS.size?DS.size:10,
							color:labelColor,
							align:"left",
							valign:"center"
						})
							.centerReg({add:false})
							.reg(0)
							.loc(x+labelMargin+2,y-1,labels);
					}
				}
				ticks.x = bar.x+15;
			}
		} else {
			start = (inside) ? button.width / 2 : 0;
			bar = this.bar = new zim.Rectangle(barLength, barWidth, barColor, null, null, null, null, null, null, false);
			if (expandBar) bar.expand(expandBar, expandBarVertical);
			else bar.expand(0,20);
			bar.centerReg(this);
			button.centerReg(this);
			bounds = bar.getBounds();
			rect = new createjs.Rectangle(bounds.x+start, bar.y, bounds.width-start*2, 0);
			if (useTicks) {
				if (useLabels) {
					labels = that.labels = new zim.Container().addTo(that);
				}
				for (i=0; i<=Math.abs(stepsTotal); i++) {
					tickLarge = (i%(semiTicks+1)==0);
					x = start+spacing*i;
					y = -(tickLarge?25*tickScale:15*semiTickScale);
					g.mt(x,0).lt(x,y);
					if (useLabels && ((semiTicks && tickLarge) || !semiTicks)) {						
						dd = Math.max(zim.countDecimals(step0), zim.countDecimals(min), zim.countDecimals(max));
						new zim.Label({
							text:zim.decimals(min+(max-min)/Math.abs(stepsTotal)*i,dd+1,addZero),
							size:DS.size?DS.size:10,
							color:labelColor,
							align:"center",
							valign:"center"
						})
							.centerReg({add:false})
							.loc(x,y-labelMargin,labels)
					}
				}
				ticks.y = bar.y-10;				
			}
		}
		button.x = rect.x;
		button.y = rect.y;

		function snap(v) {
			if (step == 0) return v;
			return Math.round(v/step)*step;
		}

		var diffX, diffY;
		button.on("mousedown", function(e) {
			stage = e.target.stage;
			that.focus = true;
			var point = that.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
			diffX = point.x - button.x;
			diffY = point.y - button.y;
			if (stage) stage.mouseMoveOutside = true;
		});
	
		button.on("pressmove", function(e) {
			setValue(e);
		});
		function setValue(e) {
			var point = that.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
			var p = checkBounds(point.x-diffX, point.y-diffY, rect);
			if (vertical) {
				button.x = p.x;
				myValue = snap((p.y-rect.y) / rect.height * (min - max));
				button.y = rect.y + myValue * rect.height / (min - max);
				myValue += max;
				if (button.y != lastValue) {
					that.dispatchEvent("change");
				}
				lastValue = button.y;
			} else {
				myValue = snap((p.x-rect.x) / rect.width * (max - min));
				button.x = rect.x + myValue * rect.width / (max - min);
				myValue += min;
				button.y = p.y;
				if (button.x != lastValue) {
					that.dispatchEvent("change");
				}
				lastValue = button.x;
			}
			if (accent) drawAccent();
			setAccessibility();
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}

		function sign(n) {return n > 0 ? 1 : -1;}

		function setAccessibility() {
			if (that.zimAccessibility) that.zimAccessibility.changeTitle(that, null, true);
		}

		function checkBounds(x,y,rect) {
			x = Math.max(rect.x, Math.min(rect.x+rect.width, x));
			y = Math.max(rect.y, Math.min(rect.y+rect.height, y));
			return {x:x,y:y};
		}

		bar.on("mousedown", function(e) {
			stage = e.target.stage;
			diffX = 0; // button.width/2;
			diffY = 0; // button.height/2;
			if (that.zimAccessibility && that.zimAccessibility.aria) return;
			setValue(e);
		});

		var myDampedValue;
		var dampObject;
		if (damp) {
			myDampedValue = min;
			dampObject = new zim.Damp(myDampedValue, damp);
			that.ticker = zim.Ticker.add(function () {
				myDampedValue = dampObject.convert(myValue);
			});
		}

		Object.defineProperty(this, 'currentValue', {
			get: function() {
				return damp?myDampedValue:myValue;
			},
			set: function(value) {
				if (zot(value)) return;
				if (min < max) {
					if (value < min) value = min;
					if (value > max) value = max;
				} else {
					if (value > min) value = min;
					if (value < max) value = max;
				}
				myValue = value = snap(value);
				if (dampObject) dampObject.immediate(myValue);
				if (vertical) {
					button.y = (value - max) / (min - max) * rect.height + start;
					lastValue = button.y;
				} else {
					button.x = (value - min) / (max - min) * rect.width + start;
					lastValue = button.x;
				}
				if (accent) drawAccent();
				setAccessibility();
				if (range) that.update();
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(this, 'currentValueEvent', {
			get: function() {
				return damp?myDampedValue:myValue;
			},
			set: function(value) {
				if (value != that.currentValue) {
					that.currentValue = value;
					that.dispatchEvent("change");
				}
			}
		});

		Object.defineProperty(this, 'min', {
			get: function() {
				return min;
			},
			set: function() {
				if (zon) zogy("Slider() - min is read only");
			}
		});

		Object.defineProperty(this, 'max', {
			get: function() {
				return max;
			},
			set: function() {
				if (zon) zogy("Slider() - max is read only");
			}
		});

		Object.defineProperty(this, 'step', {
			get: function() {
				return step;
			},
			set: function() {
				if (zon) zogy("Slider() - step is read only");
			}
		});

		Object.defineProperty(this, 'keyArrowsH', {
			get: function() {
				return keyArrowsH;
			},
			set: function(value) {
				keyArrowsH = value;
			}
		});

		Object.defineProperty(this, 'keyArrowsV', {
			get: function() {
				return keyArrowsV;
			},
			set: function(value) {
				keyArrowsV = value;
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (keyArrows && !zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {if (keyArrows) setFocus();});
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}

		var leftCheck = false; var downCheck = false; var rightCheck = false; var upCheck = false;
		this.keyDownEvent = function(e) {
			if (!that.stage) return;
			if ((that.zimAccessibility && that.focus) || (!that.zimAccessibility && that.keyFocus)) {
				if (e.keyCode == 37 && keyArrowsH) leftCheck = true;
				else if (e.keyCode == 40 && keyArrowsV) downCheck = true;
				else if (e.keyCode == 39 && keyArrowsH) rightCheck = true;
				else if (e.keyCode == 38 && keyArrowsV) upCheck = true;
				if (that.keyInterval == null && (leftCheck || downCheck || rightCheck || upCheck)) {
					checkKey();
					// add traditional keydown delay
					that.keyTimeout = setTimeout(function() {
						if (that.keyInterval == null && (leftCheck || downCheck || rightCheck || upCheck)) that.keyInterval = setInterval(checkKey, 40);
					}, 140);
				}
			}
		};
		function checkKey() {
			if (leftCheck || downCheck) {
				if (step > 0) that.currentValueEvent -= step * sign(max-min);
				else that.currentValueEvent -= keyArrowsStep * sign(max-min);
			}
			if (rightCheck || upCheck) {
				if (step > 0) that.currentValueEvent += step * sign(max-min);
				else that.currentValueEvent += keyArrowsStep * sign(max-min);
			}
		}
		WW.addEventListener("keydown", this.keyDownEvent);
		that.keyUpEvent = function(e) {
			if (e.keyCode == 37) leftCheck = false;
			else if (e.keyCode == 40) downCheck = false;
			else if (e.keyCode == 39) rightCheck = false;
			else if (e.keyCode == 38) upCheck = false;
			if (that.keyInterval != null && !leftCheck && !downCheck && !rightCheck && !upCheck) {
				clearInterval(that.keyInterval);
				that.keyInterval = null;
			}
		};
		WW.addEventListener("keyup", this.keyUpEvent);

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
				if (value) {
					if (range) return;
					WW.addEventListener("keydown", that.keyDownEvent);
					WW.addEventListener("keyup", that.keyUpEvent);
				} else {
					if (range) return;
					WW.removeEventListener("keydown", that.keyDownEvent);
					WW.removeEventListener("keyup", that.keyUpEvent);
				}
			}
		});


		if (!zot(currentValue)) that.currentValue = currentValue;
		
		zim.setSwipe(this, false);

		if (style!==false) zim.styleTransforms(this, DS);
		

		this.clone = function(exact) {
			return that.cloneProps(new zim.Slider((exact||!zim.isPick(oa[0]))?that.min:oa[0], (exact||!zim.isPick(oa[1]))?that.max:oa[1], (exact||!zim.isPick(oa[2]))?that.step:oa[2], button.clone(), barLength, barWidth, barColor, vertical, useTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, inside, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, damp, (exact||!zim.isPick(oa[3]))?that.currentValue:oa[3], expand, expandVertical, expandBar, expandBarVertical, useLabels, labelMargin, labelColor, range, rangeColor, rangeWidth, rangeMin, rangeMax, rangeAve, addZero, style, this.group, inherit));
		};

		if (range) {
			range = false;
			WW.removeEventListener("keydown", that.keyDownEvent);
			WW.removeEventListener("keyup", that.keyUpEvent);
			this.rangeSliderA = this;			
			this.rangeButtonA = button;			
			var slider2 = this.rangeSliderB = this.clone().addTo(this);
			slider2.on("change", function() {
				that.dispatchEvent("change");
			});
			this.rangeSliderA.currentValue = rangeMin;
			this.rangeSliderB.currentValue = rangeMax;
			var button2 = this.rangeButtonB = slider2.button;
			WW.removeEventListener("keydown", slider2.keyDownEvent);
			WW.removeEventListener("keyup", slider2.keyUpEvent);
			if (slider2.bar) slider2.bar.dispose();
			if (slider2.labels) slider2.labels.dispose();
			if (slider2.ticks) slider2.ticks.dispose();
			if (slider2.accent) slider2.accent.dispose();
			if (slider2.accentBacking) slider2.accentBacking.dispose();
			var line = this.rangeBar = new zim.Rectangle(100,rangeWidth,rangeColor).reg(0,rangeWidth/2).addTo(this).ord(-2).drag({onTop:false});
			line.on("pressmove", function() {
				line.y = bar.y;
				if (line.x < 0) line.x = 0;
				if (line.x > bar.width - line.width) line.x = bar.width - line.width;
				slider2.currentValue = (line.x + line.width) / bar.width * (that.max - that.min);				
				that.currentValue = line.x / bar.width * (that.max - that.min);
                that.dispatchEvent("change");
			})
			this.update = function() {
				line.x = Math.min(button2.x, button.x);
				line.widthOnly = Math.abs(button2.x-button.x);
			}
			this.bar.noMouse();
			button.on("pressmove", this.update);
			button2.on("pressmove", this.update);
			this.update();
			range = true;

			Object.defineProperty(that, 'rangeMin', {
				get: function() {
					return Math.min(button2.x, button.x) / bar.width * (that.max - that.min);
				},
				set: function(value) {
					if (button2.x < button.x) slider2.currentValue = value;
					else that.currentValue = value;
					that.update();
				}
			});

			Object.defineProperty(that, 'rangeMax', {
				get: function() {
					return Math.max(button2.x, button.x) / bar.width * (that.max - that.min);
				},
				set: function(value) {
					if (button2.x > button.x) slider2.currentValue = value;
					else that.currentValue = value;
					that.update();
				}
			});

			Object.defineProperty(that, 'rangeAve', {
				get: function() {
					return (Math.min(button2.x, button.x) + Math.abs(button2.x - button.x)/2) / bar.width * (that.max - that.min);
				},
				set: function(value) {
					var diff = Math.abs(button2.x - button.x);
					var loc = (value - that.min) / (that.max - that.min) * bar.width;
					var diffMin = loc - diff/2;
					var diffMax = loc + diff/2;
					if (diffMin < 0) {
						if (button.x < button2.x) {
							button.x = 0;
							button2.x = button.x + diff;
						} else {
							button2.x = that.min;
							button.x = button2.x + diff;
						}
					} else if (diffMax > bar.width) {
						if (button.x > button2.x) {
							button.x = bar.width;
							button2.x = button.x - diff;
						} else {
							button2.x = bar.width;
							button.x = button2.x - diff;
						}
					} else {
						if (button.x < button2.x) {
							button.x = loc - diff/2;
							button2.x = loc + diff/2;
						} else {
							button2.x = loc - diff/2;
							button.x = loc + diff/2;
						}
					}
					that.update();
				}
			});

			Object.defineProperty(that, 'rangeAmount', {
				get: function() {
					return Math.abs(button2.x - button.x) * (that.max - that.min) / bar.width;
				},
				set: function(value) {
					zogy("ZIM Slider - rangeAmount is read only")
				}
			});
			if (!zot(rangeAve)) this.rangeAve = rangeAve;

		}

		this.dispose = function(a,b,disposing) {
			WW.removeEventListener("keydown", that.keyDownEvent);
			WW.removeEventListener("keyup", that.keyUpEvent);
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};
	};
	zim.extend(zim.Slider, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-62

/*--
zim.Selector = function(tile, borderColor, borderWidth, backgroundColor, corner, dashed, paddingH, paddingV, speed, diagonal, dim, multi, keyArrows, behind, resizeScale, selectedIndex, liveIndex, style, group, inherit);

Selector
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A Selector acts on a ZIM Tile to provide an interactive selector that highlights a tile element.
The selector works as a select bar and a select pad.

See: https://zimjs.com/ten/wrapper.html which includes several Selector objects as bars
Selector as a pad would be similar to selecting letters on an onscreen TV remote system

Selector has a multi parameter that allows for multiple elements to be in selected mode.
The selectedIndex or selectedItem will only be the last selected.
And only one selecteIndex can be set at a time
but as many as desired can be set one after another - in a loop for instance.
The difference is that once selected, the item remains highlighted until unselected with a presseup.
This allows for a synth pad for instance where multiple notes can be played at the same time.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// the items in the Tile should be centerReg()
new Selector(new Tile(new Rectangle().centerReg(), 4, 4, 20, 20))
	.center()
	.change(e=>{
		e.target.currentItem.alpha = 0;
		S.update();
	});
S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
tile - (default four red circles) the ZIM Tile to which to apply the selector
	the elements should have their registration centered
	see Tile for how to tile a series of different objects, etc.
	this will work as a horizontal or vertical bar or a grid selector
borderColor - (default white) the border color of the selector
borderWidth - (default 2) the border width of the selector
backgroundColor - (default "rgba(0,0,0,.1)") the background color of the selector
corner - (default 10) the corner radius of the selector
dashed - (default false) the dashed border setting of the selector
paddingH - (default half tile spacingH) the space from the selected item
paddingV - (default half tile spacingV) the background color of the selector
speed - (default 2) the speed the selector moves to the next selection - can set to 0 for instant
diagonal - (default false) defaults to animate horizontally and vertically - set to true for diagonally
dim - (default null) set to true for .7 alpha or a number between 0-1 for tile to dim while selector animates
multi - (default false) set to true to enable multiple highlights
	selectedIndex and selectedItem will still read only the last selected tile or set only one tile at a time
	will need a multitouch devices - degrades fine to single touch if no multitouch
keyArrows - (default true) set to false to disable keyboard arrows
behind - (default false) set to true to put selector behind tile
resizeScale - (default false) set to true to resize the border as selector changes scale
selectedIndex - (default 0) the item index on which to start the selector - set to -1 for no selection
liveIndex - (default false) set to true to update the selectedIndex and dispatch a change event as selector animates across items
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - the index number of the selected item in the tile - set to -1 for no selection
liveIndex - gets or sets whether to update the selectedIndex and dispatch a change event as selector animates across items
currentItem - gets or sets the current item under the selector
noAnimate - set to make the next selectedIndex or currentItem call not animate to tile
MULTI - in a change event with multi set:
	downIndex - this will be the index under the selector on press down (or null if pressing up)
	upIndex - this will be the index under the selector on press up (or null if pressing down)
	downItem - this will be the item under the selector on press down (or null if pressing up)
	upItem - this will be the item under the selector on press up (or null if pressing down)
lastIndex - get the last selected index
lastItem - get the last selected item
selectedCol - get the index of the selected column
selectedRow - get the index of the selected row
lastCol - get the index of the last selected column
lastRow - get the index of the last selected row
tile - a reference to the Tile object
selector - a reference to the Rectangle object used as the selector
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event when selector finishes animating to a new selection or for each index if liveIndex is true 
dispatches a "changeset" event if selectedIndex or currentItem is set programatically (not user selected)
note that a tap() or mousedown/click function can be used if the selectedIndex is desired right away

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+62.5
	zim.Selector = function(tile, borderColor, borderWidth, backgroundColor, corner, dashed, paddingH, paddingV, speed, diagonal, dim, multi, keyArrows, behind, resizeScale, selectedIndex, liveIndex, style, group, inherit) {
		var sig = "tile, borderColor, borderWidth, backgroundColor, corner, dashed, paddingH, paddingV, speed, diagonal, dim, multi, keyArrows, behind, resizeScale, selectedIndex, liveIndex, style, group, inherit";
		var duo; if (duo = zob(zim.Selector, arguments, sig, this)) return duo;
		z_d("62.5");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Selector";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		var timeType = getTIME();

		if (zot(tile)) tile = DS.tile!=null?DS.tile:new zim.Tile(new zim.Circle(20, zim.red), 4, 4, 10, 10);
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zim.white;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:2;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"rgba(0,0,0,.1)";
		if (zot(corner)) corner = DS.corner!=null?DS.corner:10;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:false;
		if (zot(paddingH)) paddingH = DS.padding!=null?DS.padding:tile.spacingH/2;
		if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:tile.spacingV/2;
		if (zot(speed)) speed = DS.speed!=null?DS.speed:2;
		if (zot(diagonal)) diagonal = DS.diagonal!=null?DS.diagonal:false;
		if (zot(dim)) dim = DS.dim!=null?DS.dim:false;
		if (zot(multi)) multi = DS.multi!=null?DS.multi:false;
		if (multi) speed = 0;
		if (zot(keyArrows)) keyArrows = DS.keyArrows!=null?DS.keyArrows:true;
		if (zot(behind)) behind = DS.behind!=null?DS.behind:false;
		if (zot(resizeScale)) resizeScale = DS.resizeScale!=null?DS.resizeScale:false;
		if (zot(selectedIndex)) selectedIndex = DS.selectedIndex!=null?DS.selectedIndex:null;
		if (zot(liveIndex)) liveIndex = DS.liveIndex!=null?DS.liveIndex:false;
		this.liveIndex = liveIndex;

		var borderColors = [];
		var backgroundColors = [];
		zim.loop(tile.items.length, function() {
			borderColors.push(zik(borderColor));
			backgroundColors.push(zik(backgroundColor));
		});

		var that = this;

		if (!(zot(selectedIndex) && multi)) {
			var originalIndex = selectedIndex;
			var tempIndex = zot(selectedIndex)||selectedIndex<0?0:selectedIndex;
			var currentItem = tile.getChildAt(tempIndex);
			that.currentItem = tile.getChildAt(tempIndex);
			selectedIndex = originalIndex;
			if (zot(selectedIndex)) selectedIndex = DS.selectedIndex!=null?DS.selectedIndex:0;
		}

		var target;
		var targetW;
		var targetH;

		target = currentItem || tile.getChildAt(0);
		if (target) {
			targetW = target.width+paddingH*2;
			targetH = target.height+paddingV*2;
		}

		that.tile = tile.addTo(that).cur();

		var selector;
		if (multi) {
			var selectors = this.selectors = [];
			selector;
			zim.loop(10, function () {
				selector = new zim.Rectangle(targetW, targetH, zim.faint, zim.faint, borderWidth, corner, dashed, {ignoreScale:!resizeScale})
					.centerReg(that, behind?0:1);
				selector.visible = false;
				selectors.push(selector);
				selector.mouseEnabled = false;
			});
			this.selector = selector;
		} else {
			selector = this.selector = new zim.Rectangle(targetW, targetH, zim.faint, zim.faint, borderWidth, corner, dashed, {ignoreScale:!resizeScale})
				.centerReg(that);
			selector.loc(tile.width/2, target.y+paddingV, that, behind?0:1);
			selector.visible = false;
		}
		if (!(selectedIndex < 0 || zot(currentItem))) {
			selector.loc(target.x+paddingH, target.y+paddingV, that, behind?0:1);
			selector.color = backgroundColors[selectedIndex];
			selector.borderColor = borderColors[selectedIndex];
			selector.visible = true;
		}

		tile.mov(paddingH, paddingV);
		this.setBounds(tile.width+paddingH*2, tile.height+paddingV*2);

		var pointers = {};
		this.tileDown = tile.on("mousedown", function (e) {
			var sel = selector;
			if (multi) {
				sel = selectors.shift();
				if (zot(sel)) return;
			}
			sel.visible = true;
			var target = e.target;
			var tries = 0;
			while(target.parent != tile && tries < 10) {target = target.parent; tries++;}

			if (target.parent == tile) go(target, null, sel);
			if (multi) {
				var id = "id"+Math.abs(e.pointerID+1); // some pointers have negative ids
				pointers[id] = {index:selectedIndex, item:currentItem, selector:sel};
			}
		});
		if (multi) {
			this.tileMove = tile.on("pressmove", function (e) {
				var id = "id"+Math.abs(e.pointerID+1); // some pointers have negative ids
				var p = pointers[id];
				if (zot(p)) return;
				var item = tile.itemUnderPoint(e.stageX/zim.scaX, e.stageY/zim.scaY);
				if (p.item != item) {
					that.upItem = p.item;
					that.upIndex = p.index;
					that.downItem = p.item = item;
					that.downIndex = p.index = item?item.tileNum:null;
					that.dispatchEvent("change");
					if (zot(item)) p.selector.visible = false;
					else {
						var point = tile.localToLocal(item.x, item.y, that);
						p.selector.loc(point.x, point.y).siz(item.width+paddingH*2, item.height+paddingV*2);
						p.selector.color = backgroundColors[p.index];
						p.selector.borderColor = borderColors[p.index];
						p.selector.visible = true;
					}
					that.stage.update();
				}
			});
			this.tileUp = tile.on("pressup", function (e) {
				var id = "id"+Math.abs(e.pointerID+1); // some pointers have negative ids
				var p = pointers[id];
				if (zot(p)) return;
				that.downIndex = that.downItem = null;
				that.upIndex = p.index;
				that.upItem = p.item;
				selectors.push(p.selector);
				p.selector.visible = false;
				that.dispatchEvent("change");
				if (that.stage && (!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE))) that.stage.update();
				delete pointers[id];
			});
		}
		that.noAnimate = false;
		function go(target, noAnimate, sel, noDispatch) {
			if (zot(sel)) sel = selector;
			currentItem = target;
			selectedIndex = target.tileNum;
			sel.color = backgroundColors[selectedIndex];
			sel.borderColor = borderColors[selectedIndex];
			if (multi) {
				that.upItem = that.upIndex = null;
				that.downItem = currentItem;
				that.downIndex = selectedIndex;
			}
			that.animating = true;
			var point = tile.localToLocal(target.x, target.y, that);
			var dX = Math.abs(point.x-selector.x);
			var dY = Math.abs(point.y-selector.y);
			var s = that.noAnimate||noAnimate?0:speed;
			that.noAnimate = false;

			if (s == 0) {
				sel.loc(point.x, point.y).siz(target.width+paddingH*2, target.height+paddingV*2);
				that.animating = false;
				that.dispatchEvent("change");
			} else {
				if (diagonal || (dX+dY)*s <= 0) {
					sel.animate({x:point.x, y:point.y},(dY+dX)*s);
				} else {
					sel.stopAnimate();
					if (dX>=dY) {
						sel.animate([
							{props:{x:point.x}, time:Math.max(timeType=="s"?.1:100,dX*s/(timeType=="s"?1000:1))},
							{props:{y:point.y}, time:Math.max(timeType=="s"?.1:100,dY*s/(timeType=="s"?1000:1))}
						]);
					} else {
						sel.animate([
							{props:{y:point.y}, time:Math.max(timeType=="s"?.1:100,dY*s/(timeType=="s"?1000:1))},
							{props:{x:point.x}, time:Math.max(timeType=="s"?.1:100,dX*s/(timeType=="s"?1000:1))}
						]);
					}
				}
				sel.animate({
					props:{widthOnly:target.width+paddingH*2, heightOnly:target.height+paddingV*2},
					time:Math.max(timeType=="s"?.2:200,(dY+dX)*s/(timeType=="s"?1000:1)),
					events:that.liveIndex,
					call:function () {
						that.animating = false;
						if (!noDispatch) that.dispatchEvent("change");
						else that.dispatchEvent("changeset")
					}
				});
				if (that.liveIndex) {
					var lastNum = null;
					sel.on("animation", function() {
						var point = sel.parent.localToGlobal(sel.x, sel.y);
						var over = tile.itemUnderPoint(point.x, point.y);
						if (over.tileNum != lastNum) {
							selectedIndex = over.tileNum;
							if (!noDispatch) that.dispatchEvent("change");
							else that.dispatchEvent("changeset")
							lastNum = over.tileNum;
						}
					})
				}
				if (dim) {
					if (dim === true) var d = .7;
					else d = zim.constrain(dim, 0, 1);
					tile.animate({
						props:{alpha:d},
						rewind:true,
						time:(dY+dX)*speed*.7/(timeType=="s"?1000:1)
					});
				}
			}
			if (tile.stage) tile.stage.update();
		}

		if (keyArrows) {
			that.added(function () {
				that.keyEvent = that.stage.frame.on("keydown", function (e) {
					if (!that.stage) return;
					if (!that.enabled) return;
					if (that.animating) return;
					if ((that.zimAccessibility && that.focus) || (!that.zimAccessibility && that.keyFocus)) {
						var answer = zim.loop(tile.items2D, function (row, j) {
							var answer = zim.loop(row, function (item, i) {
								if (item == currentItem) {return [i,j];}
							});
							if (Array.isArray(answer)) return answer;
						});
						if (answer === true) answer = [0,0];
						var colLength = tile.items2D[answer[1]].length;
						var rowLength = tile.items2D.length;
						var newIndex;
						if (e.keyCode == "39") {
							newIndex = (answer[0]+1)%colLength;
							go(tile.items2D[answer[1]][newIndex], newIndex<answer[0]);
						} else if (e.keyCode == "37") {
							newIndex = (answer[0]-1+colLength)%colLength;
							go(tile.items2D[answer[1]][newIndex], newIndex>answer[0]);
						} else if (e.keyCode == "38") {
							newIndex = (answer[1]-1+rowLength)%rowLength;
							go(tile.items2D[newIndex][answer[0]], newIndex>answer[1]);
						} else if (e.keyCode == "40") {
							newIndex = (answer[1]+1)%rowLength;
							go(tile.items2D[newIndex][answer[0]], newIndex<answer[1]);
						}
					}
				});
			});
		}

		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				return selectedIndex;
			},
			set: function(value) {
				if (zot(value)) that.currentItem = null;
				that.currentItem = tile.items[Math.round(value)];
			}
		});
		
		Object.defineProperty(this, 'text', {
			get: function() {
				return currentItem.text;
			},
			set: function() {
				if (zon) zogy("Selector() - text is read only");
			}
		});

		Object.defineProperty(this, 'currentItem', {
			get: function() {
				return currentItem;
			},
			set: function(value) {
				if (zot(value)) {
					currentItem = null;
					selectedIndex = null;
					selector.visible = false;
					that.selectedCol = null;
					that.selectedRow = null;
					return;
				}
				selector.visible = true;
				that.lastItem = currentItem;
				that.lastIndex = selectedIndex;
				that.lastCol = that.selectedCol;
				that.lastRow = that.selectedRow;
				that.selectedCol = value.tileCol;
				that.selectedRow = value.tileRow;
				selectedIndex = value.tileNum;
				currentItem = value;
				go(currentItem, null, null, true);
			}
		});
		
		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				if (value) {
					that.mouse();
				} else {
					that.noMouse();
				}
				that._enabled = value;
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (!zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {setFocus();});
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.clone = function(exact) {
			var cl = tile.clone?tile.clone(exact):tile;
			cl.x = cl.y = 0;
			return that.cloneProps(new zim.Selector(cl, borderColor, borderWidth, backgroundColor, corner, dashed, paddingH, paddingV, speed, diagonal, dim, multi, keyArrows, behind, resizeScale, selectedIndex, liveIndex, this.style, this.group));
		};
		this.dispose = function(a,b,disposing) {
			if (that.keyEvent && that.stage) that.stage.frame.off("keydown", that.keyEvent);
			tile.off(that.tileDown);
			tile.dispose();			
			if (multi) {
				tile.off(that.tileMove);
				tile.off(that.tileUp);
			}
			if (!disposing) this.zimContainer_dispose(true);
		};

	};
	zim.extend(zim.Selector, zim.Container, ["clone","dispose"], "zimContainer", false);
	//-62.5

/*--
zim.Dial = function(min, max, step, width, backgroundColor, indicatorColor, indicatorScale, indicatorType, useTicks, innerTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, innerCircle, innerScale, innerColor, inner2Color, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, linear, gap, limit, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, continuous, continuousMin, continuousMax, damp, currentValue, useLabels, labelMargin, addZero, style, group, inherit);

Dial
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A traditional dial - will give values back based on min and max and position of dial.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
var dial = new Dial({step:1, backgroundColor:"violet"})
	.center()
	.change(()=>{
		zog(dial.currentValue); // 1-10 in steps of 1
	});
S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
min - |ZIM VEE| (default 0) the minimum value for the dial
max - |ZIM VEE| (default 10) the maximum value for the dial
step - |ZIM VEE| (default 1) 1 provides steps of 1, 0 is continuous decimal, 2 would provide steps of 2, etc.
width - (default 100) the width of the dial (diameter)
backgroundColor - (default granite) the background color of the dial
indicatorColor - (default licorice) the color of the indicator
indicatorScale - (default 1) the scale of the indicator
indicatorType - (default "arrow" or "triangle") can also be "dot" or "circle", and "line" or "rectangle"
useTicks - (default true - unless step set to 0) will show lines for ticks
innerTicks (default false) set to true to put the ticks inside if step is set
tickColor - (default backgroundColor) set the tick color if ticks are set
tickStep - (default step - or 1 if no step and useTicks is true) set to adjust tick amount
semiTicks - (default 0) add a number of semiTicks.  1 would add one smaller tick between ticks, 4 would add 4 smaller ticks, etc.
tickScale - (default 1) scale the height of the ticks
semiTickScale - (default 1) scale the height of the semiTicks
innerCircle - (default true) gives an inner knob look - set to false for flat
innerScale - (default 1) can be adjusted along with indicatorScale to get a variety of looks
innerColor - (default "rgba(0,0,0,.2)") color of first inner circle
inner2Color - (default "rgba(0,0,0,.1)") color of inside inner circle
accentSize - (defualt 0) height of a ring around the dial that can be used to accent selection
accentOffset - (default .45 width/2) distance from edge of dial the accent will show
accentColor - (default zim.pink) color of filled part of accent
accentBackgroundColor - (default clear) color of background of accent
accentDifference - (default -.25) pixels accent background is bigger (or smaller if negative) than accentSize
	this is used to stop bleeding of accent background
	but can also be used to make the accent half the width of the background so it runs in a track, etc.
	or fatter than the background so it runs on a wire or mono-rail
sound - (default false) - set to true to rotate dial -180 and set a gap of .25
	adjusts various defaults for ticks, accent, indicatorType, etc.
linear - (default false - unless sound is true) - set to true to pressdrag up and down to increase and decrease dial
gap - (default 0) ratio of circle 360 to leave as a gap between dial start and dial end
limit - (default true) stops dial from spinning right around - set to false to not limit dial
keyArrows - (default true) set to false to disable keyboard arrows
keyArrowsStep - (default 1% of max-min) number to increase or decrease value when arrow is used
	if step is set, then this value is ignored and set to step
keyArrowsH - (default true) use left and right arrows when keyArrows is true
keyArrowsV - (default true) use up and down arrows when keyArrows is true
continuous - (default false) this turns the dial into a continuous dial from the min at the top
	The (max-min)/360 give a delta value per degree
	and as the dial goes clockwise it adds the delta and as it goes counterclockwise it subtracts the delta
	The steps are still used or not if set to zero
	The min and max are no longer a real min and max - see the continuousMin and continuousMax below
	limit is ignored or set to false when continuous is true
continuousMin - (default null) set to Number to limit the minimum total value of the dial when continuous is true
continuousMax - (default null) set to Number to limit the maximum total value of the dial when continuous is true
damp - (default null) set to value such as .1 to damp the slider currentValue
	IGNORED when limit set to false - otherwise may damp incorrectly
	use with Ticker rather than "change" event - eg:
	Ticker.add(function () {circle.x = slider.currentValue;});
currentValue - |ZIM VEE| (default min value) - set the currentValue at start
useLabels - (default false) - add Labels to ticks if useTicks is true - can apply STYLE 
labelMargin - (default 10) - distance from ticks to Label if useLabels is true
addZero - (default false) add zero on end of decimals for useLabels true
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
currentValue - gets or sets the current value of the dial
currentValueEvent - gets or sets the current value and dispatches a "change" event if set and changed
min, max - read only assigned values unless continuous is true - then write enabled
step - read only - the assigned values
continuous - gets a boolean as to whether the continuous is true (read only)
continuousMin - get or set the continuousMin if continuous is set to true
continuousMax - get or set the continuousMax if continuous is set to true
backing - gives access to the dial backing Circle
inner and inner2 give access to any inner circles
ticks - gives access to the ticks (to scale these for example)
labels - access to the labels container if useLabels is true
accent - gives access to the access Shape
accentBacking - gives access to the accessBacking Shape
indicator - gives access to the indicator container with registration point at the dial center
indicatorShape - gives access to the shape on the end of the indicator (zim Triangle, Circle, Rectangle)
keyArrowsH, keyArrowsV - get or set the type of arrow keys to use (helpful for when cloning)
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

EVENTS
dispatches a "change" event when dial changes value (but not when setting currentValue property)

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+63
	zim.Dial = function(min, max, step, width, backgroundColor, indicatorColor, indicatorScale, indicatorType, useTicks, innerTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, innerCircle, innerScale, innerColor, inner2Color, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, linear, gap, limit, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, continuous, continuousMin, continuousMax, damp, currentValue, useLabels, labelMargin, addZero, style, group, inherit) {
		var sig = "min, max, step, width, backgroundColor, indicatorColor, indicatorScale, indicatorType, useTicks, innerTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, innerCircle, innerScale, innerColor, inner2Color, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, linear, gap, limit, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, continuous, continuousMin, continuousMax, damp, currentValue, useLabels, labelMargin, addZero, style, group, inherit";
		var duo; if (duo = zob(zim.Dial, arguments, sig, this)) return duo;
		z_d("63");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Dial";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(min)) min = DS.min!=null?DS.min:0;
		if (zot(max)) max = DS.max!=null?DS.max:10;
		if (max-min == 0) {zogy("ZIM Dial range must not be 0"); return;}
		if (zot(sound)) sound = DS.sound!=null?DS.sound:false;
		if (zot(step)) step = DS.step!=null?DS.step:sound?0:1;
		if (zot(width)) width = DS.width!=null?DS.width:100;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.granite;
		if (zot(indicatorColor)) indicatorColor = DS.indicatorColor!=null?DS.indicatorColor:sound?zim.white:zim.licorice;
		if (zot(indicatorScale)) indicatorScale = DS.indicatorScale!=null?DS.indicatorScale:sound?1:1;
		if (zot(indicatorType)) indicatorType = DS.indicatorType!=null?DS.indicatorType:sound?"aztec":"arrow";
		if (zot(useTicks)) useTicks = DS.useTicks!=null?DS.useTicks:step!=0;
		if (zot(innerTicks)) innerTicks = DS.innerTicks!=null?DS.innerTicks:false;
		if (zot(tickStep)) tickStep = DS.tickStep!=null?DS.tickStep:step?step:useTicks?.25:0;
		if (zot(semiTicks)) semiTicks = DS.semiTicks!=null?DS.semiTicks:sound?3:0;
		if (zot(tickColor)) tickColor = DS.tickColor!=null?DS.tickColor:sound?zim.tin:backgroundColor;
		if (zot(tickScale)) tickScale = DS.tickScale!=null?DS.tickScale:sound?1.25:1;
		if (zot(semiTickScale)) semiTickScale = DS.semiTickScale!=null?DS.semiTickScale:1.25;
		if (zot(innerCircle)) innerCircle = DS.innerCircle!=null?DS.innerCircle:true;
		if (zot(innerColor)) innerColor = DS.innerColor!=null?DS.innerColor:sound?zim.pink:"rgba(0,0,0,.2)";
		if (zot(inner2Color)) inner2Color = DS.inner2Color!=null?DS.inner2Color:sound?zim.light:"rgba(0,0,0,.1)";
		if (zot(innerScale)) innerScale = DS.innerScale!=null?DS.innerScale:sound?.4:.5;
		if (zot(accentSize)) accentSize = DS.accentSize!=null?DS.accentSize:sound?width/2*.15:0;
		if (zot(accentOffset)) accentOffset = DS.accentOffset!=null?DS.accentOffset:width/2*.45;
		if (zot(accentDifference)) accentDifference = DS.accentDifference!=null?DS.accentDifference:-.25;
		if (zot(accentColor)) accentColor = DS.accentColor!=null?DS.accentColor:zim.pink;
		if (zot(accentBackgroundColor)) accentBackgroundColor = DS.accentBackgroundColor!=null?DS.accentBackgroundColor:sound?zim.blue:zim.clear;
		if (zot(gap)) gap = DS.gap!=null?DS.gap:sound?.25:0;
		if (zot(linear)) linear = DS.linear!=null?DS.linear:sound;
		if (gap) {linear = true; continuous = false;}
		if (zot(limit)) limit = DS.limit!=null?DS.limit:true;
		if (zot(keyArrows)) keyArrows = DS.keyArrows!=null?DS.keyArrows:true;
		if (zot(keyArrowsStep)) keyArrowsStep = DS.keyArrowsStep!=null?DS.keyArrowsStep:(max-min)/100;
		if (zot(keyArrowsH)) keyArrowsH = DS.keyArrowsH!=null?DS.keyArrowsH:true;
		if (zot(keyArrowsV)) keyArrowsV = DS.keyArrowsV!=null?DS.keyArrowsV:true;
		if (zot(continuous)) continuous = DS.continuous!=null?DS.continuous:false;
		if (continuous) limit = DS.limit!=null?DS.limit:false; // continuous sets the limit to false
		if (zot(damp)) damp = DS.damp!=null?DS.damp:false;
		if (zot(currentValue)) currentValue = DS.currentValue!=null?DS.currentValue:null;		
		if (zot(useLabels)) useLabels = DS.useLabels!=null?DS.useLabels:false;
		if (zot(labelMargin)) labelMargin = DS.labelMargin!=null?DS.labelMargin:10;
		if (zot(addZero)) addZero = DS.addZero!=null?DS.addZero:false;
		if (limit == false) damp = null;

		var that = this;
		this.cur("pointer");
		
		// PICK
		var oa = remember(min,max,step,currentValue);
		this.veeObj = {min:oa[0], max:oa[1], step:oa[2], currentValue:oa[3]};
		function remember() {return arguments;} // for cloning PICK
		min = zim.Pick.choose(min);
		max = zim.Pick.choose(max);
		step = zim.Pick.choose(step);
		var step0 = step;
		currentValue = zim.Pick.choose(currentValue);
		
		var r = width / 2;
		var height = width;
		var myValue = min; // includes the min
		var lastValue = 0; // does not include min (so always starts at 0)

		var accent;
		if (accentSize) {
			var ar = width/2+accentOffset+accentSize/2;
			var aa = (360*gap/2);

			that.accentBacking = new zim.Shape(-r, -r, r*2, r*2)
				.addTo(this)
				.s(accentBackgroundColor)
				.ss(accentSize+accentDifference)
				.a(0,0,ar,(aa-90)*zim.RAD,(360-aa-90)*zim.RAD);
			accent = that.accent = new zim.Shape(-r, -r, r*2, r*2)
				.addTo(this);

			// var accent = that.accent = new zim.Circle(accentOffset+accentSize, accentColor).addTo(this);
		}
		function drawAccent() {
			accent.c()
				.s(accentColor)
				.ss(accentSize)
			if (linear) accent.a(0,0,ar, (aa-90)*zim.RAD, (indicator.rotation-aa*2)*zim.RAD);
			else accent.a(0,0,ar, (aa-90)*zim.RAD, (indicator.rotation-90)*zim.RAD);
		}

		var backing = this.backing = new zim.Circle(r, backgroundColor, null, null, null, null, null, null, null, false);
		if (accentSize) backing.center(this);
		else this.addChild(backing);

		if (innerCircle) {
			// var ic = (innerTicks || sound) ? "rgba(0,0,0,.2)" : "rgba(0,0,0,.1)";
			var inner = this.inner = new zim.Circle(r*innerScale, innerColor, null, null, null, null, null, null, null, false);
			this.addChild(inner);

			// if (!innerTicks) {
				var inner2 = this.inner2 = new zim.Circle(r*(innerScale-.1), inner2Color, null, null, null, null, null, null, null, false);
				this.addChild(inner2);
			//}
		}

		if (sound) that.rotation = 180;

		var ticksTotal = Math.abs(max-min)/(tickStep?tickStep:step)+(gap?1:0);
		var stepsTotal = step?Math.abs(max-min)/step:0;
		if (useTicks) {
			var ticks = this.ticks = new zim.Container({style:false});
			this.addChild(ticks);
			if (useLabels) {					
				var labels = that.labels = new zim.Container(width*2,height*2).centerReg(that);
			}
			for (var i=0; i<ticksTotal; i++) {
				var tickLarge = (i%(semiTicks+1)==0);
				var tick = new zim.Rectangle(1, r*(tickLarge?.2*tickScale:.1*semiTickScale), tickColor, null, null, null, null, null, null, false);
				tick.regY = r + (innerTicks ? innerScale-.05 : tick.height + r*.1);
				tick.regX = .5;
				tick.rotation = (360-360*gap)/(ticksTotal-(gap?1:0)) * i + 360*gap/2;
				ticks.addChild(tick);			

				if (useLabels && ((semiTicks && tickLarge) || !semiTicks)) {	
					var dd = Math.max(zim.countDecimals(step0), zim.countDecimals(min), zim.countDecimals(max));					
					new zim.Label({
						text:zim.decimals(min+(max-min)/Math.abs(stepsTotal||ticksTotal)*i,dd+1,addZero),
						size:DS.size?DS.size:10,
						align:"center",
						valign:"center"
					})
						.centerReg({add:false})
						.loc(0,-labelMargin-1,tick)
						.addTo(labels)
				}			
			}
			that.expand(tick.height);
		}

		this.setBounds(-r,-r,width,width);
		var indicator,indicatorShape;
		if (indicatorType == "dot" || indicatorType == "circle") {
			indicator = this.indicator = new zim.Container({style:false});
			indicatorShape = this.indicatorShape = new zim.Circle(r*.19, indicatorColor, null, null, null, null, null, null, null, false);
			indicator.addChild(indicatorShape);
			zim.sca(indicator, indicatorScale);
			indicator.regY = r - indicator.getBounds().width*indicatorScale/2 - r*.07;
		} else if (indicatorType == "line" || indicatorType == "rectangle") {
			indicator = this.indicator = new zim.Container({style:false});
			indicatorShape = this.indicatorShape = new zim.Rectangle(r*.1, r*.3, indicatorColor, null, null, null, null, null, null, null, null, false);
			indicator.addChild(indicatorShape);
			zim.sca(indicator, indicatorScale);
			indicator.regY = r - indicator.getBounds().width*indicatorScale/2 - r*.07;
			indicator.regX = r * .05;
		} else if (indicatorType == "aztec") {
			indicator = this.indicator = new zim.Container({style:false});
			var w1 = r*.05;
			var w2 = r*.1;
			var h = r*.42;
			indicatorShape = this.indicatorShape = new zim.Shape(-w2, 0, w2*2, h)
				.f(indicatorColor).mt(-w1,0)
				.lt(w1, 0).lt(w2, h).lt(-w2,h).cp();
			indicator.addChild(indicatorShape);
			zim.sca(indicator, indicatorScale);
			indicator.regY = r - indicator.getBounds().width*indicatorScale/2 - r*.04;
			// indicator.regX = r * .05;
		} else { // arrow
			indicator = this.indicator = new zim.Container({style:false});
			indicatorShape = this.indicatorShape = new zim.Triangle(r*.4, r*.4, r*.4, indicatorColor, null, null, null, null, null, null, null, false);
			indicator.addChild(indicatorShape);
			zim.sca(indicator, indicatorScale);
			indicator.regY = r - indicator.getBounds().height*indicatorScale*((innerTicks)?.85:.75);
			if (innerTicks) {
				indicatorShape.rotation = 180;
			}
		}
		indicator.regY /= indicatorScale;
		this.addChild(indicator);

		function snap(v) {
			if (step == 0) return v;
			return Math.round(v/step)*step;
		}

		var lastAngle;
		var startAngle;
		var moveEvent;
		var upEvent;
		var lastA = 0;
		if (continuous) {
			var lastContinuous = 0;
			var continuousAngle = 0;
			var continuousBase = 0; // keeps track of 360s
			var continuousAdjust = false; // for hitting bounds
			var resetContinuous = false; // for adjusting lastContinuous on keyUp
			var resetContinuousCheck = true; // turned off by normal rotation but turned on by key and direct currentValue calls
		} 
		if (!linear) {
			var limitCheck = true;
			this.on("mousedown", function(e) {
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				lastAngle = indicator.rotation;
				var p = that.parent.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
				var dX = p.x-that.x;
				var dY = that.y-p.y;
				startAngle = Math.atan2(dX,dY)*180/Math.PI;
				var pressTime = new Date().getTime();
				moveEvent = that.on("pressmove", function(e) {
					if (continuousAdjust) { // hit bounds so reset start
						var p = that.parent.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
						var dX = p.x-that.x;
						var dY = that.y-p.y;
						startAngle = Math.atan2(dX,dY)*180/Math.PI;
						lastAngle = indicator.rotation;
					}
					p = that.parent.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
					dX = p.x-that.x;
					dY = that.y-p.y;
					var endAngle = Math.atan2(dX,dY)*180/Math.PI;
					var angle = lastAngle + endAngle - startAngle;
					angle = (angle + 360*10000) % 360;
					if (limit && limitCheck) {
						if (angle - lastA > 180 && that.currentValue != max) angle = 0;
						else if (angle - lastA < -180) angle = 359;
					}
					limitCheck=true;
					setValue(angle);
					lastA = angle;
				});
				upEvent = this.on("pressup", function(e) {
					// added limitCheck otherwise click to other side then drag bug
					// but needs to work if sitting on edge
					if (that.currentValue != that.min && that.currentValue != that.max) limitCheck = false;
					var deltaTime = new Date().getTime()-pressTime;
					if (deltaTime < 200) {
						p = that.parent.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
						dX = p.x-that.x;
						dY = that.y-p.y;
						var angle = Math.atan2(dX,dY)*180/Math.PI-that.rotation;
						setValue(angle);
					}
					lastAngle = indicator.rotation;
					that.off("pressmove", moveEvent);
					that.off("pressup", upEvent);
				});
			});

		} else { // linear

			this.on("mousedown", function(e) {				
				if (that.zimAccessibility && that.zimAccessibility.aria) return;
				var angle = lastAngle = indicator.rotation;
				var p = that.parent.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
				moveEvent = that.on("pressmove", function(e) {
					var p2 = that.parent.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
					indicator.rotation = angle = lastAngle+(p.y-p2.y)*100/(this.width||1);
					if (limit) {
						if (angle > 360 - (360*gap/2) || angle < 0 + (360*gap/2)) {
							angle = zim.constrain(angle, (360*gap/2), 360-(360*gap/2));
							p = that.parent.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
							lastAngle = angle;
						}
					}
					setValue(angle);
				});
				upEvent = this.on("pressup", function() {
					that.off("pressmove", moveEvent);
					that.off("pressup", upEvent);
				});
			});

		}

		function sign(n) {return n > 0 ? 1 : -1;}

		function setAccessibility() {
			if (that.zimAccessibility) that.zimAccessibility.changeTitle(that, null, true);
		}

		function setValue(angle) {
			if (continuous) {
				if (resetContinuous) { // if coming from keyup
					lastContinuous = angle; // removed in 7.0.1 added in 10.9.1
					resetContinuous = false;
				}
				if (angle > lastContinuous + 180) {
					continuousBase -= 360;
				} else if (angle < lastContinuous - 180) {
					continuousBase += 360;
				}
				continuousAngle  = continuousBase + angle;
				resetContinuousCheck = false;
				var earlierValue = that.currentValue;
				that.currentValue = snap(continuousAngle * (max-min) / 360);
				if (earlierValue != that.currentValue) that.dispatchEvent("change");
				lastContinuous = angle;
				resetContinuousCheck = true;
				if (accent) drawAccent();
				return true;
			}
			var v; // value (not including min)
			if (angle < 0) angle += 360;
			angle = angle % 360;
			if (step != 0) {
				angle = Math.min(angle, 360);
				v = snap((angle-(360*gap/2)) / ((360-(360*gap))) * (max - min));
				indicator.rotation = (360*gap/2) + v * ((360-(360*gap))) / (max - min);
			} else {
				indicator.rotation = angle;
				// v = angle / 360 * (max - min);
				v = (angle-(360*gap/2)) / (360-(360*gap)) * (max - min);
			}
			if (v != lastValue) {
				lastValue = v;
				myValue = v + min;
				if (accent) drawAccent();
				that.dispatchEvent("change");
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
			setAccessibility();
		}

		var myDampedValue;
		var dampObject;
		if (damp) {
			myDampedValue = min;
			dampObject = new zim.Damp(myDampedValue, damp);
			that.ticker = zim.Ticker.add(function () {
				myDampedValue = dampObject.convert(myValue);
			});
		}

		Object.defineProperty(this, 'currentValue', {
			get: function() {
				return damp?myDampedValue:myValue;
			},
			set: function(value) {
				if(zot(value)) return;
				if (continuous) {
					continuousAdjust = false;
					if (!zot(continuousMin) && !zot(continuousMax)) {
						if (continuousMin < continuousMax) {
							if (value < continuousMin) {value = continuousMin; continuousAdjust = true;}
							if (value > continuousMax) {value = continuousMax; continuousAdjust = true;}
						} else {
							if (value > continuousMin) {value = continuousMin; continuousAdjust = true;}
							if (value < continuousMax) {value = continuousMax; continuousAdjust = true;}
						}
					} else if (!zot(continuousMin)) {
						if (value < continuousMin) {value = continuousMin; continuousAdjust = true;}
					} else if (!zot(continuousMax)) {
						if (value > continuousMax) {value = continuousMax; continuousAdjust = true;}
					}
					if (resetContinuousCheck) {
						resetContinuous = true;
						continuousBase = Math.floor(value / (max-min)) * 360;
					}
				} else {
					if (min < max) {
						if (value < min) value = limit?min:max;
						if (value > max) value = limit?max:min;
					} else {
						if (value > min) value = limit?min:max;
						if (value < max) value = limit?max:min;
					}
				}
				myValue = value;
				value = snap(value);
				if (damp) damp.immediate(myValue);

				indicator.rotation = (gap*360/2) + (value - min) * (360-gap*360) / (max - min); //  + (continuous?0:sign(max - min)*step));
				indicator.rotation = (indicator.rotation + 360 * 10000) % 360;
				lastValue = value - min;
				lastA = indicator.rotation;
				if (accent) drawAccent();
				setAccessibility();
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(this, 'currentValueEvent', {
			get: function() {
				return damp?myDampedValue:myValue;
			},
			set: function(value) {
				if (value != that.currentValue) {
					that.currentValue = value;
					that.dispatchEvent("change");
				}
			}
		});

		Object.defineProperty(this, 'min', {
			get: function() {
				return min;
			},
			set: function(value) {
				if (continuous) min = value;
				else if (zon) zogy("Dial() - min is read only");
			}
		});

		Object.defineProperty(this, 'max', {
			get: function() {
				return max;
			},
			set: function(value) {
				if (continuous) max = value;
				else if (zon) zogy("Dial() - max is read only");
			}
		});

		Object.defineProperty(this, 'continuous', {
			get: function() {
				return continuous;
			},
			set: function() {
				if (zon) zogy("Dial() - continuous is read only");
			}
		});

		Object.defineProperty(this, 'continuousMin', {
			get: function() {
				return continuousMin;
			},
			set: function(value) {
				continuousMin = value;
				if (that.currentValue < continuousMin) that.currentValue = continuousMin;
			}
		});

		Object.defineProperty(this, 'continuousMax', {
			get: function() {
				return continuousMax;
			},
			set: function(value) {
				continuousMax = value;
				if (that.currentValue > continuousMax) that.currentValue = continuousMax;
			}
		});

		Object.defineProperty(this, 'step', {
			get: function() {
				return step;
			},
			set: function() {
				if (zon) zogy("Dial() - step is read only");
			}
		});

		Object.defineProperty(this, 'keyArrowsH', {
			get: function() {
				return keyArrowsH;
			},
			set: function(value) {
				keyArrowsH = value;
			}
		});

		Object.defineProperty(this, 'keyArrowsV', {
			get: function() {
				return keyArrowsV;
			},
			set: function(value) {
				keyArrowsV = value;
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (keyArrows && !zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {if (keyArrows) setFocus();});
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}

		var leftCheck = false; var downCheck = false; var rightCheck = false; var upCheck = false;
		this.keyDownEvent = function(e) {
			if (!that.stage) return;
			if ((that.zimAccessibility && that.focus) || (!that.zimAccessibility && that.keyFocus)) {
				if (e.keyCode == 37 && keyArrowsH) leftCheck = true;
				else if (e.keyCode == 40 && keyArrowsV) downCheck = true;
				else if (e.keyCode == 39 && keyArrowsH) rightCheck = true;
				else if (e.keyCode == 38 && keyArrowsV) upCheck = true;
				if (that.keyInterval == null && (leftCheck || downCheck || rightCheck || upCheck)) {
					checkKey();
					// add traditional keydown delay
					that.keyTimeout = setTimeout(function() {
						if (that.keyInterval == null && (leftCheck || downCheck || rightCheck || upCheck)) that.keyInterval = setInterval(checkKey, 40);
					}, 140);
				}
			}
		};
		function checkKey() {
			if (leftCheck || downCheck) {
				if (step > 0) that.currentValueEvent -= step * sign(max-min);
				else that.currentValueEvent -= keyArrowsStep * sign(max-min);
			}
			if (rightCheck || upCheck) {
				if (step > 0) that.currentValueEvent += step * sign(max-min);
				else that.currentValueEvent += keyArrowsStep * sign(max-min);
			}
		}
		WW.addEventListener("keydown", this.keyDownEvent);
		that.keyUpEvent = function(e) {
			if (e.keyCode == 37) leftCheck = false;
			else if (e.keyCode == 40) downCheck = false;
			else if (e.keyCode == 39) rightCheck = false;
			else if (e.keyCode == 38) upCheck = false;
			if (that.keyInterval != null && !leftCheck && !downCheck && !rightCheck && !upCheck) {
				clearInterval(that.keyInterval);
				that.keyInterval = null;
			}
		}
		WW.addEventListener("keyup", this.keyUpEvent);

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				if (value) {
					WW.addEventListener("keydown", that.keyDownEvent);
					WW.addEventListener("keyup", that.keyUpEvent);
				} else {
					WW.removeEventListener("keydown", that.keyDownEvent);
					WW.removeEventListener("keyup", that.keyUpEvent);
				}
				that._enabled = value;
			}
		});

		if (zot(currentValue)) currentValue=DS.currentValue!=null?DS.currentValue:min;
		that.currentValue = currentValue;

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function(exact) {
			return that.cloneProps(new zim.Dial((exact||!zim.isPick(oa[0]))?that.min:oa[0], (exact||!zim.isPick(oa[1]))?that.max:oa[1], (exact||!zim.isPick(oa[2]))?that.step:oa[2], width, backgroundColor, indicatorColor, indicatorScale, indicatorType, useTicks, innerTicks, tickColor, tickStep, semiTicks, tickScale, semiTickScale, innerCircle, innerScale, innerColor, inner2Color, accentSize, accentOffset, accentColor, accentBackgroundColor, accentDifference, sound, linear, gap, limit, keyArrows, keyArrowsStep, keyArrowsH, keyArrowsV, continuous, continuousMin, continuousMax, damp, (exact||!zim.isPick(oa[3]))?that.currentValue:oa[3], useLabels, labelMargin, addZero, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			WW.removeEventListener("keydown", that.keyDownEvent);
			WW.removeEventListener("keyup", that.keyUpEvent);
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};
	};
	zim.extend(zim.Dial, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-63

//***************** RADIAL  64

/*--
zim.Tabs = function(width, height, tabs, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, vertical, spacing, currentEnabled, currentSelected, corner, base, keyEnabled, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, backdropColor, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, useTap, excludeCustomTap, selectedIndex, styleLabels, keyWrap, style, group, inherit)

Tabs
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A traditional tab layout for along the edge of content.
Can also act as an independent button row or column.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
var tabs = new Tabs({tabs:["A", "B", "C", "D"], spacing:5, corner:14})
	.center()
	.change(()=>{
		zog(tabs.selectedIndex);
		zog(tabs.text);
	});
S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 240) overall width of tab set (ZIM divides the width across tabs and spacing)
height - (default 60) height of tabs
tabs - (default ["1","2","3","4"]) an array of any String, Number, Label, Button, (or any DisplayObject)
	OR tab objects with the following properties available:
	any tab specific properties will override the default values from other parameters
	[{label:"String", width:200, backgroundColor:red, rollBackgroundColor:pink, downBackgroundColor:purple, selectedBackgroundColor:grey, color:yellow, selectedColor:"lime", downColor:white}, {etc.}]
	label can be a String or a Label object - default text color is white
	Tab objects can also include wait properties for individual buttons.
	(this was put in place before Buttons were allowed in the tabs array - so you can just add a Button to the tab array instead)
	See wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal and waitEnabled parameters below
	wait can be used with button's waiting property to offer an alternative to a loading screen or confirmation panel
	also see the button's clearWait() method to cancel the wait state and waited event that triggers when the wait is done
	wait will primarily be applicable when the tabs are used as a set of buttons rather than traditional tabbing
	Warning - do not use the same array for multiple tabs as the array is turned into an array of objects used by the Tabs object.
backgroundColor - (default tin) the background color of a deselected tab when not rolled over
rollBackgroundColor - (default grey) the rollover background color
downBackgroundColor - (default null) the pressing down background color
selectedBackgroundColor - (default dark) the background color of the selected tab (any CSS color)
selectedRollBackgroundColor - (default rollBackgroundColor) the background color of the selected tab on rollover (if currentEnabled is true)
color - (default white) the text color of a deselected tab when not rolled over
rollColor - (default color) the rollover color (selected tabs do not roll over)
downColor - (default null) the pressing down color 
selectedColor - (default color) the text color of the selected tab (any CSS color)
selectedRollColor - (default rollColor) the text color of the selected tab on rollover (if currentEnabled is true)
vertical - (default false) set to true to make vertical tabs with text still horizontal
spacing - (default 1) is the pixels between tab buttons
currentEnabled - (default false) set to true to be able to press (a second time) the selected tab button
currentSelected - (default true) set to false to not highlight the current button (good for button bars)
	setting this to true will set currentEnabled to true
corner - (default 0) the corner radius of the tabs
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
base - (default "none") specifiy a side for flat bottom when corner is set (but not set to an array)
	other values are "bottom" (default when corner and not vertical), LEFT (default when corner and vertical), TOP, RIGHT
	** this was flatBottom - but then vertical tabs were added so it was changed in ZIM 9.2.0
keyEnabled - (default true) so tab key cycles through tabs, shift tab backwards
gradient - (default null) 0 to 1 (try .3) adds a gradient to the tabs
gloss - (default null) 0 to 1 (try .1) adds a gloss to the tabs
wait - (default null) String text for tab to say when pressed to enter a wait mode
	The wait parameters can be (and probably will be) set as properties for each individual tab in the tabs array
waitTime - (default 20000) milliseconds to stay in wait state before returning to normal tab
waitBackgroundColor - (default color) the color of the tab during wait period
rollWaitBackgroundColor - (default color) the color of the tab during wait period
waitBackgroundColor - (default red) color to make button during wait time if wait is set
rollWaitBackgroundColor - (default rollColor) color for button when waiting and rolled over
waitColor - (default label's color) color to make text during wait time if wait is set
rollWaitColor - (default label's roll color) color for text when waiting and rolled over
waitModal - (default false) set to true to exit wait state if user clicks off tabs or to another tab
waitEnabled - (default true) set to false to disable tabs while in wait mode
backdropColor - (default null) set to a color to show behind the tabs (handy for when corner is not 0)
align - (default CENTER) horizontal align
valign - (default CENTER) vertical align
labelAlign - (default CENTER) horizontal align of the label only
labelValign - (default CENTER) vertical align of the label only
labelIndent - (default indent) indent of label when align or valign is set - usually same as indent unless custom objects are in tabs
labelIndentH - (default indent) horizontal indent of label when align or valign is set
labelIndentV - (default indent) vertical indent of label when align or valign is set
indent - (default 10) indent of items when align or valign is set and there are custom objects in tabs
useTap - (default false) set to true to use tap to activate otherwise uses ACTIONEVENT (mousedown or click)
excludeCustomTap - (default false) set to true to exclude custom buttons from tap() which would override existing tap() on the buttons
selectedIndex - (default 0) - set the selectedIndex at start
	for no selected tab to start set this to -1
styleLabels - (default false) - set to true to pass styles to Tab labels
keyWrap - (default true) - set to false to not wrap around Tabs when tab key reaches end or start
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
addAt(items, index, setStyle) - an array of items to insert at an index in the tab - tabs will grow in size - returns the object for chaining
	To keep the same size - run insertAt() and then remake the Tabs using the tabs.buttons array as the tabs parameter
	Can also send in a setStyle object literal {} with color, rollColor, selectedColor and selectedRollColor plus the background color versions of these!
removeAt(number, index) - remove number of items starting at a an index (default 1, length-1) - tabs will shrink in size - returns the object for chaining
first() - select first tab - returns object to chain
last() - select last tab - returns object to chain
getItemIndex(item) - gets the index of the list item provided

hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - gets or sets the selected index of the tabs
selected - gets the selected button - selected.enabled = true, etc.
tabs - gets or sets tabs object (will have to manually change buttons as well as adjust props)
backgroundColor - gets or sets default unselected background color - not applied to custom buttons
rollBackgroundColor - gets or sets default rolled over background color - not applied to custom buttons
selectedBackgroundColor - gets or sets default selected background color - not applied to custom buttons
selectedRollBackgroundColor - gets or sets default selected roll background color - not applied to custom buttons
color - gets or sets default unselected text color - not applied to custom buttons
rollColor - gets or sets default rolled over text color - not applied to custom buttons
selectedColor - gets or sets default selected text color - not applied to custom buttons
selectedRollColor - gets or sets default selected roll text color - not applied to custom buttons
text - gets current selected label text
label - gets current selected label object
buttons - an array of the ZIM Button objects. buttons[0].enabled = false;
labels - an array of the ZIM Label objects. labels[0].text = "YUM"; labels[2].y -= 10;
buttonDown - the button that is currently being pressed
backdrop - reference to backdrop Rectangle if backdropColor is provided
keyEnabled - gets or sets whether the tab key and shift tab key cycles through tabs (does not affect accessibility)
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "change" event when a tab changes (but not when setting selectedIndex property)

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+65
	zim.Tabs = function(width, height, tabs, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, vertical, spacing, currentEnabled, currentSelected, corner, base, keyEnabled, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, backdropColor, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, useTap, excludeCustomTap, selectedIndex, styleLabels, keyWrap, style, group, inherit) {
		var sig = "width, height, tabs, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, vertical, spacing, currentEnabled, currentSelected, corner, base, keyEnabled, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, backdropColor, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, useTap, excludeCustomTap, selectedIndex, styleLabels, keyWrap, style, group, inherit";
		var duo; if (duo = zob(zim.Tabs, arguments, sig, this)) return duo;
		z_d("65");

		var DS = style===false?{}:zim.getStyle("Tabs", group, inherit);
		if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:false;
		if (zot(width)) width = DS.width!=null?DS.width:null;
		var specifiedWidth = !zot(width);

		if (zot(width)) width = vertical?60:240;
		if (zot(height)) height = DS.height!=null?DS.height:(vertical?240:60);

		this.zimContainer_constructor(null,null,null,null,true);
		this.type = "Tabs";
		this.group = group;

		if (zot(tabs) || tabs.length<=0) tabs = DS.tabs!=null?DS.tabs:[1,2,3,4];
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.tin;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.grey;
		if (zot(downBackgroundColor)) downBackgroundColor = DS.downBackgroundColor!=null?DS.downBackgroundColor:rollBackgroundColor;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor = DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.dark;
		if (zot(selectedRollBackgroundColor)) selectedRollBackgroundColor = DS.selectedRollBackgroundColor!=null?DS.selectedRollBackgroundColor:rollBackgroundColor;
		if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(downColor)) downColor = DS.downColor!=null?DS.downColor:rollColor;
		if (zot(selectedColor)) selectedColor = DS.selectedColor!=null?DS.selectedColor:color;
		if (zot(selectedRollColor)) selectedRollColor = DS.selectedRollColor!=null?DS.selectedRollColor:rollColor;
		if (zot(backing)) backing = DS.backing!=null?DS.backing.clone():null;
		if (zot(rollBacking)) rollBacking = DS.rollBacking!=null?DS.rollBacking.clone():null;
		if (zot(align)) align=DS.align!=null?DS.align:"center";
		if (zot(valign)) valign=DS.valign!=null?DS.valign:"center";
		if (zot(labelAlign)) labelAlign=DS.labelAlign!=null?DS.labelAlign:align;
		if (zot(labelValign)) labelValign=DS.labelValign!=null?DS.labelValign:valign;

		if (zot(indent)) indent=DS.indent!=null?DS.indent:10;
		if (zot(labelIndent)) labelIndent=DS.labelIndent!=null?DS.labelIndent:indent;
		if (zot(labelIndentH)) labelIndentH=DS.labelIndentH!=null?DS.labelIndentH:labelIndent;
		if (zot(labelIndentV)) labelIndentV=DS.labelIndentV!=null?DS.labelIndentV:labelIndent;

		if (zot(currentEnabled)) currentEnabled = DS.currentEnabled!=null?DS.currentEnabled:false;
		if (zot(currentSelected)) {
			currentSelected = DS.currentSelected!=null?DS.currentSelected:true; // keep the highlight on after pressup
		}
		if (!currentSelected) currentEnabled = true; // button bar

		if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:1;
		if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
		if (zot(gradient)) gradient = DS.gradient!=null?DS.gradient:null;
		if (zot(gloss)) gloss = DS.gloss!=null?DS.gloss:null;
		if (zot(base)) base = DS.base!=null?DS.base:((corner==0&&!Array.isArray(corner))?"none":(vertical?"left":"bottom"));
		if (zot(keyEnabled)) keyEnabled = DS.keyEnabled!=null?DS.keyEnabled:true;
		if (zot(useTap)) useTap = DS.useTap!=null?DS.useTap:false;
		if (zot(excludeCustomTap)) excludeCustomTap = DS.excludeCustomTap!=null?DS.excludeCustomTap:false;
		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:null;
		if (zot(styleLabels)) styleLabels = DS.styleLabels!=null?DS.styleLabels:false;
		if (zot(keyWrap)) keyWrap = DS.keyWrap!=null?DS.keyWrap:true;
		if (base != "none" && corner != 0 && !Array.isArray(corner)) {
			switch (base) {
				case "bottom":
					corner = [corner, corner, 0, 0]; break;
				case "left":
					corner = [0, corner, corner, 0]; break;
				case "top":
					corner = [0, 0, corner, corner]; break;
				case "right":
					corner = [corner, 0, 0, corner]; break;
			}
		} else if (!Array.isArray(corner)) {
			corner = [corner, corner, corner, corner];
		}

		var that = this;
		this.keyEnabled = keyEnabled;

		var myIndex = 0; // local value for this.selectedIndex
		var labels = [];
		var buttons = [];
		var button; 
		var t;
		var num = tabs.length;
		var tabW = (width - spacing*(num-1))/num;
		var tabH = (height - spacing*(num-1)-2)/num;

		if (!zot(backdropColor)) {
			// may be resized later
			var backdrop = this.backdrop = new zim.Rectangle(width,height,backdropColor, null, null, null, null, null, null, false);
			this.addChild(backdrop);
		}

		// Make a list be tab data objects if string, number, label or {} - other objects are ignored
		var mix = false; // used to determine how to treat indent
		var mixType;
		function makeDataObject(list) {
			for (var i=0; i<list.length; i++) {
				var item = list[i];
				if (item.constructor === {}.constructor) {
					if (mixType && mixType != "TabObject") mix = true;
					mixType = "TabObject";
					item.type = "TabObject";
					continue;
				}
				if (typeof item == "string" || typeof item == "number" || item.type == "Label") {
					list[i] = {type:"TabObject", label:(String((item!=null))||item.type=="Label")?item:"1"};
					if (mixType && mixType != "TabObject") mix = true;
					mixType = "TabObject";
				} else {
					if (mixType && mixType == "TabObject") mix = true;
					mixType = "Other";
				}
			}
		}
		makeDataObject(tabs);
		
		// calculate widths - done only once at start
		var total = 0;
		var newTabW; var nonSpecifiedCount = 0;
		for (var i=0; i<tabs.length; i++) {
			t = tabs[i];
			if (!vertical) {
				if (zot(t.width)) nonSpecifiedCount++;
				total += (zot(t.width))?tabW:t.width;
			} else if (specifiedWidth) {
				t.width = t.width?t.width:width;
			}
		}
		if (!vertical) {
			if (total > width - spacing*(num-1)) {
				// go back and assign proportional widths
				for (i=0; i<tabs.length; i++) {
					t = tabs[i];
					t.width = (width - spacing*(num-1)) / total * ((zot(t.width))?tabW:t.width);
				}
			} else if (Math.round(total) < Math.round(width - spacing*(num-1))) {
				// go back and readjust the average of non specified widths
				if (nonSpecifiedCount > 0) {
					newTabW = (num*tabW-(total-nonSpecifiedCount*tabW))/nonSpecifiedCount;
					for (i=0; i<tabs.length; i++) {
						t = tabs[i];
						t.width = ((zot(t.width))?newTabW:t.width);
					}
				} else {
					// that.width = width;
					// // if (zon) zogy("Tabs - total less than width");
					// width = total + spacing*(num-1);
				}
			}
		}



		// Create Label Objects including Label and also get max width
		function makeLabels(list, addStyle) {
			for (i=0; i<list.length; i++) {
				t = list[i];
				if (t == "") continue; // was break?
				if (t.type == "TabObject") {
					if (zot(t.label)) t.label = " ";
					if (typeof t.label == "string" || typeof t.label == "number") {
						// will do colors in Button
						t.label = new zim.Label({
							text:t.label,
							size:DS.size!=null?DS.size:(vertical?tabH/2:height/2),
							font:DS.font!=null?DS.font:null,
							style:styleLabels,
							valign:labelValign,
							inherit:addStyle
						});
					}
				}
			}
		}
		makeLabels(tabs, styleLabels?DS:null);


		// get maxWidth - done only once at start
		var maxWidth = 0;
		for (i=0; i<tabs.length; i++) {
			t = tabs[i];
			if (!t.width && vertical && t.label.width > maxWidth) maxWidth = t.label.width;
		}

		// create buttons
		var hMaxWidth = 0;
		function makeButtons(list, addStyle) {
			var buttons = [];
			var labels = [];
			for (i=0; i<list.length; i++) {
				t = list[i];
				if (t.type == "TabObject") {
					var tabInfo = {
						color:zot(t.color)?zim.Pick.choose(color):t.color,
						rollColor:zot(t.rollColor)?zim.Pick.choose(rollColor):t.rollColor,
						downColor:zot(t.downColor)?zim.Pick.choose(downColor):t.downColor,
						selectedColor:zot(t.selectedColor)?zim.Pick.choose(selectedColor):t.selectedColor,
						selectedRollColor:zot(t.selectedRollColor)?zim.Pick.choose(selectedRollColor):t.selectedRollColor,
						backgroundColor:zot(t.backgroundColor)?zim.Pick.choose(backgroundColor):t.backgroundColor,
						rollBackgroundColor:(zot(t.rollBackgroundColor))?zim.Pick.choose(rollBackgroundColor):t.rollBackgroundColor,
						downBackgroundColor:(zot(t.downBackgroundColor))?zim.Pick.choose(downBackgroundColor):t.downBackgroundColor,
						selectedBackgroundColor:(zot(t.selectedBackgroundColor))?zim.Pick.choose(selectedBackgroundColor):t.selectedBackgroundColor,
						selectedRollBackgroundColor:(zot(t.selectedRollBackgroundColor))?zim.Pick.choose(selectedRollBackgroundColor):t.selectedRollBackgroundColor,
						wait:(zot(t.wait))?zim.Pick.choose(wait):t.wait
					};
					if (addStyle) {
						for (var aStyle in addStyle) {
							if (!zot(addStyle[aStyle])) tabInfo[aStyle] = addStyle[aStyle];
						}
					}
					button = new zim.Button({
						width:vertical?(zot(t.width)?specifiedWidth?width:(maxWidth+tabH/2+corner[0]/2):t.width):((zot(t.width))?tabW:t.width),
						height:vertical?tabH:height,
						label:t.label,
						borderColor:DS.borderColor!=null?DS.borderColor:null,
						borderWidth:DS.borderWidth!=null?DS.borderWidth:null,
						backgroundColor:tabInfo.backgroundColor,
						rollBackgroundColor:tabInfo.rollBackgroundColor,
						downBackgroundColor:tabInfo.downBackgroundColor,
						downColor:tabInfo.downColor,
						corner:corner,
						shadowColor:-1,
						gradient:gradient,
						gloss:gloss,
						backing:backing?backing.clone():null,
						rollBacking:rollBacking?rollBacking.clone():null,
						wait:tabInfo.wait,
						waitTime:(zot(t.waitTime))?waitTime:t.waitTime,
						waitBackgroundColor:(zot(t.waitBackgroundColor))?waitBackgroundColor:t.waitBackgroundColor,
						rollWaitBackgroundColor:(zot(t.rollWaitBackgroundColor))?rollWaitBackgroundColor:t.rollWaitBackgroundColor,
						waitColor:(zot(t.waitColor))?waitColor:t.waitColor,
						rollWaitColor:(zot(t.rollWaitBackgroundColor))?rollWaitColor:t.rollWaitColor,
						waitModal:(zot(t.waitModal))?waitModal:t.waitModal,
						waitEnabled:(zot(t.waitEnabled))?waitEnabled:t.waitEnabled,
						align:labelAlign,
						valign:labelValign,
						indentH:labelIndentH,
						indentV:labelIndentV,
						inherit:zim.copy(DS)
					});
					button.tabInfo = tabInfo;
					// set the label colors
					button.color = button.tabInfo.color;
					button.rollColor = button.tabInfo.rollColor;
					button.type = "TabsButton";
					button.content = t;
					button.listIndentReady = true;
				} else {					
					if (t.listIndentReady) button = t;
					else {
						button = new zim.Container();
						button.type = t.type;
						button.content = t;
						var specialList = ["text", "backing", "label", "slider", "stepper", "checkBox", "colorPicker", "swatch", "colorLabel"];
						for (var j=0; j<specialList.length; j++) {
							if (t[specialList[j]]) {
								button[specialList[j]] = t[specialList[j]];
							}
						}
					}
					if (t.checkBox) button.checkBox = t.checkBox;
					if (zot(button.tabInfo)) button.tabInfo = {};
					if (excludeCustomTap) button.excludeTap = true;
					button.tabInfo.color = zot(t.color)?color:t.color;
					button.tabInfo.backgroundColor = zot(t.backgroundColor)?backgroundColor:t.backgroundColor;

					if (!t.listIndentReady) {
						new zim.Rectangle(
							Math.max(t.width, vertical?(specifiedWidth?width:(maxWidth+tabH/2+corner[0]/2)):t.width), // was tabW (bug?)
							Math.max(t.height, vertical?tabH:height),
							zim.clear
						).addTo(button).expand(0).cur();

						t.center(button).cur();
						if (!(align=="center" || align=="middle")) t.pos(0,null,align=="right");
						if (!(valign=="center" || valign=="middle")) t.pos(null,0,null,valign=="bottom");
						button.listIndentReady = true;
					}
				}
				if (button.width > hMaxWidth) hMaxWidth = button.width;

				// apply events
				if (useTap) {
					button.tap(function (e) {
						change(e.currentTarget.znum);
						that.dispatchEvent("change");
						if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
					});
				} else {
					button.zimTabEvent = button.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(e) {
						change(e.currentTarget.znum);
						that.dispatchEvent("change");
						if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
					});
				}
				button.on("mousedown", function(e) {
					that.buttonDown = e.currentTarget;
				});
				button.on("pressup", function(e) {
					that.buttonDown = null;
					var num = e.currentTarget.znum;
					if (useTap || zim.ACTIONEVENT=="click") setTimeout(function(){changeBack(num);},50)
					else changeBack(num);
				});
				labels.push(t.label);
				buttons.push(button);
				button.index = i;
			}
			return [buttons, labels];
		}
		var result = makeButtons(tabs);
		buttons = result[0];
		labels = result[1];


		// finalize index, location, bounds
		function prepareAllButtons() {
			var lastX = 0; var lastY = 0; var button;
			for (i=0; i<buttons.length; i++) {
				button = buttons[i];
				button.znum = i;
				button.selectedIndex = i;
				if (button.selectedIndex == myIndex && currentSelected) {
					button.backgroundColor = selectedBackgroundColor;
					button.rollBackgroundColor = selectedRollBackgroundColor;
					button.color = selectedColor;
				}
				if (labels[i]) labels[i].znum = i;
				that.addChild(button);
				if (!vertical || specifiedWidth) {
					button.x = (width-button.width)/2;
					button.y = (height-button.height)/2;
				}
				if (vertical) {
					button.y = lastY;
					lastY = button.y + button.height + spacing;
					// if (align=="left") button.x = ((button.type=="TabsButton" || !mix)?0:indent) + (button.regX - (button.getBounds()?button.getBounds().x:0))*button.scaleX;
					// else if (align=="right") button.x = (specifiedWidth?width:hMaxWidth)-button.width-((button.type=="TabsButton" || !mix)?0:indent);
					if (align=="left") button.x = ((button.type=="TabsButton" || button.type=="ListItem")?0:indent) + (button.regX - (button.getBounds()?button.getBounds().x:0))*button.scaleX;
					else if (align=="right") button.x = (specifiedWidth?width:hMaxWidth)-button.width-((button.type=="TabsButton" || button.type=="ListItem")?0:indent);
				} else {
					button.x = lastX;
					lastX = button.x + button.width + spacing;
					if (valign=="top") button.y = (button.type=="TabsButton" && !mix?0:indent) + (button.regY - (button.getBounds()?button.getBounds().y:0))*button.scaleY;
					else if (valign=="bottom") button.y = height-button.height-(button.type=="TabsButton" && !mix?0:indent);
				}
				if (i==myIndex && !currentEnabled) button.enabled = false;
				else button.enabled = true;
			}

			// might have to use w and h rather than width and height if run multiple times...
			if (!zot(backdropColor)) {
				that.removeChild(backdrop);
			}

			that._bounds = null; // for old version of CreateJS including Animate's
			// that.setBounds();
			var bou = that.getBounds();
			var w = 0;
			var h = 0;

			if (!bou && createjs.EaselJS.version[0] != 0) {
				that.setBounds();
			} else {
				if (bou) {
					w = vertical&&bou.width!=0&&specifiedWidth?width:bou.width;
					h = vertical&&bou.height!=0?bou.height:height;
					that.setBounds(w,h);
				}
			}
			if (!zot(backdropColor)) {
				backdrop.widthOnly = w;
				backdrop.heightOnly = h;
				that.addChildAt(backdrop,0);
			}

			if (vertical && !specifiedWidth) {
				for (i=0; i<=buttons.length; i++) {
					if (align=="center" || align=="middle") button.x = (w-button.width)/2;
				}
			}
		}
		prepareAllButtons(); // operates on buttons array - not tabs array

		function change(num, immediate) {
			if (num==myIndex) return;
			var b = buttons[myIndex];
			if (b && currentSelected) {
				if (b.tabInfo && zot(b.tabInfo.wait)) {
					if (b.tabInfo.backgroundColor) b.backgroundColor = b.tabInfo.backgroundColor;
					if (b.tabInfo.rollBackgroundColor) b.rollBackgroundColor = b.tabInfo.rollBackgroundColor;
					if (b.tabInfo.color && b.label) b.color = b.tabInfo.color;
					if (b.tabInfo.rollColor && b.label) b.rollColor = b.tabInfo.rollColor;
				}
				if (!currentEnabled) b.enabled = true;
			}
			myIndex = num;
			b = buttons[myIndex];
			if (b) {
				var ti = b.tabInfo;
				if (ti && zot(b.tabInfo.wait) && currentSelected) {
					if (ti.selectedBackgroundColor) b.backgroundColor = !zot(ti.downBackgroundColor)&&!immediate?ti.downBackgroundColor:ti.selectedBackgroundColor;
					if (ti.selectedRollBackgroundColor) b.rollBackgroundColor = ti.selectedRollBackgroundColor;
					if (ti.selectedColor && b.label) b.color = !zot(ti.downColor)&&!immediate?ti.downColor:ti.selectedColor;
					if (ti.selectedRollColor && b.label) b.rollColor = ti.selectedRollColor;
				}
				if (immediate&&!currentEnabled) b.enabled = false; // moved to changeBack in ZIM ZIM 02 to support downBackgroundColor and downColor
			}
		}
		
		function changeBack(num) {
			var b = buttons[num];
			if (b && currentSelected) {
				var ti = b.tabInfo;
				if (ti && zot(ti.wait)) {	
					// should be rollBackgroundColor but if setting it seems to stick after rolloff
					if (ti.selectedBackgroundColor) b.backgroundColor = that.selected==b?ti.selectedBackgroundColor:ti.backgroundColor					
					if (ti.selectedColor && b.label) b.color = that.selected==b?ti.selectedColor:ti.color;
				} 
				if (!currentEnabled) b.enabled = false;
			}
		}

		this.addAt = function(items, index, addStyle) {
			if (zot(index)) index = buttons.length;
			index = zim.constrain(index, 0, buttons.length);
			// create tabObjects from new item(s)
			if (!Array.isArray(items)) items = [items];
			makeDataObject(items);
			makeLabels(items, addStyle);
			var result = makeButtons(items, addStyle);
			var buts = result[0];
			var labs = result[1];
			if (index <= myIndex) myIndex += buts.length;
			// insert buttons into buttons and labels into labels
			var args = [index, 0].concat(buts);
			Array.prototype.splice.apply(buttons, args);
			args = [index, 0].concat(labs);
			Array.prototype.splice.apply(labels, args);
			prepareAllButtons(); // operates on buttons array - not tabs array
			return that;
		};

		this.removeAt = function(num, index) {
			if (buttons.length == 0) return that;
			if (zot(num)) num = 1;
			if (zot(index)) index = buttons.length-num;
			index = zim.constrain(index, 0, buttons.length-num);

			// adjust selection
			if (myIndex >= index && myIndex <= index+num) myIndex = -1;
			if (myIndex > index+num) myIndex -= num;

			// remove listeners
			for (i=index; i<index+num; i++) {
				if (buttons[i].tabInfo) {
					if (buttons[i].tabInfo.backgroundColor) buttons[i].backgroundColor = buttons[i].tabInfo.backgroundColor;
					if (buttons[i].tabInfo.color && buttons[i].label) buttons[i].color = buttons[i].tabInfo.color;
				}
				if (useTap) buttons[i].noTap();
				else buttons[i].off((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", buttons[i].zimTabEvent);
				buttons[i].removeFrom();
			}
			// splice from buttons and labels from labels
			buttons.splice(index, num);
			labels.splice(index, num);
			prepareAllButtons(); // operates on buttons array - not tabs array
			return that;
		};

		that.keyEvent = function(e) {
		if (!that.keyEnabled || !that.keyFocus || that.zimAccessibility) return;
			if (e.keyCode == 9) {
				var next = myIndex; // note that change updates the index
				if (e.shiftKey) {
					change((--next<0)?(keyWrap?tabs.length-1:0):next);
				} else {
					change((++next>tabs.length-1)?(keyWrap?0:tabs.length-1):next);
				}
				that.dispatchEvent("change");
				that.dispatchEvent("keychange");
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				e.preventDefault();
			}
		};
		WW.addEventListener("keydown", that.keyEvent);		

		Object.defineProperty(this, 'selected', {
			get: function() {
				return buttons[myIndex];
			},
			set: function() {
				if (zon) zogy("Tabs() - selected is read only - try selectedIndex");
			}
		});

		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				return myIndex;
			},
			set: function(value) {
				// change(Math.min(Math.max(value, 0), tabs.length-1));
				change(value, true); // true for immediate
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		this.last = function() {
			this.selectedIndex = this.buttons.length-1;
			return this;
		};
		this.first = function() {
			this.selectedIndex = 0;
			return this;
		};

		Object.defineProperty(this, 'tabs', {
			get: function() {
				return myIndex;
			},
			set: function(value) {
				change(Math.min(Math.max(value, 0), tabs.length-1));
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		Object.defineProperty(this, 'color', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.color;
				else return color;
			},
			set: function(value) {
				color = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.color = value;
						}
						if (i != myIndex || !currentSelected) that.buttons[i].color = color;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'rollColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.rollColor;
				else return rollColor;
			},
			set: function(value) {
				rollColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.rollColor = value;
						}
						that.buttons[i].rollColor = rollColor;
						if (i != myIndex && that.buttons[i].rolled) that.buttons[i].color = rollColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'selectedColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.selectedColor;
				else return selectedColor;
			},
			set: function(value) {
				selectedColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.selectedColor = value;
						}
						if ((i == myIndex && currentSelected)) that.buttons[i].color = selectedColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'selectedRollColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.selectedRollColor;
				else return selectedRollColor;
			},
			set: function(value) {
				selectedRollColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.selectedRollColor = value;
						}
						if ((i == myIndex && currentSelected) && that.buttons[i].rolled) that.buttons[i].color = selectedRollColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'backgroundColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.backgroundColor;
				else return backgroundColor;
			},
			set: function(value) {
				backgroundColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.backgroundColor = value;
						}
						if (i != myIndex || !currentSelected) that.buttons[i].backgroundColor = backgroundColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});


		Object.defineProperty(this, 'rollBackgroundColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.rollBackgroundColor;
				else return rollBackgroundColor;
			},
			set: function(value) {
				rollBackgroundColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.rollBackgroundColor = value;
						}
						that.buttons[i].rollBackgroundColor = rollBackgroundColor;
						if (i != myIndex && that.buttons[i].rolled) that.buttons[i].backgroundColor = rollBackgroundColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'selectedBackgroundColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.selectedBackgroundColor;
				else return selectedBackgroundColor;
			},
			set: function(value) {
				selectedBackgroundColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.selectedBackgroundColor = value;
						}
						if ((i == myIndex && currentSelected)) that.buttons[i].backgroundColor = selectedBackgroundColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'selectedRollBackgroundColor', {
			get: function() {
				if (that.buttons[0].tabItems) return that.buttons[0].tabItems.selectedRollBackgroundColor;
				else return selectedRollBackgroundColor;
			},
			set: function(value) {
				selectedRollBackgroundColor = value;
				if (that.buttons[0].tabInfo) {
					for (var i=0; i<that.buttons.length; i++) {
						if (that.buttons[i].tabInfo) {
							that.buttons[i].tabInfo.selectedRollBackgroundColor = value;
						}
						if ((i == myIndex && currentSelected) && that.buttons[i].rolled) that.buttons[i].backgroundColor = selectedRollBackgroundColor;
					}
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				}
			}
		});

		Object.defineProperty(this, 'label', {
			get: function() {
				return labels[myIndex];
			},
			set: function() {
				if (zon) zogy("Tabs() - selected is read only - try selectedIndex");
			}
		});

		Object.defineProperty(this, 'text', {
			get: function() {
				return (labels[myIndex]!=null) ? labels[myIndex].text : undefined;
			},
			set: function() {
				if (zon) zogy("Tabs() - selected is read only - try selectedIndex");
			}
		});

		Object.defineProperty(this, 'buttons', {
			get: function() {
				return buttons;
			},
			set: function() {
				if (zon) zogy("Tabs() - buttons is read only");
			}
		});

		Object.defineProperty(this, 'labels', {
			get: function() {
				return labels;
			},
			set: function() {
				if (zon) zogy("Tabs() - labels is read only");
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);				
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (keyEnabled && zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {if (keyEnabled) setFocus();});
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}

		var bou = that.getBounds();
		if (zot(bou) || bou.width==0) that.setBounds(0,0,width,height);
		else that.width = width;

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			var tabsCopy = zim.copy(tabs, true);
			for (var i=0; i<tabsCopy.length; i++) {
				tabsCopy[i].label = tabsCopy[i].label.clone();
			}
			return that.cloneProps(new zim.Tabs(width, height, tabsCopy, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, vertical, spacing, currentEnabled, currentSelected, corner, base, keyEnabled, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, backdropColor, align, valign, labelAlign, labelValign, labelIndent, labelIndentH, labelIndentV, indent, useTap, excludeCustomTap, selectedIndex, styleLabels, keyWrap, style, this.group, inherit));
		};
		
		this.doDispose = function(a,b,disposing) {
			if (that.keyEvent) WW.removeEventListener("keydown", that.keyEvent);
			zim.loop(that.buttons, function (b) {
				b.dispose();
			});			
			that.keyEvent = null;
			if (!disposing) this.zimContainer_dispose(true);
			currentSelected = t = tabs = labels = button = buttons = result = null;
		};
	};
	zim.extend(zim.Tabs, zim.Container, ["clone", "dispose"], "zimContainer", false);
	zim.Tabs.prototype.dispose = function(disposing) {return this.doDispose(null,null,disposing);};
	//-65

/*--
zim.Pad = function(width, cols, rows, keys, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, spacing, currentEnabled, currentSelected, corner, labelColor, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, selectedIndex, style, group, inherit)

Pad
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A pad that has rows and cols made of square keys.
When the keys are pressed the pad will dispatch a change event - get the selectedIndex or text property.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
var pad = new Pad()
	.center()
	.change(()=>{
		zog(pad.selectedIndex); // 0-8
		zog(pad.text); // 1-9
	});
S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
** inherits STYLE from type selector for Pad, then general styles then type selector for Tabs
width - (default 150) overall width of pad (ZIM divides the width across cols and spacing)
cols - (default 3) the columns in the pad
rows - (default cols) the rows in the pad
keys - (default an Array for cols x rows) an array of key objects with the following properties available:
	any key specific properties will override the default values from other parameters
	[{label:"String", width:200, backgroundColor:red, rollBackgroundColor:pink, selectedBackgroundColor:grey}, {etc.}]
	the label can be a String or a Label object - default text color is white
	Key objects can also include wait properties for individual buttons.
	See wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal and waitEnabled parameters below
	wait can be used with button's waiting property to offer an alternative to a loading screen or confirmation panel
	also see the button's clearWait() method to cancel the wait state and waited event that triggers when the wait is done
backgroundColor - (default tin) the background color of a deselected key when not rolled over
rollBackgroundColor - (default grey) the rollover background color (selected keys do not roll over)
downBackgroundColor - (default null) the pressing down background color
selectedBackgroundColor - (default dark) the background color of the selected key (any CSS color)
color - (default white) the text color of a deselected key when not rolled over
rollColor - (default color) the rollover color (selected keys do not roll over)
downColor - (default null) the pressing down color
selectedColor - (default color) the text color of the selected key (any CSS color)
spacing - (default 1) is the pixels between key buttons
currentEnabled - (default true) set to false to make selected key not pressable
currentSelected - (default true) set to false to make the current selected key not the selected colors
corner - (default 0) the corner radius of the keys
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
labelColor - (default white) the color of the label
gradient - (default null) 0 to 1 (try .3) adds a gradient to the tabs
gloss - (default null) 0 to 1 (try .1) adds a gloss to the tabs
wait - (default null) String text for button to say when pressed to enter a wait mode
	The wait parameters can be (and probably will be) set as properties for each individual button in the pads array
waitTime - (default 20000) milliseconds to stay in wait state before returning to normal button
waitBackgroundColor - (default color) the color of the button during wait period
rollWaitBackgroundColor - (default color) the color of the button during wait period
waitBackgroundColor - (default red) color to make button during wait time if wait is set
rollWaitBackgroundColor - (default rollColor) color for button when waiting and rolled over
waitColor - (default label's color) color to make text during wait time if wait is set
rollWaitColor - (default label's roll color) color for text when waiting and rolled over
waitModal - (default false) set to true to exit wait state if user clicks off the pad or to another button
waitEnabled - (default true) set to false to disable pad while in wait mode
selectedIndex - (default 0) - set the selectedIndex at start
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - gets or sets the selected index of the pad
text - gets current selected label text
selected - gets the selected button - selected.enabled = true, etc.
label - gets current selected label object
selectedBackgroundColor - gets or sets default selected background color
backgroundColor - gets or sets default unselected background color
rollBackgroundColor - gets or sets default rolled over background color
color - gets or sets default unselected text color
rollColor - gets or sets default rolled over text color
selectedColor - gets or sets default selected text color
buttons - an array of the ZIM Button objects. buttons[0].enabled = false;
labels - an array of the ZIM Label objects. labels[0].text = "YUM"; labels[2].y -= 10;
tabs - an array of the zim Tabs objects (one object per row)
enabled - default is true - set to false to disable
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.
ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "change" event when a pad changes (but not when setting selectedIndex property)

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+66
	zim.Pad = function(width, cols, rows, keys, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, spacing, currentEnabled, currentSelected, corner, labelColor, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, selectedIndex, style, group, inherit) {
		var sig = "width, cols, rows, keys, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, spacing, currentEnabled, currentSelected, corner, labelColor, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, selectedIndex, style, group, inherit";
		var duo; if (duo = zob(zim.Pad, arguments, sig, this)) return duo;
		z_d("66");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Pad";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		// the other parameters will be handled by the Tabs object for each row
		if (zot(width)) width = DS.width!=null?DS.width:150;
		if (zot(cols)) cols = DS.cols!=null?DS.cols:3;
		if (zot(rows)) rows = DS.rows!=null?DS.rows:cols;
		var i;
		if (zot(keys)) {
			if (DS.keys!=null) {keys = DS.keys;}
			else {keys = []; for (i=1; i<=rows*cols; i++){keys.push(i);}}
		}
		if (zot(currentEnabled)) currentEnabled = DS.currentEnabled!=null?DS.currentEnabled:true;
		if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:1;

		var that = this;
		var myIndex;

		this.cols = cols; // read only
		this.rows = rows;

		var height = width / cols - spacing;
		var rowTabs = [];
		var count = 0;
		var r;
		this.labels = [];
		this.buttons = [];
		for (i=0; i<rows; i++) {
			var rowKeys = [];
			for (var j=0; j<cols; j++) {
				rowKeys.push((keys[count]!=null) ? keys[count] : "");
				count++;
			}
			var corn = DS.corner!=null?DS.corner:corner;
			if (corn && !Array.isArray(corn)) corn = [corn,corn,corn,corn];
			r = rowTabs[i] = new zim.Tabs({
				width:width,
				height:height,
				tabs:rowKeys,
				backgroundColor:DS.backgroundColor!=null?DS.backgroundColor:backgroundColor,
				rollBackgroundColor:DS.rollBackgroundColor!=null?DS.rollBackgroundColor:rollBackgroundColor,
				downBackgroundColor:DS.downBackgroundColor!=null?DS.downBackgroundColor:downBackgroundColor,
				selectedBackgroundColor:DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:selectedBackgroundColor,
				color:DS.color!=null?DS.color:color,
				rollColor:DS.rollColor!=null?DS.rollColor:rollColor,
				downColor:DS.downColor!=null?DS.downColor:downColor,
				selectedColor:DS.selectedColor!=null?DS.selectedColor:selectedColor,
				spacing:DS.spacing!=null?DS.spacing:spacing,
				currentEnabled:DS.currentEnabled!=null?DS.currentEnabled:currentEnabled,
				currentSelected:DS.currentSelected!=null?DS.currentSelected:currentSelected,
				corner:corn,
				backing:DS.backing!=null?DS.backing.clone():backing,
				rollBacking:DS.rollBacking!=null?DS.rollBacking.clone():rollBacking,
				base:null,
				keyEnabled:false,
				gradient:DS.gradient!=null?DS.gradient:gradient,
				gloss:DS.gloss!=null?DS.gloss:gloss,
				wait:DS.wait!=null?DS.wait:wait,
				waitTime:DS.waitTime!=null?DS.waitTime:waitTime,
				waitBackgroundColor:DS.waitBackgroundColor!=null?DS.waitBackgroundColor:waitBackgroundColor,
				rollWaitBackgroundColor:DS.rollWaitBackgroundColor!=null?DS.rollWaitBackgroundColor:rollWaitBackgroundColor,
				waitColor:DS.waitColor!=null?DS.waitColor:waitColor,
				rollWaitColor:DS.rollWaitColor!=null?DS.rollWaitColor:rollWaitColor,
				waitModal:DS.waitModal!=null?DS.waitModal:waitModal,
				waitEnabled:DS.waitEnabled!=null?DS.waitEnabled:waitEnabled,
				group:group,
				style:false
			});
			this.labels = this.labels.concat(r.labels);
			this.buttons = this.buttons.concat(r.buttons);
			this.addChild(r);
			r.selectedIndex = -1;
			r.y = (height+spacing)*i;
			r.znum = i;
			r.on("change", pressKey);
		}
		this.tabs = rowTabs;
		function pressKey(e) {
			var r = e.target;
			that.selected = r.selected;
			that.text = r.text;
			that.label = r.label;
			var s = r.selectedIndex; // store selected then clear all in pad
			for (var i=0; i<rowTabs.length; i++) {
				if (r==rowTabs[i]) continue;
				rowTabs[i].selectedIndex = -1;
			}
			myIndex = r.znum * cols + s; // calculate pad selected
			that.dispatchEvent("change");
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
		}

		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				return myIndex;
			},
			set: function(value) {
				myIndex = value;
				for (var i=0; i<rowTabs.length; i++) {
					rowTabs[i].selectedIndex = -1;
				}
				var tabNum = Math.floor(myIndex / cols);
				if (tabNum >= 0 && tabNum < that.tabs.length) {
					that.tabs[tabNum].selectedIndex = myIndex % cols;
				}
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Pad(width, cols, rows, keys, backgroundColor, rollBackgroundColor, downBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, downColor, selectedColor, selectedRollColor, spacing, currentEnabled, currentSelected, corner, labelColor, gradient, gloss, backing, rollBacking, wait, waitTime, waitBackgroundColor, rollWaitBackgroundColor, waitColor, rollWaitColor, waitModal, waitEnabled, selectedIndex, style, this.group, inherit));
		};
		this.dispose = function(a,b,disposing) {
			zim.loop(rowTabs, function (t) {
				t.dispose();
			});		
			this.labels = this.buttons = this.tabs = null;	
			r = rowTabs = that.rowTabs = null;
			if (!disposing) this.zimContainer_dispose(true);
		};
	};
	zim.extend(zim.Pad, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-66

/*--
zim.NumPad = function(advanced, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, numberCorner, close, closeColor, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit)

NumPad
zim class - extends a zim.Panel which extends a zim.Container which extends a createjs.Container

DESCRIPTION
A number pad that can be used on its own or with the ZIM Keyboard() which has a key at the bottom right to pop up the NumPad 
The Keyboard can also be shown with the NumPadOnly parameter set to true to make use of the labels parameter to target labels.

See https://zimjs.com/zim/numpad.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const label = new Label("").pos(0,100,CENTER);

// The NumPad is built in to the Keyboard
// To set the parameters, such as titleBar, use STYLE before making the Keyboard
STYLE = {titleBar:"CALCULATE", align:CENTER};

const keyboard = new Keyboard({
	labels:label, 
	numPadScale:.75,
	numPadOnly:true, 
	numPadAdvanced:true     
}).show();
keyboard.numPad.mov(0,120);
END EXAMPLE 

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
advanced - (default false) set to true to add one more row of round brackets, exponential and percent or modulus
	or set to "simple" to show only numbers, backspace and return
titleBar - |ZIM VEE| (default "NUMPAD") a String or ZIM Label title that will be presented on a titleBar across the top
titleBarColor - |ZIM VEE| (default black) the text color of the titleBar if a titleBar is requested
titleBarBackgroundColor - |ZIM VEE| (default "rgba(0,0,0,.2)") the background color of the titleBar if a titleBar is requested
titleBarHeight - (default fit label) the height of the titleBar if a titleBar is requested
backgroundColor - |ZIM VEE| (default lighter) background color (use clear - or "rbga(0,0,0,0)" for no background)
borderColor - |ZIM VEE| (default pewter) border color
borderWidth - (default 1) the thickness of the border
corner - (default 15) the round of corner
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
numberCorner (default 30) the corner of the number keys
close - (default false) - add a close icon top right
closeColor - (default titleBarColor) the color of the close icon
collapse - (default false) - set to true to add a collapse icon to the titleBar that reduces the panel so only the bar shows and adds an icon to expand
	also can double click bar to collapse panel
collapseColor - (default grey) - the color of the collapse icon
collapsed - (default false) set to true to start the panel collapsed
align - (default LEFT) set to CENTER, MIDDLE or "right" to align the label on the titleBar
	this may get in the way of the close, arrow, collapse or extra buttons at right
shadowColor - (default "rgba(0,0,0,.3)" if shadowBlur) the shadow color - set to -1 for no shadow
shadowBlur - (default 14 if shadowColor) the shadow blur - set to -1 for no shadow
draggable - (default true if titleBar) set to false to not allow dragging titleBar to drag window
boundary - (default null) set to ZIM Boundary() object - or CreateJS.rectangle()
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: see ZIM Panel methods like collapse()
ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
key - the last key pressed - also see the pressed event
	this may include special colored keys: "clear", "space", "backspace" and "enter" 
pad - the ZIM Pad used for the numbers - see ZIM Pad() for properties to access buttons, and labels

ALSO: see ZIM Panel properties like contentContainer, collapsed, etc.
ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.
ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "pressed" event when pressed - also see the key property to give the text of the key pressed
dispatches a "close" event when closed with close button if there is a close button
dispatches a "collapse" event if collapsing
dispatches a "expand" event if expanding after being collapsed

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+57.7
	zim.NumPad = function(advanced, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, numberCorner, close, closeColor, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit) {
        var sig = "advanced, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, numberCorner, close, closeColor, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit";
        var duo; if (duo = zob(zim.NumPad, arguments, sig, this)) return duo;
		z_d("57.7");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("NumPad", this.group, inherit);
		if (zot(advanced)) advanced = DS.advanced!=null?DS.advanced:false;		
		var width = advanced=="simple"?310:400;
		var height = advanced=="simple"?440:advanced?620:530;        	
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:"NUMPAD";
		if (zot(titleBarColor)) titleBarColor = DS.titleBarColor!=null?DS.titleBarColor:zim.white;
		if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = DS.titleBarBackgroundColor!=null?DS.titleBarBackgroundColor:zim.grey;
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:40;
        if (zot(backgroundColor)) backgroundColor=DS.backgroundColor!=null?DS.backgroundColor:zim.darker;
        if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zim.pewter;
        if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
        if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
        else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(corner)) corner=DS.corner!=null?DS.corner:15;
		if (zot(numberCorner)) numberCorner=DS.numberCorner!=null?DS.numberCorner:30;
		if (zot(align)) align=DS.align!=null?DS.align:"left";
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(draggable)) draggable = DS.draggable!=null?DS.draggable:true;
		if (zot(boundary)) boundary = DS.boundary!=null?DS.boundary:null;
		if (zot(close)) close=DS.close!=null?DS.close:true;
		if (zot(closeColor)) closeColor = DS.closeColor!=null?DS.closeColor:!zot(titleBarColor)?titleBarColor:zim.grey;
		if (!Array.isArray(corner)) corner = [corner,corner,corner,corner];
		if (zot(collapse)) collapse=DS.collapse!=null?DS.collapse:true;
		if (zot(collapseColor)) collapseColor = DS.collapseColor!=null?DS.collapseColor:!zot(titleBarColor)?titleBarColor:zim.grey;
		if (zot(collapsed)) collapsed=DS.collapsed!=null?DS.collapsed:false;
		
		this.zimPanel_constructor(width, height, null, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, close, closeColor, null, null, null, collapse, collapseColor, collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, group, inherit);
        this.type = "NumPad";	

		var that = this;
				
		function ms(letter, color) {
			if (zot(color)) color = mist;
		    return {label:letter, backgroundColor:color, rollBackgroundColor:white, color:darker, rollColor:darker};
		}		
		var padArray = [
			ms("C",zim.red.darken(.1)),ms(new zim.Label({text:"␣", size:90, shiftV:-24}),zim.yellow.darken(.1)),ms(new zim.Label({text:"/",size:48,bold:true,shiftV:3})),ms(new zim.Label({text:"*", size:65, shiftV:18})),
			1,2,3,ms(new zim.Label({text:"-",size:60,shiftV:-3})),4,5,6,ms(new zim.Label({text:"+",size:55,shiftV:3})),
			7,8,9,ms(new zim.Label({text:"⌫",size:M=="ios"?60:35}), zim.red.darken(.1)),
			ms(new zim.Label({text:",",size:70,shiftV:-3})),ms(new Label({text:".",size:70,shiftV:-3})),0,ms(new zim.Label({text:"⏎", size:M=="ios"?40:50, shiftV:5}), zim.green.darken(.1))];
		
		
		function isRTL(){   
			return getComputedStyle(zdf.canvas).direction == "rtl";						
		};
		if (advanced=="simple") {
			padArray.splice(0,4);
			padArray.splice(3,1);
			padArray.splice(6,1);
			padArray.splice(10,2);
			padArray[12] = padArray[9];
			padArray[9] = padArray[10];
			padArray[10] = padArray[12];
		} else if (advanced) {
			padArray.splice(2,0,ms("%", yellow.darken(.1)));
			padArray.splice(4,0,ms(new zim.Label({text:"^",size:47,shiftV:10}), yellow.darken(.1)));
			padArray.splice(4,0,ms(isRTL()?"(":")", yellow.darken(.1)));
			padArray.splice(4,0,ms(isRTL()?")":"(", yellow.darken(.1)));
		}
		that.pad = new zim.Pad({
            width:advanced=="simple"?290:380,
            cols:advanced=="simple"?3:4,
            rows:advanced=="simple"?4:advanced?6:5,
            keys:padArray,
            spacing:6,
			currentSelected:false,
            backgroundColor:zim.grey,
            rollBackgroundColor:zim.tin,
            selectedBackgroundColor:zim.grey,
            downBackgroundColor:zim.green,
            corner:numberCorner
        })
		that.pad.on("mousedown", function () {
			if (that.pad.text == "C") that.key = "clear";
			else if (that.pad.text == "␣") that.key = "space";
			else if (that.pad.text == "⌫") that.key = "backspace";
			else if (that.pad.text == "⏎") that.key = "enter";
			else that.key = that.pad.text;
			that.dispatchEvent("pressed");
		})
		
		that.add(that.pad, null, true);

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function () {
			return that.cloneProps(new zim.NumPad(advanced, titleBar ? titleBar.clone() : "", titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, numberCorner, close, closeColor, collapse, collapseColor, that.collapsed, align, shadowColor, shadowBlur, draggable, boundary, style, this.group, inherit));
		};
    };
	zim.extend(zim.NumPad, zim.Panel, ["clone"], "zimPanel", false);
	//-66.1
	
/*--
zim.DPad = function(axis, width, backgroundColor, borderWidth, borderColor, indicatorColor, indicatorPressColor, indicatorScale, indicatorRadius, innerCircle, innerScale, activeRadius, clamp, logo, style, group, inherit)

DPad
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A DPad (Directional Pad) can be used to control x and y values
This is primarily handy on mobile where a substitute for keypresses is needed
The DPad can be set up for all directions, horizontal or vertical
The DPad can be passed in to a ZIM MotionController to control an object

See: https://zimjs.com/ten/dpad.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const dPad = new DPad().pos(50,50,LEFT,BOTTOM);
new MotionController({
	target:new Circle().center(),
	type:dPad,
	speed:mobile()?100:80,
	boundary:new Boundary(0,0,W,H)
});
S.update();
END EXAMPLE

EXAMPLE
// importing zim_physics... 
const physics = new Physics(0);
const ball = new Circle().center().addPhysics();
const dPad = new DPad().pos(40,40,LEFT,BOTTOM);
ball.control(dPad, 80);
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
axis - (default ALL) set to HORIZONTAL or VERTICAL or BOTH.  Appropriate arrows will show
width - (default 100) width of DPad 
backgroundColor - (default granite) the background color (any zim or html color)
indicatorColor - (default moon) the color of the arrows
indicatorPressColor - (default lighter) the color of the arrows as pressed
indicatorScale - (default 1) the scale of the arrows
indicatorRadius - (default null) set the indicator radius
innerCircle - (default true) set to false to not show an inner circle
innerScale - (default .5) the scale relative to the indicator
activeRadius - (default width*2) radius at which the DPad works
clamp - (default true) set to false to not limit the value between -1 and 1
logo - (default false) set to true to show the letter D in the DPad - or add your own
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
dirX, dirY - the x and y values for the DPad - between -1 and 1 if clamp is set
	these can be multiplied by a factor to adjust speed - or use speed parameter of associated MotionController
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
enabled - default is true - set to false to disable

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event with dirX and dirY provided as well on the event object

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+66.2
	zim.DPad = function(axis, width, backgroundColor, borderWidth, borderColor, indicatorColor, indicatorPressColor, indicatorScale, indicatorRadius, innerCircle, innerScale, activeRadius, clamp, logo, style, group, inherit) {
		var sig = "axis, width, backgroundColor, borderWidth, borderColor, indicatorColor, indicatorPressColor, indicatorScale, indicatorRadius, innerCircle, innerScale, activeRadius, clamp, logo, style, group, inherit";
		var duo; if (duo = zob(zim.DPad, arguments, sig, this)) return duo;
		z_d("66.2");

		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "DPad";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(axis)) axis = DS.axis!=null?DS.axis:"all";
		if (zot(width)) width = DS.width!=null?DS.width:100;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.granite;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:null;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(indicatorColor)) indicatorColor = DS.indicatorColor!=null?DS.indicatorColor:zim.moon;
		if (zot(indicatorPressColor)) indicatorPressColor = DS.indicatorPressColor!=null?DS.indicatorPressColor:zim.lighter;
		if (zot(indicatorScale)) indicatorScale = DS.indicatorScale!=null?DS.indicatorScale:1;
		if (zot(indicatorRadius)) indicatorRadius = DS.indicatorRadius!=null?DS.indicatorRadius:null;
		if (zot(innerCircle)) innerCircle = DS.innerCircle!=null?DS.innerCircle:true;
		if (zot(innerScale)) innerScale = DS.innerScale!=null?DS.innerScale:.5;
		if (zot(activeRadius)) activeRadius = DS.activeRadius!=null?DS.activeRadius:width; // note, twice diameter
		if (zot(clamp)) clamp = DS.clamp!=null?DS.clamp:true;
		if (zot(logo)) logo = DS.logo!=null?DS.logo:false;

		var that = this;

		this.axis = axis;
		this.outer = new zim.Circle(width/2, backgroundColor, borderColor, borderWidth).addTo(this);
		var inner = this.inner = new zim.Circle(width*innerScale/2, "rgba(0,0,0,.2)").center(this);
		if (logo) this.logo = new zim.Label({text:"D", bold:true}).center(inner).mov(1,2).alp(.3);
		var arrows = new zim.Container().addTo(this);
		var arrowSize = (width-borderWidth)*.2*indicatorScale;
		var numArrows = 8; // default all
		if (axis == "vertical") {
			numArrows = 2;
		} else if (axis == "horizontal") {
			numArrows = 2;
			arrows.rotation = 90;
		} else if (axis == "both") {
			numArrows = 4;
		}
		zim.loop(numArrows, function (i, total) {
			new zim.Triangle(arrowSize, arrowSize, arrowSize, indicatorColor).addTo(arrows).reg(null, zot(indicatorRadius)?(width-borderWidth)*.475:indicatorRadius).rot(i*360/total);
		});

		var startX = 0;
		var startY = 0;
		var p;
		that.dirX = 0;
		that.dirY = 0;

		var currentEvent;
		var firstTime = true;
		this.on("mousedown", function (e) {
			currentEvent = e;
			arrows.loop(function (arrow) {
				arrow.color = indicatorPressColor;
			});
			if (firstTime) {
				that.ticker = zim.Ticker.add(function () {
					calculatePos();
				});
			} else {
				zim.Ticker.add(that.ticker);
			}
		});

		this.on("pressmove", function (e) {
			currentEvent = e;
		});
		this.on("pressup", function () {
			zim.Ticker.remove(that.ticker);
			that.dirX = that.dirY = 0;
			arrows.loop(function (arrow) {
				arrow.color = indicatorColor;
			});
			if (that.stage) that.stage.update();
		});
		function calculatePos(){
			var e = currentEvent;
			startX = e.stageX/zim.scaX;
			startY = e.stageY/zim.scaY;
			p = that.globalToLocal(startX, startY);
			e = new createjs.Event("change");
			e.dirX = ((p.x+activeRadius)/(activeRadius*2)-.5)*2;
			e.dirY = ((p.y+activeRadius)/(activeRadius*2)-.5)*2;
			if (clamp) {
				e.dirX = zim.constrain(e.dirX, -1, 1);
				e.dirY = zim.constrain(e.dirY, -1, 1);
			}
			that.dirX = e.dirX;
			that.dirY = e.dirY;
			that.dispatchEvent(e);
		}

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
			}
		});

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.DPad(axis, width, backgroundColor, borderWidth, borderColor, indicatorColor, indicatorPressColor, indicatorScale, indicatorRadius, innerCircle, innerScale, activeRadius, clamp, logo, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			if (this.ticker) zim.Ticker.remove(this.ticker);
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};
	};
	zim.extend(zim.DPad, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-66.2

//
/*--
zim.Radial = function(labels, size, font, height, coreRadius, coreColor, startAngle, totalAngle, angles, flip, shiftV, icons, rollIcons, rotateIcons, iconsShiftVertical, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, selectedIndex, style, group, inherit)

Radial
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A radial ring with selectable buttons with lables or icons
Used internally by ZIM RadialMenu which has expandable rings for a hierarchical interface
Radial uses LabelOnArc for labels

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
var radial = new Radial(["one", "two", "three", "four"])
	.center()
	.change(()=>{
		zog(radial.selectedIndex);
	});
S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)

labels - (default ["A", "B", "C", "D", "E"]) an array of text or ZIM Label objects for buttons
size - (default 30) label size
font - (default "verdana") the font - can also import fonts in Frame() asset parameter or F.loadAssets()
startAngle - (default null) will start first button centered at top - see also totalAngle
	setting an angle will start left side of first button at this angle
	with 0 being the top (note, ZIM angles usually start along x axis - but not here)
totalAngle - (default 360) set to use only a portion of the circle - see also startAngle
angles - (default null) can set an array of angles for center of the buttons
	can use angles property toString() to get existing angle data
	this can be modified to suit and passed into this parameter for unequal button sizes
flip - (default true) flip the text between 90 and -180 (from 0 at top)
shiftRadial - (default 0) amount to shift text in radially
icons - (default null) set to an array of objects that will go under the text
	can set the labels to ["", "", "", etc.] to hide the text
	icons should be centerReg({add:false}) to ensure centered placement
rollIcons - (default null) set to an array of objects to replace icon when rolled over
rotateIcons - (default false) set to true to rotate icons around radial
iconsShiftRadial - (default 0) amount to shif the icons radially
height - (default 60) height of radial - not including core
coreRadius - (default 100) the radius of the core
	this is fairly large but can sca(.5) the radial after creating, etc.
coreColor - (default dark) the color of the core
backgroundColor - |ZIM VEE| (default granite) the background color of a button
	ZIM VEE means you can specify different colors for instance: series(blue, green, red, yellow)
	these would then be the color order of the buttons - same for rollBackgroundColor, etc.
rollBackgroundColor - |ZIM VEE| (default tin) the rollover background color of a button
selectedBackgroundColor - |ZIM VEE| (default charcoal) the background color of the selected button
selectedRollBackgroundColor - |ZIM VEE| (default selectedBackgroundColor) the roll background color of the selected button
backdropColor - (default clear) set to change the color behind the radial - including spacingOuter
color - |ZIM VEE| (default white) the text color of the button
rollColor - |ZIM VEE| (default color) the rollover text color of the button
selectedColor - |ZIM VEE| (default color) the text color of the selected button
selectedRollColor - |ZIM VEE| (default color) the rollover text color of the selected button
borderColor - (default dark) color of the button border
borderWidth - (default 2) width of the button border
gradient - (default null) set to a number between 0 and 1 - would suggest .1 for gradient on button
gap - (default 6 pixels or 3 degrees if gapAsAngle is true) gap between buttons
gapAsAngle - (default false) set to true set gap as angle
spacing - (default 6) radial spacing around button from core or edge of backdrop
spacingInner - (default spacing) inside radial spacing from core
spacingOuter - (default spacing) outside radial spacing from edge of backdrop
currentEnabled - (default false) set to true to make selected key pressable (for change event)
currentSelected - (default true) set to true to make selected key show selected colors
selectedIndex - (default 0) - set the selectedIndex at start
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - gets or sets the selected index of the pad
text - gets current selected label text
label - gets current selected label object
selected - gets the selected button - selected.enabled = true, etc.
buttons - a container of buttons
	each button has label and icon properties
angles - an array of angles to the center of the buttons
	can log angles.toString() to get angle data
	this can be adjusted and passed in to the angles parameter for unequal size buttons
core - a reference to the core circle object
backdrop - a reference to the backdrop circle
enabled - default is true - set to false to disable

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "change" event when the button changes (but not when setting selectedIndex property)
see also currentEnabled to get change event for each press - or use tap()

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+66.4
	zim.Radial = function(labels, size, font, height, coreRadius, coreColor, startAngle, totalAngle, angles, flip, shiftRadial, icons, rollIcons, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, selectedIndex, style, group, inherit) {
		var sig = "labels, size, font, height, coreRadius, coreColor, startAngle, totalAngle, angles, flip, shiftRadial, icons, rollIcons, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, selectedIndex, style, group, inherit";
		var duo; if (duo = zob(zim.Radial, arguments, sig, this)) return duo;
		z_d("66.4");

		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Radial";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(labels)) labels = DS.labels!=null?DS.labels:["A", "B", "C", "D", "E"];
		if (zot(size)) size = DS.size!=null?DS.size:30;
		if (zot(font)) font = DS.font!=null?DS.font:"verdana";
		if (zot(startAngle)) startAngle = DS.startAngle!=null?DS.startAngle:null; // top center
		if (zot(totalAngle)) totalAngle = DS.totalAngle!=null?DS.totalAngle:360;
		if (zot(angles)) angles = DS.angles!=null?DS.angles:null;
		if (zot(flip)) flip = DS.flip!=null?DS.flip:true;
		if (zot(shiftRadial)) shiftRadial = DS.shiftRadial!=null?DS.shiftRadial:0;
		if (zot(icons)) icons = DS.icons!=null?DS.icons:null;
		if (zot(rollIcons)) rollIcons = DS.rollIcons!=null?DS.rollIcons:null;
		if (zot(rotateIcons)) rotateIcons = DS.rotateIcons!=null?DS.rotateIcons:false;
		if (zot(iconsShiftRadial)) iconsShiftRadial = DS.iconsShiftRadial!=null?DS.iconsShiftRadial:0;

		if (zot(height)) height = DS.height!=null?DS.height:60;
		if (zot(coreRadius)) coreRadius = DS.coreRadius!=null?DS.coreRadius:100;
		if (zot(coreColor)) coreColor = DS.coreColor!=null?DS.coreColor:zim.dark;

		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:zim.clear;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.granite;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.tin;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor = DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.charcoal;
		if (zot(selectedRollBackgroundColor)) selectedRollBackgroundColor = DS.selectedRollBackgroundColor!=null?DS.selectedRollBackgroundColor:selectedBackgroundColor;
		if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(selectedColor)) selectedColor = DS.selectedColor!=null?DS.selectedColor:color;
		if (zot(selectedRollColor)) selectedRollColor = DS.selectedRollColor!=null?DS.selectedRollColor:rollColor;
		if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:zim.dark;
		if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:2; // 0
		if (zot(gapAsAngle)) gapAsAngle=DS.gapAsAngle!=null?DS.gapAsAngle:false;
		if (zot(gap)) gap=DS.gap!=null?DS.gap:(gapAsAngle?3:6);
		if (zot(gradient)) gradient=DS.gradient!=null?DS.gradient:null;
		if (gradient === true) gradient = .1;
		if (zot(spacing)) spacing=DS.spacing!=null?DS.spacing:6;
		if (zot(spacingInner)) spacingInner=DS.spacingInner!=null?DS.spacingInner:spacing;
		if (zot(spacingOuter)) spacingOuter=DS.spacingOuter!=null?DS.spacingOuter:spacing;
		if (zot(currentEnabled)) currentEnabled=DS.currentEnabled!=null?DS.currentEnabled:false;
		if (zot(currentSelected)) currentSelected=DS.currentSelected!=null?DS.currentSelected:true;

		var that = this;

		var innerRadius = this.innerRadius = coreRadius+spacingInner;
		var outerRadius = this.outerRadius = innerRadius + height;

		this.setBounds(-outerRadius, -outerRadius, outerRadius*2, outerRadius*2);
		var backdrop = this.backdrop = new zim.Circle(outerRadius+spacingOuter, backdropColor).center(this);
		if (coreRadius > 0) this.core = new zim.Circle(coreRadius, coreColor).center(this);

		if (angles && angles.length < labels.length-1) {
			if (zon) zogy("Radial() - not enough angles provided");
			return this;
		}
		if ((labels && labels.length > 0) || (icons && icons.length > 0)) {

			var total;
			if (labels && labels.length > 0) total = labels.length;
			if (icons && icons.length > 0) {
				if (total > 0) total = Math.min(icons.length, total);
				else total = icons.length;
			}
			if (rollIcons && rollIcons.length < total) {
				for (var j=0; j<total-rollIcons.length; j++) {
					rollIcons.push(new zim.Circle(1,zim.clear));
				}
			}

			var s = backdrop.width;
			var buttons = this.buttons = new zim.Container(-s/2, -s/2, s, s).centerReg(this);

			var gapInner = gap;
			if (!gapAsAngle) { // use circumference
				gap = gap/outerRadius*180/Math.PI;
				gapInner = gapInner/innerRadius*180/Math.PI;
			}
			var segmentAngle = (totalAngle-gap*total+(totalAngle==360?0:gap)) / total;
			var lastAngle = startAngle?startAngle:0;
			for (var i=0; i<total; i++) {
				if (angles) segmentAngle = angles[i];

				var button = new zim.Shape(-s/2, -s/2, s, s).centerReg(buttons);
				button.num = i;
				button.zimSelected = false;
				button.angle = segmentAngle;
				var g = button.graphics;

				button.backgroundColor = zim.Pick.choose(backgroundColor);
				button.rollBackgroundColor = zim.Pick.choose(rollBackgroundColor);
				button.selectedBackgroundColor = zim.Pick.choose(selectedBackgroundColor);
				button.selectedRollBackgroundColor = zim.Pick.choose(selectedRollBackgroundColor);
				button.color = zim.Pick.choose(color);
				button.rollColor = zim.Pick.choose(rollColor);
				button.selectedColor = zim.Pick.choose(selectedColor);
				button.selectedRollColor = zim.Pick.choose(selectedRollColor);

				button.colorCommand = g.f(button.backgroundColor).command;
				// border of 0 or a string value still draws a border in CreateJS
				if (zot(borderWidth) || borderWidth > 0) { // no border specified or a border > 0
					if (!zot(borderColor) || !zot(borderWidth)) { // either a border color or thickness
						if (zot(borderColor)) borderColor = zim.black;
						button.borderColorCommand = g.s(borderColor).command;
						button.borderWidthCommand = g.ss(borderWidth).command;
					}
				}
				var a0 = (lastAngle-90-segmentAngle/2)*Math.PI/180;
				var a1 = (lastAngle-90+segmentAngle/2)*Math.PI/180;
				var a2 = (lastAngle-90+(segmentAngle+gap-gapInner)/2)*Math.PI/180;
				var a3 = (lastAngle-90-(segmentAngle+gap-gapInner)/2)*Math.PI/180;
				g.arc(0, 0, outerRadius, a0, a1, false);
				g.arc(0, 0, innerRadius, a2, a3, true).cp();
				if (gradient) {
					g.s().ss().rf(["rgba(0,0,0,"+gradient+")","rgba(255,255,255,"+gradient+")"], [0, 1], 0, 0, innerRadius, 0, 0, outerRadius);
					g.arc(0, 0, outerRadius, a0, a1, false);
					g.arc(0, 0, innerRadius, a2, a3, true).cp();
				}
				button.cur("pointer");

				button.zimOverEvent = button.on("mouseover", function(e) {
					var button = e.target;
					button.colorCommand.style = (button==that.selected&&currentSelected)?button.selectedRollBackgroundColor:button.rollBackgroundColor;

					if (button.label) button.label.color = (button==that.selected&&currentSelected)?button.selectedRollColor:button.rollColor;
					if (rollIcons) {
						button.holder.removeAllChildren();
						rollIcons[button.num].loc(1,0,button.holder);
					}
					if (that.stage) that.stage.update();
				});
				button.zimOutEvent = button.on("mouseout", function(e) {
					var button = e.target;
					button.colorCommand.style = (button==that.selected&&currentSelected)?button.selectedBackgroundColor:button.backgroundColor;
					if (button.label) button.label.color = (button==that.selected&&currentSelected)?button.selectedColor:button.color;
					if (rollIcons) {
						button.holder.removeAllChildren();
						if (icons) icons[button.num].loc(1,0,button.holder);
					}
					if (that.stage) that.stage.update();
				});


				button.zimDownEvent = button.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(e) {
					var button = e.target;
					var diff = button !== that.selected;
					that.lastSelected = that.selected;
					myIndex = button.num;
					if (currentSelected) {
						if (diff) {
							if (that.selected) {
								that.selected.colorCommand.style = that.selected.backgroundColor;
								if (that.selected.label) that.selected.label.color = that.selected.color;
							}
							that.selected = button;
							that.label = button.label;
							if (that.label) that.text = that.label.text;
							that.icon = button.icon;
							button.colorCommand.style = button.selectedRollBackgroundColor;
							if (button.label) button.label.color = button.selectedRollColor;
						} else {
							if (!currentEnabled) {
								myIndex = -1;
								that.selected = null;
								that.label = null;
								that.text = null;
								that.icon = null;
								button.colorCommand.style = button.rollBackgroundColor;
								if (button.label) button.label.color = button.rollColor;
							}
						}
					} else {
						that.selected = button;
						that.label = button.label;
						if (that.label) that.text = that.label.text;
						that.icon = button.icon;
					}
					that.dispatchEvent("change");
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
				});


				if (icons && icons.length > 0) {
					var h = innerRadius+height/2+iconsShiftRadial;
					var holder = button.holder = new zim.Container(3, h).addTo(this).reg(1,h).rot(lastAngle);
					holder.mouseChildren = false;
					holder.mouseEnabled = false;
					button.icon = icons[i];
					icons[i].loc(1,0,holder);
					if (!rotateIcons) icons[i].rotation = -lastAngle;
				} // end icons

				if (labels && labels.length > 0) {
					// var buttons = this.buttons = new zim.Container(-s/2, -s/2, s, s).centerReg(this);
					var loa;
					if (labels[i].type != "LabelOnArc") {
						var label = (labels[i].type=="Label"?labels[i]:new zim.Label({text:labels[i], size:size, font:font, color:color, style:style, inherit:inherit}));
						loa = new zim.LabelOnArc({
							label: label,
							color:color,
							size:size,
							spacing:-5,
							flip:(flip && lastAngle>90 && lastAngle<270),
							radius:innerRadius+(height-label.height)/2+2+shiftRadial,
							style:style,
							inherit:inherit
						});
					} else {
						loa = labels[i];
					}
					labels[i] = loa;
					button.label = loa;
					loa.center(this).rot(lastAngle);
					loa.mouseChildren = false;
					loa.mouseEnabled = false;
				} // end labels

				if (i==labels.length-1) continue;
				var segmentAngle2 = angles?angles[i+1]:segmentAngle;
				lastAngle += (segmentAngle+segmentAngle2)/2+gap;

			}
			if (!zot(startAngle)) {
				that.rotation += that.buttons.getChildAt(0).angle/2;
			}

		}

		var myIndex = null;
		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				return myIndex;
			},
			set: function(value) {
				var button;
				if (that.buttons) button = that.buttons.getChildAt(value);
				if (button !== that.selected) {
					if (that.selected) {
						that.selected.colorCommand.style = that.selected.backgroundColor;
						if (that.selected.label) that.selected.label.color = that.selected.color;
					}
					that.selected = button;
					if (button) {
						if (currentSelected) button.colorCommand.style = button.selectedRollBackgroundColor;
						if (button.label) {
							if (currentSelected) button.label.color = button.selectedColor;
							that.text = button.label.text;
						}
					}
				}
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Radial(labels, size, font, height, coreRadius, coreColor, startAngle, totalAngle, angles, flip, shiftRadial, icons, rollIcons, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, selectedIndex, style, this.group, inherit));
		};

	};
	zim.extend(zim.Radial, zim.Container, "clone", "zimContainer", false);
	//-66.4

/*--
zim.RadialMenu = function(menu, size, font, height, coreRadius, coreColor, title, titleIcon, startAngle, totalAngle, flip, shiftRadial, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, open, under, style, group, inherit)

RadialMenu
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
An expanding hierarchy menu of button rings - using ZIM Radial objects.
The menu is specified by a menu parameter in the format of a ZIM Hierarchy object.
Styles for each ring can be specified in the menu object.
Icons for each ring can be specified in the styles.

See https://zimjs.com/ten/radial.html (ZIM TEN)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const menu = {
	"one":[1,2,3,4], // an array is okay as all items are leaf nodes (end nodes)
	"two":{ // an object literal is required as one or more items hold other items
	   "1":[], // this holds nothing (a leaf node) but still needs an empty array
	   "2":["a", "b", "c"], // this holds a linear list - all leaf nodes
	   "3":{ // this holds another nested list where at least one item holds more
		   "emotions":["love","hate","happy","sad"],
		   "flavors":["sweet","sour","bland","spicy"]
	   }
	},
	"three":[1,2,3,4,5,6],
	"four":[1,2,3,4,5,6,7,8]
}
new RadialMenu(menu).sca(.5).center();

// OR ADD STYLES
// see https://zimjs.com/ten/radial.html for full example (ZIM TEN)
// any Radial parameters can go in the styles:{} brackets
// including icons and rollIcons
// and can use series to apply background colors and colors to individual buttons
// PS - this is the EXTRA version of the simple ZIM Hierarchy format
// here we pass styles as an extra property - list is required
// styles is optional but used by ZIM RadialMenu to apply associated styles

var menu = {
	list:{
		"one":{
			list:["A","B","C","D"], // an array is okay as all items are leaf nodes (end nodes)
			styles:{backgroundColor:blue}
		},
		"two":{
			list:{ // an object literal is required as one or more items hold other items
			   "1":[], // this holds nothing (a leaf node) but still needs an empty array
			   "2":{
				   list:["a", "b", "c"], // this holds a linear list - all leaf nodes
				   styles:{}
			   },
			   "3":{ // this holds another nested list where at least one item holds more
				   list:{
					   "emotions":{
						   list:["love","hate","happy","sad"],
						   styles:{}
					   },
					   "flavors":{
						   list:["sweet","sour","bland","spicy"]   ,
						   styles:{}
					   }
				   },
				   styles:{}
			   }
		   },
		   styles:{}
	   },
	   "three":{
		   list:[1,2,3,4,5,6],
		   styles:{}
	   },
	   "four":{
		   list:[1,2,3,4,5,6,7,8],
		   styles:{}
	   }
	},
	// the styles for the first list
	// here we make each backgroundColor a different color
	styles:{backgroundColor:series(red,green,blue,yellow)}
}

new RadialMenu(menu).sca(.5).center();
S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)

menu - (default a simple menu) a ZIM Hierarchy (simple, simple EXTRA or complex)
	that holds the menu labels and optionally styles
 	see the ZIM RadialMenu examples and the format descriptions of ZIM Hierarchy for details
size - (default 30) label size
font - (default "verdana") the font - can also import fonts in Frame() asset parameter or F.loadAssets()
startAngle - (default null) will start first button centered at top - see also totalAngle
	setting an angle will start left side of first button at this angle
	with 0 being the top (note, ZIM angles usually start along x axis - but not here)
totalAngle - (default 360) set to use only a portion of the circle - see also startAngle
flip - (default true) flip the text between 90 and -180 (from 0 at top)
shiftRadial - (default 0) amount to shift text in radially
rotateIcons - (default false) set to true to rotate icons around radial
iconsShiftRadial - (default 0) amount to shif the icons radially
height - (default 60) height of radial - not including core or previous radials
coreRadius - (default 100) the radius of the core
	this is fairly large but can sca(.5) the radial after creating, etc.
coreColor - (default dark) the color of the core
title - (default "MENU") the label text in the core
titleIcon - (default null) an object to put under the title
** FOR BELOW: see menu parameter where colors can be set per ring and per button for ZIM VEE colors
backgroundColor - |ZIM VEE| (default granite) the background color of a button
	ZIM VEE means you can specify different colors for instance: series(blue, green, red, yellow)
	these would then be the color order of the buttons - same for rollBackgroundColor, etc.
rollBackgroundColor - |ZIM VEE| (default tin) the rollover background color of a button
selectedBackgroundColor - |ZIM VEE| (default charcoal) the background color of the selected button
selectedRollBackgroundColor - |ZIM VEE| (default selectedBackgroundColor) the roll background color of the selected button
backdropColor - (default clear) set to change the color behind the radial - including spacingOuter
color - |ZIM VEE| (default white) the text color of the button
rollColor - |ZIM VEE| (default color) the rollover text color of the button
selectedColor - |ZIM VEE| (default color) the text color of the selected button
selectedRollColor - |ZIM VEE| (default color) the rollover text color of the selected button
borderColor - (default dark) color of the button border
borderWidth - (default 2) width of the button border
gradient - (default null) set to a number between 0 and 1 - would suggest .1 for gradient on button
gap - (default 6 pixels or 3 degrees if gapAsAngle is true) gap between buttons
gapAsAngle - (default false) set to true set gap as angle
spacing - (default 6) radial spacing around button from core or edge of backdrop
spacingInner - (default spacing) inside radial spacing from nearest inside object
spacingOuter - (default spacing) outside radial spacing from edge of backdrop
currentEnabled - (default false) set to true to make selected key pressable (for change event)
currentSelected - (default true) set to true to make selected key show selected colors
open - (default false) set to true to start with first menu open
under - (default true) set to false to open menu rings in the top layer (usually under just in case there is a backdrop)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
closeRings(num) - close menu rings - default is all rings but use 1 to close the outer ring, 2 to close the two outer rings, etc.
 	see the outerLevel property for the current outer ring number with core being 0
	opening rings programmatically is not yet supported but may be in the future
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - gets the selected index of the outer ring (setting may come soon)
selectedLevel - gets the index of the level with the latest selection - the core is 0
selectedMenu - gets a reference to the selected menu
outerLevel - gets the index number of the outside level - the core is 0
outerMenu - gets a reference to the outer menu
text - gets current selected label text
label - gets current selected label object
selected - gets the selected button
core - a reference to the core circle object
enabled - default is true - set to false to disable

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

OPTIMIZED
This component is affected by the general OPTIMIZE setting (default is false)
if set to true, you will have to S.update() after setting certain properties
and S.update() in change event to see component change its graphics

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "change" event when the button changes (but not when setting selectedIndex property)
see also selectedIndex, selectedLevel, selected and text properties
see also currentEnabled to get change event for each press - or use tap()

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+66.6
	zim.RadialMenu = function(menu, size, font, height, coreRadius, coreColor, title, titleIcon, startAngle, totalAngle, flip, shiftRadial, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, open, under, style, group, inherit) {
		var sig = "menu, size, font, height, coreRadius, coreColor, title, titleIcon, startAngle, totalAngle, flip, shiftRadial, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, open, under, style, group, inherit";
		var sigList = sig.split(", ");
		var duoTest = false;
		if (menu && menu.constructor === {}.constructor) {
			for (var i in menu) {
				if (sigList.indexOf(i) >= 0) {
					duoTest = true;
					break;
				}
			}
		}
		if (menu && duoTest) {var duo; if (duo = zob(zim.RadialMenu, arguments, sig, this)) return duo;}
		z_d("66.6");

		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "RadialMenu";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(menu)) menu = DS.menu!=null?DS.menu:{A:{A1:["AA1", "AA2", "AA3", "AA4"],A2:[],A3:[]},B:["B1","B2","B3","B4","B5","B6"],C:[]};
		if (zot(size)) size = DS.size!=null?DS.size:30;
		if (zot(font)) font = DS.font!=null?DS.font:"verdana";
		if (zot(startAngle)) startAngle = DS.startAngle!=null?DS.startAngle:null; // top center
		if (zot(totalAngle)) totalAngle = DS.totalAngle!=null?DS.totalAngle:360;
		if (zot(flip)) flip = DS.flip!=null?DS.flip:true;
		if (zot(rotateIcons)) rotateIcons = DS.rotateIcons!=null?DS.rotateIcons:false;
		if (zot(shiftRadial)) shiftRadial = DS.shiftRadial!=null?DS.shiftRadial:0;
		if (zot(iconsShiftRadial)) iconsShiftRadial = DS.iconsShiftRadial!=null?DS.iconsShiftRadial:0;

		if (zot(height)) height = DS.height!=null?DS.height:60;
		if (zot(coreRadius)) coreRadius = DS.coreRadius!=null?DS.coreRadius:100;
		if (zot(coreColor)) coreColor = DS.coreColor!=null?DS.coreColor:zim.dark;
		if (zot(title)) title = DS.title!=null?DS.title:"MENU";
		if (zot(titleIcon)) titleIcon = DS.titleIcon!=null?DS.titleIcon:null;

		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:zim.clear;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.granite;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.tin;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor = DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.charcoal;
		if (zot(selectedRollBackgroundColor)) selectedRollBackgroundColor = DS.selectedRollBackgroundColor!=null?DS.selectedRollBackgroundColor:selectedBackgroundColor;
		if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(selectedColor)) selectedColor = DS.selectedColor!=null?DS.selectedColor:color;
		if (zot(selectedRollColor)) selectedRollColor = DS.selectedRollColor!=null?DS.selectedRollColor:rollColor;
		if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:zim.dark;
		if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:2; // 0
		if (zot(gapAsAngle)) gapAsAngle=DS.gapAsAngle!=null?DS.gapAsAngle:false;
		if (zot(gap)) gap=DS.gap!=null?DS.gap:(gapAsAngle?3:6);
		if (zot(spacing)) spacing=DS.spacing!=null?DS.spacing:6;
		if (zot(gradient)) gradient=DS.gradient!=null?DS.gradient:null;
		if (gradient === true) gradient = .1;
		if (zot(spacingInner)) spacingInner=DS.spacingInner!=null?DS.spacingInner:spacing;
		if (zot(spacingOuter)) spacingOuter=DS.spacingOuter!=null?DS.spacingOuter:spacing;
		if (zot(currentEnabled)) currentEnabled=DS.currentEnabled!=null?DS.currentEnabled:false;
		if (zot(currentSelected)) currentSelected=DS.currentSelected!=null?DS.currentSelected:true;
		if (zot(open)) open=DS.open!=null?DS.open:false;
		if (zot(under)) under=DS.under!=null?DS.under:true;

		var that = this;

		var eventType = (!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click";
		var lastSelected = null;
		var core = this.core = new zim.Circle({radius:coreRadius, color:coreColor, style:style, inherit:inherit}).addTo(this);
		if (titleIcon) this.titleIcon = titleIcon.center(core);
		if (title) this.title = new zim.Label({text:title, size:size, font:font, color:color, style:style, inherit:inherit}).center(core);
		core.cur("pointer");
		core.on(eventType, function() {
			that.leafNode = false;
			if (radials.length == 0) {
				changeRadial();
			} else {
				zim.loop(radials, function (radial) {
					radial.selectedIndex = -1;
					radial.removeFrom();
					radials = [];
				});
				that.outerLevel = 0;
				that.selected = that.outerMenu = that.selectedMenu = that.text = null;
			}

			if (currentEnabled || that.selected != lastSelected) that.dispatchEvent("change");
			lastSelected = that.selected;

			if (that.stage) that.stage.update();
		});

		this.closeRings = function(num) {
			if (zot(num)) num = that.outerLevel;
			var lev = that.outerLevel - num;
			zim.loop(radials, function (radial, i) {
				if (i>lev-1) {
					radial.removeFrom();
					radial.selectedIndex = -1;
					radials.pop();
				}
			}, true); // loop backwards
			that.outerLevel = lev;
			that.outerMenu = radials[radials.length-1];
			if (that.outerMenu) that.outerMenu.selectedIndex = -1;
			that.selected = that.selectedMenu = that.text = null;
			if (radials[radials.length-2]) {
				that.selectedMenu = radials[radials.length-2];
				that.selectedIndex = that.selectedMenu.selectedIndex;
			}
			else that.selectedIndex = -1;

			if (that.selected != lastSelected) that.dispatchEvent("change");
			lastSelected = that.selected;

			if (that.stage) that.stage.update();
		};

		// handle menu data
		var menus = {}; // holds created menus and does not remove them
		var tree;
		var ids;
		that.outerLevel = 0;
		if (menu.constructor == {}.constructor) {
			menu = {core:menu};
			tree = that.tree = new zim.Hierarchy(menu);
			ids = tree.getLinearIDs();
		}

		that.lastRadial = null;
		var radials = this.radials = [];
		if (open) {changeRadial();}

		function changeRadial(currentRadial) {
			var level, radius;
			if (!currentRadial) { // from core
				level = 0;
				radius = coreRadius;
			} else {
				// figure out the level based on currentRadial
				level = currentRadial.ringLevel;
			}

			// remove previous outer selections
			zim.loop(radials, function (radial, i) {
				if (i>level-1) {
					radial.removeFrom();
					radial.selectedIndex = -1;
					radials.pop();
				}
			}, true); // loop backwards

			var currentButton;
			if (currentRadial) currentButton = currentRadial.selected;
			if (currentButton) {
				var id = currentButton.id;
				radius = currentRadial.outerRadius;
				makeRadial(id, level+1, radius);
			} else if (!currentRadial) {
				makeRadial("id0", level+1, radius);
			} // else turning off button on current radial
			that.selected = currentButton;
			if (that.selected) {
				that.selectedMenu = radials[that.selected.menu.ringLevel-1];
				that.selectedIndex = that.selected.num;
				if (that.selected.label) that.text = that.selected.label.text;
				else that.text = null;
			} else {
				if (currentEnabled && currentRadial) {
					that.selectedIndex = currentRadial.selectedIndex;
					that.label = currentRadial.label;
					that.text = currentRadial.text;
					that.icon = currentRadial.icon;
					that.selectedMenu = currentRadial;
				} else {
					that.text = null;
					that.selectedIndex = -1;
					that.selectedMenu = null;
				}
			}
			if (that.stage) that.stage.update();
		}

		function makeRadial(id, level, radius) {
			if (level) that.outerLevel = level;
			var currentMenu;
			if (!menus[id]) {
				var data = tree.getData(id);
				var list = data.list;
				if (list && !zim.isEmpty(list)) {
					var props = {
						labels:tree.getLinearList(list),
						coreRadius:radius,
						size:size,
						font:font,
						startAngle:startAngle,
						totalAngle:totalAngle,
						flip:flip,
						rotateIcons:rotateIcons,
						shiftRadial:shiftRadial,
						iconsShiftRadial:iconsShiftRadial,
						height:height,
						coreColor:zim.clear,
						backdropColor:backdropColor,
						backgroundColor:backgroundColor,
						rollBackgroundColor:rollBackgroundColor,
						selectedBackgroundColor:selectedBackgroundColor,
						selectedRollBackgroundColor:selectedRollBackgroundColor,
						color:color,
						rollColor:rollColor,
						selectedColor:selectedColor,
						selectedRollColor:selectedRollColor,
						borderColor:borderColor,
						borderWidth:borderWidth,
						gapAsAngle:gapAsAngle,
						gap:gap,
						gradient:gradient,
						spacingInner:spacingInner,
						spacingOuter:spacingOuter,
						currentSelected:currentSelected,
						currentEnabled:currentEnabled,
						style:style,
						inherit:inherit
					};
					if (data.styles) {
						props = zim.merge(props, data.styles);
					}

					currentMenu = menus[id] = new zim.Radial(props);
					ids = tree.getLinearIDs(list);
					currentMenu.buttons.loop(function (button, i) {
						button.menu = currentMenu;
						button.id = ids[i];
					});
					currentMenu.ringLevel = that.outerLevel;
					currentMenu.selectedIndex = -1;
					currentMenu.on("change", function(e) {
						that.leafNode = false;
						changeRadial(e.target);
						if (currentEnabled || that.selected != lastSelected) that.dispatchEvent("change");
						lastSelected = that.selected;
					});
				}
			}
			if (menus[id]) {
				radials.push(menus[id]);
				menus[id].center(that);
				if (under) menus[id].bot();
			} else {
				that.leafNode = true;
				that.outerLevel -= 1;
			}
			that.outerMenu = currentMenu;
		}

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.RadialMenu(menu, size, font, height, coreRadius, coreColor, title, titleIcon, startAngle, totalAngle, flip, shiftRadial, rotateIcons, iconsShiftRadial, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, backdropColor, color, rollColor, selectedColor, selectedRollColor, borderColor, borderWidth, gradient, gap, gapAsAngle, spacing, spacingInner, spacingOuter, currentEnabled, currentSelected, open, under, style, this.group, inherit));
		};

	};
	zim.extend(zim.RadialMenu, zim.Container, "clone", "zimContainer", false);
	//-66.6

/*--
zim.ColorPicker = function(width, colors, cols, spacing, greyPicker, alphaPicker, startBackgroundColor, draggable, shadowColor, shadowBlur, buttonBar, circles, indicator, backgroundColor, keyArrows, container, selectedIndex, selectedColor, dropperTarget, spectrumCollapse, spectrumMode, spectrumClose, spectrumOk, spectrumTitle, tolerancePicker, collapsed, style, group, inherit)

ColorPicker
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A traditional color picker which shows 256 Web colors by default or custom colors.
Can additionally show 16 greys and / or an alpha slider.
Picking on a color sets the swatch color and the selectedColor property.
OK dispatches a "change" event if the color changed or a close event if not.
The X dispatches a "close" event.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const cp = new ColorPicker()
	.show() // use show() and hide() with ColorPicker. As of ZIM ZIM 01 can also use pos(), loc(), center(), etc.
	.change(()=>{
		zog(cp.selectedColor); // #ffcc99, etc. after pressing OK
		zog(cp.selectedAlpha); // 0-1
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 500) the width of the color picker
colors - (default "spectrum") - this shows a color spectrum, drag bar with collapse, mode and close (if no buttonBar)
	these can be configured with ColorPicker parameters (see spectrum parameter near end of parameters).
	The mode toggles between a gradient and pixel blocks
	Set the colors to "legacy" to show the traditional 256 colors
	or pass in an optional list of colors ["red", "#CCC", etc.]
cols - (default 10) how many columns to use if you pass in custom colors
spacing - (default 2) is the space between the color squares
greyPicker - (default true unless one row) shows an extra 16 greys (set to false to hide these)
	for the default colors it also includes 2 starting colors that record last picked colors
alphaPicker - (default true unless one row) shows an alpha slider (set to false to hide this)
	the swatch has a black, grey and white backing underneath to show multiple alpha effects
startBackgroundColor - (default the last color in color array) the starting color
draggable - (default true (false if no buttonBar or no spectrum)) whether you can drag the component - set to false to not drag
	a small grip under the color text shows if draggable
shadowColor - (default rgba(0,0,0,.3)) set to -1 for no drop shadow
shadowBlur - (default 14) the blur of the shadow if shadow is set
buttonBar - (default true unless one row) set to false to hide the button bar with OK and X (close)
circles - (default false) set to true to show colors in circles rather than squares
indicator - (default true) set to false to remove indicator from currentBackgroundColor
backgroundColor - (default black) the color of the background
keyArrows - (default true) set to false to disable keyboard arrows
container - (default zimDefaultFrame) if using show(), hide(), toggle() can set which container to center on
selectedIndex - (default 0) - set the selectedIndex at start
dropperTarget - (default null) - set to a DisplayObject to use dropper on the target - such as the stage 
	the dropper will always work on the spectrum
 	dropperTarget will cache the target so a color can be picked from it
	but this is modal on the target so buttons, etc. cannot be used and animations will not be seen
spectrumCollapse - (default true) - if spectrum color is set, set to false to not show a collapse button 
spectrumMode - (default true) - if spectrum color is set, set to false to not show a mode button
spectrumClose - (default true) - if spectrum color is set, set to false to not show a close button 
spectrumOk - (default true) - if spectrum color is set and there is a buttonBar, set to false to not show an OK button 
spectrumTitle - (default null) - if spectrum color then this is the title - for example, set to "Color Picker"
collapsed - (default false) - if spectrum and spectrumCollapse then set to true to start collapsed
tolerancePicker - (default false) - show a slider for tolerance - useful for when using ColorPicker to keyOut a color
	note: this will automatically hide the alphaPicker
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show() - show the picker (returns the picker for chaining) (as of ZIM ZIM 01 can also use pos(), loc(), center(), etc.)
hide() - hides the picker (as of ZIM ZIM 01 can also use removeFrom())
toggle(state - default null) - shows if hidden and hides if showing (returns the picker for chaining)
	or pass in true to show picker or false to hide picker
toggleSpectrum(state - default null) - if run without state will toggle the spectrum mode
	or pass in true to show gradient or false to show pixel blocks
collapse(state - default true) - with the "spectrum" setting, set state to true (default) to collapse or false to expand the picker  
updateDropperTarget() - with the "spectrum" setting, a cached view of the dropperTarger is shown to pick the color from 
	using updateDropperTarget() will update this cached view - it is processor intensive so beware
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedColor - gets or sets the selected color swatch
currentValue - same as selectedColor but consistent with other components
currentValueEvent - gets or sets the current value and dispatches a "change" event if set and changed
selectedAlpha - gets or sets the selected alpha (set does not work if alphaPicker is false)
selectedIndex - get or sets the selected index of the colorPicker
colors - read only array of colors in picker - not including greys - or "spectrum"
greys - read only array of greys in picker if the grey picker is set
toggled - read-only Boolean property as to whether picker is showing
collapsed - read-only Boolean property as to whether picker is collapsed
swatch - gets the Rectangle that is the color swatch
swatchBacking - gets the zim Shape that is under the swatch (seen if alpha set low)
swatchText - gets the Label that shows the color text
grip - gets the createjs.Shape for the grip if the panel is dragable
background - gets the Rectangle that is the background (cp.background.color = "white" - now a backgroundColor parameter)
okBut - references the OK Button
closeBut - references the X Button
indicator - gets the zim shape that is the indicator (if indicator is true)
title - reference to the spectrum title Label
NOTE: for colors:"spectrum"
	dropper - reference to the circle dropper
	gradient - reference to the gradient spectrum Bitmap
	pixels - reference to the pixel spectrum Bitmap
	closeIcon - reference to the close icon if there is one on the top bar 
	modeIcon - reference to the mode icon if there is one on the top bar 
	collapseIcon - reference to the collapse icon if there is one on the top bar 
	spectrumToggled - read-only Boolean that is true if gradient and false if spectrum is pixel blocks
NOTE: if alphaPicker is true:
	alphaBacking - gets reference to the Rectangle that makes the backing for the alpha slider
	alphaBut - the Button on the alpha slider
	alphaSlider - the Slider for the alpha
	alphaText - the Label for the alpha
NOTE: if tolerancePicker is true:
	toleranceBacking - gets reference to the Rectangle that makes the backing for the tolerance slider
	toleranceBut - the Button on the tolerance slider
	toleranceSlider - the Slider for the tolerance
	toleranceText - the Label for the tolerance
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
NOTE: these have been updated in ZIM 00
dispatches a "change" event when the color swatch changes or if no swatch when a color is picked. 
	also dispatches when the alpha is changed if there is an alpha picker.
	also dispatches when the tolerance is changed if there is an tolerance picker.
	also dispatches when text of color is changed.
dispatches a "swatch" event when the swatch is pressed.
dispatches an "ok" event when the OK button is pressed.
dispatches a "close" event when the close button is pressed.  Automatically closes the ColorPicker.
dispatches a "collapsed" event when collapsed in spectrum color mode.
dispatches a "expanded" event when expanded in spectrum color mode.

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67
	zim.ColorPicker = function(width, colors, cols, spacing, greyPicker, alphaPicker, startBackgroundColor, draggable, shadowColor, shadowBlur, buttonBar, circles, indicator, backgroundColor, keyArrows, container, selectedIndex, selectedColor, dropperTarget, spectrumCollapse, spectrumMode, spectrumClose, spectrumOk, spectrumTitle, tolerancePicker, collapsed, style, group, inherit) {
		var sig = "width, colors, cols, spacing, greyPicker, alphaPicker, startBackgroundColor, draggable, shadowColor, shadowBlur, buttonBar, circles, indicator, backgroundColor, keyArrows, container, selectedIndex, selectedColor, dropperTarget, spectrumCollapse, spectrumMode, spectrumClose, spectrumOk, spectrumTitle, tolerancePicker, collapsed, style, group, inherit";
		var duo; if (duo = zob(zim.ColorPicker, arguments, sig, this)) return duo;
		z_d("67");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "ColorPicker";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		
		var standard;
		if (zot(width)) width = DS.width!=null?DS.width:500;
		if (zot(colors)) colors = DS.colors!=null?DS.colors:"spectrum";
		if (colors == "legacy") standard = true;
		if (zot(cols)) cols = DS.cols!=null?DS.cols:10;		
		if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:2;		
		var oneRow = !standard&&colors.length>0&&colors.length<=cols;
		if (colors == "spectrum") {
			cols = 10;
			spacing = 2;
			oneRow = false;
		}
		if (zot(alphaPicker)) alphaPicker = DS.alphaPicker!=null?DS.alphaPicker:(oneRow?false:true);
		if (zot(tolerancePicker)) tolerancePicker = DS.tolerancePicker!=null?DS.tolerancePicker:false;
		if (tolerancePicker) alphaPicker = false;
		if (zot(greyPicker)) greyPicker = DS.greyPicker!=null?DS.greyPicker:(oneRow?false:true);
		if (zot(shadowColor)) shadowColor = DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur = DS.shadowBlur!=null?DS.shadowBlur:14;
		if (zot(buttonBar)) buttonBar = DS.buttonBar!=null?DS.buttonBar:(oneRow?false:true);
		if (zot(draggable)) {
			if (buttonBar || colors=="spectrum") {
				draggable = DS.draggable!=null?DS.draggable:true;
			} else {
				draggable = DS.draggable!=null?DS.draggable:false;
			}
		}
		if (zot(circles)) circles = DS.circles!=null?DS.circles:false;
		if (zot(indicator)) {
			indicator = DS.indicator!=null?DS.indicator:false;
			if (!buttonBar) indicator = DS.indicator!=null?DS.indicator:true;
		}
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.black;
		if (zot(startBackgroundColor)) startBackgroundColor = DS.startBackgroundColor!=null?DS.startBackgroundColor:null;
		if (zot(keyArrows)) keyArrows = DS.keyArrows!=null?DS.keyArrows:true;
		
		if (zot(dropperTarget)) dropperTarget = DS.dropperTarget!=null?DS.dropperTarget:false;
		if (zot(spectrumCollapse)) spectrumCollapse = DS.spectrumCollapse!=null?DS.spectrumCollapse:true;
		if (zot(spectrumMode)) spectrumMode = DS.spectrumMode!=null?DS.spectrumMode:true;
		if (zot(spectrumClose)) spectrumClose = DS.spectrumClose!=null?DS.spectrumClose:true;
		if (zot(spectrumOk)) spectrumOk = DS.spectrumOk!=null?DS.spectrumOk:true;
		if (zot(spectrumTitle)) spectrumTitle = DS.spectrumTitle!=null?DS.spectrumTitle:null;
		if (zot(collapsed)) collapsed = DS.collapsed!=null?DS.collapsed:false;
				
		var that = this;

		if (zot(container)) {
			if (WW.zdf) container = WW.zdf.stage;
			else return;
		} else if (!container.getBounds) {
			return;
		} else if (zot(container.getStage)) {
			return;
		}
		that.container = container;

		var secondLastBackgroundColor = "#e472c4"; // only used on standard colors
		var thirdLastBackgroundColor = "#50c4b7";
		var lastAlpha = 1;
		var myAlpha = 1;

		var box = new zim.Shape(); // shape that holds all colors and greys
		this.addChild(box);
		box.x += spacing;
		box.y += spacing;

		standard = false;
		var colorsTemp; var w;
		var greys = [];
		var c, r, nC, nR, f;
		var spectrum = colors == "spectrum";
		if (zot(colors) || colors=="legacy" || colors == "spectrum") {
			standard = true;
			var num = 6; // six sets 0,3,6,9,C,F - for Web colors
			var tot = num*num*num;
			num = Math.ceil(Math.pow(tot,1/2));
			w = (width - spacing)/18-spacing;
			f = Math.floor(Math.pow(num*num, 1/3));
			colorsTemp = [];
			for (var i=0; i<6; i++) {
				for (var j=0; j<6; j++) {
					for (var k=0; k<6; k++) {
						colorsTemp.push("#" + con(i*3) + con(j*3) + con(k*3));
					}
				}
			}
			colors = []; // flip every six by six sideways and put on two lines			
			for (i=0; i<colorsTemp.length; i++) {
				c = Math.floor(i/6);
				r = i%6;
				if (c >= 6*3) {f = 1;} else {f = 0;}
				nC = c-f*6*3;
				nR = r+f*6;
				colors[nR*18+nC] = colorsTemp[i];
			}
			cols = 18;
			greys = [thirdLastBackgroundColor, secondLastBackgroundColor];
		} else {
			w = (width - spacing) / cols - spacing;
		}
		var rows = Math.ceil(colors.length/cols);

		var startAlpha = 1;
		var myColor = String(colors[colors.length-1]);
		if (!zot(startBackgroundColor)) {
			var matches = startBackgroundColor.match(/rgba\((.*)\)/);
			if (matches) {
				c = matches[1].split(",");
				startAlpha = c.pop();
				startBackgroundColor = "rgb("+c.join(",")+")";
			}
			myColor = String(startBackgroundColor);
		}

		var lastBackgroundColor;
		if (standard) lastBackgroundColor = thirdLastBackgroundColor;

		function con(n) {
			n = Math.floor(n).toString(16);
			return n + "" + n;
		}

		f=0; 
		var g = box.graphics;
		var rX,rY;
		var borderColor = DS.borderColor!=null?DS.borderColor:null;
		var borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (!zot(borderColor) && zot(borderWidth)) borderWidth = 1;
		if (borderWidth && zot(borderColor)) borderColor = zim.dark;
		if (borderWidth) g.s(borderColor).ss(borderWidth);

		var ll = colors.length;
		if (spectrum) ll = 56;
		for (i=0; i<ll; i++) {
			c = i%cols;
			r = Math.floor(i/cols);
			rX = c*(w+spacing);
			rY = r*(w+spacing);
			if (circles) {
				g.f(colors[i]).dc(rX+w/2,rY+w/2,w/2);
			} else {
				g.f(colors[i]).r(rX,rY,w,w);
			}
		}
		var lastHeight = rY + w + spacing;

		that.colors = colors;

		var greyHeight = lastHeight;
		if (greyPicker) {
			for (i=0; i<16; i++) {
				greys.push("#"+con(i)+con(i)+con(i));
			}
			for (i=0; i<greys.length; i++) {
				c = Math.floor(i/cols);
				r = i%cols;
				rX = r*(w+spacing);
				rY = c*(w+spacing)+lastHeight;
				if (circles) {
					g.f(greys[i]).dc(rX+w/2,rY+w/2,w/2);
				} else {
					g.f(greys[i]).r(rX,rY,w,w);
				}
			}
			lastHeight = rY + w + spacing;
			var greyCols = cols;
			var greyRows = Math.ceil(greys.length/cols);
		}

		that.greys = greys;
		if (indicator && !spectrum) {
			indicator = this.indicator = circles ? new zim.Circle(w/2*.5, null, null, null, null, null, null, null, null, false) : new zim.Rectangle(w*.5, w*.5, null, null, null, null, null, null, null, false);
			indicator.alpha = .5;
			indicator.centerReg();
			this.addChild(indicator);
			indicator.mouseEnabled = false;			
			positionIndicator(colors.indexOf(myColor));
		}
		function positionIndicator(i) {
			if (zot(i) || i < 0) {
				indicator.visible = false;
				return;
			} else {
				indicator.visible = true;
			}
			if (myColor == "#000" || myColor == "#000000" || myColor == "black") {
				indicator.color = "#222";
				indicator.alpha = 1;
			} else {
				indicator.color = "black";
				indicator.alpha = .5;
			}
			indicator.x = box.x + i%cols*(w+spacing) + w/2;
			indicator.y = box.x + Math.floor(i/cols)*(w+spacing) + w/2;
		}
		var margin = 10;
		
		var spectrumHeight = lastHeight;

		if (alphaPicker || tolerancePicker) {
			var alpha = new zim.Container({style:false});
			alpha.setBounds(0,0,600,70);
			this.addChild(alpha);
			alpha.x = 0;
			alpha.y = lastHeight;

			var alphaBacking = this.alphaBacking = new zim.Rectangle(600-margin*2, 50, zim.licorice, null, null, 0, null, null, null, false);
			alpha.addChild(alphaBacking);
			zim.centerReg(alphaBacking, alpha);

			var sliderBut = this.alphaBut = new zim.Button({width:20,height:30,backgroundColor:"darkorange",rollBackgroundColor:"orange",label:"",corner:0,hitPadding:20,style:false});
			var slider = this.alphaSlider = new zim.Slider({min:0,max:1,step:(tolerancePicker?0:.05),button:sliderBut,barLength:tolerancePicker?500*.55:600*.55,barWidth:2,barColor:zim.silver,vertical:false,useTicks:false,inside:false,style:false});
			slider.currentValue = !zot(startAlpha)?startAlpha:1;
			if (tolerancePicker) slider.currentValue = .1;
			alpha.addChild(slider);
			slider.x = 40;
			slider.y = alpha.height/2;	
			var alphaText = this.alphaText = new zim.Label({
				text:tolerancePicker?"Tolerance: 0.1":"Alpha: " + zim.decimals(startAlpha), size:30, color:"orange",
				backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", backgroundColor:"ignore", rollColor:"orange",
				group:this.group
			});		
			alpha.addChild(alphaText);
			alphaText.x = slider.x + slider.bar.width + 40;
			alphaText.y = alpha.height/2 - alphaText.height/2;

			alpha.scaleX = alpha.scaleY = width / 600;

			slider.on("change", function() {				
				alphaText.text = tolerancePicker?"Tolerance: " + decimals(slider.currentValue):"Alpha: " + decimals(slider.currentValue);
				if (alphaPicker && swatch) {
					swatch.alpha = myAlpha = slider.currentValue;				
				}			
				that.dispatchEvent("change");				
				if (that.stage) that.stage.update();
			});
			lastHeight += alpha.height-margin;
			
			if (tolerancePicker) {
				that.toleranceBacking = that.alphaBacking;
				that.toleranceBut = that.alphaBut;
				that.toleranceSlider = that.alphaSlider;
				that.alphaBacking = that.alphaBut = that.alphaSlider = null;
			}
		}

		if (buttonBar) {
			var nav = new zim.Container({style:false});
			nav.setBounds(0,0,600,100);
			this.addChild(nav);
			nav.x = 0;
			nav.y = lastHeight+margin;

			// var swatchText = this.swatchText = new zim.Label({
			// 	align:"center",
			// 	text:myColor.toUpperCase(), labelWidth:120, size:30, color:"orange", rollColor:"orange",
			// 	backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", backgroundColor:"ignore",
			// 	group:this.group
			// });
			var swatchText = this.swatchText = new zim.TextInput({
				align:"left",
				selectionAlpha:.5,
				text:myColor.toUpperCase(), width:140, size:30, color:"orange", 
				shadowColor:"ignore", shadowBlur:"ignore", backgroundColor:"ignore",
				group:this.group
			});
			swatchText.on("input", function () {
				if (swatchText.text.length == 4 || swatchText.text.length == 7) {
					swatch.color = swatchText.text;
					myColor = swatch.color;
					that.dispatchEvent("change");
				}
			})
			nav.addChild(swatchText);
			zim.centerReg(swatchText);
			swatchText.x = 200/2-10;
			swatchText.y = 50-2;

			if (draggable) {
				var grip = this.grip = new zim.Shape({style:false});
				grip.cur("pointer");
				nav.addChild(grip);
				grip.graphics.f("rgba(256,256,256,.25)").r(0,0,5,20).r(10,0,5,20).r(20,0,5,20).r(30,0,5,20);
				grip.x = 70; grip.y = 65;
				swatchText.y = 50-10;
				grip.mouseEnabled = false;
			}
			var closeBut = this.closeBut = new zim.Button({width:90, height:90, label:"X", backgroundColor:zim.licorice, rollBackgroundColor:zim.charcoal, corner:0, style:false});
			nav.addChild(closeBut);
			closeBut.x = 600 - closeBut.width - margin;
			closeBut.y = 0;
			closeBut.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){that.hide(); that.dispatchEvent("close");});

			var button = this.okBut = new zim.Button({width:150, height:90, label:"OK", backgroundColor:zim.licorice, rollBackgroundColor:zim.charcoal, corner:0, style:false});
			nav.addChild(button);
			button.x = closeBut.x - button.width - margin;
			button.y = 0;
			button.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){doChange(); that.dispatchEvent("ok");});

			var swatchBacking = this.swatchBacking = new zim.Shape({style:false});
			nav.addChild(swatchBacking);
			g = swatchBacking.graphics;
			g.f(zim.black).r(0.5,0.5,50,89).f(zim.granite).r(50,0.5,50,89).f(zim.white).r(100,0.5,49.5,89);
			swatchBacking.x = button.x - 150 - margin;
			swatchBacking.y = 0;

			var swatch = this.swatch = new zim.Rectangle(150, 90, myColor, null, null, null, null, null, null, false);
			nav.addChild(swatch);
			swatch.x = swatchBacking.x;
			swatch.y = 0;
			swatch.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
				that.dispatchEvent("swatch");
			});
			swatch.cur("pointer");
			swatch.alpha = myAlpha = startAlpha;

			nav.scaleX = nav.scaleY = width / 600;
			lastHeight += nav.height;
		} else {
			box.cur("pointer");
		}

		if (!alphaPicker && !buttonBar) {
			lastHeight -= margin - spacing;
		}

		var height = lastHeight + margin;
		this.setBounds(0,0,width,height);

		var background = this.background = new zim.Rectangle(width,height,backgroundColor, null, null, null, null, null, null, false);
		this.addChildAt(background,0);
		if (shadowColor != -1 && shadowBlur > 0) background.shadow = new createjs.Shadow(shadowColor, 8, 8, shadowBlur);

		var frame = WW.zdf;
		var mock;
		var dropping = false;
		this.dropperTarget = dropperTarget;		
		if (spectrum) {
			colors = "spectrum";
			var dH = 30; // dragger
			var gH = 20; // greys
			var sH = spectrumHeight-dH+1;
			var cH = sH-gH+1;
			var dragger = that.bar = new zim.Rectangle(that.width, dH+1, zim.black).addTo(that);
			if (spectrumTitle) that.title = new zim.Label(spectrumTitle, 18, null, zim.light).pos(12,1,LEFT,CENTER,that.bar).noMouse();
			if (draggable) dragger.cur();    
			var spect = new zim.Container(that.width,sH).loc(0,dH,that)
			var main = new zim.Rectangle(that.width,cH,new zim.GradientColor([
				"rgb(255 0 0)",
				"rgb(255 255 0)",
				"rgb(0 255 0)",
				"rgb(0 255 255)",
				"rgb(0 0 255)",
				"rgb(255 0 255)",
				"rgb(255 0 0)"
			],[0,1/6,2/6,3/6,4/6,5/6,6/6],0,0,500,0)).addTo(spect).mov(0,gH-1);
			new zim.Rectangle(that.width,cH/2,new zim.GradientColor(["rgba(255,255,255,1)","rgba(255,255,255,0)"],[0,1],0,0,0,cH/2)).loc(main, null, spect);
			new zim.Rectangle(that.width,cH/2+.5,new zim.GradientColor(["rgba(0,0,0,1)","rgba(0,0,00,0)"],[1,0],0,0,0,cH/2+.5)).loc(main, null, spect).mov(0,cH/2);
			new zim.Rectangle(that.width,20,new zim.GradientColor(["black","white"],[.1,.9],0,0,that.width,0)).addTo(spect);
			
			var gradient = that.gradient = new zim.Bitmap(spect).loc(spect, null, that).cur("none");
			var pixels = that.pixels = new zim.Pixel(spect, .5).loc(spect, null, that).vis(false).cur("none");
			
			spect.dispose();
			
			var closeIcon;
			if (!buttonBar && spectrumClose) {
				closeIcon = that.closeIcon = new zim.Shape(-40,-40,80,80,null,false);
				closeIcon.graphics.f(zim.light).p("AmJEVIEUkTIkXkWIB4h5IEWEYIETkTIB4B3IkTESIEQERIh4B4IkRkRIkSEVg"); // width about 90 reg in middle
				closeIcon.sca(.25)
					.expand(10, 10, 10, 1)
					.pos(7,0,zim.RIGHT,zim.CENTER,dragger)
					.cur()
					.addTo(that)
				closeIcon.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(){
					that.hide();
					that.dispatchEvent("close");
				});
			}		
						
			var collapseIcon = that.collapseIcon = new zim.Triangle(20,20,20,zim.faint,zim.light,2)
				.expand(10, 10, 10, 1)
				.pos(40+(closeIcon?30:0),0,zim.RIGHT,zim.CENTER,dragger)
				.cur()
				.addTo(that)
			collapseIcon.on("mousedown", function() {			
				that.collapse(collapseIcon.rotation==0);			
			});
			
			var b1 = new zim.Rectangle(20,20,zim.white).reg("center");
			new zim.Tile(new zim.Rectangle(10,10,zim.series(zim.silver,zim.white,zim.white,zim.silver)),2,2,0,0).addTo(b1);
			b1.mouseChildren = false;
			var modeIcon = that.modeIcon = new zim.Button({
				width:20,
				height:20,
				shadowColor:-1,
				label:"",
				backing:b1,
				toggleEvent:"mousedown",
				toggleBacking:new zim.Rectangle(20,20,new zim.GradientColor([zim.white,zim.grey],[0,1],0,0,20,20)).reg("center")
			}).pos(8+(closeIcon?30:0),5,zim.RIGHT,zim.TOP,that).expand(10, 10, 10, 1);			
			modeIcon.on("mousedown", function(){
				pixels.vis(modeIcon.toggled);
				that.spectrumToggled = !modeIcon.toggled;
				frame.stage.update();
			});
			
			if (!spectrumMode) {
				modeIcon.removeFrom();
				collapseIcon.mov(28);
			}
			if (!spectrumCollapse) {
				collapseIcon.removeFrom();
			}
			if (!spectrumOk) {
				if (that.okBut) that.okBut.removeFrom();
			}
			if (!spectrumClose && closeBut) closeBut.removeFrom(); 		

			var cover = new zim.Rectangle(that.width, that.height-sH-dH, zim.faint).pos(0,0,zim.LEFT,zim.BOTTOM,that).noMouse();    

			var dropper = this.dropper = new zim.Circle(10,zim.clear,zim.white,8);
			new zim.Circle(5,zim.clear,zim.black,2).center(dropper)
			new zim.Circle(7,zim.clear,zim.white,2).center(dropper)
			dropper.noMouse();
								
		}		
		
		this.updateDropperTarget = function() {
			dropper.vis(false);
			setMock();
			dropper.vis(true).top();
		}
		
		this.spectrumToggled = spectrum; // true for gradient and false for pixels
		this.toggleSpectrum = function(state) { // changes gradient vs pixels	
			if (state==that.spectrumToggled) return;
			if (zot(state)) state = !that.spectrumToggled;	
			that.spectrumToggled = state;			
			modeIcon.toggle(!state);
			pixels.vis(!state);
			that.updateDropperTarget();
		}		
		
		var spectrumHit = false;
		function placeDropper() {	
			// want to change color when pressing down
			// do not want to change color when pressup outside spectrum but do when on spectrum			
			if (!frame.stage.mouseInBounds) dropper.alp(0);
			else dropper.alp(1);
			
			dropper.loc(frame.mouseX, frame.mouseY, frame.stage);
			spectrumHit = that.spectrumToggled?gradient.hitTestReg(dropper):pixels.hitTestReg(dropper);
			var mockHit;
			if (!that.dropperTarget) mockHit = false;
			else mockHit = (dropper.x >= mock.x && dropper.x <= mock.x+mock.width && dropper.y >= mock.y && dropper.y <= mock.y+mock.height); 
			
			// if (!pressing) {
				var hitting; // are we wanting to show dropper
				if (that.dropperTarget) hitting = (spectrumHit || mockHit) && !cover.hitTestReg(dropper) && !dragger.hitTestReg(dropper);
				else hitting = spectrumHit;
					
				if (!dropping && hitting) { // add dropper
					showDropper(mockHit);					
				} else if (dropping && !hitting) { // remove dropper
					hideDropper();
					frame.stage.update();
					return;					
				}				
				if (!hitting) return;
			// }
			
			var ob;
			if (spectrumHit) {
				ob = that.spectrumToggled?gradient:pixels;
			} else if (!that.dropperTarget) {
				return;
			} else {
				ob = mock;
			}
			var p = ob.globalToLocal(frame.mouseX, frame.mouseY);    
			var d = ob.getColorAt(p.x, p.y, true);  
			var c = "rgba("+d[0]+","+d[1]+","+d[2]+","+d[3]+")";
			if (d[3]<.05) c = frame.color;   
			dropper.borderColor = c;			
			frame.stage.update();
		}	
		
		function showDropper(mockHit) {
			dropping = true;    
			if (mockHit) setMock(); 
			dropper.vis(true).top();
		}
		function hideDropper() {
			dropping = false;
			mock.dispose();
			dropper.vis(false);
		}		
		this.collapsed = false;
		this.collapse = function(state) {
			if (zot(state)) state=true;
			if (state == that.collapsed) return;
			that.collapsed = state;
			if (state) {
				modeIcon.enabled = false;
				collapseIcon.rot(180);
				that.background.vis(false);
				gradient.vis(false);
				cover.vis(false);
				box.visible = false;
				if (pixels) pixels.vis(false);
				if (alpha) alpha.vis(false);
				if (buttonBar) nav.vis(false);
				dropping = false;
				removeSpectrumEvents();				
				clearMock();
				that.dispatchEvent("collapsed");			
			} else {		
				modeIcon.enabled = true;
				collapseIcon.rot(0);
				that.background.vis(true);
				gradient.vis(true);
				cover.vis(true);
				box.visible = true;
				if (!that.spectrumToggled) pixels.vis(true);
				if (alpha) alpha.vis(true);
				if (buttonBar) nav.vis(true);	
				dropping = true;
				addSpectrumEvents();				
				setMock();
				if (dragger.hitTestReg(dropper)) clearMock(); // as on button
				that.dispatchEvent("expanded");				
			}
			frame.stage.update()
		}
		
		if (spectrum && spectrumCollapse) {
			that.collapseEvent = dragger.on("dblclick", function () {
				if (that.collapsed) that.collapse(false);
				else that.collapse(true);
			});
		}
		
		if (spectrum && collapsed && spectrumCollapse) {
			that.vis(false);
			setTimeout(function(){
				that.collapse(true);
				that.vis(true);
				if (that.stage) that.stage.update();
			}, 50);
		}
		
		function addSpectrumEvents() {			
			removeSpectrumEvents();
			that.dropperDown = frame.stage.on("stagemousedown", placeDropper);			
			that.dropperMove = frame.stage.on("stagemousemove", placeDropper);				
			that.dropperUp = frame.stage.on("stagemouseup", function() {
				placeDropper();		
				if (swatch && spectrum && spectrumHit && swatch.color != dropper.borderColor) setColorDrop();
				else if (!swatch && spectrum && spectrumHit) setColorDrop()
			});
		}
		function removeSpectrumEvents() {
			if (that.dropperDown) frame.stage.off("stagemousedown", that.dropperDown);			
			if (that.dropperMove) frame.stage.off("stagemousemove", that.dropperMove);
			if (that.dropperUp) frame.stage.off("stagemouseup", that.dropperUp);
		}
			
		function setMock() {			
			if (mock && mock.dispose) mock.dispose();
			var temp = new zim.Rectangle(frame.width, frame.height, frame.color).addTo(frame.stage,0); // get cursor to work
			var bounds;
			if (that.dropperTarget && that.dropperTarget.getBounds && that.dropperTarget.type && !that.dropperTarget.type.includes("Stage")) {
				bounds = that.dropperTarget.boundsToGlobal();
			} else {
				bounds = frame.stage.getBounds();	
			}
			mock = new zim.Bitmap(frame.stage, bounds.width, bounds.height, bounds.x, bounds.y).loc(bounds).cur("none");	
			temp.dispose();
			mock.on("mousedown", setColorDrop);
		}    	
		function clearMock() {
			if (mock && mock.dispose) mock.dispose();
			dropper.vis(false);
		}  	
		function setColorDrop() {
			dropper.vis(false);			
			that.currentValue = zim.convertColor(dropper.borderColor ,"hex");			
			that.dispatchEvent("change");
			if (!dropping) return;
			if (dropperTarget) { // adjusted ZIM ZIM 01 to only do when dropperTarget
				setMock();
				dropper.vis(true).top();
				setTimeout(function() {
					that.updateDropperTarget();
					frame.stage.update();
				}, 50);
			} else {
				dropper.vis(true).top();
				frame.stage.update();
			}
		}	    

		function doChange(){
			if (standard && greyPicker) {
				thirdLastBackgroundColor = secondLastBackgroundColor;
				secondLastBackgroundColor = lastBackgroundColor;
				var lastBackgroundColors = [thirdLastBackgroundColor, secondLastBackgroundColor];
				for (i=0; i<2; i++) {
					var g = box.graphics;
					c = Math.floor(i/cols);
					r = i%cols;
					rX = r*(w+spacing);
					rY = c*(w+spacing)+greyHeight;
					greys[i] = lastBackgroundColors[i];
					g.f(background.color).r(rX-1,rY-1,w+2,w+2).f(lastBackgroundColors[i]).r(rX,rY,w,w);
				}					
			}
			lastBackgroundColor = myColor;
			lastAlpha = myAlpha;

			that.dispatchEvent("change");
			if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();		
		}

		if (draggable) {
			var diffX, diffY;
			background.on("mousedown", downDrag);
			background.on("pressmove", moveDrag);
			background.on("pressup", upDrag);
			if (spectrum) {
				dragger.on("mousedown", downDrag);
				dragger.on("pressmove", moveDrag);
				dragger.on("pressup", upDrag);
			}
		}
		function downDrag(e) {
			diffX = e.stageX/zim.scaX - that.x;
			diffY = e.stageY/zim.scaY - that.y;
			// background.cursor = "move";
			// if (spectrum) dragger.cursor = "move";
		}
		function moveDrag(e) {
			that.x = e.stageX/zim.scaX-diffX;
			that.y = e.stageY/zim.scaY-diffY;
			if (that.stage) that.stage.update();
		}
		function upDrag() {
			// background.cur("default");
			// if (spectrum) dragger.cur("default");
			if (that.stage) that.stage.update();
		}

		var gridW = cols*(w+spacing);
		var gridH = rows*(w+spacing);
		if (greyPicker) {
			var greyW = greyCols*(w+spacing);
			var greyH = greyRows*(w+spacing);
		}
		box.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function(e) {
			var index = zim.hitTestGrid(box, gridW, gridH, cols, rows, e.stageX, e.stageY, 0, 0, spacing, spacing);
			if (!zot(index)) {
				myColor = colors[index];
				if (buttonBar) {
					swatch.color = myColor;
					swatchText.text = String(colors[index]).toUpperCase();
				} 
				doChange();
			}
			if (greyPicker) {
				// note greyW not gridW
				index = null;
				index = zim.hitTestGrid(box, greyW, greyH, greyCols, greyRows, e.stageX, e.stageY, 0, gridH, spacing, spacing);

				if (!zot(index)) {
					myColor = greys[index];
					if (buttonBar) {
						swatch.color = myColor;
						swatchText.text = greys[index].toUpperCase();
					} 
					doChange();
				}
			}
			if (indicator) positionIndicator(colors.indexOf(myColor));
			if (buttonBar) {
				if (that.stage) that.stage.update();
			} else if (indicator) {
				if (that.stage) that.stage.update();
				// if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
			setAccessibility();
		});

		Object.defineProperty(this, 'selectedColor', {
			get: function() {
				return myColor;
			},
			set: function(value) {
				value = value.toLowerCase();
				lastBackgroundColor = myColor = value;
				if (buttonBar) {
					swatch.color = myColor;
					swatchText.text = myColor;
					if (that.stage) that.stage.update();
				}
				if (indicator && !spectrum) positionIndicator(colors.indexOf(myColor));
				setAccessibility();
			}
		});

		Object.defineProperty(this, 'currentValue', { // alternate to selectedColor
			get: function() {
				return myColor;
			},
			set: function(value) {
				that.selectedColor = value;
			}
		});

		Object.defineProperty(this, 'currentValueEvent', { // currentValue and also triggers change event
			get: function() {
				return myColor;
			},
			set: function(value) {
				if (value != that.selectedColor) {
					that.selectedColor = value;
					that.dispatchEvent("change");
				}
			}
		});

		Object.defineProperty(this, 'selectedIndex', {
			get: function() {
				if (spectrum) return null;
				return colors.indexOf(myColor);
			},
			set: function(value) {
				if (spectrum) return;
				lastBackgroundColor = myColor = colors[value];
				if (buttonBar) {
					swatch.color = myColor;
					swatchText.text = myColor;
					if (that.stage) that.stage.update();
				}
				if (indicator) positionIndicator(colors.indexOf(myColor));
				setAccessibility();
			}
		});

		Object.defineProperty(this, 'selectedAlpha', {
			get: function() {
				if (alphaPicker) {
					return decimals(slider.currentValue);
				} else {
					return 1;
				}
			},
			set: function(value) {
				if (alphaPicker) {
					lastAlpha = slider.currentValue = value;
					if (swatch) swatch.alpha = lastAlpha;
					if (alphaText) alphaText.text = "Alpha: " + decimals(slider.currentValue);
					if (that.stage) that.stage.update();
				}
			}
		});
		
		Object.defineProperty(this, 'selectedTolerance', {
			get: function() {
				if (tolerancePicker) {
					return decimals(slider.currentValue);
				} else {
					return 1;
				}
			},
			set: function(value) {
				if (tolerancePicker) {
					slider.currentValue = value;
					if (that.stage) that.stage.update();
				}
			}
		});
	
		Object.defineProperty(this, 'colors', {
			get: function() {
				if (spectrum) return "spectrum";
				if (greyPicker) return colors.concat(greys);
				else return colors;
			},
			set: function() {
				if (zon) zogy("ColorPicker() colors is read only - make a new ColorPicker to change");
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				if (zns) zim.KEYFOCUS = that;
				else WW.KEYFOCUS = that;
			}
		});
		if (keyArrows && zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {if (keyArrows) setFocus();});
		function setFocus() {that.keyFocus = true; var d=document.activeElement; if (d) d.blur();}

		function setAccessibility() {
			if (that.zimAccessibility) that.zimAccessibility.changeTitle(that, null, true);
		}

		this.keyDownEvent = function(e) {
			if (!that.stage) return;
			if (spectrum) return;
			if ((that.zimAccessibility && that.focus) || (!that.zimAccessibility && that.keyFocus)) {
				var currentTemp = that.selectedIndex;
				if (e.keyCode == 37 || e.keyCode == 40) {
					currentTemp--;
					changeMe(currentTemp);
				} else if (e.keyCode == 38 || e.keyCode == 39){
					currentTemp++;
					changeMe(currentTemp);
				}				
			}
		};
		function changeMe(currentTemp) {
			if (currentTemp < 0) currentTemp = that.colors.length-1;
			if (currentTemp > that.colors.length-1) currentTemp = 0;
			that.selectedIndex = currentTemp;
			that.dispatchEvent("change");
			if (that.stage) that.stage.update();
		}
		WW.addEventListener("keydown", this.keyDownEvent);

		var stage, frame;
		this.hide = function() {
			stage = that.stage;	
			that.removeFrom();			
			if (stage) stage.update();
			return that;
		};
		this.on("removed", hide2);
		function hide2() {
			if (spectrum) {				
				dropping = false;
				removeSpectrumEvents();
				clearMock();
			}
			that.toggled = false;
			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				a.resize(that);
				if (accessibilityClicker) accessibilityClicker.focus();
				else that.zimTabTag.nextSibling.focus();
				setTimeout(function() {a.talk("ColorPicker has been closed.");}, 50);
			}
			if (stage) stage.update();
		}

		var accessibilityClicker;
		var firstShow = false;
		this.show = function() {			
			that.center(that.container);
			return that;
		};
		function show2() {
			if (that.stage) {
				stage = that.stage;	
				frame = stage.frame;	
			}
			if (that.zimAccessibility) {
				var a = that.zimAccessibility;
				setTimeout(function(){if (a.activatedObject) accessibilityClicker = a.activatedObject.zimTabTag;}, 50);
				a.resize(that);
				a.tabIndex = that.zimTabIndex;
			}
			that.toggled = true;
			setTimeout(function() {
				if (spectrum) {
					dropping = true;
					setMock();
					addSpectrumEvents();
					showDropper();
					placeDropper();
				}
				if (that.stage) that.stage.update();
			}, 20);			
		}
		this.on("added", show2);
		
		this.toggle = function(state) {
			if (state===true) that.show();
			else if (state===false) that.hide();
			else if (that.container.contains(that)) that.hide();
			else that.show();
			return that;
		};

		function decimals(n) {
			return Math.round(n*Math.pow(10, 2))/Math.pow(10, 2);
		}

		if (zot(selectedIndex)) selectedIndex=DS.selectedIndex!=null?DS.selectedIndex:0;
		that.selectedIndex = selectedIndex;
		if (zot(selectedColor)) selectedColor=DS.selectedColor!=null?DS.selectedColor:null;
		if (selectedColor!=null) that.selectedColor = selectedColor;
		else if (spectrum) that.selectedColor = "#888888";

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.ColorPicker(width, standard?null:colors, cols, spacing, greyPicker, alphaPicker, startBackgroundColor, draggable, shadowColor, shadowBlur, buttonBar, circles, indicator, backgroundColor, keyArrows, container, selectedIndex, selectedColor, dropperTarget, spectrumCollapse, spectrumMode, spectrumClose, spectrumOk, spectrumTitle, tolerancePicker, collapsed, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			WW.removeEventListener("keydown", that.keyDownEvent);
			if (spectrum) {
				removeSpectrumEvents();
				that.gradient.cur("default");
				that.pixels.cur("default");
				if (dropperTarget) dropperTarget.cur("default");
				mock.cur("default");
				dropping = false;
				clearMock();
			}
			if (slider) slider.dispose();
			if (dropper) dropper.dispose();
			if (that.dropperDown) frame.stage.off("stagemousedown", that.dropperDown);			
			if (that.dropperMove) frame.stage.off("stagemousemove", that.dropperMove);
			if (that.dropperUp) frame.stage.off("stagemouseup", that.dropperUp);
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};
	};
	zim.extend(zim.ColorPicker, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-67

//
/*--
zim.EmojiPicker = function(width, height, emojis, monochrome, backgroundColor, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, cache, size, collapse, collapseColor, collapsed, colSize, rowSize, style, group, inherit)

EmojiPicker
zim class - extends a zim.Window which extends a zim.Container which extends a createjs.Container

DESCRIPTION
An Emoji picker panel.
Can customize the list of emojis.
Gives a zim Emoji object as currentEmoji property on a "change" event

SEE: https://zimjs.com/nft/bubbling/emoji.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const emojiPicker = new EmojiPicker()
	.center()
	.change(() => {
		// we will make a bigger emoji by passing the code of the currentEmoji 
		// to the new Emoji - you can clone and then scale but that can look blotchy  
		const emoji = new Emoji(emojiPicker.currentEmoji.code, 200)
			.centerReg()
			.drag();
		S.update();
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 400) the width of the window
height - (default 500) the height of the window
emojis - (default a big list!) an array of UTF codes for emojis 
	["\ud83d\udca5","\ud83c\udf35", etc.]
	can view the code page https://zimjs.com/code.php?view=67.05 to get raw list to modify
monochrome - (default false) set to true to greyscale the emojis 
	this had better performance when Chrome made black and white emojis in a bold bug 
	too bad - hope they bring them back.
backgroundColor - (default lighter) background color (use clear - or "rbga(0,0,0,0)" for no background) 
titleBar - (default "Emojis") a String or ZIM Label title for the panel that will be presented on a titleBar across the top
	note: set STYLE = {titleBar:false, close:false} to turn off title bar and remove close button
titleBarColor - (default black) the text color of the titleBar if a titleBar is requested
titleBarBackgroundColor - (default "rgba(0,0,0,.2)") the background color of the titleBar if a titleBar is requested
titleBarHeight - the height of the titleBar if a titleBar is requested	
cache - (default false or true if mobile) - cache the collection of emojis for better performance - will not look as crisp on desktop
size - (default 30) - the size of the emojis in the picker
collapse - (default false) - set to true to add a collapse icon to the titleBar that reduces the window so only the bar shows and adds an icon to expand
   also can double click bar to collapse window
collapseColor - (default grey) - the color of the collapse icon
collapsed - (default false) set to true to start the window collapsed
colSize - (default size+15) - the size of the columns
rowSize - (default size+14) - the size of the rows
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: see all the methods of the ZIM Panel

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedEmoji - get the selected emoji - this is a zim Emoji object
	clone the object to let the user use it
	or make a new Emoji() from the selectedEmoji.code and pass in a different size, etc.
emojiData - get the list of emojis - warning, if zog to console they will look like emojis
wrapper - the ZIM Wrapper used for the picker 

ALSO: see all the properties of the ZIM Panel including close, titleBar, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches an "emoji" event when an emoji is picked
dispatches a "closed" event when closed

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.05
	zim.EmojiPicker = function(width, height, emojis, monochrome, backgroundColor, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, cache, size, collapse, collapseColor, collapsed, colSize, rowSize, style, group, inherit) {
		var sig = "width, height, emojis, monochrome, backgroundColor, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, cache, size, collapse, collapseColor, collapsed, colSize, rowSize, style, group, inherit";
		var duo; if (duo = zob(zim.EmojiPicker, arguments, sig, this)) return duo;
		z_d("67.05");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("EmojiPicker", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:400;
		if (zot(height)) height = DS.height!=null?DS.height:600;		
		if (zot(monochrome)) monochrome = DS.monochrome!=null?DS.monochrome:false;		
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.lighter;
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:"Emojis";			
		if (zot(titleBarColor)) titleBarColor = DS.titleBarColor!=null?DS.titleBarColor:null;
		if (zot(titleBarBackgroundColor)) titleBarBackgroundColor = DS.titleBarBackgroundColor!=null?DS.titleBarBackgroundColor:zim.silver.toAlpha(.8);
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:40;
		if (zot(cache)) cache = DS.cache!=null?DS.cache:zim.mobile()?true:false;
		if (zot(size)) size = DS.size!=null?DS.size:30;
		if (zot(colSize)) colSize = DS.colSize!=null?DS.colSize:size+15;
		if (zot(rowSize)) rowSize = DS.rowSize!=null?DS.rowSize:size+14;
		if (zot(collapse)) collapse=DS.collapse!=null?DS.collapse:false;
		if (zot(collapseColor)) collapseColor = DS.collapseColor!=null?DS.collapseColor:!zot(titleBarColor)?titleBarColor:zim.grey;
		if (zot(collapsed)) collapsed=DS.collapsed!=null?DS.collapsed:false;
					
		// width, height, content, backgroundColor, borderColor, borderWidth, padding, corner, swipe, scrollBarActive, scrollBarDrag, scrollBarColor, scrollBarAlpha, scrollBarFade, scrollBarH, scrollBarV, slide, slideFactor, slideSnap, slideSnapDamp, interactive, shadowColor, shadowBlur, paddingH, paddingV, scrollWheel, damp, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, draggable, boundary, onTop, close, closeColor, cancelCurrentDrag, fullSize, fullSizeColor, resizeHandle, collapse, collapseColor, collapsed, optimize, resizeBoundary, resizeVisible, continuous, continuous, style, group, inherit
		this.zimWindow_constructor(width, height, null, backgroundColor, null, DS.borderWidth!=null?DS.borderWidth:2, DS.padding!=null?DS.padding:10, DS.corner!=null?DS.corner:10, null, DS.scrollBarActive!=null?DS.scrollBarActive:true, DS.scrollBarDrag!=null?DS.scrollBarDrag:true, null, null, null, false, null, null, null, null, null, true, null, null, null, null, null, null, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, DS.draggable!=null?DS.draggable:true, null, null, DS.close!=null?DS.close:true, null, null, DS.fullSize!=null?DS.fullSize:false, null, DS.resizeHandle!=null?DS.resizeHandle:false, collapse, collapseColor, collapsed, null, null, style, group, zim.copy(DS));
		this.type = "EmojiPicker";
		var that = this;
		
		this.emojiData = !zot(emojis)?emojis:["\ud83d\udca5","\ud83c\udf35","\ud83c\udf82","\ud83c\udf70","\ud83d\udc29","\ud83d\udd25","\ud83c\udf2b","\ud83c\udf0a","\ud83c\udf4f","\ud83c\udf4e","\ud83c\udf4b","\ud83c\udf4c","\ud83c\udf47","\ud83c\udf51","\ud83c\udf45","\ud83c\udf46","\ud83e\uddc0","\ud83c\udf55","\ud83c\udf6c","\ud83c\udf6d","\ud83c\udf69","\ud83c\udf7a","\ud83c\udf7b","\ud83c\udf78","\ud83c\udf7e","\u2615\ufe0f","\ud83d\udca9","\ud83d\udc7b","\ud83e\udd16","\ud83d\udca4","\ud83d\udc40","\ud83d\udc83","\ud83d\udc83\ud83c\udffb","\ud83d\udc83\ud83c\udffc","\ud83d\udc83\ud83c\udffd","\ud83d\udc83\ud83c\udffe","\ud83d\udc83\ud83c\udfff","\ud83d\udc54","\ud83d\udc57","\ud83d\udc59","\ud83d\udc58","\ud83d\udc60","\ud83d\udc52","\ud83c\udfa9","\ud83d\udc31","\ud83d\udc3b","\ud83d\udc36","\ud83d\udc3c","\ud83d\udc2f","\ud83e\udd81","\ud83d\udc2e","\ud83d\udc37","\ud83d\udc19","\ud83d\udc35","\ud83d\udc12","\ud83d\udc14","\ud83d\udc26","\ud83d\udc34","\ud83e\udd84","\ud83d\udc1d","\ud83d\udc22","\ud83d\udc20","\ud83d\udc10","\ud83d\udd4a","\ud83d\udc15","\ud83d\udc08","\ud83d\udc09","\ud83d\udc32","\ud83c\udf84","\ud83c\udf40","\ud83c\udf3b","\ud83c\udf39","\ud83d\udc90","\ud83c\udf44","\u2600\ufe0f","\ud83c\udf27","\u26bd\ufe0f","\ud83c\udfc0","\ud83c\udfc8","\u26be\ufe0f","\ud83c\udfbe","\ud83c\udfd2","\u26f7","\ud83c\udfc4","\ud83c\udfca","\ud83d\udeb4","\ud83c\udfad","\ud83c\udfa8","\ud83c\udfb7","\ud83c\udfba","\ud83c\udfb8","\ud83c\udfbb","\ud83c\udfb0","\ud83c\udfb3","\ud83d\ude97","\ud83d\ude95","\ud83d\ude8c","\ud83d\ude8e","\ud83d\ude91","\ud83d\ude92","\ud83d\ude9c","\ud83d\ude82","\u2708\ufe0f","\u26f5\ufe0f","\ud83d\udef0","\ud83c\udf01","\ud83c\udf0b","\ud83c\udfde","\ud83c\udf05","\ud83c\udf86","\ud83c\udf08","\ud83c\udfe0","\ud83c\udfe5","\ud83c\udfeb","\u231a\ufe0f","\ud83d\udcf1","\ud83d\udda5","\ud83d\udcbe","\ud83d\udcfc","\ud83c\udfa5","\u260e\ufe0f","\ud83d\udcfa","\ud83d\udcfb","\ud83d\udce1","\ud83d\udd6f","\ud83d\udcb0","\ud83d\udc8e","\ud83d\udeac","\u26b0","\ud83d\udd2e","\ud83d\udc88","\ud83d\udebd","\ud83d\udd11","\ud83d\udecf","\ud83c\udf89","\ud83c\udf8a","\u2764\ufe0f","\ud83e\udd21","\ud83d\ude00","\ud83d\ude2c","\ud83d\ude01","\ud83d\ude02","\ud83d\ude03","\ud83d\ude04","\ud83d\ude05","\ud83d\ude06","\ud83d\ude07","\ud83d\ude09","\ud83d\ude0a","\ud83d\ude42","\ud83d\ude43","\u263a\ufe0f","\ud83d\ude0b","\ud83d\ude0c","\ud83d\ude0d","\ud83d\ude18","\ud83d\ude17","\ud83d\ude19","\ud83d\ude1a","\ud83d\ude1c","\ud83d\ude1d","\ud83d\ude1b","\ud83e\udd11","\ud83e\udd13","\ud83d\ude0e","\ud83e\udd17","\ud83d\ude0f","\ud83d\ude36","\ud83d\ude10","\ud83d\ude11","\ud83d\ude12","\ud83d\ude44","\ud83e\udd14","\ud83d\ude33","\ud83d\ude1f","\ud83d\ude20","\ud83d\ude14","\ud83d\ude15","\ud83d\ude41","\u2639\ufe0f","\ud83d\ude23","\ud83d\ude2b","\ud83d\ude29","\ud83d\ude31","\ud83d\ude28","\ud83d\ude30","\ud83d\ude2f","\ud83d\ude26","\ud83d\ude22","\ud83d\ude2a","\ud83d\ude13","\ud83d\ude2d","\ud83d\ude35","\ud83d\ude32","\ud83e\udd10","\ud83d\ude37","\ud83e\udd12","\ud83e\udd15","\ud83d\ude34","\ud83d\udc80","\u2620\ufe0f","\ud83d\udc7d","\ud83d\ude3a","\ud83d\ude38","\ud83d\ude39","\ud83d\ude3b","\ud83d\ude3c","\ud83d\ude3d","\ud83d\ude40","\ud83d\ude3f","\ud83d\ude3e","\ud83d\udc44","\ud83d\udc8b","\ud83d\udc45","\ud83d\udde3","\ud83d\udc64","\ud83d\udc65","\ud83d\udc56","\ud83d\udc63","\ud83d\udc61","\ud83d\udc62","\ud83d\udc5e","\ud83d\udc5f","\ud83c\udf93","\ud83d\udc51","\ud83d\udc5c","\ud83d\udc5b","\ud83d\udcbc","\ud83d\udc53","\ud83d\udd76","\ud83d\udc8d","\ud83c\udf02","\u2744\ufe0f","\ud83c\udf2a","\u26a1\ufe0f","\ud83e\udd51","\ud83e\udd8b","\ud83d\ude48","\ud83d\ude49","\ud83d\ude4a","\ud83d\udc27","\ud83d\udd77","\ud83e\udd82","\ud83e\udd80","\ud83d\udc0d","\ud83d\udc1b","\ud83d\udc0c","\ud83d\udc1e","\ud83d\udc1c","\ud83d\udc1f","\ud83d\udc21","\ud83d\udc2c","\ud83d\udc33","\ud83d\udc0b","\ud83d\udc0a","\ud83d\udc06","\ud83c\udf32","\ud83c\udf33","\ud83c\udf34","\ud83c\udf31","\ud83c\udf3f","\ud83c\udf43","\ud83c\udf42","\ud83c\udf41","\ud83c\udf3a","\ud83c\udf3c","\ud83c\udf38","\ud83c\udf30","\ud83c\udf83","\ud83d\udc1a","\ud83d\udd78","\ud83c\udf0e","\ud83c\udf0d","\ud83c\udf0f","\ud83c\udf15","\ud83c\udf16","\ud83c\udf17","\ud83c\udf18","\ud83c\udf11","\ud83c\udf12","\ud83c\udf13","\ud83c\udf14","\ud83c\udf1a","\ud83c\udf1d","\ud83c\udf1b","\ud83c\udf1c","\ud83c\udf1e","\ud83c\udf19","\u2b50\ufe0f","\ud83c\udf1f","\ud83d\udcab","\u2728","\u2604\ufe0f","\ud83c\udf54","\ud83c\udf73","\ud83c\udf5f","\ud83c\udf2d","\ud83c\udf5d","\ud83c\udf2e","\ud83c\udf2f","\ud83c\udf63","\ud83c\udf68","\ud83c\udf66","\ud83c\udf77","\ud83c\udf79","\ud83c\udfc6","\ud83c\udfaa","\ud83c\udfb9","\ud83d\ude80","\u26f2\ufe0f","\ud83c\udfa2","\u26f0","\ud83c\udfd4","\ud83d\uddfb","\ud83d\udcaf","\ud83c\udfb5","\ud83c\udfb6","\ud83d\udcac","\ud83d\udcad","\ud83d\uddef","\ud83c\udccf","\ud83c\udff3\ufe0f\u200d\ud83c\udf08","\ud83e\udd53","\ud83e\udd43","\ud83c\udfa4","\ud83d\udea8","\ud83c\udfcd","\ud83c\udfd5","\u26fa\ufe0f","\ud83c\udfdc","\ud83c\udfd6","\ud83c\udfdd","\ud83c\udf07","\ud83c\udf06","\ud83c\udfd9","\ud83c\udf03","\ud83c\udfd8","\ud83c\udfe1","\ud83c\udfe2","\ud83d\udd28","\u2699","\ud83d\udd2b","\ud83d\udca3","\ud83d\udd2a","\ud83d\udc8a","\ud83d\udd73","\ud83d\udc89","\ud83d\udec1","\u26f1","\ud83c\udf81","\ud83c\udf88","\ud83c\udf80","\ud83d\udcc5","\ud83d\uddf3","\ud83d\udcda","\u270f\ufe0f","\u26aa\ufe0f","\u26ab\ufe0f","\u2b1b\ufe0f","\u2b1c\ufe0f","\ud83d\uddbc","\ud83c\udfda","\ud83c\udfed","\ud83d\udd32","\ud83d\udd33","\ud83c\udfb1","\ud83d\udd3a","\ud83d\udd3b","\ud83d\udca6","\u26f3\ufe0f","\ud83c\udfdf","\ud83d\udca1","\ud83d\udd2d","\ud83d\udd2c","\ud83d\udd70","\ud83d\udc2a","\ud83d\udc2b","\ud83d\udc18","\ud83d\udc38","\ud83d\udc30","\ud83d\udc2d","\ud83d\udeaa","\ud83d\udecd","\ud83d\udc41","\ud83c\udf53","\ud83c\udf52","\ud83c\udf36","\ud83c\udf3d","\ud83c\udf60","\ud83c\udf6f","\ud83c\udf5e","\ud83c\udf6b","\ud83c\udf7f","\ud83c\udf6a","\ud83c\udf4a","\ud83c\udff9","\ud83d\udc6f","\ud83d\udc6f\u200d\u2642\ufe0f","\ud83d\uddd1","\u20ac"];
				
		var icons = [];
		zim.loop(this.emojiData, function(key) {        
			var icon = new zim.Emoji(key, size, monochrome);
			icons.push(icon);
		});

		this.wrapper = new zim.Wrapper({
			items:icons, 
			width:width, 
			alignInner:zim.CENTER,
			valignInner:zim.CENTER,
			wrapperType:"column",
			colSize:colSize,
			rowSize:rowSize
		}).cur();
		this.backdrop = new zim.Rectangle(this.wrapper.width, this.wrapper.height, zim.faint);
		zim.timeout(.2, function () {
			if (that.scrollBar && that.scrollBar.vertical && that.scrollBar.vertical.getBounds()) that.scrollBar.vertical.expand();
			that.backdrop.heightOnly = that.wrapper.height;
			if (cache) that.wrapper.cache();
		});
		this.add(this.backdrop);
		this.add(this.wrapper);
		this.wrapper.tap(function(e) {
			that.currentEmoji = e.target;
			that.dispatchEvent("change");
		});
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.EmojiPicker(width, height, style, this.group, inherit));
		};
		this.dispose = function() {
			return true;
		};
	};
	zim.extend(zim.EmojiPicker, zim.Window, ["clone", "dispose"], "zimWindow", false);	
	//-67.05

/*--
zim.TextEditor = function(width, color, backgroundColor, fieldColor, fieldHeight, textSize, sizeList, optionList, colorList, fontList, live, button, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, wrap, limit, scroll, placeholder, password, borderColor, borderWidth, margin, corner, shadowColor, shadowBlur, draggable, boundary, frame, fontListHeight, fontListViewNum, style, group, inherit)

TextEditor
zim class - extends a zim.Panel which extends a zim.Container which extends a createjs.Container

DESCRIPTION
A configurable text editor for a ZIM Label - or text in code memory.
Call the editor.show(label) method and pass in the label - it will let the user change the following properties:
	text, color, bold, italic, align, size, and font
Which ones the editor uses can be set with parameters.

SEE: https://zimjs.com/cat/texteditor.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const label = new Label({
	text:"press to edit with TextEditor",
	italic:true,
	align:CENTER,
	font:"verdana"
})
	.center()
	.expand()
	.tap(()=>{
		textEditor.show(label);
	});

const textEditor = new TextEditor({
	colorList:true, // or array of colors
	optionList:["bold","italic","align"], // or true, or array with any of these
	sizeList:true, // or array of sizes
	fontList:true, // or array of fonts
	live:true, // default
	scroll:true // default, etc.
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
   The TextEditor is made of of the following sub components
   and many styles need to be set on the sub component types:
   Panel, TextArea, Button, ColorPicker, Selector, Stepper, List
   For instance STYLE = {type:{Panel:{titleBarBackgroundColor:red}}}
width - (default 400) the width of the editor
color - (dark) the color of the TextArea text in the editor
backgroundColor - (default lighter) the background color of the editor
fieldColor - (default backgroundColor darkened .05) - the background color of the TextArea
fieldHeight - (default button height plus 2 margins) - the height of the TextArea
textSize - (default 20) the size of the text in the TextArea
sizeList - (default false) set to true to show numbers from 5-500
 	or set to an array of numbers used for the size Stepper [10,12,14,16] for instance
optionList - (default false) set to true to show ["bold", "italic", "align"]
 	or set to an array with any of these values ["bold", "italic"] for instance
colorList - (default false) set to true to show the default ZIM ColorPicker
 	or set to an array with colors [red, green, blue, black, "violet", "#333"] for instance
fontList - (default false) set to true to show a default list of fonts
	"Arial",
	"Courier New",
	"Georgia",
	"Helvetica",
	"Palatino",
	"Tahoma",
	"Verdana",
	// plus on desktop:
	"Impact",
	"Comic Sans"
 	or set to an array with desired fonts ["courier", "verdana"] for instance
live - (default true) will update the label as the text is typed
	set to false to update only on button press - note, other setting update live regardless
button - (default green check) set to a custom ZIM Button if desired
titleBar - (default "Text Editor") a String or ZIM Label title for the panel that will be presented on a titleBar across the top
titleBarColor - (default black) the text color of the titleBar if a titleBar is requested
titleBarBackgroundColor - (default "rgba(0,0,0,.2)") the background color of the titleBar if a titleBar is requested
titleBarHeight - (default fit label) the height of the titleBar if a titleBar is requested
wrap - (default true) set to false to not wrap text in TextArea (wrapping on the actual label can be done with label.lineWidth)
limit - (default null) set to a number to limit the TextArea number of characters
scroll - (default true) set to false to not show a vertical scrollbar when needed - note if textHeight is not high enough, a scrollbar may not show
placeholder - (default null) set to true to show default text - will be overwritten with label text if there is text
password - (default false) set to true to make the TextArea a password field - shows dots - the label will not show dots
borderColor - (default pewter) border color
borderWidth - (default 1) the thickness of the border
margin - (default 10) the margin around the various sub components
corner - (default 0) the round of corner
   can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (default "rgba(0,0,0,.3)" if shadowBlur) the shadow color - set to -1 for no shadow
shadowBlur - (default 14 if shadowColor) the shadow blur - set to -1 for no shadow
draggable - (default true if titleBar) set to false to not allow dragging titleBar to drag window
boundary - (default null) set to ZIM Boundary() object - or CreateJS.rectangle()
frame - (default zdf - ZIM Default Frame) pass in a frame if not the default frame - lets TextArea and ColorPicker work
fontListHeight - (default 100) the height of the font list if there is one 
fontListViewNum - (default 3) the number of fonts to show in the font list if there is one
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show(label, x, y, frame) - show the editor and pass in the label to operate on
	the editor will appear centered above or below the text depending on where there is more room
	this can be overridden with the x and y parameters
	the TextEditor will show on the stage of the Label
	if the label is not on the stage then the stage of the frame parameter otherwise the stage of the ZIMDefaultFrame
	If the editor is already open it will not move
	Calling show(label2) on a different label will switch the editor to that label
	see also the label property
hide() - hides the editor
closeColorPicker() - close the ColorPicker - this needs to display the text (which is hidden when the ColorPicker opens)
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: see all the methods of the ZIM Panel

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
textArea - reference to the TextArea
label - get or set the label associated with the textEditor
button - reference to the Button
	if various features are set:
swatch - reference to the Rectangle showing color
colorPicker - reference to the ColorPicker
bold - reference to the bold Button
italic - reference to the italic Button
align - reference to the align Selector
size - reference to the size Stepper
font - reference to the font List

ALSO: see all the properties of the ZIM Panel including close, titleBar, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches an "input" event when the text is changed - although default is to update live
dispatches an "update" event when any property is changed and where text is changed
dispatches a "set" event when button is pressed
dispatches a "close" event when closed
dispatches a "color" event when ColorPicker is opened

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.1
	zim.TextEditor = function(width, color, backgroundColor, fieldColor, fieldHeight, textSize, sizeList, optionList, colorList, fontList, live, button, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, wrap, limit, scroll, placeholder, password, borderColor, borderWidth, margin, corner, shadowColor, shadowBlur, draggable, boundary, frame, fontListHeight, fontListViewNum, style, group, inherit) {
		var sig = "width, color, backgroundColor, fieldColor, fieldHeight, textSize, sizeList, optionList, colorList, fontList, live, button, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, wrap, limit, scroll, placeholder, password, borderColor, borderWidth, margin, corner, shadowColor, shadowBlur, draggable, boundary, frame, fontListHeight, fontListViewNum, style, group, inherit";
		var duo; if (duo = zob(zim.TextEditor, arguments, sig, this)) return duo;
		z_d("67.1");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("TextEditor", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:400;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.lighter;
		
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:"Text Editor";
		if (zot(draggable)) draggable = DS.draggable!=null?DS.draggable:true;
		if (zot(titleBarHeight)) titleBarHeight = DS.titleBarHeight!=null?DS.titleBarHeight:30;
		if (zot(fieldColor)) fieldColor = DS.fieldColor!=null?DS.fieldColor:backgroundColor.darken(.05);
		if (zot(live)) live = DS.live!=null?DS.live:true;		
		if (zot(wrap)) wrap = DS.wrap!=null?DS.wrap:true;
		if (zot(scroll)) scroll = DS.scroll!=null?DS.scroll:true;
		if (zot(margin)) margin = DS.margin!=null?DS.margin:10;
				
		if (zot(limit)) limit = DS.limit!=null?DS.limit:null;
		if (zot(titleBar)) titleBar = DS.titleBar!=null?DS.titleBar:null;
		if (zot(sizeList)) sizeList = DS.sizeList!=null?DS.sizeList:null;
		if (zot(colorList)) colorList = DS.colorList!=null?DS.colorList:null;
		if (zot(optionList)) optionList = DS.optionList!=null?DS.optionList:null;
		if (zot(fontList)) fontList = DS.fontList!=null?DS.fontList:null;		
		if (zot(fieldColor)) fieldColor = DS.fieldColor!=null?DS.fieldColor:null;
		if (zot(fieldHeight)) fieldHeight = DS.fieldHeight!=null?DS.fieldHeight:null;
		if (zot(textSize)) textSize = DS.textSize!=null?DS.textSize:null;
		if (zot(fontListHeight)) fontListHeight = DS.fontListHeight!=null?DS.fontListHeight:100;
		if (zot(fontListViewNum)) fontListViewNum = DS.fontListViewNum!=null?DS.fontListViewNum:3;
		
		if (typeof frame == "undefined") {
			if (WW.zdf) {
				var frame = WW.zdf;
			} else {
				if (zon) {zogy("zim.TextEditor - please provide a reference to zim Frame");} return;
			}
		}

		this.zimPanel_constructor(width, 300, null, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, backgroundColor, borderColor, borderWidth, corner, true, null, null, null, null, null, null, null, null, shadowColor, shadowBlur, draggable, boundary, style, group, inherit);

		var that = this;

		if (zot(button)) button = new zim.Button({
			width:50,height:50,
			// label:new zim.Label({text:"✓", bold:true, color: zim.white}),
			label:"",
			icon:new zim.Shape().sca(.4).f("white").p("AikFsQg5jmhphxIA1gXQBeBGA3CwQC8mRCpjOIBfAoQkPFGiSFpg"),
			color:zim.white,
			corner:10,
			backgroundColor:zim.green.darken(.2),
			borderColor:zim.white,
			borderWidth:2,
			rollBackgroundColor:zim.green,
			shadowBlur:3
		})
			.pos(margin, titleBarHeight+margin*2, zim.RIGHT, zim.TOP, that);
		that.button = button;
		button.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", submit);

		if (zot(fieldHeight)) fieldHeight = DS.fieldHeight!=null?DS.fieldHeight:button.height+margin*2;

		function submit() {
			if (!live) label.text = textArea.text;
			that.hide();
			that.dispatchEvent("set");
		}
		var textArea = that.textArea = new zim.TextArea({
			color:color,
			backgroundColor:fieldColor,
			width:width-button.width-margin*3,
			height:zot(fieldHeight)?button.height+margin*2:fieldHeight,
			expand:10,
			password:password,
			placeholder:placeholder,
			frame:frame
		}).loc(margin,titleBarHeight+margin+(fieldHeight&&fieldHeight<(button.height+margin*2)?(button.height-fieldHeight)/2+margin:0),null,null,false);

		if (!wrap) textArea.tag.style.whiteSpace = "nowrap";
		if (limit) textArea.tag.setAttribute("maxLength", limit);
		if (scroll) textArea.tag.style.overflowY = "auto";

		var label = new zim.Label(); // surrugate label

		that.on("pressmove", function () {
			textArea.resize();
		});
		that.on("close", function () {
			if (that.inputEvent) textArea.off("input", that.inputEvent);
			textArea.removeFrom();
		});		

		that.panelHeight = titleBarHeight+margin+Math.max(fieldHeight, button.height+margin*2) + margin;
		var mob = zim.mobile();
		var baseSize = mob?35:30;

		if (sizeList || optionList || colorList) {
			new zim.Rectangle(width,baseSize+margin,"rgba(0,0,0,.05)").loc(0, that.panelHeight, that);
			var extras = [];			
			if (colorList) {
				var arr = Array.isArray(colorList);
				var colorPicker = that.colorPicker = new zim.ColorPicker({
					colors:arr?colorList:null,
					cols:arr?Math.min(colorList.length,12):null,
					alphaPicker:false,
					greyPicker:!arr,
					container:frame.stage
				});
				colorPicker.on("close",closePicker);				
				colorPicker.on("change", function () {
					label.color = color.color = colorPicker.selectedColor;
					that.dispatchEvent("update");
					closePicker();
				});
				that.closeColorPicker = function() {closePicker();}
				color = that.swatch = new zim.Rectangle(baseSize,baseSize,label.color,zim.dark,1).cur();
				color.on("mousedown",function () {
					that.dispatchEvent("color");
					textArea.tag.style.display = "none"; 
					colorPicker.selectedColor = color.color; 
					colorPicker.show();
					if (that.stage) that.stage.update();
				});				
				extras.push(color);
			}
			if (optionList) {
				if (optionList === true) optionList = ["bold", "italic", "align"];
				if (zot(WW.STYLE)) WW.STYLE = {};
				if (zot(WW.STYLE.group)) WW.STYLE.group = {};
				WW.STYLE.group.zimEditor = {
					width:baseSize,
					height:baseSize,
					corner:0,
					borderColor:zim.tin,
					shadowBlur:-1,
					backgroundColor:zim.light,
					rollBackgroundColor:zim.light,
					toggleBackgroundColor:zim.green,
					toggleColor:zim.grey
				};
				var bold, italic, selector;
				zim.loop(optionList, function (option) {
					if (option.toLowerCase()=="bold") {
						bold = that.bold = new zim.Button({
							label:new zim.Label({text:"B", color:zim.grey, size:16, bold:true}),
							toggle:"B",
							group:"zimEditor"
						});
						bold.on("click", function () {
							label.bold = bold.toggled;
							that.dispatchEvent("update");
							if (that.stage) that.stage.update();
						});
						extras.push(bold);
						if (label.bold) bold.toggle();
					} else if (option.toLowerCase()=="italic") {
						italic = that.italic = new zim.Button({
							label:new zim.Label({text:"I", color:zim.grey, size:16, bold:true, italic:true}),
							toggle:"I",
							group:"zimEditor"
						});
						italic.on("click", function () {
							label.italic = italic.toggled;
							that.dispatchEvent("update");
							if (that.stage) that.stage.update();
						});
						extras.push(italic);
						if (label.italic) italic.toggle();
					} else if (option.toLowerCase()=="align") {
						var alignOptions = new zim.Tile(new zim.Rectangle(baseSize-10,baseSize-10, zim.grey).centerReg(), 3, 1, 10, 10);
						var icons = mob?["⇚","⇔","⇛"]:["⇐","⇔","⇒"];
						zim.loop(3, function (i) {
							var r = alignOptions.getChildAt(i);
							new zim.Label(icons[i], baseSize*2/3, null, zim.white).center(r).expand(10);
							// rectangles not expanding?  last label not expanding?
						});
						var i = 0;
						if (label.align == "right") i = 2;
						else if (label.align == "center" || label.align == "middle") i = 1;
						selector = that.align = new zim.Selector({
							tile:alignOptions,
							corner:0,
							borderWidth:1,
							borderColor:zim.grey,
							backgroundColor:zim.clear,
							selectedIndex:i
						});
						selector.on("change", function () {
							if (selector.selectedIndex == 0) label.align = "left";
							else if (selector.selectedIndex == 1) label.align = "center";
							if (selector.selectedIndex == 2) label.align = "right";
							that.dispatchEvent("update");
							if (that.stage) that.stage.update();
						});
						extras.push(selector);
					}
				});
				delete WW.STYLE.group.zimEditor;
			}
			if (sizeList) {
				var size = that.sizePicker = new zim.Stepper({
					list:sizeList===true?null:sizeList,
					stepperType:sizeList===true?null:"list",
					min:sizeList===true?5:null,
					max:sizeList===true?500:null,
					width:150,
					shadowBlur:-1,
					borderColor:zim.dark,
					borderWidth:2,
					corner:0,
					backgroundColor:zim.green,
					downForward:false
				}).siz(null,baseSize);
				size.arrowPrev.expand(0);
				size.textBox.color = zim.lighter;
				size.on("change", function () {
					label.size = size.currentValue;
					that.dispatchEvent("update");
					if (that.stage) that.stage.update();
				});
				size.currentValue = label.size;
				extras.push(size);
			}

			var tile = new zim.Tile(extras, extras.length, 1, 10, 10, true)
				.loc(margin, that.panelHeight+margin/2, that);

			that.panelHeight = that.panelHeight + margin + tile.height + margin;
		}
		function closePicker() {
			textArea.tag.style.display = "block";
			colorPicker.hide();
			if (that.stage) that.stage.update();
		}

		var fonts;
		if (fontList) {
			if (!Array.isArray(fontList)) {
				fonts = [
					"Arial",
					"Courier New",
					"Georgia",
					"Helvetica",
					"Palatino",
					"Tahoma",
					"Verdana"
				];
				if (!mob) {
					fonts = fonts.concat([
						"Comic Sans MS",
						"Impact"
					]);
				}
				fonts.sort();
			} else {
				fonts = fontList;
			}
			var font = that.fonts = new zim.List({
				width:width-margin*2,
				height:fontListHeight,
				viewNum:fontListViewNum,
				backgroundColor:zim.moon,
				color:zim.grey,
				rollColor:zim.dark,
				rollBackgroundColor:zim.green.lighten(.5),
				selectedBackgroundColor:zim.mist,
				selectedRollBackgroundColor:zim.green.lighten(.6),
				selectedColor:zim.dark,
				backdropColor:zim.light,
				scrollBarColor:zim.dark,
				shadowBlur:-1,
				list:fonts
			}).center(that).loc(null, that.panelHeight);
			font.on("change",function () {
				label.font = font.currentValue;
				that.dispatchEvent("update");
				if (that.stage) that.stage.update();
			});
			that.panelHeight = that.panelHeight + margin + font.height + margin;
		}


		that.show = function(l, x, y, frame) {
			if (that.parent) {
				if (l==that.label) return that;
				that.label = l;
				return that;
			}
			label = l;
			textArea.addTo(that);
			var stage;
			if (label && label.stage) stage = label.stage;
			else if (frame) stage = frame.stage;
			else if (WW.zdf) stage = WW.zdf.stage;
			else return that;

			if (!zot(x) || !zot(y)) that.loc(x,y);
			else if (label && label.y>stage.height/2) that.loc(stage.width/2-width/2, label.y-that.panelHeight-stage.height*.05, stage);
			else if (label && label.y<=stage.height/2) that.loc(stage.width/2-width/2, label.y+label.height+stage.height*.05, stage);
			else that.center(stage);
			if (that.y < 20) that.y = 20;
			if (that.y+that.height > that.stage.height) that.y = that.stage.height-that.height-20;

			setLabel();
			that.stage.update();
			return that;
		};

		function setLabel() {
			// set all the defaults for the label
			if (label) textArea.text = label.text;
			if (color) color.color = label.color;
			if (bold) bold.toggle(label.bold==true);
			if (italic) italic.toggle(label.italic==true);
			if (selector) {
				selector.noAnimate = true;
				if (label.align == "center") selector.selectedIndex = 1;
				else if (label.align == "right") selector.selectedIndex = 2;
				else selector.selectedIndex = 0;
			}
			if (size) size.currentValue = label.size;
			if (font) font.currentValue = label.font;

			if (that.inputEvent) textArea.off("input", that.inputEvent);
			that.inputEvent = textArea.on("input", function () {
				if (live && label) label.text = textArea.text;
                if (textArea.text == "" && textArea.tag.placeholder) label.text = textArea.tag.placeholder;
				that.dispatchEvent("input");
				that.dispatchEvent("update");
				if (that.stage) that.stage.update();
			});
		}

		that.hide = function () {
			if (colorList) colorPicker.hide();
			if (textArea) textArea.removeFrom();
			if (zot(that.stage)) return;
			var stage = that.stage;
			that.removeFrom();
			stage.update();
			return that;
		};

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (!zim.KEYFOCUS) setFocus();
		this.on("mousedown", function() {setFocus();});
		function setFocus() {that.keyFocus = true;}


		Object.defineProperty(that, 'label', {
			get: function() {
				return label;
			},
			set: function(value) {
				label = value;
				setLabel();
			}
		});

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.TextEditor(width, color, backgroundColor, fieldColor, fieldHeight, textSize, sizeList, optionList, colorList, fontList, live, button, titleBar, titleBarColor, titleBarBackgroundColor, titleBarHeight, wrap, limit, scroll, placeholder, password, borderColor, borderWidth, margin, corner, shadowColor, shadowBlur, draggable, boundary, frame, fontListHeight, fontListViewNum, style, this.group, inherit));
		};

		this.dispose = function(a,b,disposing) {
			if (that.inputEvent) textArea.off("input", that.inputEvent);
			if (colorPicker) colorPicker.dispose();
			if (color) color.dispose();
			if (font) font.dispose();
			if (button) button.dispose();
			if (textArea) textArea.dispose();
			if (selector) selector.dispose();
			if (bold) bold.dispose();
			if (italic) italic.dispose();
			if (size) size.dispose();
			if (!disposing) this.zimPanel_dispose();
			if (that.stage) that.stage.update();
			that.textArea = that.color = that.colorPicker = that.font = that.button = that.selector = that.bold = that.italic = that.size = null;
			return true;
		};
	};
	zim.extend(zim.TextEditor, zim.Panel, ["clone", "dispose"], "zimPanel", false);	
	//-67.1
	
/*--
zim.Keyboard = function(labels, backgroundColor, color, shiftBackgroundColor, shiftHoldBackgroundColor, placeBackgroundColor, placeColor, cursorColor, shadeAlpha, borderColor, borderWidth, margin, corner, draggable, placeClose, shadowColor, shadowBlur, container, data, place, placeShiftH, placeShiftV, special, rtl, hardKeyboard, layout, numPadScale, numPadDraggable, numPadOnly, numPadAdvanced, maxLength, numbersOnly, placeScale, style, group, inherit)

Keyboard
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
The Keyboard class makes a keyboard ideal for mobile or touch screens.
Often, it seems the mobile keyboard can cause problems with layout.
This in-canvas keyboard requires much less testing and concern.
The Keyboard can work with ZIM Labels to give input text without a TextArea.
Thanks Frank Los for the initial design and coding of the Keyboard.
Keyboard also captures hard keyboard keydown and will type that as well
See https://zimjs.com/keyboard

NOTE: press and hold down the vowels for multiple vowel options
NOTE: multi-line Label and TextArea input is not supported
NOTE: the width of the Label can be set by the Label's lineWidth paremeter
NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// create Labels to capture the text from the keyboard
const text1 = new Label({text:"", backgroundColor:white}).pos(100,100);
const text2 = new Label({text:"", backgroundColor:white}).pos(100,200);

// create a new Keyboard and pass in the labels as an array
// or if just one label, then pass in the label
const keyboard = new Keyboard([text1, text2]);

// if just the letter is needed use the keydown event
keyboard.on("keydown", e=>{
	zog(e.letter);
});

// create events to capture a mousedown on the labels
const text1Event = text1.on("mousedown", activate);
const text2Event = text2.on("mousedown", activate);
function activate(e) {
	keyboard.show();
	// remove the events when keyboard is active
	text1.off("mousedown", text1Event);
	text2.off("mousedown", text2Event);
}
keyboard.show(); // optionally show the keyboard to start

// add back the events to show the keyboard
keyboard.on("close", ()=>{
	text1.on("mousedown", text1Event);
	text2.on("mousedown", text2Event);
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
labels - (default null) a ZIM Label to show letters in or an array of labels
	Keyboard will add a cursor to the Labels
	and provide management across multiple labels
	currently, multiline labels are not supported
	setting the label lineWidth will set the max width of the label
backgroundColor - (default dark) an css color for the background color of the keys
color - (default white) the color of the text
shiftBackgroundColor - (default "orange") the color of the active shift key
shiftHoldBackgroundColor - (default "red") the color of the active shift hold key
placeBackgroundColor - (default "50c4b7") the color of the arrow backings when placing cursor in label
placeColor - (default "50c4b7") the color of the arrow text when placing cursor in label
cursorColor - (default "50c4b7") the cursor color
shadeAlpha - (default .2) special keys are shaded darker by this alpha
margin - (default 5) the margin around the keyboard from the container width
corner - (default 30) the round of the corner (set to 0 for no corner)
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
draggable - (default false) set to true to show the drag handle at top right
placeClose - (default true) shows an x key to close the cursor placement menu
shadowColor - (default "rgba(0,0,0,.2)") set to -1 for no shadow
shadowBlur - (default 14) how blurred the shadow is if the shadow is set
container - (default zimCurrentFrame stage) if placing Keyboard in different container or stage
data - (default see below) pass in data for the letters on the three sets of keyboards
	also see the layout parameter for current default layouts like "arabic", "hebrew", etc.
	Below is the default data - change any of the keys to change keyboard
	There must be three boards (you can request more)
	There must be a button specified on the fourth row to toggle to the second screen and back
	There must be a button on the second and third screen at the start of the third row
	to toggle between the second and third screen
	The "shift" and "delete" keys are optional and can be moved or removed
	There is a "back" key that is like the "backspace" key but takes the space of one key and not two keys
	There will be at least 10 key places but there can be more than 10 keys per row
	The last element of the outer array is a an object with special characters for e,u,i,o,a,n
	If left off then it will use the characters below in the example.
	These can be changed to any characters showing an extra set of any characters.
	The fifth and sixth elements are lowercase to uppercase and uppercase to lowercase override mappings 
	For instance, in the turkish layout ı:"I" and i:"İ" for lowercase to uppercase 
	and I:"ı" and İ:"i" for uppercase to lowercase.
	Use the data property to get this array if desired:
	var data = [
		[
			["q","w","e","r","t","y","u","i","o","p"],
			["a","s","d","f","g","h","j","k","l"],
			["shift","z","x","c","v","b","n","m","backspace"],
			["?123"] // rest of bottom line automatically added
		],[
			["1","2","3","4","5","6","7","8","9","0"],
			["!","@","#","$","/","^","&","*","(",")"],
			["1/2","-","'", "\"",":",";",",","?","backspace"],
			["ABC"] // rest of bottom line automatically added
		],[
			["+","x","%","=","<",">","{","}","[","]"],
			["€","£","¥", "$", "￦", "~", "`","¤","♡","☆"],
			["2/2","_","\\","|","《","》","¡","¿","backspace"],
			["ABC"] // rest of bottom line automatically added
		],{
			e:["ė","ē","ę","ê","é","ë","è"],
			u:["ū","û","ú","ü","ù"],
			i:["ī","į","ì","í","ï","î"],
			o:["ō","œ","ø","õ","ô","ó","ö","ò"],
			a:["ā","ã","å","â","á","ä","à","æ"],
			n:["ñ","ń"]
		},{
			lowercaseletter:"uppercaseletter", // override lowercase to uppercase map
			lc2:"uc2"
		},{
			uppercaseletter:"lowercaseletter", // override uppercase to lowercase map
			uc2:"lc2"
		}		
	];
place - (default true) set to false to not add place arrows when selecting Label
placeShiftH - (default 0) set to shift place arrows horizontal - from default location
placeShiftV - (default 0) set to shift place arrows vertically - from default location
special - (default null) set to a string to add a special key to the left of the space bar
rtl - (default false) (Experimental) set to true to use right-to-left text
hardKeyboard - (default true) set to false to not include keypresses from physical keyboard
layout - (default "qwerty") set to change the layout (also see data parameter for custom layout)
	additionally supported layouts are "azerty", "hebrew", "turkish", "arabic" - thanks to those who submitted layouts!
	please let us know at https://forum.zimjs.com if you are using a layout that others would use!
numPadScale - (default .8) the scale of the NumPad when pressed from the numPad key at bottom right
numPadDraggable - (default true) set to false to not be able to drag the NumPad
numPadOnly - (default false) set to true to open the NumPad only but can then use with labels
numPadAdvanced - (default false) set to true to add an extra row to the NumPad with round brackets, exponential and percent or modulus keys
maxLength - (default null) set to a number for the maximum characters - also see maxLength property
numbersOnly - (default false) set to force numbers only - also see numbersOnly property
placeScale - (default 1) set the place menu scale - will move to by place parameters in ZIM 017
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
show(index) - shows the Keyboard - use this rather than addTo(), etc.
	index (default null) specify the index of the labels array to show cursor in
hide() - hides the keyboard
toggle(state - default null) - shows if hidden and hides if showing (returns the keyboard for chaining)
	or pass in true to show keyboard or false to hide keyboard
setText(text) - change the current label text to the text provided 
clearText() - clear the current label text
addChar(char) - add a character to the currentLabel at the currentIndex
removeChar() - removes the chararcter in the currentLabel at the currentIndex-1 (a backspace)
addLabels(labels) - add a ZIM Label or an array of Labels to the labels list for the Keyboard
removeLabels(labels) - remove a ZIM Label or an array of Labels
showNumPad() - shows the NumPad - also see Keyboard numPadOnly parameter and the NUMPAD key
hideNumPad() - hide the NumPad - also see the NUMPAD key and the x on the NumPad
showKeyboard() - specifically shows the keyboard if numPadOnly is set 
hideKeyboard() - specifically hides the keyboard but may still show the NumPad 
showPlace() - show the place menu for cursor
hidePlace() - hide the place menu for cursor
resize() - scales the keyboard to the stage with margin and places at bottom of screen
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a clone of the Keyboard
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
data - get the data array for the keyboard - see the data parameter for details and to set value for data
labels - get the labels array - use addLabels() and removeLabels() to set
selectedLabel - the label with the cursor or -1 if no cursor
selectedIndex - the index of the cursor in the selected label or -1 if no cursor
toggled - read-only Boolean that is true if keyboard is visible and false if not
keys - reference to the keyboard itself 
numPad - reference to the NumPad once it has been shown once
placeMenu - reference to the place menu
maxLength - get or set the maximum characters - will not change existing label 
numbersOnly - get or set to force numbers only - will not change existing label

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
Dispatches a "keydown" event with an event object having a letter property
	keyboard.on("keydown", function(e) {zog(e.letter);}); // logs letter pressed or "del" for delete
Dispatches a "special" event if the special parameter is used and the special key is pressed
Dispatches a "close" event when close keyboard icon at bottom right is pressed
Dispatches "numpadopen" and "numpadclose" events when the NumPad is opened or closed 

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.2
zim.Keyboard = function(labels, backgroundColor, color, shiftBackgroundColor, shiftHoldBackgroundColor, placeBackgroundColor, placeColor, cursorColor, shadeAlpha, borderColor, borderWidth, margin, corner, draggable, placeClose, shadowColor, shadowBlur, container, data, place, placeShiftH, placeShiftV, special, rtl, hardKeyboard, layout, numPadScale, numPadDraggable, numPadOnly, numPadAdvanced, maxLength, numbersOnly, placeScale, style, group, inherit) {
	var sig = "labels, backgroundColor, color, shiftBackgroundColor, shiftHoldBackgroundColor, placeBackgroundColor, placeColor, cursorColor, shadeAlpha, borderColor, borderWidth, margin, corner, draggable, placeClose, shadowColor, shadowBlur, container, data, place, placeShiftH, placeShiftV, special, rtl, hardKeyboard, layout, numPadScale, numPadDraggable, numPadOnly, numPadAdvanced, maxLength, numbersOnly, placeScale, style, group, inherit";
	var duo; if (duo = zob(zim.Keyboard, arguments, sig, this)) return duo;
	z_d("67.2");
	this.zimContainer_constructor(1000,400,null,null,false);
	this.type = "Keyboard";
	this.group = group;
	var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

	if (zot(labels)) labels = DS.labels!=null?DS.labels:[];
	if (!Array.isArray(labels)) labels = [labels];
	if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.dark;
	if (zot(color)) color =  DS.color!=null?DS.color:zim.white;
	if (zot(shiftBackgroundColor)) shiftBackgroundColor = DS.shiftBackgroundColor!=null?DS.shiftBackgroundColor:"orange";
	if (zot(shiftHoldBackgroundColor)) shiftHoldBackgroundColor = DS.shiftHoldBackgroundColor!=null?DS.shiftHoldBackgroundColor:"red";
	if (zot(placeBackgroundColor)) placeBackgroundColor = DS.placeBackgroundColor!=null?DS.placeBackgroundColor:zim.blue;
	if (zot(placeColor)) placeColor = DS.placeColor!=null?DS.placeColor:color;
	if (zot(cursorColor)) cursorColor = DS.cursorColor!=null?DS.cursorColor:zim.blue;
	if (zot(shadeAlpha)) shadeAlpha = DS.shadeAlpha!=null?DS.shadeAlpha:.2;
	if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:"rgba(0,0,0,.1)";
	if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
	if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
	else if (borderColor!=null && borderWidth==null) borderWidth = 1;
	if (zot(margin)) margin = DS.margin!=null?DS.margin:5;
	if (zot(corner)) corner = DS.corner!=null?DS.corner:30;
	if (zot(draggable)) draggable = DS.draggable!=null?DS.draggable:false;
	if (zot(placeClose)) placeClose = DS.placeClose!=null?DS.placeClose:true;
	if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.2)";
	if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:14;
	if (zot(data)) data = DS.data!=null?DS.data:[
			[
				["q","w","e","r","t","y","u","i","o","p"],
				["a","s","d","f","g","h","j","k","l"],
				["shift","z","x","c","v","b","n","m","backspace"],
				["?123","@"] // rest of bottom line automatically added
			],[
				["1","2","3","4","5","6","7","8","9","0"],
				["!","@","#","$","/","^","&","*","(",")"],
				["1/2","-","'", "\"",":",";",",","?","backspace"],
				["ABC","@"] // rest of bottom line automatically added
			],[
				["+","x","%","=","<",">","{","}","[","]"],
				["€","£","¥", "$", "￦", "~", "`","¤","♡","☆"],
				["2/2","_","\\","|","《","》","¡","¿","backspace"],
				["ABC","@"] // rest of bottom line automatically added
			]
		];
	if (!data[3]) data[3] = {
		e:["ė","ē","ę","ê","é","ë","è"],
		u:["ū","û","ú","ü","ù"],
		i:["ī","į","ì","í","ï","î"],
		o:["ō","œ","ø","õ","ô","ó","ö","ò"],
		a:["ā","ã","å","â","á","ä","à","æ"],
		n:["ñ","ń"]
	};
	var that = this;		
	if (zot(place)) place = DS.place!=null?DS.place:true;
	if (zot(placeShiftH)) placeShiftH = DS.placeShiftH!=null?DS.placeShiftH:0;
	if (zot(placeShiftV)) placeShiftV = DS.placeShiftV!=null?DS.placeShiftV:0;
	if (zot(placeScale)) placeScale = DS.placeScale!=null?DS.placeScale:1;
	if (zot(rtl)) rtl = DS.rtl!=null?DS.rtl:false;
	if (zot(hardKeyboard)) hardKeyboard = DS.hardKeyboard!=null?DS.hardKeyboard:true;
	if (zot(numPadScale)) numPadScale = DS.numPadScale!=null?DS.numPadScale:.8;
	if (zot(numPadOnly)) numPadOnly = DS.numPadOnly!=null?DS.numPadOnly:false;
	if (zot(numPadDraggable)) numPadDraggable = DS.numPadDraggable!=null?DS.numPadDraggable:true;
	if (zot(numPadAdvanced)) numPadAdvanced = DS.numPadAdvanced!=null?DS.numPadAdvanced:false;
	if (zot(maxLength)) maxLength = DS.maxLength!=null?DS.maxLength:null;
	if (zot(numbersOnly)) numbersOnly = DS.numbersOnly!=null?DS.numbersOnly:false;
	this.maxLength = maxLength;
	this.numbersOnly = numbersOnly;

	if (zot(layout)) layout = DS.layout!=null?DS.layout:"qwerty";
	layout = layout.toLowerCase();
	if (layout != "qwerty") {
		if (layout == "arabic") {
			data = [
		[
			["ض", "ص", "ث", "ق", "ف", "غ", "ع", "ه", "خ", "ح", "ج"],
			["ش", "س", "ي", "ب", "ل", "ا", "ت", "ن", "م", "ك", "ط"],
			["ذ", "ء", "ؤ", "ر", "ى", "ة", "و", "ز", "ظ", "د","back"],
			["?123","ـ"] // rest of bottom line automatically added
		],[
			["1","2","3","4","5","6","7","8","9","0","*"],
			["!","@","#","$","/","^","&","*","(",")","*"],
			["1/2","-","'", "\"",":",";",",","?","*","backspace"],
			["ABC","*"] // rest of bottom line automatically added
		],[
			["+","x","%","=","<",">","{","}","[","]","*"],
			["€","£","¥", "$", "￦", "~", "`","¤","♡","☆","*"],
			["2/2","_","\\","|","《","》","¡","¿","*","backspace"],
			["ABC","*"] // rest of bottom line automatically added
		],{
			ا:["أ","إ","آ","ء"],
			ى:["ئ"],
			ء:["ئ","ؤ"],
			و:["ؤ"],
			ـ:["ٍ", "ً", "ٌ", "ْ", "ُ", "ِ", "َ", "ّ"],
			"*":["ٍ", "ً", "ٌ", "ْ", "ُ", "ِ", "َ", "ّ"],
			n:["ñ","ń"]
		}
	];
		} else if (layout == "hebrew") {
			data = [
			[
				["ק", "ר", "א", "ט", "ו", "ן", "ם", "פ", "backspace"],
				["ש", "ד", "ג", "כ", "ע", "י", "ח", "ל", "ך", "ף"],
				["ז", "ס", "ב", "נ", "ה", "מ", "צ", "ת", "ץ"],
				["?123", "@"] // rest of bottom line automatically added
			], [
				["1", "2", "3", "4", "5", "6", "7", "8", "9", "0"],
				["!", "@", "#", "$", "/", "^", "&", "*", "(", ")"],
				["1/2", "-", "'", "\"", ":", ";", ",", "?", "backspace"],
				["ABC", "@"] // rest of bottom line automatically added
			], [
				["+", "x", "%", "=", "<", ">", "{", "}", "[", "]"],
				["€", "£", "¥", "$", "￦", "~", "`", "¤", "♡", "☆"],
				["2/2", "_", "\\", "|", "《", "》", "¡", "¿", "backspace"],
				["ABC", "@"] // rest of bottom line automatically added
			], {
				e: ["ė", "ē", "ę", "ê", "é", "ë", "è"],
				u: ["ū", "û", "ú", "ü", "ù"],
				i: ["ī", "į", "ì", "í", "ï", "î"],
				o: ["ō", "œ", "ø", "õ", "ô", "ó", "ö", "ò"],
				a: ["ā", "ã", "å", "â", "á", "ä", "à", "æ"],
				n: ["ñ", "ń"]
			}
			];
		} else if (layout == "azerty") {
			data = [
				[
					["a","z","e","r","t","y","u","i","o","p"],
					["q","s","d","f","g","h","j","k","l","m"],
					["shift","w","x","c","v","b","n","´","backspace"],
					["?123","@"] // rest of bottom line automatically added
				],[
					["1","2","3","4","5","6","7","8","9","0"],
					["!","@","#","$","/","^","&","*","(",")"],
					["1/2","-","'", "\"",":",";",",","?","backspace"],
					["ABC","@"] // rest of bottom line automatically added
				],[
					["+","x","%","=","<",">","{","}","[","]"],
					["€","£","¥", "$", "￦", "~", "`","¤","♡","☆"],
					["2/2","_","\\","|","《","》","¡","¿","backspace"],
					["ABC","@"] // rest of bottom line automatically added
				],{
					e:["ė","ē","ę","ê","é","ë","è"],
					u:["ū","û","ú","ü","ù"],
					i:["ī","į","ì","í","ï","î"],
					o:["ō","œ","ø","õ","ô","ó","ö","ò"],
					a:["ā","ã","å","â","á","ä","à","æ"],
					n:["ñ","ń"]
				}
				];
			} else if (layout == "turkish") {
				data = [
				[
					["q","w","e","r","t","y","u","ı","o","p","ğ","ü"],
					["a","s","d","f","g","h","j","k","l","ş","i"],
					["shift","z","x","c","v","b","n","m","ö","ç","backspace"],
					["?123","*"] // rest of bottom line automatically added
				],[
					["1","2","3","4","5","6","7","8","9","0","*"],
					["!","@","#","$","/","^","&","*","(",")","*"],
					["1/2","-","'", "\"",":",";",",","?","*","backspace"],
					["ABC","*"] // rest of bottom line automatically added
				],[
					["+","x","%","=","<",">","{","}","[","]","*"],
					["€","£","¥", "$", "￦", "~", "`","¤","♡","☆","*"],
					["2/2","_","\\","|","《","》","¡","¿","*","backspace"],
					["ABC","*"] // rest of bottom line automatically added
				],{
					e:["ė","ē","ę","ê","é","ë","è"],
					u:["ū","û","ú","ü","ù"],
					i:["ī","į","ì","í","ï","î"],
					o:["ō","œ","ø","õ","ô","ó","ö","ò"],
					a:["ā","ã","å","â","á","ä","à","æ"],
					n:["ñ","ń"]
				},{
					ı:"I", // lowercase to uppercase map
					i:"İ"
					},{
					I:"ı", // uppercase to lowercase map
					İ:"i"
				}					
			];
		} 
	}
	that.data = data;
	
	var mess = "zim display - Keyboard(): Please pass in a reference to a container with bounds set";
	if (zot(container)) {
		if (WW.zdf) {
			container = WW.zdf.stage;
		} else {
			zogy(mess);
			return;
		}
	} else if (!container.getBounds) {
		zogy(mess);
		return;
	} else if (zot(container.stage)) {
		zogy("zim display - Keyboard(): The container must have a stage property");
		return;
	}

	if (shadowColor != -1 && shadowBlur > 0) that.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
	var currentStage = WW.zdf?WW.zdf.stage:null;

	// ~~~~~~~~~~~~~~~~~  SETUP

	that.labels = labels;
	var maxWidth;
	
	// Dan Zen Cat 03 - to handle any number of keys in row (always at least 10)
	var maxNum = 10;
	zim.loop(data[0], function (d) {
		if (d.length> maxNum) maxNum = d.length;
	});
	var numH = maxNum;

	var botArray = ["/","",",",".","numpad","away"];
	if (!zot(special)) botArray.splice(1,0,special);

	var textKeys = zim.copy(data[0]);
	// textKeys[2].unshift("shift");
	// textKeys[2].push("backspace");
	textKeys[3] = textKeys[3].concat(botArray);

	var numberKeys1 = zim.copy(data[1]);
	// numberKeys1[2].push("backspace");
	numberKeys1[3] = numberKeys1[3].concat(botArray);

	var numberKeys2 = zim.copy(data[2]);
	// numberKeys2[2].push("backspace");
	numberKeys2[3] = numberKeys2[3].concat(botArray);

	// var textKeys = [
	// 	["q","w","e","r","t","y","u","i","o","p"],
	// 	["a","s","d","f","g","h","j","k","l"],
	// 	["shift","z","x","c","v","b","n","m","backspace"],
	// 	["?123","@","",".","/","away"]
	// ]
	// var numberKeys1 = [
	//     ["1","2","3","4","5","6","7","8","9","0"],
	//     ["!","@","#","$","/","^","&","*","(",")"],
	//     ["1/2","-","'", "\"",":",";",",","?","backspace"],
	//     ["ABC","@","",".","/","away"]
	// ];
	// var numberKeys2 = [
	//     ["+","x","%","=","<",">","{","}","[","]"],
	//     ["€","£","¥", "$", "￦", "~", "`","¤","♡","☆"],
	//     ["2/2","_","\\","|","《","》","¡","¿","backspace"],
	//     ["ABC", "@","",".","/","away"]
	// ];
	// var eLetters = data[3][0]; // ["ė","ē","ę","ê","é","ë","è"];//ĒĘÊÉËÈ
	// var uLetters = data[3][1]; // ["ū","û","ú","ü","ù"];//ŪÛÚÜÙ
	// var iLetters = data[3][2]; // ["ī","į","ì","í","ï","î"];//ĪĮÌÍÏÎ
	// var oLetters = data[3][3]; // ["ō","œ","ø","õ","ô","ó","ö","ò"];// ŌŒØÕÔÓÖÒ
	// var aLetters = data[3][4]; // ["ā","ã","å","â","á","ä","à","æ"];// ĀÃÅÂÁÄÀÆ
	// var nLetters = data[3][5]; // ["ñ","ń"];

	var textKeyButtons = [];

	//maateenheid horizontaal
	var size = (1000-((numH-1)*5))/numH;

	//statuses toestenbord
	var statuses = {
		def: "default",
		shift: "shift",
		number1: "number1",
		number2: "number2"
	};
	var currentStatus = statuses.def;
	var currentKeyboard;
	var alternativeMenu;
	var textBlinker;
	var bigShiftOn = false;
	var shiftKey;
	var currentLabel;
	var insertPoint = 0;
	var cursorShiftMenu;
	var buttonsCursor = [];
	var shiftKeyIcon;
	var backspaceIcon;
	var hideKeyBoardIcon;
	var showNumPadIcon;
	var hideNumPadIcon;
	var numPadKey;
	var dragButton;
	var dragY;

	makeIcons();
	makeButtons(currentStatus);
	if (draggable) makeDragButton();

	// ~~~~~~~~~~~~~~~~~  INTERACTIONS

	this.on("mousedown", buttonPressed);

	function buttonPressed(e) {
		currentStage = that.stage;
		if (alternativeMenu) {
			that.removeChild(alternativeMenu);
		}
		if (cursorShiftMenu) {
			if (buttonsCursor.indexOf(e.target) < 0) {
				removeCursorShiftMenu();
			}
		}
		if (!zot(e.target.na)) {
			//WIJZIGINGEN STATUS keyboard
			if (draggable && e.target === dragButton) {
				that.tickerMouseEvent = currentStage.on("stagemousemove", function (e) {
					that.mouseYAmount = e.stageY;
				});
				zim.Ticker.add(startDragging);
				that.on("pressup", stopDragging);
				dragY = e.stageY - that.localToGlobal(0, 0).y;
			} else if (!zot(special) && e.target.na === special) {
				that.dispatchEvent("special");
			} else if (e.target.na === "shift") { //shift
				shiftKeys();
			} else if (e.target.toggle === "?123") { //nummers
				that.removeChild(currentKeyboard);
				makeButtons(statuses.number1);
			} else if (e.target.toggle === "ABC") { //teksten
				that.removeChild(currentKeyboard);
				currentStatus = statuses.def;
				makeButtons();
				if (bigShiftOn) shiftKeys(true);
			} else if (e.target.toggle === "1/2") {
				that.removeChild(currentKeyboard);
				makeButtons(statuses.number2);
			} else if (e.target.toggle === "2/2") {
				that.removeChild(currentKeyboard);
				makeButtons(statuses.number1);
			} else if (e.target.na === "numpad") {
				showNumPad(e.target);
			} else if (e.target.na === "away") {
				that.hideKeyboard();
				that.dispatchEvent("close");
			} else if (data[3] && data[3][e.target.na]) {
				makeAlternativeLetters(e.target.na);					
				// e.target.na === "e" ||
				// e.target.na === "u" ||
				// e.target.na === "i" ||
				// e.target.na === "o" ||
				// e.target.na === "a" ||
				// e.target.na === "n") { //VARIATIES LETTERS euioan
				// makeAlternativeLetters(e.target.na);
			} else if (e.target.na === "return") {
				addToLabel("\n");
			} else if (e.target.na === "backspace") {
				backspaceRemovesLetter();
			} else if (e.target.na === "back") {
				backspaceRemovesLetter();
			} else if (e.target.na === "") {
				addToLabel(" ");
			} else {
				addToLabel(e.target.na);
			}
			currentStage.update();
		}
	}

	that.addChar = function (chara) { // do not use char - it is a keyword
		if (!zot(chara) && chara.match(/^.$/)) addToLabel(chara);
	};
	that.removeChar = function () {
		backspaceRemovesLetter(true);
	};
	that.clearText = function () {
		currentLabel.text = "";
		backspaceRemovesLetter(true);
		makeWidthsArray();
		that.selectedIndex = 0;
	};
	that.setText = function (text) {
		currentLabel.text = text;
		makeWidthsArray();
		that.selectedIndex = text.length;
	};

	var shiftEvent;
	function shiftKeys(immediate) {
		var bigShift = false;
		var i, tkb;
		//vanuit default
		if (currentStatus === statuses.def) {
			shiftKey.color = immediate ? shiftHoldBackgroundColor : shiftBackgroundColor;
			//keyboard veranderen
			for (i = 0; i < textKeyButtons.length - 6 - (zot(special) ? 0 : 1); i++) {
				tkb = textKeyButtons[i];
				if (tkb.label.text.length > 0) {
					if (tkb.na.length === 1) {
						if (data[4] && data[4][tkb.label.text]) tkb.label.text = data[4][tkb.label.text];									
						else tkb.label.text = layout=="turkish"?tkb.label.text.toLocaleUpperCase("tr-TR"):tkb.label.text.toUpperCase();
						tkb.label.centerReg(tkb).mov(0, 6);							
					} else {
						tkb.label.centerReg(tkb);
					}
				}
			}
			if (!immediate) {
				//na halve seconde gaat groot shift aan
				bigShift = true;
				setTimeout(putBigShiftOn, 500);
				shiftEvent = that.on("pressup", doNotPutBigShiftOn);
			}
			currentStatus = statuses.shift;
			//vanuit shift
		} else {
			shiftKey.color = backgroundColor;
			bigShiftOn = false;
			//keyboard veranderen
			for (i = 0; i < textKeyButtons.length - 6; i++) {
				tkb = textKeyButtons[i];
				if (tkb.label.text.length > 0) {
					if (tkb.na.length === 1) {
						if (data[5] && data[5][tkb.label.text]) tkb.label.text = data[5][tkb.label.text];
						else tkb.label.text = tkb.label.text.toLowerCase();
						tkb.label.centerReg(tkb).mov(0, 3);
					} else {
						tkb.label.centerReg(tkb);
					}
				}
			}
			currentStatus = statuses.def;
		}
		currentKeyboard.updateCache();
		if (that.stage) that.stage.update();
		function putBigShiftOn() {
			if (bigShift) {
				bigShiftOn = true;
				shiftKey.color = shiftHoldBackgroundColor;
				currentKeyboard.updateCache();
				if (that.stage) that.stage.update();
			}
		}
		function doNotPutBigShiftOn() {
			that.off("pressup", shiftEvent);
			bigShift = false;
		}
	}

	// ~~~~~~~~~~~~~~~~~  ASSETS

	function makeButtons(which) {
		var typeKeyboard;
		var label;
		var button;
		var xPos = 0;
		var yPos = 0;
		var thisWidth;
		var bigKey;
		var thisIsSpacekey = false;
		var thisKeyLetter;
		var passesLetter;
		var dark = false;
		//zonder parameters maak ik letters
		if (zot(which)) which = statuses.def;
		//letters
		if (which === statuses.def) {
			typeKeyboard = textKeys;
			//nummers1
		} else if (which === statuses.number1) {
			typeKeyboard = numberKeys1;
			//nummers 2
		} else if (which === statuses.number2) {
			typeKeyboard = numberKeys2;
		}
		//container maken
		that.keys = currentKeyboard = new zim.Container(1000, 430, null, null, false).addTo(that).vis(!numPadOnly);
		//alle toetsen, door arrays heen wandelen
		for (var i = 0; i < typeKeyboard.length; i++) {
			if (i <= 1 || (which == statuses.def && i == 2 && typeKeyboard[2][0] != "shift")) {
				xPos = (size / 2 + 2.5) * (numH - typeKeyboard[i].length);
			}
			for (var j = 0; j < typeKeyboard[i].length; j++) {
				thisIsSpacekey = false;
				thisKeyLetter = null;
				dark = false;
				if (typeKeyboard[i][j] == "backspace") {
					bigKey = true;
					thisKeyLetter = backspaceIcon;
					dark = true;
				} else if (typeKeyboard[i][j] == "back") {
					bigKey = false;
					thisKeyLetter = backspaceIcon;
					dark = true;					
				} else if (typeKeyboard[i][j] == "shift") {
					bigKey = true;
					thisKeyLetter = shiftKeyIcon;
				} else if ((i == 3 || (which != statuses.def && i == 2)) && j == 0) {
					bigKey = true;
					dark = true;
				} else if (typeKeyboard[i][j] == "") {
					bigKey = false;
					thisIsSpacekey = true;
				} else if (typeKeyboard[i][j] == "numpad") {
					thisKeyLetter = showNumPadIcon;
					bigKey = false;
					dark = true;
				} else if (typeKeyboard[i][j] == "away") {
					thisKeyLetter = hideKeyBoardIcon;
					bigKey = true;
					dark = true;
				} else {
					bigKey = false;
				}
				//brede toets: breedte instellen
				if (bigKey) {
					thisWidth = (size * 1.5 + 2.5);
				} else if (thisIsSpacekey) {	
					// Dan Zen Cat 03 patch - make spacebar take up available space					
					thisWidth = (size + 5) * ((zot(special) ? 3 : 2) + numH-10+1-data[0][3].length) - 5;
					if (data[0][3].indexOf("backspace") != -1) {
						thisWidth -= size/2;
					} 
				} else {
					thisWidth = size;
				}
				button = new zim.Rectangle(thisWidth, size, backgroundColor, borderColor, borderWidth, corner, null, null, null, false).cur().addTo(currentKeyboard);
				if (dark) button.addChild(new zim.Rectangle(thisWidth, size, "black", null, null, corner, null, null, null, false).alp(shadeAlpha));

				if (thisKeyLetter) {
					button.label = label = new zim.Label({ text: "", backgroundColor: "ignore", font: DS.font != null ? DS.font : null, style: false });
				} else {
					button.label = label = new zim.Label({
						lineWidth: 10,
						lineHeight: 25,
						font: DS.font != null ? DS.font : null,
						text: typeKeyboard[i][j],
						color: color,
						align: "center",
						style: false
					});
				}
				//plaatje op bakking
				if (thisKeyLetter) {
					var clone = thisKeyLetter.clone();
					var sc;
					if (typeKeyboard[i][j]=="numpad") {
						sc = 60;
						numPadKey = button;
					} else {
						sc = 70;
					}
					clone.scaleTo(button, sc, sc);
					clone.centerReg(button);
				}
				if (!passesLetter) {
					label.centerReg(button).mov(0, (!isNaN(label.text)) ? 7 : 3);
					button.x = xPos;
					button.y = yPos;
					button.na = typeKeyboard[i][j];
					if (i == 2 && j == 0 && which == statuses.number1) button.toggle = "1/2";
					if (i == 2 && j == 0 && which == statuses.number2) button.toggle = "2/2";
					if (i == 3 && j == 0 && which == statuses.def) button.toggle = "?123";
					if (i == 3 && j == 0 && which != statuses.def) button.toggle = "ABC";
					if (button.toggle) label.mov(0, 3);
					textKeyButtons.push(button);
					if (button.na == "shift") {
						shiftKey = button;
					}
					xPos = button.x + button.width + 5;
				} else {
					passesLetter = false;
					xPos += 67.33;
				}
			}
			yPos += size + 5;
			xPos = 0;
		}
		currentKeyboard.cache(borderWidth ? -borderWidth : 0, borderWidth ? -borderWidth : 0, borderWidth ? currentKeyboard.width + borderWidth * 2 : currentKeyboard.width, borderWidth ? currentKeyboard.height + borderWidth * 2 : currentKeyboard.height);
	}

	function makeAlternativeLetters(letter) {
		var thisArray = data[3][letter];
		var mouseReleased = false;
		var alternativeMenuIsmade = false;
		var timeWait;			
		// switch (letter) {
		// 	case "e":
		// 		thisArray = eLetters;
		// 		break;
		// 	case "u":
		// 		thisArray = uLetters;
		// 		break;
		// 	case "i":
		// 		thisArray = iLetters;
		// 		break;
		// 	case "o":
		// 		thisArray = oLetters;
		// 		break;
		// 	case "a":
		// 		thisArray = aLetters;
		// 		break;
		// 	case "n":
		// 		thisArray = nLetters;
		// 		break;
		// 	default:
		// 		break;
		// }
		timeWait = zim.timeout(500, makeAlternatemenu, null, "ms");
		var mouseUpEvent = that.on("pressup", mouseUp);
		function mouseUp() {
			mouseReleased = true;
			that.off("pressup", mouseUpEvent);
			if (!alternativeMenuIsmade) {
				addToLabel(letter);
			}
		}
		function makeAlternatemenu() {
			var label,
				button,
				overlay,
				xPos = 0,
				thisLetter;
			timeWait.clear();
			if (!mouseReleased) {
				alternativeMenuIsmade = true;
				alternativeMenu = new zim.Container(1000, size, null, null, false).addTo(that, 0);
				alternativeMenu.y = - size - 5;
				for (var i = 0; i < thisArray.length; i++) {
					if (currentStatus === statuses.shift) {
						thisLetter = layout=="turkish"?thisArray[i].toLocaleUpperCase("tr-TR"):thisArray[i].toUpperCase();
					} else {
						thisLetter = thisArray[i];
					}
					label = new zim.Label({
						lineWidth: 10,
						lineHeight: 25,
						text: thisLetter,
						font: DS.font != null ? DS.font : null,
						color: color,
						align: "center",
						style: false
					});
					button = new zim.Rectangle(size, size, backgroundColor, borderColor, borderWidth, corner, null, null, null, false).addTo(alternativeMenu);
					overlay = new zim.Rectangle(size, size, "white", null, null, corner, null, null, null, false).alp(.2);
					button.addChild(overlay);
					label.center(button);
					button.na = thisArray[i];
					button.x = xPos;
					xPos += size + 5;
				}
				if (that.stage) that.stage.update();
			}
		}
	}

	function makeIcons() {
		//shift
		shiftKeyIcon = new zim.Shape({ style: false });
		shiftKeyIcon.graphics.f(color).p("AhIFoIAAjYIixAAID5n3ID6H3IixAAIAADYgAjHBxICeAAIAADYIBTAAIAAjYICeAAIjImSg");
		shiftKeyIcon.setBounds(-51 / 2, -72 / 2, 51, 72);
		//backspace
		backspaceIcon = new zim.Container({ style: false });
		var backspaceShape1 = new zim.Shape({ style: false });
		backspaceShape1.graphics.f(color).p("ACgC+IigigIifCgQgGAGgJAAQgJAAgGgGQgGgGgBgJQABgJAGgGICgigIigifQgGgGgBgJQABgJAGgGQAGgGAJAAQAIAAAHAGICfCgICgigQAGgGAJAAQAJAAAGAGQAGAGABAJQgBAJgGAGIigCfICgCgQAGAGABAJQgBAJgGAGQgGAGgJAAQgJAAgGgGg");
		backspaceShape1.setTransform(82.6, 32);
		backspaceShape1.addTo(backspaceIcon);
		var backspaceShape2 = new zim.Shape({ style: false });
		backspaceShape2.graphics.f(color).s().p("AkhFAQgcAAgUgUIkHj6QgVgUAAgeQAAgdAVgVIEHj6QAUgTAcAAINKAAQAdAAAUAUQAUAUAAAdIAAH1QAAAdgUATQgUAVgdAAgAk0kOIkGD8QgIAHAAALQAAALAIAIIEGD7QAIAHALAAINKAAQALAAAIgIQAHgHAAgLIAAn1QAAgLgHgIQgIgIgLAAItKAAQgLAAgIAHg");
		backspaceShape2.setTransform(62.2, 32);
		backspaceShape2.addTo(backspaceIcon);
		backspaceIcon.setBounds(0, 0, 125, 64);
		//keyboardAway
		hideKeyBoardIcon = new zim.Container({ style: false });
		hideKeyBoardIcon.setBounds(0, 0, 147, 86);
		var hideKeyBoardIconArray = [
			{ p: ("Ai+heIF9AAIi/C9g"), transform: [73.4, 76] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [128.4, 43.2] },
			{ p: ("AnNAzIAAhlIObAAIAABlg"), transform: [73, 43.2] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [18.8, 43.2] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [128.2, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [114.5, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [100.8, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [87.1, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [73.4, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [59.7, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [46, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [32.3, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [18.6, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [128, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [114.3, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [100.6, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [86.9, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [73.2, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [59.5, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [45.8, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [32.1, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [18.4, 15.8] },
			{ p: ("AphEnQgzAAgkgkQglglAAgzIAAlVQAAgzAlglQAkgkAzAAITDAAQAzAAAkAkQAlAlAAAzIAAFVQAAAzglAlQgkAkgzAAgAqjjtQgcAcAAAnIAAFVQAAAnAcAbQAbAcAnAAITDAAQAnAAAcgcQAbgbAAgnIAAlVQAAgngbgcQgcgcgnAAIzDAAQgnAAgbAcg"), transform: [73.4, 29.5] }
		];
		var thisShape;
		for (var i = 0; i < hideKeyBoardIconArray.length; i++) {
			thisShape = new zim.Shape({ style: false });
			thisShape.graphics.f(color).s().p(hideKeyBoardIconArray[i].p);
			thisShape.setTransform(hideKeyBoardIconArray[i].transform[0], hideKeyBoardIconArray[i].transform[1]);
			thisShape.addTo(hideKeyBoardIcon);
		}
		showNumPadIcon = new zim.Container({ style: false });
		showNumPadIcon.setBounds(0, 0, 62, 86);
		hideNumPadIcon = new zim.Container({ style: false });
		hideNumPadIcon.setBounds(0, 0, 62, 86);
		var sA = [
			{ p: ("Ai+heIF9AAIi/C9g"), transform: [33, 76, 1, 1, 180] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [46, 43.2] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [32.3, 43.2] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [18.8, 43.2] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [46, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [32.3, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [18.6, 29.5] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [45.8, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [32.1, 15.8] },
			{ p: ("AgyAzIAAhlIBlAAIAABlg"), transform: [18.4, 15.8] }
		];
		for (var i = 0; i < sA.length; i++) {
			var numShape = new zim.Shape({ style: false });
			numShape.graphics.f(color).s().p(sA[i].p);				
			numShape.setTransform(sA[i].transform[0], sA[i].transform[1], sA[i].transform[2], sA[i].transform[3], sA[i].transform[4]);
			numShape.addTo(showNumPadIcon);
			var num2Shape = new zim.Shape({ style: false });
			num2Shape.graphics.f(color).s().p(sA[i].p);				
			num2Shape.setTransform(sA[i].transform[0], sA[i].transform[1]);
			num2Shape.addTo(hideNumPadIcon);
		}
		numShape.graphics.ef().s(white).ss(3).rr(-16,-14,60,55,10);
		num2Shape.graphics.ef().s(white).ss(3).rr(-16,-14,60,55,10);
	}

	function makeDragButton() {
		dragButton = new zim.Rectangle((size * 1.5 + 2.5) + 2.5, size, backgroundColor, borderColor, borderWidth, corner, null, null, null, false).addTo(that, 0).cur();
		var rect;
		for (var i = 0; i < 4; i++) {
			rect = new zim.Rectangle(dragButton.width * 0.4, 4, color, null, null, null, null, null, null, false).centerReg(dragButton).alp(.2);
			rect.y -= -22 + (i * 15);
		}
		dragButton.x = (8.5 * size) + (40);
		dragButton.y = - size - 5;
		dragButton.na = "drag";
	}		
	
	function showNumPad(status) {			
		if (!that.numPad) {
			that.numPad = new zim.NumPad({advanced:numPadAdvanced, draggable:numPadDraggable}).sca(numPadScale);
			if (numPadDraggable || numPadOnly) that.numPad.center({add:false, container:container});
			else that.numPad.pos({x:0, y:8, horizontal:"center", vertical:"bottom", add:false, container:container});
			that.numPad.on("pressed", function() {
				if (that.numPad.key == "enter") {
					that.dispatchEvent("enter");
				} else if (that.numPad.key == "backspace") {
					that.removeChar();
				} else if (that.numPad.key == "clear") {
					that.clearText();
				} else if (that.numPad.key == "space") {
					addToLabel(" ");
				} else {
					addToLabel(that.numPad.key);
				}
			});
			that.numPad.on("close", function() {
				numPadKey.removeChildAt(2);
				showNumPadIcon.clone().scaleTo(numPadKey, 60, 60).centerReg(numPadKey,2);
				currentKeyboard.updateCache();
				if ((!that.keys.parent || !that.keys.visible) && textBlinker) {
					textBlinker.visible = false;
					that.toggled = false;
					removeCursorShiftMenu();
				}
				that.dispatchEvent("numpadclose");
			});
		}

		
		numPadKey.removeChildAt(2);	
		if (that.numPad.parent || status === false) {
			that.numPad.removeFrom();
			that.dispatchEvent("numpadclose");
			showNumPadIcon.clone().scaleTo(numPadKey, 60, 60).centerReg(numPadKey,2);
		} else if (!that.numPad.parent || status === true) {
			that.numPad.addTo(container);
			that.dispatchEvent("numpadopen");
			hideNumPadIcon.clone().scaleTo(numPadKey, 60, 60).centerReg(numPadKey,2);
		}
		currentKeyboard.updateCache();
		if (that.stage) that.stage.update();
	}

	function startDragging() {
		if (that.mouseYAmount) that.y = that.parent.globalToLocal(0, that.mouseYAmount - dragY).y;
	}

	function stopDragging() {
		currentStage.off("pressmousemove", that.tickerMouseEvent);
		zim.Ticker.remove(startDragging);
	}
	
	that.setBounds(1000,400-(numH-10)*26); // Dan Zen for any size keyboard

	// ~~~~~~~~~~~~~~~~~  LABELS AND CURSOR

	function positionBlinker() {
		if (!currentLabel || !textBlinker) return;
		// Dan Zen added 9.5.0 using CreateJS Label to avoid padding and backing issues and addition of bounds x for align issues
		var positionXBlinker = currentLabel.label.x + currentLabel.label.getBounds().x;
		for (var i=0; i<insertPoint;i++) {
			positionXBlinker += currentLabel.widthArray[i]?currentLabel.widthArray[i]:0;
		}
		// Dan Zen added 9.5.0 padding for three types of Label (backing, backgroundColor and neither)
		textBlinker.heightOnly = currentLabel.getBounds().height*(currentLabel.backing&&zot(currentLabel.padding)?.9:1)-((currentLabel.paddingV&&currentLabel.background)?currentLabel.paddingV*2:0);
		textBlinker.center(currentLabel);
		textBlinker.x = positionXBlinker;
	}

	function makeCursorShiftmenu() {
		if (cursorShiftMenu) return that;
		if (!currentLabel) return that;
		var tekens = placeClose ? ["<", ">", "x"] : ["<", ">"];
		var bakking;
		var button;
		var point;
		buttonsCursor = [];
		point = currentLabel.localToLocal(0, 0, that);
		cursorShiftMenu = that.placeMenu = new zim.Container({ style: false }).sca(placeScale).addTo(container).cur();
		for (var i = 0; i < tekens.length; i++) {
			bakking = new zim.Rectangle(size, size, placeBackgroundColor, borderColor, borderWidth, corner, null, null, null, false);
			if (tekens[i] == "x") new zim.Rectangle(size, size, "black", null, null, corner, null, null, null, false).alp(shadeAlpha).addTo(bakking);
			button = new zim.Label({
				lineWidth: 10,
				// lineHeight:58, // ?
				text: tekens[i],
				backing: bakking,
				font: DS.font != null ? DS.font : null,
				color: placeColor,
				align: "center",
				valign: "center",
				style: false
			});
			button.pos(0, 0, zim.LEFT, zim.TOP, cursorShiftMenu).cache();
			button.x = button.x + i * (size + 5);
			buttonsCursor.push(button);
		}
		point = currentLabel.localToLocal(0, 0, container);
		cursorShiftMenu.x = point.x + placeShiftH;
		cursorShiftMenu.y = point.y + currentLabel.height + 15 + placeShiftV;
		cursorShiftMenu.on("click", verschuifCursor);
		function verschuifCursor(e) {
			if (buttonsCursor.indexOf(e.target) == 0) {
				if (insertPoint > 0) insertPoint--;
			} else if (buttonsCursor.indexOf(e.target) == 1) {
				if (insertPoint < currentLabel.text.length) insertPoint++;
			} else {
				removeCursorShiftMenu();
			}
			positionBlinker();
		}
		if (that.stage) that.stage.update();
	}

	function removeCursorShiftMenu() {
		if (!cursorShiftMenu) return that;
		cursorShiftMenu.dispose();
		cursorShiftMenu = null;
	}

	function addToLabel(letter) {
		if (!currentLabel) return;
		var measureField;
		var widthMeasureField;
		// backspace
		if (letter === "del") {
			if (currentLabel) currentLabel.text = [currentLabel.text.slice(0,insertPoint-1),currentLabel.text.slice(insertPoint)].join('');
			insertPoint--;
			makeWidthsArray();
		} else {
			if (currentStatus === statuses.shift) {
				letter = layout=="turkish"?letter.toLocaleUpperCase("tr-TR"):letter.toUpperCase();
			}
			if (currentLabel && that.maxLength && currentLabel.text.length >= that.maxLength) return;
			if (that.numbersOnly && !isFinite(Number(letter))) return;
			var textBeforeCheck = currentLabel.text;
			measureField = currentLabel.clone().removeFrom();
			measureField.text = letter;
			widthMeasureField = measureField.label.getMeasuredWidth();
			if (!currentLabel.widthArray) {
				currentLabel.widthArray = [currentLabel.breedte];
			} else {
				currentLabel.widthArray.splice(insertPoint,0,widthMeasureField);
			}
			//toevoegen in string
			if (insertPoint<currentLabel.text.length) {
				currentLabel.text = [currentLabel.text.slice(0,insertPoint),letter,currentLabel.text.slice(insertPoint)].join('');
			} else {
				// currentLabel.text+="\u202E" + letter;
				currentLabel.text+=letter;
			}
			// if (currentLabel && currentLabel.width<maxWidth) {
			if (currentLabel && currentLabel.label.getBounds().width<maxWidth) {
				insertPoint++;
				positionBlinker();
			} else {
				currentLabel.text = textBeforeCheck;
			}
		}
		if (currentStatus === statuses.shift&&!bigShiftOn) {
			that.removeChild(currentKeyboard);
			makeButtons();
			currentStatus = statuses.def;
		}
		positionBlinker();
		var keyEvent = new createjs.Event("keydown");
		keyEvent.letter = letter;
		that.dispatchEvent(keyEvent);
		if (that.stage) that.stage.update();
	}

	function activateLabel(e) {
		if (!that.stage) return;
		var point;
		var sumUp = 0;
		var found = false;
		currentLabel = e.target;
		if (!currentLabel.widthArrayCheck) makeWidthsArray();
		maxWidth = currentLabel.label.lineWidth?currentLabel.label.lineWidth:10000;

		// Dan Zen added 9.5.0 point relative to actual CreateJS Label - to avoid padding and backing issues
		point = currentLabel.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		point.x -= currentLabel.label.x; // adjusted for retina - label is CreateJS with broken globalToLocal
		point.y -= currentLabel.label.y;
		// point opzoeken in array textfield door op te tellen
		// for (var i=currentLabel.widthArray.length-1; i>=0; i--) {
		// 	sumUp += currentLabel.widthArray[i];
		// 	if (point.x < sumUp-currentLabel.widthArray[i]/2) {
		// 		insertPoint = i;
		// 		found = true;
		// 		break;
		// 	}
		// }
		// var rightOfLabel = currentLabel.getBounds().width + currentLabel.getBounds().x;
		// zog(rightOfLabel);
		// zog(currentLabel.widthArray)
		// for (var i=0; i<currentLabel.widthArray.length; i++) {
		// 	sumUp += currentLabel.widthArray.reverse()[i];
		// 	if (point.x < rightOfLabel - sumUp-currentLabel.widthArray.reverse()[i]/2) {
		// 		insertPoint = i;
		// 		found = true;
		// 		break;
		// 	}
		// }
		for (var i=0; i<currentLabel.widthArray.length; i++) {
			sumUp += currentLabel.widthArray[i];
			// Dan Zen added 9.5.0 addition of bounds x for when align is center or right
			if (point.x < sumUp-currentLabel.widthArray[i]/2+currentLabel.label.getBounds().x) {
				insertPoint = i;
				found = true;
				break;
			}
		}
		if (!found) {
			insertPoint = currentLabel.text.length;
		}
		positionBlinker();
		if (place && !cursorShiftMenu && currentLabel.text.length > 0) {
			makeCursorShiftmenu();
		}
		if (cursorShiftMenu && currentLabel) {
			if (currentLabel.text.length > 0) {
				point = currentLabel.localToLocal(0, 0, container);
				cursorShiftMenu.x = point.x+placeShiftH;
				cursorShiftMenu.y = point.y+currentLabel.height+15+placeShiftV;
			} else {
				removeCursorShiftMenu();
			}
		}
	}
	function makeWidthsArray() {
		if (!currentLabel) return;
		var measureField = new zim.Label("");
		currentLabel.widthArray = [];
		for (var i=0; i<currentLabel.text.length; i++) {
			measureField = currentLabel.clone().removeFrom();
			measureField.text = currentLabel.text[i];
			currentLabel.widthArray.push(measureField.label.getMeasuredWidth());
		}
		measureField.text = currentLabel.text; // weird bug shortening clone shortens hitArea of original
		currentLabel.widthArrayCheck = true;
		positionBlinker();
	}

	function backspaceRemovesLetter(once) {
		var removalOkay = true;
		var timeOut;
		function haalWeg() {
			if (!currentLabel || currentLabel.text.length < 1 || that.currentIndex == 0) {
				removalOkay = false;
			}
			if (removalOkay) {
				removeLetter();
				if (timeOut) timeOut = zim.timeout(200, haalWeg, null, "ms");
			}
			if (currentLabel && currentLabel.text.length < 1) {
				stopRemoval();
			}
		}
		function removeLetter() {
			if (currentLabel && currentLabel.text.length > 0) {
				if (that.selectedIndex > 0) addToLabel("del");
				if (once) stopRemoval();
				else that.on("pressup", stopRemoval);
			} else {
				addToLabel("del");
			}
		}
		function stopRemoval() {
			removalOkay = false;
			if (timeOut) timeOut.clear();
			that.off("pressup", stopRemoval);
		}
		removeLetter();
		timeOut = zim.timeout(300, haalWeg, null, "ms");
		if (that.stage) that.stage.update();
	}

	function setLabels() {
		for (var i = 0; i < labels.length; i++) {
			labels[i].clickEvent = labels[i].on("click", activateLabel);
		}
	}
	setLabels();

	function unsetLabels() {
		if (labels.length > 1) {
			for (var i = 0; i < labels.length; i++) {
				labels[i].off("click", labels[i].clickEvent);
			}
		}
	}

	function makeCursor() {
		if (textBlinker) return;
		currentLabel = labels[0];
		maxWidth = (currentLabel && currentLabel.label.lineWidth) ? currentLabel.label.lineWidth : 10000;
		if (currentLabel) {
			textBlinker = that.blinker = new zim.Rectangle(3, currentLabel.height - ((currentLabel.paddingV && currentLabel.background) ? currentLabel.paddingV * 2 : 0), cursorColor, null, null, null, null, null, null, false)
				.center(currentLabel);
			textBlinker.x = 0;
			textBlinker.visible = false;
			textBlinker.animate({
				props: { alpha: 0 },
				rewind: true,
				loop: true,
				loopWait: 750,
				time: 250,
				id: "knipperTekst",
				timeUnit: "ms"
			});
			for (var j = 0; j < labels.length; j++) {
				labels[j].widthArray = [0];
			}
			makeWidthsArray();
		}
	}
	makeCursor();
	function removeCursor() {
		zim.stopAnimate("knipperTekst");
		if (currentLabel) currentLabel.removeChild(textBlinker);
		textBlinker = null;
		currentLabel = null;
	}
	

	// ~~~~~~~~~~~~~~~ GETTER SETTER PROPS

	Object.defineProperty(this, 'selectedLabel', {
		get: function() {
			return currentLabel;
		},
		set: function(label) {
			var obj = {target:label};
			activateLabel(obj);
			that.hidePlace();
		}
	});

	Object.defineProperty(this, 'selectedIndex', {
		get: function() {
			return insertPoint;
		},
		set: function(index) {
			insertPoint = index;
			positionBlinker();
		}
	});

	// ~~~~~~~~~~~~~~~ METHODS

	this.show = function(index, override) {
		that.addTo(container);
		if (that.placeMenu) that.placeMenu.addTo(container);
		// that.resize();
		if (!zot(index)) {
			var obj = {target:labels[index]};
			activateLabel(obj);
		}
		setTimeout(()=>{if (textBlinker) textBlinker.visible = true;}, 200);
		that.toggled = true;	
		if (numPadOnly) showNumPad();	
		else if (!numPadOnly || override) {
			that.keys.vis(true);
			background.vis(true);
		}
		if (that.numPad && that.numPad.parent) that.numPad.top();
		return that;
	};
	
	this.hide = function() {
		that.removeFrom();
		if (that.placeMenu) that.placeMenu.removeFrom();
		showNumPad(false);
		if (textBlinker) {textBlinker.visible = false;}
		currentStage.update();
		that.toggled = false;
		return that;
	};
	
	this.showNumPad = function() {
		showNumPad(true);
		that.toggled = true;
		if (textBlinker) textBlinker.visible = true;
	}
	this.hideNumPad = function() {
		showNumPad(false);
		if ((!that.keys.parent || !that.keys.visible) && textBlinker) {
			textBlinker.visible = false;
			that.toggled = false;
			removeCursorShiftMenu();
		}
	}
	
	this.showKeyboard = function() {
		that.show(null, true);
	}
	
	this.hideKeyboard = function() {
		if (!that.numPad || !that.numPad.parent) {
			that.hide();
		} else {
			that.keys.vis(false);
			background.vis(false);
		}
	}

	this.toggle = function(state) {
		if (state===true) that.show();
		else if (state===false) that.hide();
		else if (that.parent) that.hide();
		else that.show();
		return that;
	};

	this.showPlace = function() {
		makeCursorShiftmenu();
		return that;
	};

	this.hidePlace = function() {
		removeCursorShiftMenu();
		return that;
	};

	this.addLabels = function(labs) {
		if (!Array.isArray(labs)) labs = [labs];
		for (var i=labs.length-1; i>=0; i--) {
			var ind = labels.indexOf(labs[i]);
			if (ind >= 0 || labs[i].type != "Label") labs.splice(i, 1);
			else labs[i].widthArray = [0];
		}
		unsetLabels();
		labels = labels.concat(labs);
		setLabels();
		makeCursor();
		if (textBlinker) textBlinker.visible = true;
		return that;
	};

	this.removeLabels = function(labs) {
		if (!Array.isArray(labs)) labs = [labs];
		unsetLabels();
		for (var i=0; i<labs.length; i++) {
			var ind = labels.indexOf(labs[i]);
			if (ind >= 0) labels.splice(ind, 1);
		}
		setLabels();
		if (labels.length == 0) {
			if (currentLabel) removeCursor();
		} else {
			if (currentLabel && labels.indexOf(currentLabel) == -1) {
				removeCursor();
				makeCursor();
			}
		}
		return that;
	};

	var background = new zim.Rectangle(this.width, this.height, zim.clear, null, null, null, null, null, null, false).addTo(this).expand().bot();
	background.on("mousedown", function(){});
	background.on("click", function(){});
	if (numPadOnly) background.vis(false); 

	this.resize = function() {
		that.scaleTo(currentStage, 100-margin*2/currentStage.width*100, 50-margin*2/currentStage.height*100);
		that.y = currentStage.height - that.height - margin;
		that.x = currentStage.width/2 - that.width/2;
		if (currentLabel && cursorShiftMenu) {
			var point = currentLabel.localToLocal(0, 0, that);
			cursorShiftMenu.x = point.x;
			cursorShiftMenu.y = point.y + currentLabel.height + 15;
		}
		if (that.stage) that.stage.update();
		return that;
	};
	this.resize();

	if (that.selectedLabel) that.selectedIndex = that.selectedLabel.text.length;

	// Dan Zen added ZIM 10.5.1
	if (hardKeyboard) {			
		this.keydownEvent = function(e) {
			if (!that.stage) return;
			var k = that;
			if (zot(k)) return;
			if (e.keyCode==35) k.selectedIndex = k.selectedLabel.text.length; // end
			if (e.keyCode==36) k.selectedIndex = 0; // home
			if (e.keyCode==37) k.selectedIndex = k.selectedIndex-1; // left
			if (e.keyCode==39) k.selectedIndex = k.selectedIndex+1; // right
			if (e.keyCode==46) { // del
				if (k.selectedIndex < k.selectedLabel.text.length) {
					k.selectedIndex = k.selectedIndex + 1;
					k.removeChar();
				}
			}
			if (e.keyCode==8) {
				e.preventDefault();
				k.removeChar(); // backspace
			}
			k.addChar(e.key);
			if (that.stage) that.stage.update();
		};
		WW.addEventListener("keydown", this.keydownEvent);
	}			

	if (style!==false) zim.styleTransforms(this, DS);
	this.clone = function() {
		var kb = new zim.Keyboard(labels, backgroundColor, color, shiftBackgroundColor, shiftHoldBackgroundColor, placeBackgroundColor, cursorColor, shadeAlpha, margin, corner, draggable, placeClose, shadowColor, shadowBlur, container, data, place, placeShiftH, placeShiftV, special, rtl, hardKeyboard, layout, numPadScale, numPadDraggable, numPadOnly, numPadAdvanced, maxLength, numbersOnly, placeScale, style, this.group, inherit);
		return that.cloneProps(kb);
	};
	this.dispose = function(a,b,disposing) {
		background.removeAllEventListeners();
		background = null;
		if (that.keydownEvent) WW.removeEventListener("keydown", that.keydownEvent);
		for(var i=0; i<that.labels.length; i++) {
			that.labels[i].removeAllEventListeners();
		}
		if (that.numPad) that.numPad.dispose()	
		if (textBlinker) textBlinker.dispose();
		that.labels = currentLabel = null;
		if (currentStage) currentStage.off("pressmousemove", that.tickerMouseEvent);
		if (!disposing) that.zimContainer_dispose(true);
		return true;
	};
};
zim.extend(zim.Keyboard, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-67.2

/*--
zim.Organizer = function(width, list, useAdd, useRemove, usePosition, autoAdd, autoRemove, autoPosition, addForward, removeForward, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, spacing, corner, keyEnabled, gradient, gloss, backdropColor, style, group, inherit)

Organizer
zim class - extends a zim.Tabs which extends a zim.Container which extends a createjs.Container

DESCRIPTION
A Tabs bar of interface for organizing a ZIM List.
This includes add, up, down, toTop, toBottom and remove icon buttons.
The Organizer can sit above the list and allow the user to add, remove and reorder the list.
Adding an item will add an empty button - this would need to be filled with the user input, etc.
If the user input is not ready, the autoAdd parameter can be set to false.
The change event will report an orgType of "add" and the add() method can be used when the input is ready.
The same for positioning or removing if desired.

See: https://zimjs.com/explore/organizer.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
	const organizer = new Organizer(250)
		.change(()=>{
			if (organizer.orgType=="add") organizer.orgItem.text = "new";
		});
	new List({
		width:250,
		organizer:organizer // pass the organizer to the list
	});
		.center()
		.mov(0,40);

	// OR

	const list = new List(250)
		.center()
		.mov(0,40);
	var organizer = new Organizer(250, list)
		.center()
		.mov(0,-80)
		.change(()=>{
			if (organizer.orgType=="add") organizer.orgItem.text = "new";
		});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 300) width of Tabs - this will determine the height as the Buttons are square.
	There is no vertical version of an Organizer.
list - (default null) an ZIM List object to control - or null to add later with the list property
useAdd - default(true) set to false to not include the add button
useRemove - default(true) set to false to not include the remove button
usePosition - default(true) set to false to not include the position buttons (up, down, toTop, toBottom)
autoAdd - default(useAdd) set to false to not automatically add an item
	the "change" event will still be dispatched and the orgType will be "add"
	the add() method can be used to add user input for instance
autoRemove - default(useRemove) set to false to not automatically add an item
	the "change" event will still be dispatched and the orgType will be "remove"
	the remove() method can be used to manually remove
autoPosition - default(usePosition) set to false to not automatically position an item
	the "change" event will still be dispatched and the orgType will be UP, DOWN, TOP, BOTTOM
	the up(), down(), toTop(), toBottom() methods can be used to manually position
addForward - (default true) set to false to add item behind the current item (in list index) when adding
removeForward - (default true) set to false to select the item before the current item (in list index) when deleting
backgroundColor - (default tin) the background color of the buttons
rollBackgroundColor - (default grey) the background color of the button as rolled over
selectedBackgroundColor - (default charcoal) the background color of the button when selected
color - (default white) the text color of a deselected button when not rolled over
rollColor - (default color) the rollover color
selectedColor - (default color) the text color of the selected button
selectedRollColor - (default color) the text color of the rolled over selected button
spacing - (default 2) the distance between the buttons
corner - (default 0) the corner radius of the tabs
   can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
keyEnabled - (default true) so tab key cycles through tabs, shift tab backwards
gradient - (default null) 0 to 1 (try .3) adds a gradient to the buttons
gloss - (default null) 0 to 1 (try .1) adds a gloss to the buttons
backdropColor - (default dark) the background color of the list window (any CSS color)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(index, item, clone) - manually add item at index - both are optional - index defaults to current index
	clone defaults to false - set to true to add a clone of the item - returns object for chaining
up(index) - move item up one index number in list - index defaults to current index - returns object for chaining
down(index) - move item down one index number in list - index defaults to current index - returns object for chaining
toTop(index) - move item to top of list (index 0) - index defaults to current index - returns object for chaining
toBottom(index) - move item bottom of list (index length-1) - index defaults to current index - returns object for chaining
remove(index) - manually remove item at index - index defaults to current index - returns object for chaining
setButtons() - manually rotate buttons to match List direction - automatically done when added to list or list is initially added to organizer
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: All Tab methods

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
list - the list the organizer is operating on
lastIndex - read-only selected index before change event is dispatched
orgIndex - read-only current index of list - same as list.currentIndex
orgItem - read-only selected item of list - same as list.selected
orgType - read-only type of button pressed - "add", "remove", UP, DOWN, TOP, BOTTOM
removedItem - a reference to the item that has been removed when removed button is pressed or remove() is called
group - used when the object is made to add STYLE with the group selector (like a CSS class)

ALSO: see all Tab properties

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event when the buttons are pressed (may be the same button again)
	use orgType for what type "add", "remove", UP, DOWN, TOP, BOTTOM
	use orgIndex or list.currentIndex for current list index
	use orgItem or list.selected for selected item
	use removedItem for a removed item
	use lastIndex for index before change

ALSO: All Tab events

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.3
	zim.Organizer = function(width, list, useAdd, useRemove, usePosition, autoAdd, autoRemove, autoPosition, addForward, removeForward, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, spacing, corner, keyEnabled, gradient, gloss, backdropColor, style, group, inherit) {
		var sig = "width, list, useAdd, useRemove, usePosition, autoAdd, autoRemove, autoPosition, addForward, removeForward, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, spacing, corner, keyEnabled, gradient, gloss, backdropColor, style, group, inherit";
		var duo; if (duo = zob(zim.Organizer, arguments, sig, this)) return duo;
		z_d("67.3");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Organizer", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:(list&&list.vertical)?list.width:300;
		if (zot(useAdd)) useAdd = DS.useAdd!=null?DS.useAdd:true;
		if (zot(useRemove)) useRemove = DS.useRemove!=null?DS.useRemove:true;
		if (zot(usePosition)) usePosition = DS.usePosition!=null?DS.usePosition:true;
		if (zot(autoAdd)) autoAdd = DS.autoAdd!=null?DS.autoAdd:useAdd;
		if (zot(autoRemove)) autoRemove = DS.autoRemove!=null?DS.autoRemove:useRemove;
		if (zot(autoPosition)) autoPosition = DS.autoPosition!=null?DS.autoPosition:usePosition;
		if (zot(addForward)) addForward = DS.addForward!=null?DS.addForward:true;
		if (zot(removeForward)) removeForward = DS.removeForward!=null?DS.removeForward:true;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.tin;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.grey;
		if (zot(selectedBackgroundColor)) selectedBackgroundColor = DS.selectedBackgroundColor!=null?DS.selectedBackgroundColor:zim.dark;
		if (zot(color)) color = DS.color!=null?DS.color:zim.white;
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(selectedColor)) selectedColor = DS.selectedColor!=null?DS.selectedColor:color;
		if (zot(selectedRollColor)) selectedRollColor = DS.selectedRollColor!=null?DS.selectedRollColor:color;
		if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:1;
		if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
		if (zot(gradient)) gradient = DS.gradient!=null?DS.gradient:.2;
		if (zot(gloss)) gloss = DS.gloss!=null?DS.gloss:null;
		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:null;
		if (!Array.isArray(corner)) {
			corner = [corner, corner, corner, corner];
		}

		if (!useAdd && !usePosition && !useRemove) return; // will lead to errors...
		var buttonNum = (useAdd?1:0) + (usePosition?4:0) + (useRemove?1:0);
		var buttonSize = (width+spacing) / buttonNum;

		var buttonStyle = {
			width:buttonSize,
			height:buttonSize,
			label:"",
			shadowColor:-1,
			gradient:gradient,
			corner:corner,
			backgroundColor:backgroundColor,
			rollBackgroundColor:rollBackgroundColor
		};

		var buttons = [];
		var addIcon = new zim.Shape();
		addIcon.graphics.f(color).p("AAAA4Ih6B8Ig5g4IB8h8Ih7h6IA4g5IB6B8IB7h8IA5A5Ih8B6IB8B7Ig5A5g");
		if (useAdd) buttons.push(new zim.Button({icon:addIcon.sca(.55).rot(-45).reg(1), inherit:buttonStyle}));
		
		if (usePosition) {
			var arrowIcon = new zim.Shape();
			arrowIcon.graphics.f(color).p("AiJieIETCeIkTCfg");
			buttons.push(new zim.Button({icon:arrowIcon.sca(.6).rot(list&&!list.vertical?180:-90).reg(-2), inherit:buttonStyle}));
			buttons.push(new zim.Button({icon:arrowIcon.clone().sca(.6).rot(list&&!list.vertical?0:90).reg(-2), inherit:buttonStyle}));
			var endIcon = new zim.Shape();
			endIcon.graphics.f(color).p("AiFCLIAAkVIBXAAIAAEVgAgiAAICoiHIAAEQg");
			buttons.push(new zim.Button({icon:endIcon.sca(.62).rot(list&&!list.vertical?0:90).reg(0), inherit:buttonStyle}));
			buttons.push(new zim.Button({icon:endIcon.clone().sca(.62).rot(list&&!list.vertical?180:-90).reg(0), inherit:buttonStyle}));
		}
		
		if (useRemove) buttons.push(new zim.Button({icon:addIcon.clone().rot(0).sca(.55), inherit:buttonStyle}));
		if (buttons.length==0) buttons = [""];
		this.zimTabs_constructor(width, buttonSize, buttons, backgroundColor, rollBackgroundColor, null, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, null, selectedColor, selectedRollColor, false, spacing, true, false, corner, null, true, gradient, gloss, null, null, null, null, null, null, null, null, null, null, backdropColor);
		
		var that = this;
		that.list = list;
		that.type = "Organizer";

		that.setButtons = function() {
			if (usePosition) {
				var startIndex = useAdd?1:0;
				if (buttons[startIndex+0]) buttons[startIndex+0].icon.rotation = that.list&&!that.list.vertical?180:-90;
				if (buttons[startIndex+1]) buttons[startIndex+1].icon.rotation = that.list&&!that.list.vertical?0:90;
				if (buttons[startIndex+2]) buttons[startIndex+2].icon.rotation = that.list&&!that.list.vertical?0:90;
				if (buttons[startIndex+3]) buttons[startIndex+3].icon.rotation = that.list&&!that.list.vertical?180:-90;
			}
		};
		
		var listEvent = false;
		var lastList = list;

		that.change(function (e) {
			// handle dynamically adding event to list, delayed list or changed list
			if ((!listEvent && that.list) || (that.list && that.list != lastList)) {
				if (that.list != lastList) {if (lastList) lastList.noChange();}
				that.list.change(function () {
					that.orgItem = that.list.selected;
					that.orgIndex = that.list.selectedIndex;
				});
				listEvent = true;
				lastList = that.list;
			}
			var val = e.target.selectedIndex;
			if (!useAdd) val++;
			if (!usePosition && (!useAdd || val>0)) val = 5;
			var badIndex = zot(that.list.selectedIndex) || that.list.selectedIndex<0;
			if (badIndex) that.currentValue = null;
			that.lastIndex = that.list.selectedIndex;
			var index;
			switch(val) {
				case 0: // add
					if (autoAdd) {
						index = Math.max(0,that.list.selectedIndex);
						that.add(index);
					}
					that.orgType = "add";
					break;
				case 1:  // up
					if (badIndex) break;
					if (autoPosition) {
						index = that.list.selectedIndex;
						that.up(index);
					}
					that.orgType = "up";
					break;
				case 2:  // down
					if (badIndex) break;
					if (autoPosition) {
						index = that.list.selectedIndex;
						that.down(index);
					}
					that.orgType = "down";
					break;
				case 3: // top
					if (badIndex) break;
					if (autoPosition) {
						index = that.list.selectedIndex;
						that.toTop(index);
					}
					that.orgType = "top";
					break;
				case 4: // bottom
					if (badIndex) break;
					if (autoPosition) {
						index = that.list.selectedIndex;
						that.toBottom(index);
					}
					that.orgType = "bottom";
					break;
				case 5: // remove
					if (badIndex) break;
					if (autoRemove) {
						index = that.list.selectedIndex;
						that.remove(index);
					}
					that.orgType = "remove";
					break;
			}
		});
		
		this.add = function(index, item, clone) {
			if (zot(index)) index = that.lastIndex;
			if (zot(item)) item = "";
			if (addForward) {
				index = Math.min(that.list.length, Math.max(0,that.list.selectedIndex)+1);
			} else {
				index = Math.max(0,that.list.selectedIndex);
			}
			that.list.addAt(item, index, clone);
			that.list.selectedIndexPlusPosition = index;
			that.orgItem = that.list.selected;
			that.orgIndex = that.list.selectedIndex;
			return that;
		};
		
		this.up = function(index) {
			if (zot(index)) index = that.lastIndex;
			var button = that.list.items[index];
			if (zot(button)) return that;
			that.list.removeAt(1, index);
			that.list.addAt(button, index-1);
			that.list.selectedIndexPlusPosition = Math.max(0,index-1);
			that.orgItem = that.list.selected;
			that.orgIndex = that.list.selectedIndex;
			return that;
		};
		
		this.down = function(index) {
			if (zot(index)) index = that.lastIndex;
			var button = that.list.items[index];
			if (zot(button)) return that;
			that.list.removeAt(1, index);
			that.list.addAt(button, index+1);
			that.list.selectedIndexPlusPosition = Math.min(that.list.length-1,index+1);
			that.orgItem = that.list.selected;
			that.orgIndex = that.list.selectedIndex;
			return that;
		};
		
		this.toTop = function(index) {
			if (zot(index)) index = that.lastIndex;
			var button = that.list.items[index];
			if (zot(button)) return that;
			that.list.removeAt(1, index);
			that.list.addAt(button, 0);
			that.list.first();
			that.orgItem = that.list.selected;
			that.orgIndex = that.list.selectedIndex;
			return that;
		};
		
		this.toBottom = function(index) {
			if (zot(index)) index = that.lastIndex;
			var button = that.list.items[index];
			if (zot(button)) return;
			that.list.removeAt(1, index);
			that.list.addAt(button, that.list.length);
			that.list.last();
			that.orgItem = that.list.selected;
			that.orgIndex = that.list.selectedIndex;
			return that;
		};
		
		this.remove = function(index) {
			if (zot(index)) {
				if (that.list.selectedIndex >= 0) index = that.list.selectedIndex;
				else return that;
			}
			var same = index == that.list.selectedIndex;
			that.removedItem = that.list.items[index];
		
			that.list.removeAt(1, index);
		
			if (same) {
				if (!removeForward) {
					index = Math.max(0,index-1);
				}
			} else {
				index = that.list.selectedIndex;
			}
		
			that.list.selectedIndexPlusPosition = Math.min(that.list.length-1, index);
			that.orgItem = that.list.selected;
			that.orgIndex = that.list.selectedIndex;
			return that;
		};

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Organizer(width, list, useAdd, useRemove, usePosition, autoAdd, autoRemove, autoPosition, addForward, removeForward, backgroundColor, rollBackgroundColor, selectedBackgroundColor, selectedRollBackgroundColor, color, rollColor, selectedColor, selectedRollColor, spacing, corner, keyEnabled, gradient, gloss, backdropColor, style, that.group, inherit));
		};
		
		this.dispose = function(a,b,disposing) {			
			buttons = null;				
			if (!disposing) {				
				that.zimTabs_dispose(true); // will go to Container dispose				
			}			
			return true;
		};
	};
	zim.extend(zim.Organizer, zim.Tabs, ["clone", "dispose"], "zimTabs", false);
	//-67.3

/*--
zim.Connectors = function(width, height, points, node, line, linear, linearWrap, linearOrder, num, snapH, snapV, dropType, dropArray, continuous, startIndex, duplicateLine, deleteNode, dblclick, fullMove, min, max, boundary, expand, nodeRollColor, nodeRollBorderColor, nodeSelectedColor, nodeSelectedBorderColor, baseColor, baseBorderColor, baseRollover, rootLock, grandChildren, dblclickTime, steps, style, group, inherit)

Connectors
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Adds nodes (any DisplayObject - default a Circle) that can be dragged to draw a connector line.
There are three main uses for Connectors:

1. Connecting dots like in coloring books - use linear:true
2. Making hieararchy type drawings - use snaps
3. Connecting objects like boxes together - pass in objects to the points

The num parameter limits the number of lines that can be drawn from a node.
The dropType can be set to require nodes to be dropped on or off other nodes (or the default, any).
There are min and max distances the connections can be made.
These and the other parameters provide a variety of game and puzzle options.

The Line can be set to have start and end heads.
The lineType in the Line can be set to "straight", "corner" or "curve"
Line also accepts points for any arrangement of a connector
but in this version, these have not been used in Connectors.

BASE 
A DisplayObject can be used as a base for the connector and have nodes added.
A base can have multiple nodes attached on any of its sides
This approaches diagramming tools like Powerpoint, etc.
but currently, only vertically placed nodes can connect to vertically placed nodes 
and horizontally placed nodes can connect to horizontally placed nodes.
DropType single works per node, not per base so use a single node on a base for this.
A base can be a Blob or a Squiggle as well with nodes added to points.

See: https://zimjs.com/cat/connectors.html

PREMADE CONNECTIONS 
As of ZIM ZIM 02, Connectors() have a steps property that represents connections made.
Use getSteps(true) when done making connections - this will popup an array of steps.
Copy this array of steps to the steps parameter of the Connector() in the app code.
Connectors will then be made and the additional steps added. 
Connectors can also be added to a ZIM TransformManager() so users can easily recreated their connections.

See https://zimjs.com/zim/connectors.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// draws four general connectors that can be connected to one another in a box
// adjust connector nodes after connections are complete
const connectors = new Connectors({linear:true}).center();
connectors.on("complete", ()=>{
	connectors.nodes.loop(node=>{
		node.radius = 5;
		node.color = red;
	});
	// or hide connectors
	// connectors.nodes.alp(0);
	S.update();
});
END EXAMPLE

EXAMPLE
// make a grid of connectors and only connect to other nodes
// do not let user delete a node or doubleclick to move a node
const points = [];
const spacing = 60;
loop(10, i=>{
	loop(10, j=>{
		points.push([i*spacing, j*spacing]);
	});
});
const connectors = new Connectors({
	points:points,
	node:new Rectangle(12,12,purple).centerReg(),
	line:new Line({color:purple, thickness:12}),
	nodeRollColor:orange,
	dropType:"on",
	dblclick:false,
	deleteNode:false,
	max:70
}).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default null) the width of the connnectors container or will grow with added connectors
height - (default null) the height of the connnectors container or will grow with added connectors
points - (default [[0,0], [100,0], [100,100], [0,100]]) an array of point arrays for the connectors	
	or can be [[x, y, startNode, endNode, startLength, endLength], etc]
		x - the x position of the node
		y - the y position of the node
		startNode - (default true) set to false to not drag from node
		endNode - (default true) set to false to not drop on node
		startLength - (default null) set line startLength - see Connectors line parameter (for corner or curve lineType)
		endLength - (default null) set line endLength - see Connectors line parameter (for corner or curve lineType)	
	example:
		[[0,0,true,false,50], [100,0,false,true], ...] 
			would allow dragging from the first to the second but not the second to the first 
			and if the line (see line parameter) is lineType corner or curve the start length would be 50
			Another point could have a different startLength to avoid overlapping lines
		A convenience object literal can be used as well for any or all points:
		[{x:0, y:0, endNode:false, startLength:50}, {x:100, y:0, startNode:false}, ...]	
	or the first two items in the array can can be a base (that connectors nodes will be added to) and baseInfo as follows:
		[[base, baseInfo], [base, baseInfo], [base, baseInfo], etc.]
			these can have the startNode, endNode, startLength, endLength as well 
			and can have the object literal format as follows:
		[{base:base, info:baseInfo, etc.}, etc.] rather than the x:x and y:y properties
	the baseInfo can be a number of nodes to place around all base sides
	or baseInfo can be an array with three different formats:
		[all]
		[left/right, top/bottom]
		[left, right, top, bottom]
	These can be numbers greater than 0 for the number of nodes on the side
		or 0 for no nodes on the side
		or -1 for both corners on the side
		or -2 for the first corner on the side
		or -3 for the second corner on the side
	or can specify a ZIM Blob or Squiggle to place connectors on their points
		so: points:blob or points:squiggle
		the Blob or Squiggle do not need to be added to the stage
		use the getPoints(true) method of the Blob or Squiggle or see https://zimjs.com/paths/
node - (default new Circle(10, grey, grey)) the DisplayObject to use as a node - should be centerReg()
line - (default new zim.Line({thickness:3, color:tin, strokeObj:{caps:"round"}})) the line to use as the connector
	ZIM Line has a lineType parameter for "straight", "corner", and "curve" which will affect the connector lines
	ZIM Line has a lineOrientation parameter of AUTO, HORIZONTAL or VERTICAL that will affect the connector lines
	ZIM LIne has startLength and endLength parameters that work with "corner" and "curve"
		these accept ZIM VEE to dynamically set random or a series of values 
		that can help avoid overlapping lines or
		these values can be set individually on the points parameter or on bases directly as properties
		which will override any values set on the line provided here in the line parameter
	ZIM Line as curveH and curveV settings that will adjust the lines for the "curve" setting
	the caps should be set to "round" if drawing with clear or transparent nodes
linear - (default false) lines will only connect to points that are next to one another (in the point order)
	this is good for connecting dots
linearWrap - (default true) let the first point connect to the last point in the linear setting
linearOrder - (default false) require the points to be connected in order
num - (default null) set the maximum number of lines that can come from a node
snapH - (default null) snap the nodes to a provided horizontal distance
snapV - (default null) snap the nodes to a provided vertical distance
dropType - (default "any") determines what happens when a node is dropped as follows:
	"any" lets the node be dropped anywhere (and may be snapped)
	"on" will save the node if dropped on an existing node otherwise it is removed or put back to where it is dragged from
	"off" will save the node if not dropped on an existing node otherwise it is removed or put back to where it is dragged from
	"single" will save the node if dropped on a node with no existing connections otherwise it is removed or put back to where it is dragged from
	note - these only work with the currently dragged node - not other multiple selected nodes
dropArray - (defult null) with "on" or "single" dropType and NOT linear - specify which nodes a node can be connected to
	use an array of arrays for each point index [[indexes], [indexes], etc]
	eg. [[1,2],[0,2],[3],[0,1]] - if in "on", point 0 can go to 1 or 2, point 1 can go to point 0 or 2, point 2 can only go to 3, etc.
	if "single" is set then only one line can be drawn	
	also see dropIndex and dropArray for each node and the targetNode property 
	each time a connection is made, a new node is created - these will inherit the dropIndex and dropArray from a targetNode
	and if the latestNode's dropArray and its lineArray are the same and the duplicateLine is false then a "blocked" event is dispatched
continuous - (default false) set to true to force nodes to only be made from the last node 
	all other nodes will have their noMouse() set - also see startIndex - also see linear for doing points in order
startIndex - (default null) set to a point index to force connectors to start at that node
	all other nodes will have there noMouse() set - also see continous 
duplicateLine - (default true) set to false to not allow multiple lines between the same connectors
deleteNode - (default true) set to false to not allow nodes to be deleted by holding or doubleclicking and delete or backspace key
dblclick - (default true) set to false to not allow nodes to be selected by doubleclicking
	selected nodes can be moved together
	selecting a node selects its children unless the ctrl key is held at which point it will not select children
	selected nodes can be deleted with the delete key (or hold to delete)
	deleting a node will delete its children
fullMove - (default true) set to false to not automatically drag a node when it is full (if num is set)
min - (default node radius or smallest dimension) the minimum distance from the node's parent a node must move before placing node
max - (default null) the maximum distance from the node's parent a node can be moved to be placed
boundary - (default null) a ZIM Boundary object for the nodes - or a DisplayObject such as the stage (see ZIM Drag)
expand - (default 0 or 10 on mobile) expand the node mousedown area
nodeRollColor - (default node.color.lighten(.2)) the color of the node as rolled over
nodeRollBorderColor - (default node.borderColor) the borderColor of the node as rolled over
nodeSelectedColor - (default white) the selected node color if doubleclicked
nodeSelectedBorderColor - (default node.borderColor) the selected node borderColor if doubleclicked
baseColor - (default node.color) the color of the node connected to a base DisplayObject (see points parameter)
baseBorderColor - (default node.borderColor) the borderColor of the node connected to a base DisplayObject (see points parameter)
baseRollover - (default false) set to true to change all nodes on a base to their roll colors when rolling over the base
rootLock - (default false) do not let the root node (a node in the points array) be draggable or deletable
grandChildren - (default true) do not let there be grandchildren - so there can only be the root nodes and their direct children
dblclickTime - (default .5) time in seconds to capture a double click within (also see ZIM TIME constant)
steps - (default null) pass in an array of [nodeNum, dropX, dropY] arrays to recreate the steps - see getSteps(), setSteps() and steps property
	this can be used to recreate a previously made set of connectors and connections
	note: the steps may also include a delete flag, and moveX and moveY values and a flag for single select (rather than default children select)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
addNode(x, y, startNode, endNode, startLength, endLength) - add a node at x and y 
		cannot add nodes in linear mode - see linear parameter
		addNode will not work with the dropArray parameter
	x - the x position of the node or provide a base (see Connectors points parameter)
	y - the y position of the node or provide base info (see Connectors points parameter)
	startNode - (default true) set to false to not drag from node
	endNode - (default true) set to false to not drop on node
	startLength - (default null) set line startLength - see Connectors line parameter (for corner or curve lineType)
	endLength - (default null) set line endLength - see Connectors line parameter (for corner or curve lineType)	
removeNode(node) - remove the node (and its children)
removeConnectors() - removes all nodes and connectors except for root nodes which were specified in the points parameter
selectNode(node, children) - select a node and its children unless children parameter is set to false
makeConnection(node, x, y) - add a connection from a node to an x and y position
getSteps(popup) - gets an array of [nodeNum, dropX, dropY] that are automatically recorded each connection.  Also see the steps property.
	This can then copeied and passed into the steps parameter of Connectors() or the setSteps() method 
	to recreate recorded connections allowing a set of connectors to be recreated.	
	note: the steps may also include a delete flag, and moveX and moveY values and a flag for single select (rather than default children select).
setSteps(steps) - add steps to a Connectors() object - or use the steps parameter - also applySteps() for backwards compatibility
	steps of [nodeNum, dropX, dropY] are automatically collected when nodes are made and stored in a steps array.
	The data for the steps can be collected with getSteps(popup) and shown in a popup window if desired.
	Then pass the steps in to the Connectors() step parameter or use setSteps(steps) to recreate the recorded Connectors.
	note: the steps may also include a delete flag, and moveX and moveY values and a flag for single select (rather than default children select).
addBase(base, baseInfo) - add nodes to a base DisplayObject - see the points parameter for info about the baseInfo
removeBase(base) - remove the connectors for a base - the base will still need to be removed with removeFrom()
setAvailableIndexes(indexes) - set the provided index or array of indexes to be active
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
latestNode - reference to the latest node while being dragged or and dropped successfully creating a connection
	this is set to null if the dragged node is dropped and a connection is not made
	see all the properties added to the node objects to get for instance, a creator node
targetNode - reference to a node on which the latestNode was dropped to successfully create a connection
	the latestNode will inherit the dropIndex and dropArray from the targetNode
node - the DisplayObject used to make the connector nodes
	the node objects also have these added properties:
	creator - the node the node was created from (parent in hierarchy) or null if root node
	creatorLine - the line going back to the creator or null if root node
	creations - an array of nodes made from the node (its children in hiearchy)
	before - the node before it in the original points array (or null if first)
	after - the node after it in the original points array (or null if last)
	nodeColor - remembers the node color in case ZIM VEE is used for color so rolloff knows what color to set
	base - the base the node is associated with or null if no base
	selected - whether the node is selected or not
	orientation - the orientation of the lines from the node
	nodeNum - a unique index in order nodes are made
		this is used in steps to recreate nodes and connections with the Connectors steps parameter or setSteps(steps) method
	dropIndex - get or set the index of the point on which an original node is made
		this will get transfered from a targerNode 
	dropArray - get or set the array of dropIndexes that this node can connect to 
		this will get transfered from a targerNode 
		and if the dropArray and the lineArray are the same 
		and the duplicateLine is false then a "blocked" event is dispatched
	lineArray - get an array of indexes to other node connections 
		this will get transfered to a targetNode 
		and if the lineArray and dropArray are the same 
		and the duplicateLine is false then a "blocked" event is dispatched
line - the Line object used to make the connector lines
	the line objects also have these added properties:
	node - a reference to the node at the start of the line
	creatorNode - a reference to the node at the end of the line
nodes - the Container that holds the nodes
lines - the Container that holds the lines
points - a read only array of points of node
steps - an array of [nodeNum, dropX, dropY] arrays that can be used to recreate connections
	see also the getSteps(popup) method and the Connectors() steps parameter or setSteps(steps) method to recreate connections
	note: the steps may also include a delete flag, and moveX and moveY values.
selectedList - a read-only array of selected nodes
bases - an Array of DisplayObjects used as bases (provided through the points parameter or addBase())
	the base objects also have these added properties and methods:
	connectors - an array of all connector nodes on the base
	connectorMoveEvent - reference to pressmove event on base
	connectorUpEvent - reference to pressmove event on base
	connectorOverEvent - reference to pressmove event on base
	connectorOutEvent - reference to pressmove event on base
	setConnectorColors(baseColor, baseBorderColor, nodeRollColor, nodeRollBorderColor) - method to set colors
	startNode - set to false to not start a line from this base - see points parameter
	endNode - set to false to not end a line on this base - see points parameter
	startLength - set a start length for the connector - see points parameter
		good to prevent corner and curved lines from overlapping
	endLength - set an end Length for the connector - see points parameter
		good to prevent corner and curved lines from overlapping

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "connection" event if a new node is made and lastNode property is set to the new node
dispatches a "noconnection" event if the connector is dropped and no new node is made
dispatches a "blocked" event of duplicateLine is false and continuous is true and there are no more connections available 
	this will happen if the latestNode's dropArray is the same as its linesArray (the order in the array does not matter)
dispatches a "complete" event in linear mode when the connections are complete

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.39
	zim.Connectors = function(width, height, points, node, line, linear, linearWrap, linearOrder, num, snapH, snapV, dropType, dropArray, continuous, startIndex, duplicateLine, deleteNode, dblclick, fullMove, min, max, boundary, expand, nodeRollColor, nodeRollBorderColor, nodeSelectedColor, nodeSelectedBorderColor, baseColor, baseBorderColor, baseRollover, rootLock, grandChildren, dblclickTime, steps, style, group, inherit) {
		var sig = "width, height, points, node, line, linear, linearWrap, linearOrder, num, snapH, snapV, dropType, dropArray, continuous, startIndex, duplicateLine, deleteNode, dblclick, fullMove, min, max, boundary, expand, nodeRollColor, nodeRollBorderColor, nodeSelectedColor, nodeSelectedBorderColor, baseColor, baseBorderColor, baseRollover, rootLock, grandChildren, dblclickTime, steps, style, group, inherit";
		var duo; if (duo = zob(zim.Connectors, arguments, sig, this)) return duo;
		z_d("67.39");		

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Connectors", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:null;
		if (zot(height)) height = DS.height!=null?DS.height:null;
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Connectors";

		if (zot(points)) points = DS.points!=null?DS.points:[[0,0], [100,0], [100,100], [0,100]];
		if (zot(node)) node = DS.node!=null?DS.node:new zim.Circle(10, zim.grey, zim.grey);
		node.removeFrom(); // in case centerReg() is used
		if (node.color == zim.clear && !node.hitArea) node.expand(0);
		if (zot(line)) line = DS.line!=null?DS.line:new zim.Line({
			length:10,
			thickness:3,
			color:zim.tin,
			strokeObj:{caps:"round"}
		});
		line.oStartLength = line.startLength;
		line.oEndLength = line.endLength;
		if (zot(num)) num = DS.num!=null?DS.num:10;
		if (zot(linear)) linear = DS.linear!=null?DS.linear:false;
		if (zot(linearWrap)) linearWrap = DS.linearWrap!=null?DS.linearWrap:true;

		if (zot(nodeRollColor)) nodeRollColor = DS.nodeRollColor!=null?DS.nodeRollColor:node.color.match("rgb")?node.color:node.color.lighten(.2);
		if (zot(nodeRollBorderColor)) nodeRollBorderColor = DS.nodeRollBorderColor!=null?DS.nodeRollBorderColor:node.borderColor;
		if (zot(nodeSelectedColor)) nodeSelectedColor = DS.nodeSelectedColor!=null?DS.nodeSelectedColor:zim.white;
		if (zot(nodeSelectedBorderColor)) nodeSelectedBorderColor = DS.nodeSelectedBorderColor!=null?DS.nodeSelectedBorderColor:node.borderColor;

		if (zot(baseColor)) baseColor = DS.baseColor!=null?DS.baseColor:node.color;
		if (zot(baseBorderColor)) baseBorderColor = DS.baseBorderColor!=null?DS.baseBorderColor:node.borderColor;
		if (zot(baseRollover)) baseRollover = DS.baseRollover!=null?DS.baseRollover:false;

		if (zot(min)) min = DS.min!=null?DS.min:node.radius?node.radius*2:Math.min(node.width,node.height);
		if (zot(max)) max = DS.max!=null?DS.max:null;
		if (zot(expand)) expand = DS.expand!=null?DS.expand:zim.mobile()?10:0;
		if (zot(dropType)) dropType = DS.dropType!=null?DS.dropType:"any"; // "any"; // "on", "off" // on is must be on another node, off is must be off other nodes
		if (zot(dropArray)) dropArray = DS.dropArray!=null?DS.dropArray:null;
		if (zot(continuous)) continuous = DS.continuous!=null?DS.continuous:false;
		if (zot(startIndex)) startIndex = DS.startIndex!=null?DS.startIndex:null;
		if (zot(duplicateLine)) duplicateLine = DS.duplicateLine!=null?DS.duplicateLine:true;
		if (zot(deleteNode)) deleteNode = DS.deleteNode!=null?DS.deleteNode:true;
		if (zot(dblclick)) dblclick = DS.dblclick!=null?DS.dblclick:true;
		if (zot(fullMove)) fullMove = DS.fullMove!=null?DS.fullMove:true;		

		if (zot(dblclickTime)) dblclickTime = DS.dblclickTime!=null?DS.dblclickTime:.5;
		var timeType = getTIME(dblclickTime);
		dblclickTime *= timeType=="s"?1000:1;

		if (zot(snapH)) snapH = DS.snapH!=null?DS.snapH:null;
		if (zot(snapV)) snapV = DS.snapV!=null?DS.snapV:null;

		if (zot(rootLock)) rootLock = DS.rootLock!=null?DS.rootLock:false;
		if (zot(grandChildren)) grandChildren = DS.grandChildren!=null?DS.grandChildren:true;
		if (zot(steps)) steps = DS.steps!=null?DS.steps:null;

		if (linear && points.length <= 1) {
			if (zon) zogy("Connector() - linear needs more than one point");
			return;
		}

		var that = this;

		var nodeCount = 0;
		that.node = node;
		that.line = line;
		var _steps = []; // as each connector is made the steps for original index, x and y are stored 

		var nodeColor = node.color;
		var nodeBorderColor = node.borderColor;
		// var offColor = zim.faint; // to reduce edge anti-aliasing

		var lines = that.lines = new zim.Container(width, height).addTo(that);
		var nodes = that.nodes = new zim.Container(width, height).addTo(that);
			

		if (points.type == "Blob" || points.type == "Squiggle") {
			var p = [];
			zim.loop(points.points, function (point) {
				p.push([point[0], point[1]]);
			});
			points = p;
		} else {
			// convert any convenience objects to array
			zim.loop(points, function(p, i) {
				if (p.constructor === {}.constructor) {
					points[i] = [p.x, p.y, p.startNode, p.endNode, p.startLength, p.endLength];
					if (p.base != null) points[i][0] = p.base;
					if (p.info != null) points[i][1] = p.info;
				}
			});
		}
		that.points = points;
		

		this.addNode = function(x, y, startNode, endNode, startLength, endLength) {
			if (linear) return; // cannot add nodes in linear
			return addNode(x, y, startNode, endNode, startLength, endLength);
		};

		function addNode (x, y, startNode, endNode, startLength, endLength, orientation) {
			if (x.addChild) {
				// adding connector to a base

				// {base:squares.items[0], info:[0,0,1,0], startNode:true, endNode:false, startLength:50, endLength:100},
				// [squares.items[0], [0,0,1,0], true, false, 50, 100], 

				// second value is a single number for all sides
				// or an array of two numbers for left/top and right/bottom
				// or an array of four numbers for left,right,top,bottom
				// 0 means none, -1 means both corners, -2 means first corner, -3 means second corner
				// [box1,3], [box2,[0,3]]
				// [[box1,3], [box2,-1]]
				// [[box1,[0,3,0,3]], [box2,[3,0,0,3]]] none left top, none right top

				// override rootLock and grandChildren
				// dropType = "on"; // // removed override of dropType in ZIM 016 patch
				rootLock = true;
				grandChildren = false;

				var base = x;

				if (!base.connectorMoveEvent) {
					if (!that.bases) that.bases = [];
					that.bases.push(base);
					base.connectorMoveEvent = base.on("pressmove", function () {						
						// move all nodes and redraw lines
						base.positionConnectors(base, true, true);
					});
					base.connectorUpEvent = base.on("pressup", function () {
						// move all nodes and redraw lines
						base.positionConnectors(base, true, true);
					});
					if (baseRollover) {
						base.connectorOverEvent = base.on("mouseover", function () {
							addBaseColors(base);
						});
						base.connectorOutEvent = base.on("mouseout", function () {
							removeBaseColors(base);
						});
					}
					base.positionConnectors = function(base, arrowAdjustStart, arrowAdjustEnd) {
						zim.loop(base.connectors, function (node) {
							var newPoint = base.parent.localToLocal(base.x-base.baseStart.x+node.nodeStart.x, base.y-base.baseStart.y+node.nodeStart.y, node.parent);
							node.x = newPoint.x;
							node.y = newPoint.y;
							drawLines(node, arrowAdjustStart, arrowAdjustEnd);
						});
						if (base.stage) base.stage.update();
					};
					base.setConnectorColors = function (color, borderColor, rollColor, rollBorderColor) {
						if (!zot(color)) base.connectorColor = color;
						if (!zot(borderColor)) base.connectorBorderColor = borderColor;
						if (!zot(rollColor)) base.connectorRollColor = rollColor;
						if (!zot(rollBorderColor)) base.connectorRollBorderColor = rollBorderColor;
						zim.loop(base.connectors, function (node) {
							if (!zot(color)) node.color = color;
							if (!zot(borderColor)) node.borderColor = borderColor;
						});
						return base;
					};
					base.setConnectorColors(baseColor, baseBorderColor, nodeRollColor, nodeRollBorderColor);
				}
				var baseBounds = base.getBounds();
				if (line.endHead)
				baseBounds;
				if (!Array.isArray(y)) y = [y, y];
				var basePoints = [];
				if (y.length==2) y = [y[0],y[1],y[0],y[1]];

				if (line.lineOrientation == zim.HORIZONTAL || line.lineOrientation == "auto") {
					zim.loop([y[0],y[1]], function (data,i) {
						if (data==-1 || data==-2) { // top and bottom or or top (side 1)
							var top = base.localToLocal(i==0?baseBounds.x:baseBounds.x+baseBounds.width, baseBounds.y, that);
							basePoints.push([top.x, top.y, zim.HORIZONTAL]);
						}
						if (data==-1 || data==-3) { // top and bottom or or top (side 2)
							var bot = base.localToLocal(i==0?baseBounds.x:baseBounds.x+baseBounds.width, baseBounds.y+baseBounds.height, that);
							basePoints.push([bot.x, bot.y, zim.HORIZONTAL]);
						}
						if (data > 0) {
							zim.loop(data, function (j, t) {
								var side = base.localToLocal(i==0?baseBounds.x:baseBounds.x+baseBounds.width, baseBounds.y+baseBounds.height*(j+1)/(t+1), that);
								basePoints.push([side.x, side.y, zim.HORIZONTAL]);
							});
						}
					});
				}
				if (line.lineOrientation == zim.VERTICAL || line.lineOrientation == "auto") {
					zim.loop([y[2],y[3]], function (data,i) {
						if (data==-1 || data==-2) { // top and bottom or or top (side 1)
							var left = base.localToLocal(baseBounds.x, i==0?baseBounds.y:baseBounds.y+baseBounds.height, that);
							basePoints.push([left.x, left.y, zim.VERTICAL]);
						}
						if (data==-1 || data==-3) { // top and bottom or or top (side 2)
							var right = base.localToLocal(baseBounds.x+baseBounds.width, i==0?baseBounds.y:baseBounds.y+baseBounds.height, that);
							basePoints.push([right.x, right.y, zim.VERTICAL]);
						}
						if (data > 0) {
							zim.loop(data, function (j, t) {
								var side = base.localToLocal(baseBounds.x+baseBounds.width*(j+1)/(t+1), i==0?baseBounds.y:baseBounds.y+baseBounds.height, that);
								basePoints.push([side.x, side.y, zim.VERTICAL]);
							});
						}
					});
				}
				base.connectors = [];
				base.baseStart = new zim.Point(base.x, base.y);
				zim.loop(basePoints, function (point) {
					var node = addNode(point[0], point[1], startNode, endNode, startLength, endLength, point[2]);
					if (startNode===false || (startNode!==true && base.startNode===false)) node.noMouse();
					addBaseConnector(base, node);					
				});
					
				setTimeout(function () {
					base.positionConnectors(base, true, true);
				}, 50);
				return that;

			} // end base node - then calls addNode again with each one

			var theNode = node.clone().loc(x, y, nodes).drag({boundary:boundary}).expand(expand);
			theNode.orientation = orientation;
			theNode.startLength = startLength;
			theNode.endLength = endLength;
			theNode.startNode = startNode;
			theNode.endNode = endNode;
			theNode.nodeColor = theNode.color;

			theNode.on("mouseover", overNode);
			theNode.on("mouseout", outNode);
			theNode.on("mousedown", downNode);
			theNode.on("pressmove", moveNode);
			theNode.on("pressup", upNode);
			if (deleteNode) theNode.hold(holdNode);
			theNode.nodeNum = nodeCount++;
			theNode.creations = [];
			return theNode;

		}

		// that.added(function () {
		function setNodes() {
			zim.loop(points, function (point, i) {
				var node = addNode(point[0], point[1], point[2], point[3], point[4], point[5]);
				// var node = addNode(point[0], point[1]);
				node.dropIndex = i;
				if (dropArray) node.dropArray = dropArray[i];
			});

			// for linear, loop through all nodes and give them before and after nodes
			if (linear) {
				nodes.loop(function (node, i, t) {
					if (i==0) {
						if (linearWrap) {
							node.before = nodes.getChildAt(t-1);
						} else {
							node.before = null;
						}
						node.after = nodes.getChildAt(i+1);
					} else if (i == t-1) {
						if (linearWrap) {
							node.after = nodes.getChildAt(0);
						} else {
							node.after = null;
						}
						node.before = nodes.getChildAt(i-1);
					} else {
						node.before = nodes.getChildAt(i-1);
						node.after = nodes.getChildAt(i+1);
					}
					if (linearOrder && i > 0) node.noMouse();
				});
			}
		}
		setNodes();
		that.setAvailableIndexes = function(indexes) {
			if (!Array.isArray(indexes)) indexes = [indexes];
			that.nodes.loop(function(node, i) {
				if (indexes.indexOf(i) == -1) node.noMouse();
				else node.mouse();
			});		
			return that;	
		}		
		if (!zot(startIndex)) that.setAvailableIndexes(startIndex);

		that.keyEvent = function (e) {
			if (deleteNode && (e.keyCode == 46 || e.key == "Backspace")) { // delete
				zim.loop(selectedList, function (obj) {
					if (obj && obj.parent) removeNode(obj);
				});
				if (that.stage) that.stage.update();
			}
		}
		WW.addEventListener("keydown", that.keyEvent);

		// EVENT FUNCTIONS

		function holdNode(e) {
			var stage = e.target.stage;
			var node = e.target;
			if (that.bases || (rootLock && !node.creator.creator)) return;
			if (node.adding) removeNode(node.creator);
			else removeNode(node);
			if (that.stage) that.stage.update();
		}

		function overNode(e) {
			var node = e.target;
			if (node.selected) return;
			node.color = node.base?node.base.connectorRollColor:nodeRollColor;
			node.borderColor = node.base?node.base.connectorRollBorderColor:nodeRollBorderColor;
			if (that.stage) that.stage.update();
		}
		function outNode(e) {
			var node = e.target;
			if (node.selected) return;
			node.color = node.base?node.base.connectorColor:node.nodeColor;
			node.borderColor = node.base?node.base.connectorBorderColor:nodeBorderColor;
			if (that.stage) that.stage.update();
		}

		var selectedList = [];
		var stagedownID;

		var downCount = 0;
		var downID;
		var downIndex;
		function downNode(e, stepping, moving, ctrl) {
			var child = e.target;			
			if (zot(child)) return;	
			// if (child.selected)	return;

			if (moving) {
				child.selected = true;
				selectedList = [];
				that.selectNode(child, !ctrl);
			}	

			
			downIndex = child.nodeNum; // used in record()
			if (!linear && (!rootLock || child.creator) && dblclick && !stepping) {
				if (downCount == 0) {
					downID = setTimeout(function () {
						downCount = 0;
						// also clear the selectedList if not mousing over an object in the selectedList
						// as the time for a double click to add an object to the selectedList has expired
						if (selectedList) {
							var frame = that.stage?that.stage.frame:WW.zdf;
							var clearMove = nodes.loop(function (node) {
								if (node.hitTestPoint(frame.mouseX, frame.mouseY) && node.selected) return false;
							});
							if (clearMove) clearselectedList();
						}
					}, dblclickTime);
				}
				downCount++;
			} 
			
			child.startX = child.x;
			child.startY = child.y;

			if (!linear && selectedList.length > 0) {
				zim.loop(selectedList, function (obj) {
					obj.startX = obj.x;
					obj.startY = obj.y;
				});
			}

			if (child.creations.length >= num || child.selected || (child.creator && !grandChildren)) return;


			child.adding = true;

			var parent = addNode(child.x, child.y).bot();

			// we can't drag a newly created object as the mousedown does not happen on it
			// so we could swap the two objects at the pressup
			// but this means that all the children of the dragging object would draw lines to the dragging object
			// 1. or we can swap all the properties and turn the new object into the parent creator
			// and the old object into the child creation
			// 2. when we swap, we have to tell its parent that we are swapping
			// 3. and we have to tell its children that we are swapping

			// 1. swap properties to child so it becomes parent
			parent.creations = child.creations;
			parent.creatorLine = child.creatorLine;
			parent.creator = child.creator;
			parent.orientation = child.orientation;
			parent.startX = child.startX;
			parent.startY = child.startY;
			parent.dropIndex = child.dropIndex;
			parent.dropArray = child.dropArray;
			parent.lineArray = child.lineArray;
			parent.color = parent.nodeColor = child.nodeColor;			

			parent.startLength = child.startLength;
			parent.endLength = child.endLength;
			parent.startNode = child.startNode;
			parent.endNode = child.endNode;
			
			var newNodeNum = parent.nodeNum;
			parent.nodeNum = child.nodeNum;
			child.nodeNum = newNodeNum;

			// adjust for bases
			if (child.base) {
				parent.base = child.base;
				parent.baseStart = child.baseStart;
				parent.nodeStart = child.nodeStart;
				parent.connectors = child.connectors;
				child.base = child.baseStart = child.nodeStart = child.connectors = null;
				if (parent.base.connectors) parent.base.connectors.splice(parent.base.connectors.indexOf(child), 1, parent);
				parent.color = parent.base.connectorColor;
				parent.borderColor = parent.base.connectorBorderColor;
				if (parent.base.startLength != null) line.startLength = parent.base.startLength;
				if (parent.base.endLength != null) line.endLength = parent.base.endLength;
			}
			if (child.startLength != null) line.startLength = child.startLength; // override base
			if (child.endLength != null) line.endLength = child.endLength;

			// adjust to handle linearWrap
			parent.before = child.before;
			parent.after = child.after;
			if (parent.before) parent.before.after = parent;
			if (parent.after) parent.after.before = parent;

			// 2. tell parent's original parent (creator, if there is one) that its creation has been swapped
			if (parent.creator) {
				var index = parent.creator.creations.indexOf(child);
				if (index != -1) parent.creator.creations.splice(index, 1, parent);
			}

			// 3. tell parent's children (other creations) that its creator has been swapped
			zim.loop(parent.creations, function(creation) {
				creation.creator = parent;
			});

			// set up properties for child
			child.creator = parent;
			child.creatorLine = line.clone(true).setPoints(child.x,child.y,child.x,child.y).addTo(lines).alp(0);
			// reset original
			line.startLength = line.oStartLength;
			line.endLength = line.oEndLength; 
			child.creatorLine.lineOrientation = child.orientation;
			child.creatorLine.node = child;
			child.creatorLine.creatorNode = parent;
			child.creations = [];
			if (child.veeObj && !zot(child.veeObj.color)) child.color = zim.Pick.choose(child.veeObj.color);
			else child.color = parent.color;
			child.nodeColor = child.color;
			parent.creations.push(child);			
			that.latestNode = child;

			if (rootLock) checkRootLock(child);
			

		}

		function moveNode(e, stepping, moving, ctrl) {
			var node = e.target;
			if (node.creatorLine) node.creatorLine.alp(1);
			// if nodes are selected that are not this node being dragged
			// then clear the selectedList rather than wait for the clear in the double click timeout
			if (!linear && selectedList.length > 0 && selectedList.indexOf(node) == -1) clearselectedList();
			drawLines(node, false, true);
			if (that.bases) {
				zim.loop(that.bases, function (base) {
					if (node.creator && node.creator.base == base) return;
					if (!base.connectorsOn && node.hitTestBounds(base)) {
						addBaseColors(base);
					}
					if (base.connectorsOn && !node.hitTestBounds(base)) {
						removeBaseColors(base);
					}
				});
			}
			if (that.stage) that.stage.update();
		}

		function upNode(e, stepping, moving, ctrl) { 
			var node = e.target;
			if (that.bases) {
				zim.loop(that.bases, function (base) {
					if (base == node.base) return;
					if (base.connectorsOn) {
						removeBaseColors(base);
					}
				});
			}		
			
			var dbl = false;
			if (!linear && downCount > 1 && !stepping) { // double click
				clearTimeout(downID);
				var n = node.adding?node.creator:node;
				if (node.adding) removeNode(n.creations[n.creations.length-1], true);
				if (!n.selected) {
					var frame = that.stage?that.stage.frame:WW.zdf;
					selectNode(n, !frame.ctrlKey);
				}
				downCount = 0;
				dbl = true;
			}
			if (!linear && !that.base) {
				// test for snap
				if (snapH) node.x = Math.round(node.x / snapH)*snapH;
				if (snapV) node.y = Math.round(node.y / snapV)*snapV;
			}
			if ((min && zim.dist(node.x, node.y, node.startX, node.startY) < min) || (max && zim.dist(node.x, node.y, node.startX, node.startY) > max)) {				
				if (node.adding) {
					removeNode(node, true);
				} else {
					node.loc(node.startX, node.startY);
					if (!dbl) drawLines(node); // drawing twice on double was causing bug
				}
				if (that.stage) that.stage.update();
				that.lastNode = null;
				that.targetNode = null;
				that.dispatchEvent("noconnection");
				return;
			}
			var complete = false;
			var connected = false;
			if (linear) {
				// must be hitting either active before or after
				// must remove target before or after too
				var parentNode = node.creator;
				that.connectionStart = parentNode;
				that.connectionEnd = node;

				if (parentNode.before && node.hitTestCircle(parentNode.before) && !linearOrder) {
					node.loc(parentNode.before).removeFrom();
					parentNode.before.after = null;
					if (!parentNode.before.before) parentNode.before.noMouse();
					parentNode.before = null;
					if (!parentNode.after) parentNode.noMouse();
					connected = true;
					complete = testComplete();
				} else if (parentNode.after && node.hitTestCircle(parentNode.after)) {
					node.loc(parentNode.after).removeFrom();
					parentNode.after.before = null;
					if (!parentNode.after.after) parentNode.after.noMouse();
					if (linearOrder) parentNode.after.mouse();
					parentNode.after = null;
					if (!parentNode.before) parentNode.noMouse();
					if (linearOrder) parentNode.noMouse();
					connected = true;
					complete = testComplete();
				} else {
					if (!parentNode || node.creations.length > 0) {
						node.loc(node.startX, node.startY).bot();
					} else {
						removeNode(node, true);
						if (that.stage) that.stage.update();
						that.lastNode = null;
						that.targetNode = null;
						that.dispatchEvent("noconnection");
						return;
					}
				}
			} else {
				if (dropType == "off") { // can't be on a node
					var good = nodes.loop(function (obj) {
						if (node == obj) return;
						if (node.hitTestCircles(obj)) {
							if (node.adding) removeNode(node, true);
							else {
								node.loc(node.startX, node.startY);
								drawLines(node);
							}
							if (rootLock) checkRootLock(node);
							if (!fullMove && node.creator && num > 0 && node.creator.creations.length >= num) node.creator.noMouse();
							that.targetNode = obj;			
							if (continuous) {
								that.nodes.loop(function(node) {
						            if (node != that.latestNode) node.noMouse();
						        });
							}	
							if (continuous) {
								that.nodes.loop(function(node) {
									if (node != that.latestNode) node.noMouse();
								});
							}			
							record(); 
							that.dispatchEvent("connection");
							if (that.stage) that.stage.update();
							return;
						}
					});
					if (!good) {
						noConnect(node);
						return;
					}
				} else if (dropType == "on" || dropType == "single") { // can't be off a node					
					var hitCount = 0;
					var hitObj;
					var bad = nodes.loop(function (obj) {
						if (node == obj) return;
						if (node.hitTestCircles(obj)) {
							hitObj = obj;	
							hitCount++;
							hitCount+=obj.creations.length;			
							if (that.bases && (obj.endNode===false || (obj.endNode!==true && obj.base && obj.base.endNode===false) || node.orientation != obj.orientation || (node.creator && node.creator.base && node.creator.base == obj.base))) return "no";
							if (node.dropArray) if (node.dropArray.indexOf(obj.dropIndex) == -1) return;
							if (!duplicateLine && node.lineArray && node.lineArray.indexOf(obj.dropIndex) != -1) return;
							if (dropType == "on") return false; // bad will be true
							// hitCount++;
							// hitCount+=obj.creations.length;
						}
					});					
					if (bad=="no" || (bad && !(dropType=="single" && hitCount==1))) {
						noConnect(node);
						return;
					} else {	
						node.loc(hitObj);
						if ((node.creator && node.orientation==zim.VERTICAL && Math.round(node.y) == Math.round(node.creator.startY)) || (node.creator && node.orientation==zim.HORIZONTAL && Math.round(node.x) == Math.round(node.creator.startX))) return;
						that.targetNode = hitObj;
						var lastIndex = node.dropIndex;
						node.dropIndex = hitObj.dropIndex;
						node.dropArray = zim.copy(hitObj.dropArray);
						if (!hitObj.lineArray) hitObj.lineArray = [lastIndex]; 
						else hitObj.lineArray.push(lastIndex); // just in case the top node is removed
						node.lineArray = zim.copy(hitObj.lineArray);	
						if (node.creator) {
							if (!node.creator.lineArray) node.creator.lineArray = [];
							node.creator.lineArray.push(node.dropIndex);		
						}				
						// TODO: add more lineType options like a side connector (down/across/up) and an elbow connector (down/up)
						if (hitObj.base && hitObj.base.connectors) addBaseConnector(hitObj.base, node);
						connected = true; // ZIM ZIM 02 - changed this from complete to connected - think it was an original typo
					}					
				} else {
					// if we made a line then a connection otherwise it is just a move
					if (!node.selected) connected = true;
				}
			}

			if (!fullMove && node.creator && num > 0 && node.creator.creations.length >= num) node.creator.noMouse();

			node.adding = false;
			drawLines(node, true, true); // true handles any triangles
			zim.loop(selectedList, function (obj) {
				// if the node's creator is not in the list record it but need to know the ctrl flag 
				// so if no children in the list then ctrl 1 else if there are children then ctrl 0 
				if (selectedList.indexOf(obj.creator)==-1) {
					var alone = zim.loop(obj.creations, function(creation) {
						if (selectedList.indexOf(creation) >= 0) return false;
					});
					record(obj.nodeNum,null,zim.decimals(obj.x,2),zim.decimals(obj.y,2),(alone || alone===undefined)?1:0);
				}			
				obj.startX = obj.x;
				obj.startY = obj.y;		
			});
						
			node.startX = node.x;
			node.startY = node.y;
			if (rootLock) checkRootLock(node);

			if (connected) {
				if (continuous) {
					that.nodes.loop(function(node) {
						if (node != that.latestNode) node.noMouse();
					});
				}
				record();
				that.dispatchEvent("connection");
				if (zim.arraysEqual(node.dropArray, node.lineArray, false)) that.dispatchEvent("blocked");
			} else {
				that.dispatchEvent("noconnection");
			}
			if (complete) that.dispatchEvent("complete");

			if (that.stage) that.stage.update();
		}
		
		

		// STEPS 	
		
		function record(i,d,x2,y2,ctrl) { // index, d (deleting), x2,y2 (moving), ctrl is whether parent node is single when moving (no children selected)
			if (d) _steps.push([i,null,null,1]); // deleting			
			else if (!zot(x2)) _steps.push([i,null,null,null,x2,y2,ctrl]); // moving
			else _steps.push([downIndex, zim.decimals(that.latestNode.x,2), zim.decimals(that.latestNode.y,2)]); // connecting
		}
		
		that.makeConnection = function(node, x, y, move, ctrl) {		
			var frame = that.stage?that.stage.frame:WW.zdf;		
			if (move) {
				frame.ctrlKey = ctrl==1?true:false;							
				downNode({target:node}, true, true, ctrl);
				node.loc(x,y);
				moveNode({target:node}, true, true, ctrl);
				upNode({target:node}, true, true, ctrl);
			} else {
				downNode({target:node}, true, false, null);
				that.latestNode.loc(x,y);			
				moveNode({target:that.latestNode}, true, false, null);
				upNode({target:that.latestNode}, true, false, null); 
			}
			
			frame.ctrlKey = false;
			return that.latestNode;
		}
		
		
		function getNodeFromNum(num) {
			var n = that.nodes.loop(function(node) {
				if (node.nodeNum==num) return node;
			});
			if (n.type) return n;
		}
				
		that.setSteps = function(steps) {
			zim.loop(steps, function(step) {
				var n = getNodeFromNum(step[0]);
				if (n) {
					if (step[3]) { // delete 
						if (n) removeNode(n);
					} else if (!zot(step[4])) { // move
						that.makeConnection(n, step[4], step[5], true, step[6]);
						clearselectedList();
					} else {
						that.makeConnection(n, step[1], step[2]);
					} 		
				}	
			});			
			return that;
		}
		that.applySteps = that.setSteps; // backwards compatibility
		
		that.getSteps = function(popup) {
			if (popup) {
				if (!that.stage) that.stage = zdf.stage;
				if (!that.pane) {
					that.pane = new zim.Pane({
						displayClose:false,
						container:that.stage,
						width:Math.min(500, that.stage.width-20),
						height:Math.min(500, that.stage.height-20),
						draggable:true,
					});
					that.textArea = new zim.TextArea(Math.min(400, that.stage.width-70), Math.min(400, that.stage.height-70))
					that.pane.add(that.textArea);
				} 
				that.pane.show();		
				that.textArea.text = JSON.stringify(_steps);
			}				
			return _steps;
		}
		
		Object.defineProperty(this, 'steps', {
			get: function() {
				return _steps;
			},
			set: function(steps) {
				that.setSteps(steps);
			}
		});

		// HELPER FUNCTIONS

		function noConnect(node) {
			if (node.adding || !grandChildren) removeNode(node, true);
			else {
				node.loc(node.startX, node.startY);
				drawLines(node);
			}
			if (rootLock) checkRootLock(node);
			if (node.base && node.base.connectors) removeBaseConnector(node.base, node);
			that.lastNode = null;
			that.targetNode = null;
			that.dispatchEvent("noconnection");
			if (that.stage) that.stage.update();
		}

		function addBaseColors(base) {
			zim.loop(base.connectors, function (node) {
				node.color = base.connectorRollColor;
				node.borderColor = base.connectorRollBorderColor;
			});
			base.connectorsOn = true;
			if (base.stage) base.stage.update();
		}
		function removeBaseColors(base) {
			zim.loop(base.connectors, function (node) {
				node.color = base.connectorColor;
				node.borderColor = base.connectorBorderColor;
			});
			base.connectorsOn = false;
			if (base.stage) base.stage.update();
		}
		
		// zim.loop(base.connectors, function (node) {
		// 	var newPoint = base.parent.localToLocal(base.x-base.baseStart.x+node.nodeStart.x, base.y-base.baseStart.y+node.nodeStart.y, node.parent);
		// 	node.x = newPoint.x ;
		// 	node.y = newPoint.y ;
		// 	drawLines(node, arrowAdjustStart, arrowAdjustEnd);
		// });

		function addBaseConnector(base, node) {			
			base.connectors.push(node);
			node.nodeStart = node.parent.localToLocal(node.x, node.y, base.parent);
			node.nodeStart.x -= base.x - base.baseStart.x;
			node.nodeStart.y -= base.y - base.baseStart.y;
			node.base = base;
		}

		function removeBaseConnector(base, node) {
			base.connectors.splice(base.connectors.indexOf(node), 1);
			node.nodeStart = null;
			node.base = null;
		}

		function checkRootLock(node) {
			if (!node.creator) return;
			// stops base from being dragged or doubleClicked
			if (node.creator.creator) {
				checkRootLock(node.creator);
				return;
			}
			if (node.creator && node.creator.creations.length >= num) node.creator.noMouse();
			else node.creator.mouse();
		}

		function selectNode(n, children) {
			if (children) {
				zim.loop(n.creations, function (c) {
					selectNode(c, children);
				});
			}
			n.selected = true;
			n.color = n.base?n.base.connectorColor:nodeSelectedColor;
			n.borderColor = n.base?n.base.connectorBorderColor:nodeSelectedBorderColor;
			selectedList.push(n);
			n.top();

			if (!stagedownID) {
				stagedownID = that.stage.on("stagemousedown", function () {
					// test if mouse down on any objects
					// would have only cleared if not on any objects in selectedList (selected true)
					// but have to wait for the double click to see if we are adding an object to the selectedList
					// so final clear if clicking on a non-selectedList node is on the expiry of the double click timeout
					// there is also a clearselectedList in the pressmove event
					var frame = that.stage?that.stage.frame:WW.zdf;
					var clearMove = nodes.loop(function (node) {
						if (node.hitTestPoint(frame.mouseX, frame.mouseY)) return false;
					});
					if (clearMove) clearselectedList();
				});
			}
		}
		this.selectNode = function(node, children) {
			selectNode(node, children);
		};


		function testComplete() {
			var complete = nodes.loop(function (node) {
				if (node.before || node.after) {
					return false;
				}
			});
			if (complete) {
				nodes.loop(function (node) {
					node.noMouse();
				});
				return true;
			}
		}

		function clearselectedList() {
			zim.loop(selectedList, function (obj) {
				obj.selected = false;
				obj.color = obj.base?obj.base.connectorColor:obj.nodeColor;
				obj.borderColor = obj.base?obj.base.connectorBorderColor:nodeBorderColor;
			});
			selectedList = [];
			that.stage.off("stagemousedown", stagedownID);
			stagedownID = null;
			if (that.stage) that.stage.update();
		}

		function drawLines(node, arrowAdjustStart, arrowAdjustEnd) {
			// may have multiple nodes to drag if there is a selectedList
			var list = selectedList.length>0?selectedList:[node];
			zim.loop(list, function (obj) {
				// move other objects to match
				if (obj != node) obj.loc(obj.startX+node.x-node.startX, obj.startY+node.y-node.startY);
				// draw line back to parent
				if (obj.creator) {
					obj.creatorLine.setPoints(obj.x, obj.y, obj.creator.x, obj.creator.y, arrowAdjustStart, arrowAdjustEnd);
				}
				// draw lines to children
				zim.loop(obj.creations, function (creation) {
					creation.creatorLine.setPoints(creation.x, creation.y, creation.creator.x, creation.creator.y, arrowAdjustStart, arrowAdjustEnd);
				});
			});
		}

		function removeNode(node, count) {
			zim.loop(node.creations, function (creation) {
				removeNode(creation);
			}, true);
			if (node.creatorLine) {
				node.creatorLine.removeFrom();
				var index = node.creator.creations.indexOf(node);
				if (index != -1) node.creator.creations.splice(index, 1);
				// if dragFull then might have noMoused the creator - so mouse the creator as long as not a base and lockBase
				if (!node.creator.mouseEnabled && !(rootLock && !node.creator.creator)) node.creator.mouse();
			}
			node.removeFrom();
			node.removeAllEventListeners();			
			if (count) nodeCount--;
			else record(node.nodeNum, 1); // record an actual deleted node - not one that was made when deleting
			node = null;
			return that;
		}
		this.removeNode = function(node) {
			removeNode(node);
		};

		// function arrive(node) {
		// 	// turn all node colors off except for the dragging node
		// 	nodes.loop(function (n) {
		// 		if (node == n) return;
		// 		if (node.type == "Circle") {
		// 			if (n.hitTestCircles(node)) n.color = offColor;
		// 		} else {
		// 			if (n.hitTestBounds(node)) n.color = offColor;
		// 		}
		// 	});
		// }
		
		// function leave(node) {
		// 	// turn all nodes off except one
		// 	var set = false;
		// 	nodes.loop(function (n) {
		// 		if (node == n) return;
		// 		if (node.type == "Circle") {
		// 			if (n.hitTestCircles(node)) {
		// 				if (!set) {
		// 					n.color = nodeColor;
		// 					set = true;
		// 				} else {
		// 					n.color = offColor;
		// 				}
		// 			}
		// 		} else {
		// 			if (n.hitTestBounds(node)) {
		// 				if (!set) {
		// 					n.color = nodeColor;
		// 					set = true;
		// 				} else {
		// 					n.color = offColor;
		// 				}
		// 			}
		// 		}
		// 	});
		// }

		this.removeConnectors = function() {
			zim.loop(nodes, function (node) {
				removeNode(node);
			}, true);
			setNodes();
			if (that.stage) that.stage.update();
		};

		this.removeBase = function(base) {
			zim.loop(base.connectors, function (node) {
				removeNode(node);
			});
			clearBaseEvents(base);
		};

		this.addBase = function(base, baseInfo) {
			addNode(base, baseInfo);
		};

		function clearBaseEvents(base) {
			base.off("pressmove", base.connectorMoveEvent);
			base.off("pressup", base.connectorUpEvent);
			if (base.connectorOverEvent) base.off("mouseover", base.connectorOverEvent);
			if (base.connectorOutEvent) base.off("mouseout", base.connectorOutEvent);
			base.connectors = null;
			base.baseStart = null;
			base.positionConnectors = base.setConnectorColors = null;
			base.connectorColor = base.connectorBorderColor = base.connectorRollColor = base.connectorRollBorderColor = null;
			that.bases.splice(that.bases.indexOf(base), 1);
			if (that.stage) that.stage.update();
		}
				
		if (steps) that.added(function(){
			that.setSteps(steps);
			that.stage.update();
		});

		Object.defineProperty(this, 'selectedList', {
			get: function() {
				return selectedList;
			},
			set: function() {
				if (zon) zogy("Selectors() - selectedList is read only");
			}
		});

		this.dispose = function(a,b,disposing) {

			that.nodes.loop(function (node) {
				node.removeFrom();
				node.removeAllEventListeners();
				node = null;
			}, true);
			that.lines.loop(function (line) {
				line.removeFrom();
				line = null;
			}, true);
			
			WW.removeEventListener("keydown", that.keyEvent);	
			that.keyEvent = null;
			
			if (that.bases) {
				zim.loop(that.bases, function (base) {
					clearBaseEvents(base);
				});
			}
			if (!disposing) {
				that.zimContainer_dispose(true);
				if (that.stage) that.stage.update();
			}
			return true;
		};

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Connectors(width, height, points, node, line, linear, linearWrap, linearOrder, num, snapH, snapV, dropType, zim.copy(dropArray), continuous, startIndex, duplicateLine, deleteNode, dblclick, fullMove, min, max, boundary, expand, nodeRollColor, nodeRollBorderColor, nodeSelectedColor, nodeSelectedBorderColor, baseColor, baseBorderColor, baseRollover, rootLock, grandChildren, dblclickTime, steps, style, that.group, inherit));
		};
	};
	zim.extend(zim.Connectors, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-67.39


/*--
zim.Marquee = function(width, height, items, time, transition, speed, direction, marginLeft, marginRight, marqueeType, borderColor, borderWidth, refresh, mix, style, group, inherit)

Marquee
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A display for ads and promos using an optional ZIM Indicator with pause button.
The Marquee uses the ZIM Pages class to transition multiple items.
The items can be interactive ZIM objects made ahead of time and passed into the items parameters
Images can also be loaded with the load() method.

See: https://zimjs.com/marquee.html for an example
See: zim Carousel as well for a more simple object with arrows

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
	const promo1 = new Container(600, 200);
	new Rectangle(promo1.width, promo1.height, yellow).addTo(promo1);
	new Circle(30, red).center(promo1).drag();

	// could be more

	// optionally or alternatively, specify a Marquee object
	// there can be multiple image properties using end src as key
	// just use null as value if no URL
	const marqueeData = {"retina.jpg": ["https://zimjs.com/retina.html", "_blank"]};
	const marqueePath = "assets/";

	// create Marquee
	// note the actual width of marquee will be 25+25 more for added margins (optional)
	const marquee = new Marquee(600, 200, [promo1])
		.center()
		.load(marqueeData, marqueePath);
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 300) width of marquee content
	final marquee width will have marginLeft and marginRight added to this width
height - (default 100) height of content and marquee
items - default(null) an array of Display Objects - can be interactive
time - default(5) time interval in seconds for changing items (also see ZIM TIME constant)
	also see marqueeTime property for each item to individually override the time for viewing
transition - default("slide") the transition between items
	options are: "none", "reveal", "slide", "fade", "clear", "black", "white", "fan"
speed - default(.5) speed of transition in seconds (also see ZIM TIME constant)
direction - default(RIGHT) location of next item relative to current item
	options are: RIGHT, LEFT, UP, DOWN
marginLeft - default(25) width at left of content for Indicator and Pause button
	set to 0 to not show indicator and pause button
marginRight - default(25) width at right of content for Z logo with animated MARQUEE
	set to 0 to not show Z logo with animated MARQUEE
marqueeType - (default "dot" or "circle") the Indicator type - also "box" or "square"
borderColor - (default dark) border color - any ZIM or HTML color - set to -1 for no border
borderWidth - (default 1) width of border if borderColor - set to 0 for no border
refresh - (default 30*60 seconds) page refresh to handle browser memory build
mix - (default true) randomize content and then play in that order - different for each page load
	note: loaded files will always come after initial marquee items
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(obj, url, target) - add a Display Object (obj) - can be interactive content - returns obj for chaining
	can provide an overall url and target for url
	but often will provide navigation button, etc. as part of interactive content
remove(obj) - remove an object from the marquee - returns obj for chaining
	will also call a dispose() method on the obj if there is one
go(page) - transition to specific page (obj) or index - returns obj for chaining
pause(state, immediate) - pause or unpause the Marquee - returns obj for chaining
	can be used by interactive code to pause Marquee when interacting
	immediate (default false) set to true to make the Marquee go to next item right away when unpausing (no effect when pausing)
load(data, path) - Marquee object for images their optional action url and target: - returns obj for chaining
 	data in format: {imageSrc:"actionURL", imageSrc:["actionURL", "target"], etc.}
	path: optional directory location such as a relative path: "assets/"
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
content - a reference to the ZIM Container that holds the content
pages - a reference to the ZIM Pages object that holds the items
	use pages.pages to access an array of pages, etc. - see Pages Class
button - a reference to the pause/play button if there is one
indicator - a reference to the ZIM Indicator if there is one - see Indicator Class
selectedIndex - the selected index of the Marquee
selected - the selected item of the Marquee
lastSelected - the last selected item of the Marquee
time - get or set the time of the marquee (between changing items)
speed - get the speed of the transition
paused - read only property as to whether the Marquee is paused - see pause() method
interval - a reference to the ZIM interval
left - a reference to the left Container
right - a reference to the right Container if there is one
icon - a reference to the Z icon if there is one
label - a reference to the MARQUEE Label that pops out of the Z if there is one
	eg. label.visible = false to not show label popping out
marqueeLoader - a reference to the ZIM loadAssets queue if load() is used

Each item gets a marquee property that points to the ZIM marquee it is in
Each item gets a marqueViews property recording how many times viewed
Each item can have a marqueeTime property set to ms to customize its view time

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "page" event when item starts to change
dispatches a "pagetransitioned" event when item finishes changing

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.4

	zim.Marquee = function(width, height, items, time, transition, speed, direction, marginLeft, marginRight, marqueeType, borderColor, borderWidth, refresh, mix, style, group, inherit) {
		var sig = "width, height, items, time, transition, speed, direction, marginLeft, marginRight, marqueeType, borderColor, borderWidth, refresh, mix, style, group, inherit";
		var duo; if (duo = zob(zim.Marquee, arguments, sig, this)) return duo;
		z_d("67.4");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Marquee", this.group, inherit);
		var that = this;

		if (zot(width)) width = DS.width!=null?DS.width:300;
		if (zot(height)) height = DS.height!=null?DS.height:100;
		var timeType = getTIME(time);
		if (zot(time)) time = DS.time!=null?DS.time:timeType=="s"?5:5000;
		if (zot(transition)) transition = DS.transition!=null?DS.transition:"slide";
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zim.dark;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:1;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(marginLeft)) marginLeft = DS.marginLeft!=null?DS.marginLeft:25;
		if (zot(marginRight)) marginRight = DS.marginRight!=null?DS.marginRight:25;
		if (zot(speed)) speed = DS.speed!=null?DS.speed:timeType=="s"?.5:500;
		checkTIME(speed, timeType);
		if (zot(direction)) direction = DS.direction!=null?DS.direction:"right";
		if (zot(refresh)) refresh = DS.refresh!=null?DS.refresh:timeType=="s"?30*60:30*60*1000; // 30 minutes
		if (zot(mix)) mix = DS.mix!=null?DS.mix:true;
		this.zimContainer_constructor(width+marginLeft+marginRight,height,null,null,false);
		this.type = "Marquee";
		this.speed = speed;

		var mask = new zim.Rectangle(width-1,height-1,zim.clear).addTo(that).mov(marginLeft+.5, .5);

		var content = this.content = new zim.Container(width, height)
			.loc(marginLeft,0,that)
			.setMask(mask);
		var pages = this.pages = new zim.Pages(null, transition, speed, null, content).addTo(content);

		var startCheck = false;
		this.add = function(obj, url, target, skip, center) {
			if (zot(center)) center = true;
			obj.scaleTo(content,100,100);
			if (url) obj.cur().on("click", function() {
				zgo(url, target);
			});
			pages.addPage(obj);
			if (center) pages.center();
			obj.marqueeViews = 0;
			obj.marquee = that;
			if (!startCheck) startSelection();
			if (!skip) makeIndicator();
			if (border) border.top();
		};
		this.remove = function(obj) {
			if (that.selected == obj) {
				if (that.pages.pages.length == 1) return;
				var newIndex = that.selectedIndex+1;
				if (newIndex == that.pages.pages.length) newIndex = 0;
				that.pages.go(newIndex,null,null,0);
				setTimeout(function () {
					that.pages.removePage(obj);
					if (obj.dispose) obj.dispose();
					makeIndicator();
				}, 20);
			} else {
				that.pages.removePage(obj);
				if (obj.dispose) obj.dispose();
				makeIndicator();
			}
		};
		function startSelection() {
			startCheck = true;
			that.selectedIndex = 0;
			that.selected = pages.pages[that.selectedIndex].page;
			that.lastSelected = null;
			if (that.selected.marqueeOn) that.selected.marqueeOn();
			that.interval = zim.interval(time, function () {
				that.go();
			});
		}

		if (!zot(items) && !Array.isArray(items)) items = [items];
		if (items && items.length > 0) {
			if (mix) zim.shuffle(items);
			zim.loop(items, function (item) {
				that.add(item, null, null, true); // don't make indicator
			});
		}

		if (refresh > 0) var to = zim.timeout(refresh*(timeType=="s"?1000:1), function(){
			location.reload();
		}, null, "ms");

		that.go = function(page) {
			that.selected.marqueeViews+=1;
			if (that.selected.marqueeOff) that.selected.marqueeOff();
			if (page) {
				that.selected = page;
				zim.loop(pages.pages, function (p,i) {
					if (p.page==page) {
						that.selectedIndex = i;
						return;
					}
				});
				that.interval.interval = that.selected.marqueeTime ? that.selected.marqueeTime : time;
				that.interval.pause(pause.toggled, null, true); // reset time
			} else {
				var next = that.selectedIndex+1;
				that.selectedIndex = next%pages.pages.length;
				that.selected = pages.pages[that.selectedIndex].page;
				that.interval.time = that.selected.marqueeTime ? that.selected.marqueeTime : time;
			}
			that.dispatchEvent("page");
			if (that.selected.marqueeOn) that.selected.marqueeOn();
			pages.go(that.selected, direction, transition, speed);
		};

		pages.on("pagetransitioned", function () {
			that.dispatchEvent("pagetransitioned");
			if (that.indicator) that.indicator.selectedIndex = that.selectedIndex;
		});

		// ~~~~~~~~~~~~
		// LEFT

		var _paused = false;
		var left = that.left = new zim.Container(marginLeft-4,height-4);

		var pauseIcon = new zim.Shape().sca(.6);
		pauseIcon.graphics.f(zim.light).mt(0,0).p("AAhCLIAAkVIBXAAIAAEVgAh3CLIAAkVIBXAAIAAEVg");
		var playIcon = new zim.Shape().sca(.6).reg(-2,0);
		playIcon.graphics.f(zim.light).mt(0,0).p("AiJieIETCeIkTCfg");
		var pause = that.button = new zim.Button({
			label:"",
			icon:pauseIcon,
			toggleIcon:playIcon,
			width:45,
			height:45,
			corner:0,
			shadowBlur:0
		})
			.scaleTo(left, 100)
			.pos(0,0,false,true,left);
		pause.on("click", function () {
			if (that.interval) that.interval.pause(pause.toggled);
			_paused = pause.toggled;
			that.stage.update();
		});

		var prop;
		function makeIndicator() {
			if (zot(marginLeft) || marginLeft==0) return;

			var gutterLeft = 4*marginLeft/25;
			left.pos((marginLeft-left.width)-gutterLeft,gutterLeft/2,false,true,that);

			if (that.indicator) {
				that.indicator.dispose();
				that.indicator.removeFrom();
			}
			if (!prop) prop = new zim.Proportion(8,16,left.width+gutterLeft,left.width/2+gutterLeft,-1);
			that.indicator = new zim.Indicator({
				width:(pages.pages.length<=2?pages.pages.length:pages.pages.length-1)*(left.width-3),
				height: prop.convert(pages.pages.length),
				num: pages.pages.length,
				shadowBlur:-1,
				interactive:true,
				scale:1.2,
				indicatorType:marqueeType
			});
			that.indicator.fit(0,0,height-pause.height,pause.width);
			that.indicator.rot(direction=="down"?-90:90)
				.center(left)
				.pos(null,left.width-gutterLeft/2,null,true);
			that.indicator.selectedIndex = that.selectedIndex;
			that.indicator.on("change", function () {
				that.go(pages.pages[that.indicator.selectedIndex].page);
			});
		}
		makeIndicator();

		// ~~~~~~~~~~~~~
		// RIGHT

		if (!zot(marginRight) && marginRight>0 && WW.zdf && WW.zdf) {
			var gutterRight = 4*marginRight/25;
			var right = that.right = new zim.Container(45,270);
			var icon = that.icon = WW.zdf.makeIcon(zim.grey, zim.lighter, zim.silver)
				.sca(.5)
				.pos(0,0,true,true,right)
				.mov(0,0)
				.cur();
				// .sha(white,0,1,1);
			icon.on("mouseover", function () {
				lab.animate({props:{scaleX:1}, time:500, ease:"backOut", override:true, timeUnit:"ms"});
				icon.stage.update();
			});
			icon.on("mouseout", function () {
				lab.animate({props:{scaleX:0}, time:300, ease:"backIn", override:true, timeUnit:"ms"});
				icon.stage.update();
			});
			icon.on("mousedown", function () {
				zgo("https://zimjs.com/marquee", "_blank");
			});

			var lab = that.label = new zim.Label({
				text:"MARQUEE",
				color:zim.dark,
				backgroundColor:zim.lighter,
				shiftV:1,
				paddingV:5
			})
				.rot(-90)
				.pos(0,13,true,false,right)
				.reg(-10)
				.sca(0,1)
				.mov(0);

			right.fit(0,0,marginRight-gutterRight,height-gutterRight);
			right.pos(marginRight-right.width-gutterRight,gutterRight/2,true,true,that);
		}

		if (that.stage) that.stage.update();

		this.pause = function(state, immediate) {
			if (zot(state)) state = true;
			if (state == _paused) return;
			_paused = state;
			that.interval.pause(state, immediate);
			that.button.toggle(state);
		};

		Object.defineProperty(this, 'paused', {
			get: function() {
				return _paused;
			},
			set: function() {
				if (zon) zogy("Marquee() - paused is read only - use pause()");
			}
		});

		Object.defineProperty(this, 'time', {
			get: function() {
				return time;
			},
			set: function(value) {
				time = value;
				that.interval.time = time;
			}
		});

		this.load = function(data, path) {
			// Load any marqueeAssets with lazy-loading
			var a = []; // make an array of only the asset urls
			if (mix) zim.shuffle(data);
			zim.loop(data, function(asset) {
				if (Array.isArray(asset)) a.push(asset[0]); // could have target window
				else a.push(asset);
			});
			var frame = that.stage?that.stage.frame:WW.zdf;
			that.marqueeLoader = frame.loadAssets(a, path);
			that.loadEvent = that.marqueeLoader.on("assetload", function (e) {
				var d = data[e.asset.id];
				var u,t;
				if (Array.isArray(d)) {
					u = d[0];
					t = d[1];
				} else {
					u = d;
					t = "_self";
				}
				that.add(e.asset, u, t);
				makeIndicator();
			});
			return that;
		};

		if (!zot(borderColor)) {
			var border = new zim.Rectangle(width-1, height-1, zim.clear, borderColor, borderWidth).loc(mask,null,that);
			border.mouseEnabled = false;
		}

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {return that.cloneProps(new zim.Marquee(width, height, items, time, transition, speed, direction, marqueeType, borderColor, borderWidth, refresh, mix, style, this.group, inherit));};

		this.dispose = function (a,b,disposing) {
			if (to) to.clear();
			if (that.interval) that.interval.clear();
			if (that.loadEvent) that.marqueeLoader.off("assetload", that.loadEvent);
			pages.dispose();
			pages = null;
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};

	};
	zim.extend(zim.Marquee, zim.Container, ["clone", "dispose"], "zimContainer");
	//-67.4
	
/*--
zim.Carousel = function(items, viewNum, time, spacing, backgroundColor, backing, padding, paddingH, paddingV, arrowLeft, arrowRight, arrowGap, valign, ease, swipe, remember, selectedIndex, continuous, style, group, inherit)

Carousel
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A horizontal display for multiple objects with arrows at sides to animate to previous and next.
This is good for sliding banners, or sliding through a set of icons.
Items will be tiled in a ZIM Tile with one row.
It is expected that the items be the same width and height
but if not, the items will have width set to the most common width and heights aligned vertically to the valign setting.
Thank you Marva for the idea and original code!

See: ZIM Marquee for a more complex alternate format with Indicator
See: https://zimjs.com/zim/carousel.html for an example

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
	const items = [
		new Rectangle(400,80,red).tap(()=>{zog("red");}),
		new Rectangle(400,80,green).tap(()=>{zog("green");}),
		new Rectangle(400,80,blue).tap(()=>{zgo("https://zimjs.com","_blank");})
	];
	new Carousel(items, 1).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
items - default(seven multicolored rectangles) an array of Display Objects - can be interactive
	items will be scaled to the most common width and tiled - see the tile property	
	a String item will be converted to a new Pic(item)
viewNum - default(3) the number of items to show
time - default(.2) time in seconds to animate between items (also see ZIM TIME constant)
spacing - default(20) the space between the items
backgroundColor - default(clear) the backgroundColor - also see background property
backing - default(null) - an optional backing DisplayObject that goes on top of the backing and under the tile
padding - default(0) - the default for the background outside the tile
paddingH - default(padding) - the horizontal padding to override the padding setting
paddingV - default(padding) - the vertical padding to override the padding setting 
arrowLeft - default(new Arrow().rot(180)) - an arrow for going left
arrowRight - default(new Arrow()) - an arrow for going right
arrowGap - default(20) the gap between the arrow and the backing
valign - default(CENTER) the vertical alignment of the tile items
ease - default(quadInOut) the ease of the animation - see ZIM animate() ease parameter for types
swipe - default(true) set to false to not make the tile swipeable - see also the swipe property
remember - default("zimCarousel") set to false to not remember the selectedIndex when reloading the page
selectedIndex - default(0 or remembered index) the starting index - see also the selectedIndex property 
	this is the index of the first (left) item in view
continuous - default(true) set to false to stop at ends
	this will clone the items and use the modulus to keep index numbers correct
	if continuous is false and the carousel is cycled then it will bounce back and forth
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
goRight(time) - go to the right - time defaults to Carousel time parameter but can be customized - returns object for chaining
goLeft(time) - go to the left - time defaults to Carousel time parameter but can be customized - returns object for chaining
cycle(cycleTime, transitionTime, repeat, repeatNum, recycle, rtl) - |ZIM VEE| cycle the carousel from the current selectedIndex (see also remember)
	cycleTime (default 5) in seconds to animate to next item 
	transitionTime (default 1) in seconds to animate between items - overrides Carousel time setting
		often a faster Carousel time is desired for pressing arrows or swiping 
		but a slower transitionTime when cycling
	repeat (default true) continue past ends if carousel continuous is set
		or go back and forth from start to end if continuous is not set
		set to false to just go one once
	repeatNum (default 0) set to a number greater than 0 to limit repeats or bounces - returns object for chaining 
		for bounce, use .5 for partial cycle for example, 1.5 will go forth then back then forth
	recycle (default cycleTime*2) time in seconds to restart cycle if cleared due to arrows or swipes
		set to false or -1 to not restart the cycle
	rtl (default DIR) if true will stop going back to 0 selectedIndex if no repeat
cycleClear() - stops the cycle
disableArrows() - turn arrows off - returns object for chaining
enableArrows() - turn arrows on - returns object for chaining
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
selectedIndex - get or set the first index (left) of the viewable area
items - reference to the original array of items
tile - reference to the single-row tile that holds the items
viewNum - get the number of items viewable
itemWidth - get the calculated item width
itemHeight - get the calculated maximum height
spacing - get the spacing between the items
arrowLeft - reference to the left arrow
arrowRight - reference to the right arrow
swipe - get or set whether the tile can be swiped
repeatTotal - the number of repeats or bounce cycles
swipeObj - reference to the ZIM Swipe object
cycleInterval - reference to the cycle interval
recycleEvent - reference to the recycle event
recycleWait - reference to the recycle timeout
background - reference to the background rectangle
backing - reference to a provided backing 
continuous - get whether the carousel is continuous

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "page" event when starting an animation 
dispatches a "goleft" and a "goright" event when going left or right - just after the page event
dispatches a "transitioned" event when item finishes changing
dispatches a "bounced" event on each bounce 
dispatches a "bouncedone" event if the cycle bounceNum is set and the bounce is done 
dispatches a "cyclecleared" event if the cycle is set and stops due to arrow press or swipe

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.45

	zim.Carousel = function(items, viewNum, time, spacing, backgroundColor, backing, padding, paddingH, paddingV, arrowLeft, arrowRight, arrowGap, valign, ease, swipe, remember, selectedIndex, continuous, style, group, inherit) {
		var sig = "items, viewNum, time, spacing, backgroundColor, backing, padding, paddingH, paddingV, arrowLeft, arrowRight, arrowGap, valign, ease, swipe, remember, selectedIndex, continuous, style, group, inherit";
		var duo; if (duo = zob(zim.Carousel, arguments, sig, this)) return duo;
		z_d("67.45");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Carousel", this.group, inherit);
		var that = this;
		
		this.zimContainer_constructor();
		
		if (zot(items)) items = DS.items!=null?DS.items:[
			new Rectangle({color: red}),
			new Rectangle({color: orange}),
			new Rectangle({color: yellow}),
			new Rectangle({color: green}),
			new Rectangle({color: blue}),
			new Rectangle({color: purple}),
			new Rectangle({color: pink})
		];    
		
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.clear;
		if (zot(backing)) backing = DS.backing!=null?DS.backing:null;
		if (zot(valign)) valign = DS.valign!=null?DS.valign:"center";
		if (zot(viewNum)) viewNum = DS.viewNum!=null?DS.viewNum:3;
		if (zot(spacing)) spacing = DS.spacing!=null?DS.spacing:20;
		if (zot(padding)) padding = DS.padding!=null?DS.padding:0;
		if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:padding;
		if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:padding;
		if (zot(arrowLeft)) arrowLeft = DS.arrowLeft!=null?DS.arrowLeft:new zim.Arrow().rot(180);
		if (zot(arrowRight)) arrowRight = DS.arrowRight!=null?DS.arrowRight:new zim.Arrow();
		if (zot(arrowGap)) arrowGap = DS.arrowGap!=null?DS.arrowGap:20;
		var timeType = getTIME(time);
		if (zot(time)) time = DS.time!=null?DS.time:timeType=="s"?.2:200;
		if (zot(ease)) ease = DS.ease!=null?DS.ease:"quadInOut";
		if (zot(swipe)) swipe = DS.swipe!=null?DS.swipe:true;		
		if (zot(remember)) remember = DS.remember!=null?DS.remember:"zimCarousel";		
		if (zot(selectedIndex)) selectedIndex = DS.selectedIndex!=null?DS.selectedIndex:0;
		if (zot(continuous)) continuous = DS.continuous!=null?DS.continuous:true;
		if (remember&&localStorage&&!zot(localStorage[remember])) {
			if (localStorage[remember] == "NaN") localStorage[remember] = 0;
			selectedIndex = Number(localStorage[remember]);
		}
		
		that.items = items;
		that.viewNum = viewNum;
		that.spacing = spacing;
		that.arrowLeft = arrowLeft;
		that.arrowRight = arrowRight;
		that.arrowLeft.oW = arrowLeft.width;
		that.arrowRight.oW = arrowRight.width;
		if (backing) that.backing = backing;
		
		var widths = {};             
		zim.loop(items, function(item, i) {
			if (typeof item == "string") item = items[i] = new zim.Pic(item);
			item.reg(CENTER, CENTER);
			var w = widths["width"+item.width];
			if (!w) widths["width"+item.width] = 1;
			else widths["width"+item.width] += 1;            
		});
		var commonTotal = 0;
		var itemWidth = 0;        
		zim.loop(widths, function(nam, val) {
			if (val > commonTotal) {
				commonTotal = val;
				itemWidth = Number(nam.substring(5));                
			}
		});        
		var itemHeight = 0;   
		zim.loop(items, function(item) {
			item.width = itemWidth;
			if (item.height > itemHeight) itemHeight = item.height;
		});

		var workingItems;
		if (continuous) {
			that.continuous = true;
			workingItems = zim.copy(items);
			zim.loop(items.length, function(i) {
				workingItems.push(items[i].duplicate());
			});
		} else {
			workingItems = items;
		}

		that.itemWidth = itemWidth;
		that.itemHeight = itemHeight;
		

		var tileStartX = arrowLeft.width+arrowGap+paddingH;
		var cw;
		function buildTile() {
			var viewW = viewNum*(itemWidth+spacing)-spacing;            
			var viewH = itemHeight;
			
			cw = viewW+paddingH*2+arrowGap*2+arrowLeft.width+arrowRight.width;
			that.setBounds(0,0,cw,viewH+paddingV*2);
						
			that.tile = new zim.Tile({
				obj: workingItems,
				cols: workingItems.length,
				spacingH:spacing,
				rows: 1,
				unique: true,
				align: "center",
				valign: valign
			}).center(that).loc(tileStartX);       

			that.background = new Rectangle(viewW+paddingH*2, viewH+paddingV*2, backgroundColor).center(that, 0);			
			that.tile.setMask(that.background);
		}
		

		function buildArrows() {
			arrowLeft.pos(0, 0, "left", "center", that);
			arrowRight.pos(0, 0, "right", "center", that);    
			arrowLeft.on("mousedown", function(){
				if (that.cycleInterval) {
					that.cycleClear();
					that.dispatchEvent("cyclecleared");			
				}
				that.goLeft();
			});
			arrowRight.on("mousedown", function(){
				if (that.cycleInterval) {
					that.cycleClear();
					that.dispatchEvent("cyclecleared");				
				}
				that.goRight();
			});  
			setArrowsActivate();
			
		}
		
		function buildSwipe() {
			if (!that.swipe) return;    
			var swipeObj = that.swipeObj = new zim.Swipe(that.tile);
			swipeObj.on("swipe", function(e) {
				if (e.swipeX!=0 && that.cycleInterval) {
					that.cycleClear();
					that.dispatchEvent("cyclecleared");
				}
				if (e.swipeX==1) that.goLeft();
				else if (e.swipeX==-1) that.goRight();                
			});
		}   

		function setArrowsActivate() {
			if (localStorage && remember) localStorage[remember] = that.selectedIndex;
			arrowLeft.activate(true);
			arrowRight.activate(true);    
			if (continuous) return;
			if (that.tile.x + that.tile.width <= cw-arrowRight.oW-paddingH-arrowGap) {                
				arrowRight.activate(false);
			}    
			if (that.tile.x >= tileStartX) {
				arrowLeft.activate(false);
			}
		}
		
		that.goLeft = function(t) {
			if (zot(t)) t = time;
			if (continuous && that.tile.x >= -itemWidth) {that.tile.x -= that.tile.width/2 + spacing/2}
			if (that.tile.x < tileStartX) {
				that.disableArrows();   
				selectedIndex--;  
				that.dispatchEvent("page");
				that.dispatchEvent("goleft");
				that.tile.animate({
					props: {x:that.tile.x+itemWidth+spacing},
					time: t,
					ease: ease,
					call: function() {
						setArrowsActivate();
						that.enableArrows();
						that.dispatchEvent("transitioned");
					}
				});
			}
			return that;
		}

		that.goRight = function(t) {
			if (zot(t)) t = time;
			if (continuous && that.tile.x - itemWidth <= cw - that.tile.width) {that.tile.x += that.tile.width/2 + spacing/2}
			if (that.tile.x + that.tile.width > cw-arrowRight.oW-paddingH-arrowGap) {
				that.disableArrows();   
				selectedIndex++; 
				that.dispatchEvent("page");
				that.dispatchEvent("goright");
				that.tile.animate({
					props: {x:that.tile.x-itemWidth-spacing},
					time: t,
					ease: ease,
					call: function() {
						setArrowsActivate();
						that.enableArrows();
						that.dispatchEvent("transitioned");
					}
				});
			}
			return that;
		}
		
		that.cycleClear = function() {
			that.cycleInterval.clear();
			that.cycleInterval = null;	
			return that;
		}

		that.cycle = function(cycleTime, transitionTime, repeat, repeatNum, recycle, rtl) {
			var sig = "cycleTime, transitionTime, repeat, repeatNum, recycle, rtl";
			var duo; if (duo = zob(that.cycle, arguments, sig)) return duo;
			if (zot(cycleTime)) cycleTime = DS.cycleTime!=null?DS.cycleTime:timeType=="s"?5:5000;
			if (zot(transitionTime)) transitionTime = DS.transitionTime!=null?DS.transitionTime:timeType=="s"?1:1000;
			if (zot(repeat)) repeat = true;
			if (zot(repeatNum)) repeatNum = 0;
			if (zot(recycle)) recycle = cycleTime*2;
			if (zot(rtl)) rtl = ((WW.DIR && WW.DIR=="rtl") || (!WW.DIR && zim.DIR=="rtl"));
			var dir = rtl?-1:1;
			if (that.cycleInterval) that.cycleInterval.clear();
			if (recycle && recycle != -1) {
				if (that.recycleEvent) that.off("cyclecleared", that.recycleEvent);
				if (that.recycleWait) that.recycleWait.clear();
				that.recycleEvent = that.on("cyclecleared", function() {
					if (that.recycleWait) that.recycleWait.clear();
					that.recycleWait = timeout(recycle, function() {
						that.cycle(cycleTime, transitionTime, repeat, repeatNum, recycle, rtl);
					});
				});
			}
			if (continuous) {

				// fix this up to not bounce but continue - add repeatCount.
				that.repeatTotal = 0;
				that.cycleInterval = zim.interval(cycleTime*2, function(obj) {
					if (that.selectedIndex == 0) {	
						if (!repeat && rtl) {
							that.cycleInterval.clear();
						} else {
							if (rtl && obj.count!=1) that.repeatTotal+=1;
							if (rtl && repeatNum != 0 && that.repeatTotal >= repeatNum) {
								that.cycleInterval.clear();
								that.dispatchEvent("repeatdone");							
								return;
							}
							if (dir==1) that.goRight(transitionTime);
							else that.goLeft(transitionTime);
						}
					} else if (that.selectedIndex == items.length-viewNum) {
						if (!rtl && obj.count!=1) that.repeatTotal+=1;
						if (!rtl && repeatNum != 0 && that.repeatTotal >= repeatNum) {
							that.cycleInterval.clear();
							that.dispatchEvent("repeatdone");							
							return;
						}
						if (that.repeatTotal >= 1) that.dispatchEvent("repeated");
						if (!rtl && !repeat) {
							that.cycleInterval.clear();
						} else {
							if (dir==1) that.goRight(transitionTime);
							else that.goLeft(transitionTime);
						}					
					} else {
						if (dir==1) that.goRight(transitionTime);
						else that.goLeft(transitionTime);
					}	
				}); 
		   
			} else { // bounce
				that.repeatTotal = .5;
				that.cycleInterval = zim.interval(cycleTime*2, function(obj) {
					if (that.selectedIndex == 0) {	
						if (obj.count!=1) that.repeatTotal+=.5;
						if (repeatNum != 0 && that.repeatTotal > repeatNum) {
							that.cycleInterval.clear();
							that.dispatchEvent("bouncedone");							
							return;
						}
						if (that.repeatTotal >= 1) that.dispatchEvent("bounced");
						dir = 1;
						that.goRight(transitionTime);						
					} else if (that.selectedIndex == items.length-viewNum) {					
						if (obj.count!=1) that.repeatTotal+=.5;
						if (repeatNum != 0 && that.repeatTotal > repeatNum) {
							that.cycleInterval.clear();
							that.dispatchEvent("bouncedone");							
							return;
						}
						if (that.repeatTotal >= 1) that.dispatchEvent("bounced");					
						dir = -1;
						that.goLeft(transitionTime);									
					} else {
						zogb()
						if (dir==1) that.goRight(transitionTime);
						else that.goLeft(transitionTime);
					}		        
				});
			}
			
			return that;
		}

		that.enableArrows = function() {
			if (that.swipeObj) that.swipeObj.active = true;
			arrowLeft.mouse();
			arrowRight.mouse();
			return that;
		}

		that.disableArrows = function() {
			if (that.swipeObj) that.swipeObj.active = false;
			arrowLeft.noMouse();
			arrowRight.noMouse();
			return that;
		}
		
		Object.defineProperty(that, 'selectedIndex', {
			get: function() {
				return (selectedIndex+items.length)%items.length;
			},
			set: function(val) {
				selectedIndex = zim.constrain(val, 0, items.length-viewNum);
				that.tile.x = tileStartX - selectedIndex*(itemWidth + spacing);
				setArrowsActivate();
			}
		});
		
		Object.defineProperty(that, 'swipe', {
			get: function() {
				return swipe;
			},
			set: function(val) {
				swipe = val;
				if (swipe && !that.swipeObj) buildSwipe();
				that.swipeObj.active = swipe;
			}
		});
		
		buildTile();
		buildArrows();
		buildSwipe();
		
		if (backing) backing.center(that,1);        
		if (selectedIndex) that.selectedIndex = selectedIndex;    

		this.dispose = function(a,b,disposing) {
			if (that.swipeObj) that.swipeObj.dispose();
			if (that.recycleEvent) that.off("cyclecleared", that.recycleEvent);
			if (that.cycleWait) that.cycleWait.clear();
			if (that.cycleInterval) that.cycleInterval.clear();
			that.swipeObj = that.recycleEvent = that.cycleWait = null;
			if (!disposing) {this.zimContainer_dispose();}
			return true;
		};
		
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			var newItems = [];
			for (var i=0; i<items.length; i++) {
				var newItem = items[i];
				if (newItem.duplicate) newItems.push(newItem.duplicate());
				else if (newItem.clone) newItems.push(newItem.clone());
				else newItems.push(zim.copy(items[i]));
			}
			return that.cloneProps(new zim.Carousel(newItems, viewNum, time, spacing, backgroundColor, backing, padding, paddingH, paddingV, arrowLeft.duplicate(), arrowRight.duplicate(), arrowGap, valign, ease, swipe, remember, selectedIndex, continuous, style, this.group));
		};	
	}
	zim.extend(zim.Carousel, zim.Container, ["clone", "dispose"], "zimContainer", false);	
	//-67.45

/*--
zim.Loader = function(width, height, label, type, backgroundColor, rollBackgroundColor, color, rollColor, borderColor, borderWidth, corner, shadowColor, shadowBlur, hitPadding, gradient, gloss, dashed, backing, rollBacking, rollPersist, icon, rollIcon, toggle, toggleBacking, rollToggleBacking, toggleIcon, rollToggleIcon, toggleEvent, frame, multiple, accept, style, group, inherit)

Loader
zim class - extends a zim.Button which extends a zim.Container

DESCRIPTION
Loader lets you upload images, text or JSON.  These are available on the loaded event function.
Loader uses the HTML input type=file tag and overlays this with a createjs DOMElement.
Loader is a Button so can be displayed for the user to click on.
It defaults to a dashed line region as you can also drag and drop files to the loader.
You can also save an image using the save() method to a new browser window for the user to save

NOTE: due to the HTML tag being overlayed, the loader.resize() must be called if it is moved
(This is called automatically when the stage is resized)

NOTE: if the loader is placed in a container and the container is removed or added again
the loader must be manually removed or added again with loader.removeFrom() or loader.addTo().
This is so ZIM does not have to keep track of HTML tags each time a container is added or removed.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const loader = new Loader({
	label:"UPLOAD PIC OR DROP PICS HERE",
	width:700,
	height:400,
	corner:50
}).center();
loader.on("loaded", e=>{
	loop(e.bitmaps, bitmap=>{
		bitmap.centerReg().drag();
	});
	loader.removeFrom();
	S.update();
});

// and to later save for instance in a button event:
saveButton.on("click") {
	loader.save(stage); // or some other container... can specify crop bounds too
}
END EXAMPLE

EXAMPLE
// loading a JSON file:
const loader = new Loader({
	type:"JSON",
	label:"UPLOAD JSON",
	width:700,
	height:400,
	corner:50
}).center();
// choose a test.json file with the following in it:
// {"test":"testing"}
loader.on("loaded", e=>{
	zog(e.json.test); // "testing"
	loader.removeFrom();
	S.update();
});
END EXAMPLE

EXAMPLE
// save a json file
const obj = {a:[1,2,3], b:"hello"};
new Loader().save({content:obj, type:"json"}); // save a json file with obj
END EXAMPLE

EXAMPLE
// save a text file
const textInput = new TextInput().center();
new Button({label:"SUBMIT", wait:"SAVED"}).center().mov(0,100).tap(()=>{
	new Loader().save({content:textInput.text, filename:"answer.txt", type:"text"});
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 250) the width of the button
height - (default 70) the height of the button
label - (default "UPLOAD PIC") ZIM Label or plain text
type - (default "image") set to "text" to receive text or "JSON" to receive a parsed JSON file and "other" for others like MP3
backgroundColor - (default "rgba(0,0,0,.05)") background color of button (any CSS color)
rollBackgroundColor - (default "rgba(0,0,0,.1)") rollover color of button backbground
color - (default "rgba(0,0,0,.5)") text color of button (any CSS color)
rollColor - (default color) rollover text color of button
borderColor - (default rgba(0,0,0,.3)) the color of the border
borderWidth - (default 1) thickness of the border
corner - (default 0) the round of the corner (set to 0 for no corner)
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (default "rgba(0,0,0,.3)") set to -1 for no shadow
shadowBlur - (default 14) how blurred the shadow is if the shadow is set
hitPadding - (default 0) adds extra hit area to the button (good for mobile)
gradient - (default 0) 0 to 1 (try .3) adds a gradient to the button
gloss - (default 0) 0 to 1 (try .1) adds a gloss to the button
backing - (default null) a Display object for the backing of the button (eg. Shape, Bitmap, Container, Sprite)
	see ZIM Pizzazz module for a fun set of Button Shapes like Boomerangs, Ovals, Lightning Bolts, etc.
	https://zimjs.com/bits/view/pizzazz.html
rollBacking - (default null) a Display object for the backing of the rolled-on button
rollPersist - (default false) set to true to keep rollover state when button is pressed even if rolling off
icon - (default false) set to display object to add icon at the center of the button and remove label
	https://zimjs.com/bits/view/icons.html
rollIcon - (default false) set to display object to show icon on rollover
toggle - (default null) set to string to toggle with label or display object to toggle with icon or if no icon, the backing
rollToggle - (default null) set to display object to toggle with rollIcon or rollBacking if no icon
	there is no rollToggle for a label - that is handled by rollColor on the label
toggleEvent - (default mousedown for mobile and click for not mobile) what event causes the toggle
dashed - (default true) set to false to turn off the dashed for the border
frame - (default the zdf) a reference to the Frame (to scale and position the HTML tag)
multiple - (default true) set to false to let user only upload one file rather than multiple files (with shift or ctrl)
accept - (default null) set to extension / MIME-type to limit types of files the upload dialog will suggest
	here are some examples:
	"image/*"
	"image/jpeg, image/png"
	".png, .jpeg, .jpg, .gif"	
	"image/jpeg, .jpeg, .jpg"
	".txt, .json, application/json"
	"audio/mpeg, .mp3"
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
resize() - call the resize event if the scale or position of the Loader is changed
	this will sync the location of the HTML input tag
	resize() is only needed if the scale or x, y of the Loader (or its container) is changed
	it is not needed for general window resizing - the Loader handles this
	Note: if the Frame itself changes location in the HTML document, call a F.update()
	this will then dispatch an update event to the Loader and it will resize()
	this is not needed if resizing the window or scrolling - see Frame update() method docs
save(content, filename, x, y, width, height, cached, cachedBounds, type, data, quality) - save a picture or text (supports ZIM DUO)
	content - the Display object to be saved such as a Container, Bitmap, etc. 
		or text (or Label, TextInput, TextArea) or JSON or object for JSON
		if text or json, then x, y, width, height, cached, cachedBounds, data, and quality are ignored
	filename - (default random) - the text name of the file (with or without extension - also see type)
	x, y, width, height - the cropping bounds on that object otherwise defaults to 0,0,W,H
	cached - (default false) set to true if the object is currently already cached
	cachedBounds - if you are saving a different bounds than was previously cached
		setting the bounds here (createjs.Rectangle) will restore the cache to the previous bounds
	type - (default "png") set to "jpeg" for jpeg or "txt", "text" or "json"
		json will convert the content to JSON if it is not already in JSON format
	data - (default false) set to true to save as base64 data
		otherwise save returns the object for chaining
	quality - (default .92) a number between 0 an 1 representing the quality of the saved image (jpeg)
		note, this parameter may be moved to before data in the next version of ZIM 

Button methods:
setBacking(type, newBacking) - dynamically set any type of backing for button (if null removes backing for that type)
	Backing types are: "backing", "rollBacking", "toggleBacking", "rollToggleBacking", "waitBacking", "rollWaitBacking"
	note - all backing will have a pattern property if a pattern is set as a backing
setIcon(type, newIcon) - dynamically set any type of icon for button (if null removes icon for that type)
	Icon types are: "icon", "rollIcon", "toggleIcon", "rollToggleIcon", "waitIcon", "rollWaitIcon"
toggle(state) - forces a toggle of label if toggle param is string, else toggles icon if icon is set or otherwise toggles backing
	state defaults to null so just toggles
	pass in true to go to the toggled state and false to go to the original state
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
tag - the HTML input tag of type file - used for uploading
frame - get or set the frame - set this if changing frames

Button properties:
text - references the text property of the Label object of the button
label - gives access to the label
backgroundColor - get or set non-rolled on backing color (if no backing specified)
rollBackgroundColor - get or set rolled on backing color
color - get or set non-rolled on text color (if no icon specified)
rollColor - get or set rolled on text color
backing - references the backing of the button
rollBacking - references the rollBacking (if set)
icon - references the icon of the button (if set)
rollIcon - references the rollIcon (if set)
toggleObj - references the toggle object (string or display object if set)
rollToggle - references the rollToggle (if set)
toggled - true if button is in toggled state, false if button is in original state
enabled - default is true - set to false to disable
rollPersist - default is false - set to true to keep rollover state when button is pressed even if rolling off
focus - get or set the focus property of the Button used for tabOrder

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
loaded - is dispatched when the files(s) are uploaded - the event object comes with the following properties:
	FOR IMAGES (see types array)
		e.bitmaps - an array of Bitmap objects of the loaded images
		e.bitmap - the first Bitmap to be created from the loaded images
		e.lastBitmap - the last Bitmap to be created from the loaded images
		e.total - the total Bitmap objects to be created from the loaded images
	FOR TEXT (see types array)
		e.texts - an array of String objects of the loaded text files
		e.text - the first text loaded
		e.lastText - the last text loaded
		e.total - the total number of texts loaded
	FOR JSON (see types array)
		e.jsons - an array of JSON objects of the loaded JSON files
		e.json - the first JSON object loaded
		e.lastJSON - the last JSON object loaded
		e.total - the total number of JSON files loaded
	FOR OTHER (see types array)
		e.others - an array of other objects of loaded files
		e.other - the first other object loaded
		e.lastOther - the last other object loaded
		e.total - the total number of other files loaded

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.5

	zim.Loader = function(width, height, label, type, backgroundColor, rollBackgroundColor, color, rollColor, borderColor, rollBorderColor, borderWidth, corner, shadowColor, shadowBlur, hitPadding, gradient, gloss, dashed, backing, rollBacking, rollPersist, icon, rollIcon, toggle, toggleBacking, rollToggleBacking, toggleIcon, rollToggleIcon, toggleEvent, frame, multiple, accept, style, group, inherit) {
		var sig = "width, height, label, type, backgroundColor, rollBackgroundColor, color, rollColor, borderColor, rollBorderColor, borderWidth, corner, shadowColor, shadowBlur, hitPadding, gradient, gloss, dashed, backing, rollBacking, rollPersist, icon, rollIcon, toggle, toggleBacking, rollToggleBacking, toggleIcon, rollToggleIcon, toggleEvent, frame, multiple, accept, style, group, inherit";
		var duo; if (duo = zob(zim.Loader, arguments, sig, this)) return duo;
		z_d("67.5");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Loader", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:250;
		if (zot(height)) height = DS.height!=null?DS.height:70;
		if (zot(type)) type = DS.type!=null?DS.type:"image";
		type = type.toLowerCase();
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"rgba(0,0,0,.05)";
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:"rgba(0,0,0,.1)";
		if (zot(color)) color = DS.color!=null?DS.color:"rgba(0,0,0,.5)";
		if (zot(rollColor)) rollColor = DS.rollColor!=null?DS.rollColor:color;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:"rgba(0,0,0,.3)";
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:1;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:true;
		if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
		if (zot(multiple)) multiple = DS.multiple!=null?DS.multiple:true;
		if (zot(label)) label = DS.label!=null?DS.label:new zim.Label({
			text:"UPLOAD PIC", color:color, rollColor:rollColor, valign:"center", align:"center",
			backing:"ignore", shadowColor:"ignore", shadowBlur:"ignore", backgroundColor:"ignore",
			group:this.group
		});
		if (typeof frame == "undefined") {
			if (WW.zdf) {
				var frame = WW.zdf;
			} else {
				if (zon) {zogy("zim.Loader - please provide a reference to zim Frame");} return;
			}
		}
	
		this.zimButton_constructor(width, height, label, backgroundColor, rollBackgroundColor, null, color, rollColor, null, borderColor, borderWidth, rollBorderColor, null, backing, rollBacking, null, icon, rollIcon, null, corner, dashed, shadowColor, shadowBlur, gradient, gloss, null, null, null, null, null, hitPadding, null, null, null, rollPersist, toggle, null, null, null, null, null, null, toggleBacking, rollToggleBacking, null, toggleIcon, rollToggleIcon, null, toggleEvent, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, null, false);
		this.type = "Loader";
		var that = this;
		var stage = frame.stage;
		label = that.label;

		var uploadTag = that.tag = document.createElement("input");
		if (frame.tag) {
			frame.tag.appendChild(uploadTag);
		} else {
			document.body.appendChild(uploadTag);
		}
		uploadTag.setAttribute("type", "file");
		uploadTag.setAttribute("aria-hidden", true);
		if (multiple) uploadTag.setAttribute("multiple", "multiple");
		if (accept) uploadTag.setAttribute("accept", accept);
		uploadTag.hidden = true;
		uploadTag.zimDisplay = uploadTag.style.display || "inline-block";
		uploadTag.style.cssText = "border:thin solid grey; z-index:2; width:" + width + "px; height:" + height + "px; overflow:hidden; outline:none;"
								+ "position:absolute; left:0px; top:0px; display:none; cursor:pointer; opacity: 0; filter: alpha(opacity=0);";

		this.addEventListener('mousedown', function() { // added for zim.Accessibility
			uploadTag.click();
		});
		uploadTag.addEventListener('change', handleFile);
		var upload = new createjs.DOMElement(uploadTag);
		stage.addChild(upload);
		upload.alpha = 0;

		var pRatio = frame.retina?(WW.devicePixelRatio || 1):1;

		// jitter is happing if in ZIM Window() with scrollbar and damping - unlikely
		// fixed on TextArea and Tag but did not work on Loader - yet the code is the same?
		this.resize = function(update, last) {
			if (!that.stage) {
				uploadTag.setAttribute("aria-hidden", true);
				uploadTag.hidden = true;
				uploadTag.style.display = "none";
				// uploadTag.previosSibling.hidden = true;
				// uploadTag.previosSibling.style.display = "none";
				return;
			}
			uploadTag.setAttribute("aria-hidden", false);
			uploadTag.hidden = false;
			uploadTag.style.display = uploadTag.zimDisplay;
			// uploadTag.previosSibling.hidden = false;
			// uploadTag.previosSibling.style.display = "block";
			
			if (zot(update)) update = true;
			if (that.time1) clearTimeout(that.time1);
			// before ZIM ZIM 01 rand the setTimeout on the whole resize code 
			// but that was causing jutters in damped window scrolling
			// so implemented a final call to help with a delayed update 
			// which was probably put in place to capture a mobile orientation change
			if (!last) {
				that.time1 = setTimeout(function() {
					that.resize(null, true);
				}, 40);
			}			
						
			var displayProps = that.getConcatenatedMatrix().decompose();
			var point = that.localToGlobal(0, 0);
			if (frame.retina) {
				var sc = zim.browserZoom();					
				if (frame.tag) {
					upload.x = point.x/pRatio/sc;
					upload.y = point.y/pRatio/sc;
				} else {
					upload.x = frame.x/stage.scaleX + point.x/pRatio/sc;
					upload.y = frame.y/stage.scaleY + point.y/pRatio/sc;
				}					
				// CreateJS DOMElement is scaling tag as stage scales
				zim.sca(upload, displayProps.scaleX/pRatio/stage.scaleX/sc, displayProps.scaleY/pRatio/stage.scaleY/sc);
			} else {
				upload.x = frame.x + point.x * frame.scale;
				upload.y = frame.y + point.y * frame.scale;
				zim.sca(upload, frame.scale*displayProps.scaleX, frame.scale*displayProps.scaleY);
			}
			stage.update();
			
			return that;
		};
		this.resize();
		that.on("added", function() {
			uploadTag.style.display = "block";
			uploadTag.hidden = false;
			uploadTag.style.display = "block";
			that.resize();
		});
		that.added(addedCallback);
		function addedCallback() {
			that.resize();
			that.time2 = setTimeout(function() {
				uploadTag.style.display = "block";
				uploadTag.hidden = false;
				uploadTag.style.display = "block";
			}, 50);
			that.on("added", addedCallback, null, true); // once
		}
		that.on("removed", function() {
			if (that.time1) clearTimeout(that.time1);
			if (that.time2) clearTimeout(that.time2);
			if (uploadTag) {
				uploadTag.style.display = "none";
				uploadTag.hidden = true;
				uploadTag.style.display = "none";
			}
		});

		function handleFile(e) {
			var files;
			if (e.dataTransfer && e.dataTransfer.files && e.dataTransfer.files.length > 0) {
				files = e.dataTransfer.files;
			} else {
				files = e.target.files;
			}

			if (type=="text" || type=="json") {
				var texts = [];
				var firstText;
				if (type.toLowerCase()=="json") {
					var jsons = [];
					var firstJSON;
				}
			} else if (type=="other") {
				var others = [];
				var firstOther;
			} else {
				var bitmaps = [];
				var firstBitmap;
			}
			for (var i=0; i<files.length; i++) {
				(function(file) {
					var reader = new FileReader();
					reader.onload = function(event){
						if (type=="text" || type=="json") {
							var text = event.target.result;
							texts.push(text);
							if (type=="json") {
								var json = zim.parseJSON(text);
								jsons.push(json);
							}
							if (texts.length == 1) {
								firstText = text;
								if (type=="json") firstJSON = json;
							}
							if (texts.length == files.length) {
								var e = new createjs.Event("loaded");
								e.texts = texts;
								e.text = firstText;
								e.lastText = text;
								e.total = texts.length;
								if (type=="json") {
									e.jsons = jsons;
									e.json = firstJSON;
									e.lastJSON = json;
								}
								that.dispatchEvent(e);
								uploadTag.value = "";
							}
						} else if (type=="other") {
							var other = event.target.result;
							others.push(other);							
							if (others.length == 1) {
								firstOther = other;
							}
							if (others.length == files.length) {
								var e = new createjs.Event("loaded");
								e.others = others;
								e.other = firstOther;
								e.lastOther = other;
								e.total = others.length;								
								that.dispatchEvent(e);
								uploadTag.value = "";
							}
						} else {
							var img = new Image();
							img.onload = function(){
								var bitmap = new zim.Bitmap(img);
								bitmaps.push(bitmap);
								if (bitmaps.length == 1) firstBitmap = bitmap;
								if (bitmaps.length == files.length) {
									var e = new createjs.Event("loaded");
									e.bitmaps = bitmaps;
									e.bitmap = firstBitmap;
									e.lastBitmap = bitmap;
									e.total = bitmaps.length;
									that.dispatchEvent(e);
									uploadTag.value = "";
								}
							};
							img.src = event.target.result;
						} 
					};
					if (type=="text" || type=="json") reader.readAsText(file);
					else reader.readAsDataURL(file);
				})(files[i]);
			}
		}
		var xhr = new XMLHttpRequest();
		if (xhr.upload) {
			var uploadEvent = function(e) {
				// first imageLoader change event triggers so remove event then add it again later
				uploadTag.removeEventListener('change', handleFile);
				handleFile(e);
				setInterval(function() {uploadTag.addEventListener('change', handleFile);}, 100);
			}
			uploadTag.addEventListener("drop", uploadEvent);
		}

		this.save = function(content, filename, x, y, width, height, cached, cachedBounds, type, data, quality) {
		
			var sig = "content, filename, x, y, width, height, cached, cachedBounds, type, data, quality";
			var duo; if (duo = zob(that.save, arguments, sig)) return duo;
			if (zot(content)) content = frame.stage;			

			if (type=="text") type = "txt";
			if (zot(type)) type = "png";
			if (zot(filename)) {
				filename = "saved_" + String(zim.makeID("numbers", 5)) + "." + type;
			} else {
				var parts = filename.split(".");
				if (parts.length == 1) {
					filename += "." + type;
				} else {
					var types = ["png","jpg","jpeg","txt","json"];
					var ind = types.indexOf(parts[parts.length-1].toLowerCase());
					if (ind == -1) {
						filename += "." + type;
					} else {
						type = types[ind];
					}
				}
			}

			if (type=="txt" || type=="json") {
				// thanks https://www.tutorialspoint.com/how-to-create-and-save-text-file-in-javascript
				var link = document.createElement("a");
				var ff;
				if (typeof content != "string" && content.text) content = content.text; 
				if (type=="json" && !isJSON(content)) content = JSON.stringify(content);
				if (document && document.Blob) ff = new document.Blob([content], {type:'text/plain'});
				else ff = new Blob([content], {type:'text/plain'});
				link.href = URL.createObjectURL(ff);
				link.download = filename;
				link.click();
				URL.revokeObjectURL(link.href);
				return that;				
			}

			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(width)) width = (content.getBounds && content.getBounds()) ? content.getBounds().width : frame.width;
			if (zot(height)) height = (content.getBounds && content.getBounds()) ? content.getBounds().height : frame.height;
            var cacheO = content.cacheCanvas;

			content.cache(x, y, width, height);

			if (data) {
				var image = content.cacheCanvas.toDataURL('image/' + type, quality);
				if (cached) {
					if (cachedBounds) content.cache(cachedBounds.x, cachedBounds.y, cachedBounds.width, cachedBounds.height);
				} else {
					content.uncache();
				}
				return image;
			}
			// if (!zot(url)) {
			// 	zim.async(url+"?data="+content.cacheCanvas.toDataURL('image/jpeg'), loaderReply);
			// 	function loaderReply(result) {
			// 		var e = new createjs.Event("saved");
			// 		e.result = result;
			// 		that.dispatchEvent(e);
			// 	}
			// // or to a script using zim.async (currently untested - will test and provide examples soon)
			// // saved - is dispatched when a file is saved to a script (needs the url parameter) - event object includes:
			// // e.result - the message sent back from the server in the zim.async.loaderReply('message')
			// } else {
				// disabled by Chrome https://groups.google.com/a/chromium.org/forum/#!topic/blink-dev/GbVcuwg_QjM%5B1-25%5D
				// zgo(content.cacheCanvas.toDataURL('image/'+type), "_blank");

				// iframe option
				// var win = window.open();
				// win.document.write("<html><head><title>saved</title></head><body style='margin:0px;padding:0px;overflow:hidden'><iframe src="+content.cacheCanvas.toDataURL('image/'+type)+" frameborder=0 style='overflow:hidden;height:100%;width:100%' height=100% width=100%></iframe></body></html>");
				// win.document.close();

				// var win = window.open();
				// win.document.write("<html><head><title>saved</title><s"+"cript>function test(){document.getElementById('pic').src='" +content.cacheCanvas.toDataURL('image/'+type)+"';}</s"+"cript></head><body style='margin:0px;padding:0px;overflow:hidden'><iframe id=pic frameborder=0 style='overflow:hidden;height:100%;width:100%' height=100% width=100%></iframe></body></html>");
				// win.document.close();
				// win.test();

				// Thanks Frank Loss for the prompting
				// Thanks Ken for the fiddle guidance - https://jsfiddle.net/AbdiasSoftware/7PRNN/
				var isMsEdge = /Edge\/(\d)+/.test(navigator.userAgent);
				if (isMsEdge){
					var win = WW.open();
					win.document.write("<html><head><title>saved</title></head><body style='margin:0px;padding:0px;overflow:hidden'><img src="+content.cacheCanvas.toDataURL('image/'+type)+"></body></html>");
					win.document.close();
				} else {
					if (type == "jpg") type = "jpeg";
					var a = document.createElement("a");
					a.setAttribute("download", filename);
					a.setAttribute("href", content.cacheCanvas.toDataURL('image/'+type, quality));
					document.body.appendChild(a);
					a.click();
					document.body.removeChild(a);
				}

				// img option
				// var win = window.open();
				// win.document.write("<html><head><title>saved</title></head><body style='margin:0px;padding:0px;overflow:hidden'><img src="+content.cacheCanvas.toDataURL('image/'+type)+"></body></html>");
				// win.document.close();

			// }
			if (cached || cacheO) {
				if (cachedBounds) content.cache(cachedBounds.x, cachedBounds.y, cachedBounds.width, cachedBounds.height);
			} else {
				content.uncache();
			}

			return that;
		}

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			var u = new zim.Loader(
				width, height, !zot(label)?label.clone():null, backgroundColor, rollBackgroundColor, color, rollColor, borderColor, borderWidth, corner, shadowColor, shadowBlur, hitPadding, gradient, gloss,
				!zot(backing)?backing.clone():null,
				!zot(rollBacking)?rollBacking.clone():null,
				rollPersist,
				!zot(icon)?icon.clone():null, !zot(rollIcon)?rollIcon.clone():null,
				toggle,
				!zot(toggleBacking)?toggleBacking.clone():null,
				!zot(rollToggleBacking)?rollToggleBacking.clone():null,
				!zot(toggleIcon)?toggleIcon.clone():null,
				!zot(rollToggleIcon)?rollToggleIcon.clone():null,
				toggleEvent, frame, style, this.group
			);
			return that.cloneProps(u);
		};
		Object.defineProperty(this, 'frame', {
			get: function() {
				return frame;
			},
			set: function(value) {
				if (value != frame) {
					frame.off("update", that.updateEvent);
					frame.off("resize", that.resizeEvent);
					frame = value;
					that.resizeEvent = frame.on("resize", that.resize);
					that.updateEvent = frame.on("update", that.resize);
					that.resize();
				}
			}
		});
		this.resizeEvent = frame.on("resize", that.resize);
		this.updateEvent = frame.on("update", that.resize);
		this.dispose = function(a,b,disposing) {
			var stage;
			if (that.stage) stage = that.stage;
			frame.off("update", that.updateEvent);
			frame.off("resize", that.resizeEvent);
			if (handleFile) uploadTag.removeEventListener('change', handleFile);
			if (uploadEvent) uploadTag.removeEventListener("drop", uploadEvent);
			if (uploadTag && uploadTag.parentNode) {
				uploadTag.parentNode.removeChild(uploadTag);
			}
			uploadTag = null;
			if (!disposing) {
				this.zimButton_dispose();
				if (stage) stage.update();
			}
			return true;
		};
	};
	zim.extend(zim.Loader, zim.Button, ["clone", "dispose"], "zimButton", false);	
	//-67.5

/*--
zim.TextArea = function(width, height, placeholder, text, size, padding, color, backgroundColor, borderColor, borderWidth, corner, shadowColor, shadowBlur, dashed, id, readOnly, spellCheck, password, inputType, wrap, maxLength, frame, expand, keyboardShift, style, group, inherit)

TextArea
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
TextArea creates an input text field by overlaying an HTML TextArea.
The TextArea is then overlayed with the createjs DOMElement
and scaled and positioned with ZIM code. This can also be used if selectable text is required
Access to the HTML tag is provided with the TextArea tag property.
So CSS Styles can be applied to the HTML tag as with any HTML textarea tag
The TextArea comes with a ZIM Rectangle in behind that you can adjust with parameters
or remove completely if you so desire using the TextArea background property
ie. myTextArea.background.alpha=0; or myTextArea.removeChild(myTextArea.background)

NOTE: due to the HTML tag being overlayed, the TextArea.resize() must be called if it is moved
(This is called automatically when the stage is resized)  
It also means that a TextArea in a Window or List is probably not a good thing.
Consider using Label and then toggling a TextArea on mouseover and mouseout. 
See https://zimjs.com/snips for an older discontinued example.

NOTE: if the TextArea is placed in a container and the container is removed or added again
the textArea must be manually removed or added again with textArea.removeFrom() or textArea.addTo().
This is so ZIM does not have to keep track of HTML tags each time a container is added or removed.
When using TextArea in a Pane or in Pages this will be automatically handled 
only if the TextArea is directly in the Pane or the page (not nested in further Containers) 

NOTE: rotation and skewing of TextArea is not supported - although might work with custom CSS transformations

NOTE: because of these limitations, consider the TextEditor as a solution.
The TextEditor allows you to use a Label which is a proper part of the Canvas 
and then change the label with a pop-up editor that includes a TextArea.
SEE: https://zimjs.com/cat/texteditor.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const textArea = new TextArea(300, 200).center();

const label = new Label({text:""}).pos(20,20);
textArea.on("input", ()=>{
	label.text = textArea.text;
	S.update();
});

// to set scrollBars on TextArea use CSS on the TextArea tag property:
textArea.tag.style.overflow = "auto"; // etc.

// if manually scaled or positioned (or container is scaled or positioned)
// then the TextArea must be resized with the resize method
textArea.sca(.5).mov(200);
textArea.resize();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 250) the width of the TextArea backing (the textarea field will be that less the padding*2)
height - (default 70) the height of the TextArea backing (the textarea field will be that less the padding*2)
	Note: to set scrollBars use CSS: textArea.tag.style.overflow = "auto";
placeholder - (default null) the HTML placeholder for the TextArea
text - (default null) the text of the TextArea - see also the text property 
size - (default 20) a Number for the font-size of the TextArea (do not use px on the end)
	to change the font, use CSS on the tag property: textArea.tag.style.fontFamily = "courier";
padding - (default 5) the pixels between the backing border and the HTML textarea
color - (default granite) text color (any CSS color)
backgroundColor - (default "rgba(256,256,256,.1)") background color of box
borderColor - (default rgba(0,0,0,.1)) the color of the border
borderWidth - (default 1) thickness of the border
corner - (default 0) the round of the corner (set to 0 for no corner)
	can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
shadowColor - (default null) the shadow color (css color) of a drop shadow
shadowBlur - (default null) pixels of how blurred the shadow is if the shadow is set - eg. 10
dashed - (default true) set to false to turn off the dashed for the border
id - (default null) a string id for the HTML textarea tag for CSS styling, etc.
placeholder - (default null) a string that is used for the HTML textarea tag placeholder parameter
readOnly - (default false) set to true to make TextArea read only (still selectable)
spellCheck - (default true) set to false to turn Browser spell check off
password - (default false) set to true to turn the field into a password field - single line only (uses input field type=password and not TextArea)
inputType - (default false) set to "text" to show a text input (one line) - or try other HTML input types - "email", "number", etc.
	the various types of HTML inputs are not really tested - would suggest using Tag() instead for these (or preferably ZIM components)
wrap - (default true) set to false to stop the textarea from wrapping (css white-space:pre)
maxLength - (default null) set to a number to limit the number of characters in the textarea
frame - (default the zdf) a reference to the Frame (to scale and position the HTML tag)
expand - (default 20) hit area around background to count as a press on TextArea - handy for dragging as HTML tag area will override mouse on canvas
keyboardShift - (default false) set to true to lift stage at least 1/4 height or up to textArea y/2 to raise textArea above keyboard
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setFocus(type) - sets the focus of the TextArea tag (thanks Armin for the prompting)
	type is a Boolean that defaults to true - set to false to make the TextArea blur (loose focus)
	might need timeout 100ms before setting
	see also focus property
resize() - call the resize method if the scale or position of the TextArea is changed
	this will sync the location of the HTML textarea tag
	resize() is only needed if the scale or x, y of the TextArea (or its container) is changed
	it is not needed for general window resizing - the TextArea handles this
	Note: if the Frame itself changes location in the HTML document, call a F.update()
	this will then dispatch an update event to the TextArea and it will resize()
	this is not needed if resizing the window or scrolling - see Frame update() method docs
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
currentValue - get or set the text content of the TextArea
text - get or set the text value
focus - get or set if the TextArea tag has focus or use setFocus() to set (might need timeout 100ms before setting)
readOnly - set to true to not be able to edit or to false to be able to edit (always can select)
maxLength - get or set the maximum number of characters typed - will not truncate existing characters until typed
tag - the HTML textarea tag - just a regular HMTL form tag which can be styled
background - access to the Rectangle() used for the background
	you can remove this with yourTextArea.background.removeFrom(yourTextArea);
	or adjust it dynamically with any of the Rectangle properties like color
blendMode - how the object blends with what is underneath - such as "difference", "multiply", etc. same as CreateJS compositeOperation
keyFocus - get or set the keyboard focus on the component - see also zim.KEYFOCUS
	will be set to true if this component is the first made or component is the last to be used
frame - get or set the frame - set this if changing frames

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
focus, blur are dispatched when the text area gains and loses focus
input is dispatched when the text area is typed or pasted into
change is dispatched when the text area is different after losing focus
These are just the html events passed on through - note the difference between input and change!

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.6
	zim.TextArea = function(width, height, placeholder, text, size, padding, color, backgroundColor, borderColor, borderWidth, corner, shadowColor, shadowBlur, dashed, id, readOnly, spellCheck, password, inputType, wrap, maxLength, frame, expand, keyboardShift, style, group, inherit) {
		var sig = "width, height, placeholder, text, size, padding, color, backgroundColor, borderColor, borderWidth, corner, shadowColor, shadowBlur, dashed, id, readOnly, spellCheck, password, inputType, wrap, maxLength, frame, expand, keyboardShift, style, group, inherit";
		var duo; if (duo = zob(zim.TextArea, arguments, sig, this)) return duo;
		z_d("67.6");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("TextArea", this.group, inherit);
		
		if (zot(width)) width = DS.width!=null?DS.width:250;
		if (zot(height)) height = DS.height!=null?DS.height:70;
		if (zot(placeholder)) placeholder = DS.placeholder!=null?DS.placeholder:null;
		if (zot(text)) text = DS.text!=null?DS.text:null;
		if (zot(size)) size = DS.size!=null?DS.size:20;
		if (zot(padding)) padding = DS.padding!=null?DS.padding:5;
		if (zot(color)) color = DS.color!=null?DS.color:zim.granite;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"rgba(256,256,256,.1)";
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:"rgba(0,0,0,.1)";
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:null;
		if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
		else if (borderColor!=null && borderWidth==null) borderWidth = 1;
		if (zot(corner)) corner = DS.corner!=null?DS.corner:0;
		if (!zot(shadowBlur) && zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (!zot(shadowColor) && zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:10;
		if (zot(password)) password=DS.password!=null?DS.password:false;
		if (zot(inputType)) inputType=DS.inputType!=null?DS.inputType:false;
		if (zot(wrap)) wrap=DS.wrap!=null?DS.wrap:true;
		if (zot(maxLength)) maxLength=DS.maxLength!=null?DS.maxLength:null;
		if (zot(spellCheck)) spellCheck=DS.spellCheck!=null?DS.spellCheck:true;
		if (zot(readOnly)) readOnly=DS.readOnly!=null?DS.readOnly:false;
		if (zot(keyboardShift)) keyboardShift=DS.keyboardShift!=null?DS.keyboardShift:false;
		this.maxLength = maxLength;
		if (zot(expand)) expand = DS.expand!=null?DS.expand:20;
		if (expand === true) expand = 20;
		if (typeof frame == "undefined") {
			if (WW.zdf) {
				var frame = WW.zdf;
			} else {
				if (zon) {zogy("zim.TextArea - please provide a reference to zim Frame");} return;
			}
		}

		this.zimContainer_constructor(width, height, null, null, false);
		this.type = "TextArea";
		var that = this;
		var stage = frame.stage;

		var background = this.background = new zim.Rectangle(width, height, backgroundColor, borderColor, borderWidth, corner, dashed, null, null, false).expand(expand);
		if (shadowColor != -1 && shadowBlur > 0) background.shadow = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
		that.addChild(background);
		var textareaTag = that.tag = inputType||password?document.createElement("input"):document.createElement("textarea");
		
		if (frame.tag) {
			frame.tag.appendChild(textareaTag);
		} else {
			document.body.appendChild(textareaTag);
		}
				
		if (!zot(id)) {
			textareaTag.setAttribute("id", id);
			textareaTag.setAttribute("name", id);
		}
		if (password) {
			textareaTag.setAttribute("type", "password");
		} else if (inputType) {
			textareaTag.setAttribute("type", inputType);
		}
		textareaTag.readOnly = readOnly;
		textareaTag.spellcheck = spellCheck;
		if (placeholder) textareaTag.setAttribute("placeholder", placeholder);
		if (text) textareaTag.value = text;
		textareaTag.zimDisplay = textareaTag.style.display || "inline-block";
		textareaTag.style.cssText = "background-color:rgba(0,0,0,.01); color:" + color + "; "
			+ "resize:none; z-index:3; width:" + (width - padding * 2) + "px; height:" + (height - padding * 2) + "px; overflow:hidden; outline:none;"
			+ "font-size:" + size + "px; font-family:" + (DS.font != null ? DS.font : "arial") + "; border:none; position:absolute; left:0px; top:0px; display:none;";


		that.taInput = function() {
			if (!zot(that.maxLength) && that.text.length > that.maxLength) {
				that.text = that.text.substring(0, that.maxLength);
			}
			that.dispatchEvent("input");
		}
		var sYO = that.y;
		that.taFocus = function() {		
			if (WW.M && keyboardShift) {
				if (that.re) that.stage.frame.off("resize", that.re);
				that.re = that.stage.frame.on("resize", function(){
					if (that.stage && h>that.stage.height/4) {
						that.stage.y = that.stage.scaleY*(that.stage.height/4-h);
						that.stage.update();
					}
				});
				var h = that.localToGlobal(0,0).y;
				if (that.stage && h>that.stage.height/4) {
					that.stage.y = that.stage.scaleY*(that.stage.height/4-h);
					that.stage.update();
				}
			}
			if (that.stage) frame = that.stage.frame;	
			if (frame.zil) WW.removeEventListener("keydown", frame.zil[0]);
			that.dispatchEvent("focus");
		}
		that.taBlur = function() {
			if (WW.M && keyboardShift) {			
				if (that.stage) {
					if (that.re) that.stage.frame.off("resize", that.re);
					that.stage.y = sYO;
					that.stage.update();
				}
			}
			if (that.stage) frame = that.stage.frame;
			if (frame.zil) WW.addEventListener("keydown", frame.zil[0]);
			that.dispatchEvent("blur");
		}
		textareaTag.addEventListener('change', that.taChange);
		textareaTag.addEventListener('input', that.taInput);
		textareaTag.addEventListener('focus', that.taFocus);
		textareaTag.addEventListener('blur', that.taBlur);
		
		var textarea = new createjs.DOMElement(textareaTag);
		textarea.alpha = 0;

		this.on('mousedown', function() {setTimeout(function(){textareaTag.focus();}, 100);}); // for zim Accessibility

		this.setFocus = function(type) {
			if (zot(type)) type = true;
			if (type) textareaTag.focus();
			else textareaTag.blur();
			return that;
		};

		var pRatio = frame.retina?(WW.devicePixelRatio || 1):1;

		this.resize = function(update, last) {			
			
			if (zot(update)) update = true;
			if (that.time1) clearTimeout(that.time1);
			// before ZIM ZIM 01 rand the setTimeout on the whole resize code 
			// but that was causing jutters in damped window scrolling
			// so implemented a final call to help with a delayed update 
			// which was probably put in place to capture a mobile orientation change
			if (!last) {
				that.time1 = setTimeout(function() {
					that.resize(null, true);
				}, 40);
			}			
			var displayProps = that.getConcatenatedMatrix().decompose();
			var point = that.localToGlobal(padding, padding);
			if (frame.retina) {
				var sc = zim.browserZoom();					
				if (frame.tag) {
					textarea.x = point.x/pRatio/sc;
					textarea.y = point.y/pRatio/sc;						
				} else {
					textarea.x = frame.x/stage.scaleX + point.x/pRatio/sc;
					textarea.y = frame.y/stage.scaleY + point.y/pRatio/sc;
				}			
				// CreateJS DOMElement is scaling tag as stage scales
				zim.sca(textarea, displayProps.scaleX/pRatio/stage.scaleX/sc, displayProps.scaleY/pRatio/stage.scaleY/sc);
			} else {
				if (frame.tag) {
					textarea.x = point.x * frame.scale;
					textarea.y = point.y * frame.scale;
				} else {
					textarea.x = frame.x + point.x * frame.scale;
					textarea.y = frame.y + point.y * frame.scale;
				}
				zim.sca(textarea, frame.scale*displayProps.scaleX, frame.scale*displayProps.scaleY);
			}				
			textarea.alpha = that.alpha;
			if (that.parent) textarea.alpha *= that.parent.alpha;
			if (update && that.stage) stage.update();
		
			return that;
		};
		this.resize();
		// timeout(100,function () {
		// 	if (frame) frame.update()
		// })
		that.added(addedCallback);
		function addedCallback() {
			stage.addChild(textarea);
			that.time2 = setTimeout(function() {textareaTag.style.display = textareaTag.zimDisplay;}, 50);
			that.resize();
			that.on("added", addedCallback, null, true); // once
			that.FOEvent = stage.on("stagemousedown", function() {
				that.focus = false;
			});
		}
		that.on("removed", function() {
			if (that.time1) clearTimeout(that.time1);
			if (that.time2) clearTimeout(that.time2);
			stage.removeChild(textarea);
			if (that.FOEvent) stage.off("stagemousedown", that.FOEvent);
			if (textareaTag) textareaTag.style.display = "none";
		});

		Object.defineProperty(this, 'currentValue', {
			get: function() {
				return textareaTag.value;
			},
			set: function(value) {
				textareaTag.value = value;
			}
		});

		Object.defineProperty(this, 'text', {
			get: function() {
				return textareaTag.value;
			},
			set: function(value) {
				textareaTag.value = value;
			}
		});

		Object.defineProperty(this, 'focus', {
			get: function() {
				return (document.activeElement == textareaTag);
			},
			set: function(value) {
				that.setFocus(value);
			}
		});


		Object.defineProperty(this, 'readOnly', {
			get: function() {
				return textareaTag.readOnly;
			},
			set: function(value) {
				textareaTag.readOnly = value;
			}
		});

		if (WW.KEYFOCUS!=null) zim.KEYFOCUS = WW.KEYFOCUS;
		Object.defineProperty(this, 'keyFocus', {
			get: function() {
				return zim.KEYFOCUS == that;
			},
			set: function() {
				zim.KEYFOCUS = that;
			}
		});
		if (!zim.KEYFOCUS) that.keyFocus = true;
		that.taMousedown = function() {that.keyFocus = true;}
		textareaTag.addEventListener("mousedown", that.taMousedown);

		if (!wrap) textareaTag.style.whiteSpace = "pre"; // stop from wrapping

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			var u = new zim.TextArea(width, height, placeholder, text, size, padding, color, backgroundColor, borderColor, borderWidth, corner, shadowColor, shadowBlur, dashed, id, readOnly, spellCheck, password, inputType, wrap, maxLength, frame, expand, keyboardShift, style, this.group, inherit);
			return that.cloneProps(u);
		};

		Object.defineProperty(this, 'frame', {
			get: function() {
				return frame;
			},
			set: function(value) {
				if (value != frame) {
					frame.off("update", that.updateEvent);
					frame.off("resize", that.resizeEvent);
					frame = value;
					that.resizeEvent = frame.on("resize", that.resize);
					that.updateEvent = frame.on("update", that.resize);
					pRatio = frame.retina?(WW.devicePixelRatio || 1):1;
					stage = frame.stage;
					that.resize();
				}
			}
		});
	
		this.resizeEvent = frame.on("resize", that.resize);
		this.updateEvent = frame.on("update", that.resize);
		this.dispose = function(a,b,disposing) {	
			var stage;
			if (that.stage) stage = that.stage;
			frame.off("update", that.updateEvent);
			frame.off("resize", that.resizeEvent);
			if (stage && that.FOEvent) stage.off("stagemousedown", that.FOEvent);
			if (textareaTag && textareaTag.parentNode) {
				textareaTag.parentNode.removeChild(textareaTag);
			}
			textareaTag.removeEventListener('change', that.taChange);
			textareaTag.removeEventListener('input', that.taInput);
			textareaTag.removeEventListener('focus', that.taFocus);
			textareaTag.removeEventListener('blur', that.taBlur);
			textareaTag.removeEventListener("mousedown", that.taMousedown);
			textareaTag = null;			
			if (!disposing) {
				this.zimContainer_dispose(true);
				if (stage) stage.update();
			}
			that.background = null;
			return true;
		};
	};
	zim.extend(zim.TextArea, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-67.6


	// function to set enabled of components
	function zenable(t,v) {
		if (v) {
			t.mouseChildren = true;
			t.mouseEnabled = true;
			t._enabled = true;
		} else {
			t.mouseChildren = false;
			t.mouseEnabled = false;
			t._enabled = false;
		}
	}

////////////////  ZIM METHODS  //////////////

// Zim Methods adds functionality to CreateJS for Zapps (apps, art, games and gadgets with ZIM)
// functions in this module require createjs namespace to exist and in particular easel.js and tween.js
// available at https://createjs.com

// SUBSECTION BASE METHODS

/*--
obj.cache = function(width||x, height||y, null||width, null||height, scale, options, margin)

cache
zim DisplayObject method overrides CreateJS cache() method with more flexible parameters
https://createjs.com/docs/easeljs/classes/Container.html#method_cache

DESCRIPTION
Turns the object into a bitmap which can be rendered more efficiently, especially on mobile.
Caching may blur the object slightly, most noticable when caching a Label. 
Every stage update must re-render objects on the stage. 
This can be processor intensive for lots of vectors - such as Labels and Shapes. 
Generally, we can build without caching but if better performance is needed, then caching may help.

A cached object can be transformed (scale, rotation, position, skew, alpha) 
but if the object inside changes, for instance if the text changes, then updateCache() will need to be called. 
Constantly calling updateCache() for instance, an animated blob, will not help performance. 
A handy trick is to cache an object before animating and uncaching it after animating 
this can improve animation performance and the slight blur of the object is not noticed during animation.

ALSO SEE: updateCache() and uncache()

EXAMPLE
const circle = new Circle(50, red).cache().center();

timeout(1, ()=>{
	circle.alpha = .5; // cache does not have to be updated to see alpha change
	S.update();
});

timeout(2, ()=>{
	circle.color = blue;
	circle.updateCache(); // cache must be updated to see color change
	S.update();
});
END EXAMPLE

EXAMPLE
// cache text as it is animated
new Label("Cached Text")
	.cache() // cache the text so animation is smoother
	.alp(0)
	.center()
	.animate({
		props:{alpha:1},
		time:2,
		call:target=>{
			target.uncache(); // uncache the label so it is crisper looking
		}
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
** cache dimensions will be set to the bounds of the object if the first two or four parameters are not provided
width||x - (default getBounds().x) the width of the chache - or the x if first four parameters are provided
height||y - (default getBounds().y) the height of the chache - or the y if first four parameters are provided
width - (default getBounds().width) the width of the chache - or null if first two parameters are provided
height - (default getBounds().height) the height of the chache - or null if first two parameters are provided
scale - (default 1) set to 2 to cache with twice the fidelity if later scaling up
options - (default null) additional parameters for cache logic - see CreateJS somewhere for details
	also added adjustBounds property for options - set to true to set new bounds and registration point 
	on cached objects with x,y,width,height different than the original
	this appears to NOT be the default with createjs cache() which keeps the original registration point and bounds
	automatically fixing this changes lots of things so use the adjustBounds option when needed 
	for instance when caching parts of a container and requiring hit tests or the part to be draggable, etc.

margin - (default 0) add or subtract a margin from the bounds
  eg. margin:10 will make the cache size 10 pixels more on all sides
  this can be handy when caching objects with borders - that go half outside the natural bounds

RETURNS obj for chaining
--*///+47.1

	// THE CODE FOR THE METHOD IS IN ZIM DISPLAY - CONTAINER

	//-47.1
	
/*--
obj.updateCache = function(blendMode)

updateCache
CreateJS method 
https://createjs.com/docs/easeljs/classes/Container.html#method_updateCache

DESCRIPTION
Updates the cache when there is a chache otherwise gives an error.

ALSO SEE: cache() and uncache()

EXAMPLE
const circle = new Circle(50, red).cache().center();

timeout(1, ()=>{
	circle.alpha = .5; // cache does not have to be updated to see alpha change
	S.update();
});

timeout(2, ()=>{
	circle.color = blue;
	circle.updateCache(); // cache must be updated to see color change
	S.update();
});
END EXAMPLE

PARAMETERS 
blendMode - (default null) a blendMode (compositeOperation) see ble() 
	if a blendMode is provided the previous cache is not deleted as the new cache is drawn

RETURNS null
--*///+47.11

	// THE CODE FOR THE METHOD IS IN CREATEJS

	//-47.11
	
/*--
obj.uncache = function()

uncache
zim DisplayObject method overrides CreateJS cache() to return object for chaining
https://createjs.com/docs/easeljs/classes/Container.html#method_uncache

DESCRIPTION
Clears the cache.

ALSO SEE: cache() and updateCache()

EXAMPLE
// cache text as it is animated then uncache
new Label("Cached Text")
	.cache() // cache the text so animation is smoother
	.alp(0)
	.center()
	.animate({
		props:{alpha:1},
		time:2,
		call:target=>{
			target.uncache(); // uncache the label so it is crisper looking
		}
});
END EXAMPLE

RETURNS obj for chaining
--*///+47.12

	// THE CODE FOR THE METHOD IS IN ZIM DISPLAY - CONTAINER

	//-47.12

/*--
obj.on = function(type, listener, scope, once, data, useCapture)

on
CreateJS method 
https://createjs.com/docs/easeljs/classes/Container.html#method_on

DESCRIPTION
Captures events.  Similar to addEventListener() in raw JavaScript 
but is shorter to write and has a few extra features.

Generally, events are when interactivity occurs or ZIM has a message.
Here are some types:
"click", "dblclick", "mousedown/pressdown", "pressmove", "pressup",
"mousemove", "stagemousemove", "mouseover", "mouseout"
"ready", "complete", "change", "keydown", "keyup"

The events available for ZIM Objects are listed at the bottom of their Doc entry. 
Events can also be turned off in a couple ways - see the examples.
To turn the event off the return value of the on() method is used 
so DO NOT CHAIN THE ON METHOD

ALSO SEE: off() and tap(), change(), movement(), hov(), hold() 

EXAMPLE
// BASIC EVENT
const button = new Button().center();
// the type of event as a string and the function to call
// here we use an arrow function
button.on("click", ()=>{
	zgo("https://zimjs.com", "_blank");
});

// alternatively, using an anonymous function
button.on("click", function() {
	zgo("https://zimjs.com", "_blank");
});

// alternatively, using a named function
// do not put () after the function name 
// that would call the function right away which is not desired 
// we want to tell the on() method which function to run when the event happens
button.on("click", doClick);
function doClick() {
	zgo("https://zimjs.com", "_blank");
}
END EXAMPLE 

EXAMPLE
// EVENT OBJECT
const tile = new Tile(new Rectangle(), 5, 5, 2, 2).center();
tile.on("mousedown", e=>{ // collect the event object in parameter e
	// e.target is the object that caused the event (one of the rectangles)
	e.target.alpha = 0;
	// e.currentTarget is the object on which the event is placed (the tile)
	e.target.mov(5);
	// do not forget to update stage in events if needed!
	S.update();
});
END EXAMPLE 

EXAMPLE
// REMOVING EVENT
let keyEvent = F.on("keydown", e=>{
	zog(e.keyCode); // will tell code for key pressed
	// etc.
});
timeout(2, ()=>{ // time in seconds as of ZIM Cat
	// remove the keyEvent
	F.off("keydown", keyEvent);
});

// RE-ADDING EVENT
timeout(4, ()=>{
	// add the keyEvent back again
	// note - the event must be re-assigned to use again
	// this leads to a tricky bug if not careful!
	keyEvent = F.on("keydown", keyEvent);
});
timeout(6, ()=>{
	// remove the keyEvent again
	// this only works if we re-assigned the latest event to keyEvent
	// which is why we used let rather than const
	F.off("keydown", keyEvent);
});
END EXAMPLE 

EXAMPLE
// ONE EVENT CALL
// call this function only once when mousing over the stage
// note: "mousemove" would only trigger if moving over an object on the stage
S.on("stagemousemove", ()=>{
	pauseAnimate(false); // unpause all animations
}, null, true); // this true means remove the event after calling it once

// REMOVE METHOD
// a remove() method is available on the event object
const circle = new Circle().center();
circle.on("mouseover", e=>{
	circle.alpha -= .1;
	if (circle.alpha <= .5) e.remove();
	S.update();
});
END EXAMPLE

PARAMETERS 
type - the type of event as a string - this depends on the object on which the event is being placed 
	here are some common events - see the EVENTS section of the specific object for more
	"click", "dblclick", "mousedown/pressdown", "pressmove", "pressup",
	"mousemove", "stagemousemove", "mouseover", "mouseout"
	"ready", "complete", "change", "keydown", "keyup"
listener - the function to call when the event happens	
	this is often an arrow function or an anonymous function but can be a named function
	the function will receive an event object as its parameter often collected as e
	see https://createjs.com/docs/easeljs/classes/MouseEvent.html for properties, etc.
	common event object properties are:
	 	target (what caused the event), 
		currentTarget (what the event was placed on) 
		keyCode (for key events)
	often used as e.target, e.currentTarget, e.keyCode	
scope - (optional) the scope to execute the listener in. 
	Defaults to the dispatcher/currentTarget for function listeners, 
	and to the listener itself for object listeners (ie. using handleEvent).
once - (default false) set to true to remove the listener after the first event call
data - (default null) arbitrary data that will be included as the second parameter when the listener is called.
useCapture - (default false) for events that bubble, indicates whether to listen for the event in the capture or bubbling/target phase

RETURNS a reference to use as the second parameter of the off() method to turn the event off (SO DO NOT CHAIN THE ON METHOD)
--*///+47.13

	// THE CODE FOR THE METHOD IS IN CREATEJS

	//-47.13

/*--
obj.off = function(type, listener, useCapture)

off
CreateJS method
https://createjs.com/docs/easeljs/classes/Container.html#method_off

DESCRIPTION
Turns an event off using the return value of the on() method.

ALSO SEE: on()

EXAMPLE
// REMOVING EVENT
let keyEvent = F.on("keydown", e=>{
	zog(e.keyCode); // will tell code for key pressed
	// etc.
});
timeout(2, ()=>{ // time in seconds as of ZIM Cat
	// remove the keyEvent
	F.off("keydown", keyEvent);
});

// RE-ADDING EVENT
timeout(4, ()=>{
	// add the keyEvent back again
	// note - the event must be re-assigned to use again
	// this leads to a tricky bug if not careful!
	keyEvent = F.on("keydown", keyEvent);
});
timeout(6, ()=>{
	// remove the keyEvent again
	// this only works if we re-assigned the latest event to keyEvent
	// which is why we used let rather than const
	F.off("keydown", keyEvent);
});
END EXAMPLE 

PARAMETERS 
type - the string type of the event used in on()
listener - the listener function or object used in on()
useCapture - (default false) the setting for the capture or bubbling/target phase used in on()

RETURNS null
--*///+47.14

	// THE CODE FOR THE METHOD IS IN CREATEJS

	//-47.14

/*--
obj.removeAllEventListeners = function(type)

removeAllEventListeners
CreateJS method
https://createjs.com/docs/easeljs/classes/Container.html#method_removeAllEventListeners

DESCRIPTION
Removes all event listeners or all event listeners of a certain type

ALSO SEE: on() and off()

EXAMPLE
// REMOVING EVENT
rect.removeAllEventListeners(); // remove all 
holder.removeAllEventListeners("click"); // remove all click listeners
END EXAMPLE 

PARAMETERS 
type - the string type of the event used in on()

RETURNS null
--*///+47.15

	// THE CODE FOR THE METHOD IS IN CREATEJS

	//-47.15

/*--
obj.getBounds = function()

getBounds
CreateJS method
https://createjs.com/docs/easeljs/classes/Container.html#method_getBounds

DESCRIPTION
Gets bounds data for a Display Object (with bounds set).
This will have x, y, width and height properties.
Imagine the bounds as an invisible rectangle around the object.
The bounds are what dictate the width and height of an object (along with scale).
The bounds will affect how an object is positioned with pos().
The bounds also may affect certain types of hitTests.

Most ZIM DisplayObjects have their bounds set automatically.
Shape() however does not have its bounds set automatically.

ALSO SEE: setBounds()

EXAMPLE
const rect = new Rectangle(100, 100, blue).center();
zog(rect.getBounds()); // {x:0, y:0, width:100, height:100}

const circle = new Circle(100, red).center(); // 100 is the radius 
zog(circle.getBounds()); // {x:-100,y:-100,width:200,height:200}
// note that a Circle has its origin (0,0) in the middle 
// so half the bounds goes to the left and above 
// and the width and height are twice the radius

// Also note that the registration point is completely independent from the bounds 
// and independent from the origin.  See https://codepen.io/zimjs/pen/qBEjYZV
END EXAMPLE 

RETURNS object with x, y, width and height properties
--*///+47.16

	// THE CODE FOR THE METHOD IS IN CREATEJS

	//-47.16

/*--
obj.setBounds = function(width||x||Boundary, height||y, null||width, null||height)

setBounds
zim DisplayObject method overrides CreateJS setBounds() method with more flexible parameters
https://createjs.com/docs/easeljs/classes/Container.html#method_setBounds

DESCRIPTION
Sets bounds for a Display Object.
Imagine the bounds as an invisible rectangle around the object.
The bounds are what dictate the width and height of an object (along with scale).
The bounds will affect how an object is positioned with pos().
The bounds also may affect certain types of hitTests.

Most ZIM DisplayObjects have their bounds set automatically.
Shape() however does not have its bounds set automatically.
The setBounds() method will override any automatic bounds.

ALSO SEE: getBounds()

EXAMPLE
new Shape().f(red).dr(0,0,100,100).setBounds(100,100).center();
// without bounds set on the shape, it would not center properly
END EXAMPLE 

EXAMPLE 
// Containers have two options for how bounds are determined 
// 1. the size can be passed in to start in which case these bounds will remain unchanged 
// 2. or no size can be passed in which means the bounds will grow to the contents 
// setting bounds to null will convert a type 1 container into a type 2 container 
const holder = new Container(100,100).center();
new Rectangle(200,200).addTo(holder);
// currently the bounds are {x:0,y:0,width:100,height:100} 
holder.setBounds(null);
// now the bounds are {x:0,y:0,width:200,height:200} 
new Rectangle(300,300).addTo(holder);
// now the bounds are {x:0,y:0,width:300,height:300} 
holder.setBounds(100,100);
// now the bounds are back to {x:0,y:0,width:100,height:100} 
// this example just demonstrates it would not be very practical
END EXAMPLE

PARAMETERS
width||x||Boundary - (default null) the width of the bounds - or the x if four parameters are provided
	or a ZIM Boundary Object {x,y,width,height} - same as CreateJS Rectangle 
height||y - (default width) the height of the bounds - or the y if four parameters are provided
width - (default null) the width of the bounds - or null if only the first two parameters are provided
height - (default null) the height of the bounds - or null if only the first two parameters are provided

RETURNS the object for chaining
--*///+47.17

	// THE CODE FOR THE METHOD IS IN ZIM DISPLAY - CONTAINER

	//-47.17

/*--
obj.localToGlobal = function(x, y)

localToGlobal
zim DisplayObject method overrides CreateJS localToGlobal() method with adjustment for scaled stage due to retina pixel density
https://createjs.com/docs/easeljs/classes/Container.html#method_localToGlobal

DESCRIPTION
Returns a point on the stage for the provided x and y within the object's (container's) coordinate system.

BACKGROUND 
Each container has its own x and y coordinate system.  The stage is said to be the global coordinate system.
Since containers may be located at different x and y positions and nested inside one another and scaled, rotated or skewed,
finding the matching x and y position within different coordinates can be tricky to calculate.
Traditionally in Interactive Media, three methods have been provided to translate x and y between coordinate systems.

localToGlobal() finds the global x and y of a specified x and y inside the container object
globalToLocal() finds the x and y inside the container object of a specified global x and y
localToLocal() finds the x and y inside an other specified container of a specified x an y inside the container object
SEE: https://zimjs.com/editor/view/Z_N5E7Z

ALSO SEE: globalToLocal() and localToLocal()

EXAMPLE
const holder = new Container(400,400).loc(100,100);
const circle = new Circle.center(holder);
zog(holder.localToGlobal(circle.x, circle.y)); // {x:300, y:300}
// Note: and easier way providing the same result is:
zog(circle.localToGlobal(0,0)); // {x:300, y:300}
END EXAMPLE 

PARAMETERS
x - (default null) the x position inside the container
y - (default null) the y position inside the container

RETURNS a Point with x and y properties on the stage (global) that match the provide x and y inside the container
--*///+47.172

	// ZIM DOES INTERNALLY ADJUST THIS METHOD BUT THE BASE CODE IS IN CREATEJS

	//-47.172

/*--
obj.globalToLocal = function(x, y)

globalToLocal
zim DisplayObject method overrides CreateJS globalToLocal() method with adjustment for scaled stage due to retina pixel density
https://createjs.com/docs/easeljs/classes/Container.html#method_globalToLocal

DESCRIPTION
Returns a point within the object's (container's) coordinate system that matches the provided x and y on the stage (global).

BACKGROUND 
Each container has its own x and y coordinate system.  The stage is said to be the global coordinate system.
Since containers may be located at different x and y positions and nested inside one another and scaled, rotated or skewed,
finding the matching x and y position within different coordinates can be tricky to calculate.
Traditionally in Interactive Media, three methods have been provided to translate x and y between coordinate systems.

localToGlobal() finds the global x and y of a specified x and y inside the container object
globalToLocal() finds the x and y inside the container object of a specified global x and y
localToLocal() finds the x and y inside an other specified container of a specified x an y inside the container object
SEE: https://zimjs.com/editor/view/Z_N5E7Z



ALSO SEE: localToGlobal() and localToLocal()

EXAMPLE
const rect = new Rectangle(500,500,red).center();
const circle = new Circle(20,purple).center(rect).noMouse(); // noMouse so movement turns off when outside rect
rect.movement(()=>{
	circle.loc(rect.globalToLocal(F.mouseX, F.mouseY)); // convert global mouse to x and y point within rect container
	S.update();
});
// Note: see Frame cursors property to do this more easily and precisely
END EXAMPLE 

PARAMETERS
x - (default null) the x position inside the container
y - (default null) the y position inside the container

RETURNS a Point with x and y properties inside the container that match the provided x and y points on the stage (global)
--*///+47.173

	// ZIM DOES INTERNALLY ADJUST THIS METHOD BUT THE BASE CODE IS IN CREATEJS

	//-47.173

/*--
obj.localToLocal = function(x, y, target)

localToLocal
zim DisplayObject method overrides CreateJS localToLocal() method with adjustment for scaled stage due to retina pixel density
https://createjs.com/docs/easeljs/classes/Container.html#method_localToLocal

DESCRIPTION
Returns a point with x and y positions inside the provided target container's coordinate system
that match the x and y within the object's (container's) coordinate system.

BACKGROUND 
Each container has its own x and y coordinate system.  The stage is said to be the global coordinate system.
Since containers may be located at different x and y positions and nested inside one another and scaled, rotated or skewed,
finding the matching x and y position within different coordinates can be tricky to calculate.
Traditionally in Interactive Media, three methods have been provided to translate x and y between coordinate systems.
SEE: https://zimjs.com/editor/view/Z_N5E7Z

localToGlobal() finds the global x and y of a specified x and y inside the container object
globalToLocal() finds the x and y inside the container object of a specified global x and y
localToLocal() finds the x and y inside an other specified container of a specified x an y inside the container object

ALSO SEE: globalToLocal() and localToLocal()

EXAMPLE
const wheel = new Circle(300, blue).center().animate({props:{rotation:360}, time:5, loop:true, ease:"linear"});
const level = new Circle(20).loc(0,250,wheel); // will spin around with wheel 
const land = new Container(800,800).center();
const player = new Circle(50,purple).center(land).drag(land);
Ticker.add(()=>{
	if (player.y < level.localToLocal(0,0,land).y) player.color = red; // if player goes below level
	else player.color = purple; // player is above level
});
END EXAMPLE 

PARAMETERS
x - (default null) the x position inside the container
y - (default null) the y position inside the container
target - (default null) the target container in which to match the provided x and y positions

RETURNS a Point with x and y properties in the target container that match the provide x and y inside the object container
--*///+47.174

	// ZIM DOES INTERNALLY ADJUST THIS METHOD BUT THE BASE CODE IS IN CREATEJS

	//-47.174

/*--
obj.clone = function(exact)

clone
zim DisplayObject method overrides CreateJS cache()
https://createjs.com/docs/easeljs/classes/Container.html#method_clone

DESCRIPTION
Makes a copy of the DisplayObject (and children).
The clone() method is particularily handy for making multiple assets from a single asset()
Although new Pic() instead of asset() is automatically cloned to give a new object each new Pic()

ALSO SEE: duplicate() to duplicate custom properties as well

EXAMPLE
const circle = new Circle(100, red).center();
circle2 = circle.clone().pos(100,100,RIGHT,BOTTOM); // make a copy and position at bottom right
END EXAMPLE 

EXAMPLE 
asset("pic.jpg").center();
asset("pic.jpg").pos(100,100,RIGHT,BOTTOM); // will just move the existing asset to the corner 
asset("pic.jpg").clone().pos(100,100,RIGHT,TOP); // will add a copy of the asset at the top
new Pic("pic.jpg").pos(0,100,CENTER); // no need to clone() a new Pic()
END EXAMPLE 

PARAMETERS
exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
   For instance, if a Container holds a new Circle(20,[blue,green])
   then its clone might be blue or green
   If exact is set to true then the clone will be whatever color was picked for the original circle

RETURNS the object for chaining
--*///+47.18

	// THE CODE FOR THE METHOD IS IN ZIM DISPLAY - CONTAINER

	//-47.18

/*--
obj.dispose = function(disposing)

dispose
zim DisplayObject method

DESCRIPTION
Deletes the DisplayObject from memory.
This means it removes event listeners, stops animations, drags, gestures, transforms, etc.
The references to the DisplayObject must still be set to null for proper garbage collection. 
Objects that have references to them may still be saved in memory 
and this can lead to memory leaks if many objects are being made.

The average DisplayObject added to the stage and removed does not really need to be disposed() 
Only when hundreds or thousands of objects are being made will there be need for dispose()

SEE: https://www.youtube.com/watch?v=aTnNicsLP3A // on memory management

EXAMPLE
const tile = new Tile(new Pic("pic.jpg"), 100, 100).center();
const tilesArray = [tile]; // if we had an array of such tiles
const tilesObject = {fave:tile}; // if we had a reference in an object literal
timeout(10, ()=>{
	tile.dispose(); // will recursively dispose all children in Tile (the Bitmaps)
	tile = null; // remove the reference to tile
	tilesArray[0] = null; // set the array reference to null
	delete tilesObject.fave; // delete the property in the object literal
	S.update();
});
END EXAMPLE 

PARAMETERS 
disposing - (default null) pass in true to indicate already started dispose if calling dispose() on the super class from a custom class
 	otherwise infinite looping can occur (used internally by ZIM)

RETURNS the object for chaining
--*///+47.19

	// THE CODE FOR THE METHOD IS IN ZIM DISPLAY - CONTAINER

	//-47.19

// SUBSECTION ADDING AND REMOVING

/*--
obj.addTo = function(container, index, still)

addTo
zim DisplayObject method

DESCRIPTION
A wrapper function for addChild() / addChildAt() to add the obj to the container.
This allows us to chain more effectively:
var circle = new Circle().addTo(stage).drag();
Also, ZIM has obj.center(container) and obj.centerReg(container) functions
where the obj comes first followed by the container.
So it is a pain to flip things and use container.addChild(obj)
Now, we can use obj.addTo(container) and the object we are adding comes first.
The index parameter is similar to an addChildAt()
We can also use obj.removeFrom() to automatically remove from the container

EXAMPLE
const circle = new Circle(50, red);
circle.addTo(stage); // or just circle.addTo(); // for the default frame's stage
// with chaining - and dragging:
var circle = new Circle(50, red).addTo().drag();

const rect = new Rectangle(100, 100, blue);
rect.addTo(stage, 0); // place on bottom
END EXAMPLE

EXAMPLE
// Changing Coordinates
// An object may appear to change positions
// when you add from one container to another (the stage is a container too).
// This happens because the x and y origin inside the containers may be at different places
// yet the x and y property of the object remains unchanged.
// The "still" parameter converts between the coordinates and updates the x and y
// so that the object does not appear to jump - this defaults to true

const container = new Container().pos(100,100);
const rectangle = new Rectangle(200, 200, yellow).addTo(container);
// we want to drag the container and the circle
// but when the circle is in the container we want to drag the circle independently
// this leads to a tricky situation that can be solved as follows:
rectangle.on("mousedown", function() {container.drag({currentTarget:true});});
rectangle.on("pressup", function() {container.noDrag();});

const circle = new Circle(50, blue).center().drag();
// check to see if the circle is over the container and if so then add the circle
// try settin the third parameter to false to see what would normally happen
circle.on("pressup", ()=>{
	if (rectangle.hitTestReg(circle)) { // do not hitTest the container!
		circle.addTo(container); // keep position with default true as third parameter
	} else {
		circle.addTo(stage);
	}
	S.update();
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
container - (default first frame's stage) the container to add to
index - (default null) if provided will addChildAt the object at the index (0 being bottom)
still - (default true or false if no parent) makes object not move when added from one coordinate space to another
	this also may change the objects x and y properties - set to false not to do this
    uses localToLocal() to accomplish this
	the still parameter is ignored if object currently does not have a parent

RETURNS obj for chaining
--*///+47.5
	zim.addTo = function(obj, container, index, still) {
		var sig = "obj, container, index, still";
		var duo; if (duo = zob(zim.addTo, arguments, sig)) return duo;
		// if (obj.type=="AC"&&zdf) {zdf.ac("addTo", arguments); return obj;}
		z_d("47.5");
		if (zot(obj)) {zogy("zim methods - addTo(): please provide object"); return;}
		if (zot(container)) {
			if (WW.zdf) {container = WW.zdf.stage;}
			else {zogy("zim methods - addTo(): please provide container"); return;}
		}
		if (zot(still)) still = true;
		if (!obj.parent) still = false;

		if (still) var point = obj.parent.localToLocal(obj.x, obj.y, container);
		if (zot(index) || isNaN(index)) {container.addChild(obj);}
		else {container.addChildAt(obj, index);}
		if (still) {obj.x = point.x; obj.y = point.y;}
		return obj;
	};//-47.5

/*--
obj.removeFrom = function(container)

removeFrom
zim DisplayObject method

DESCRIPTION
A chainable wrapper function for removeChild() that removes the obj from the container
Matches obj.addTo(container)
We have obj.removeFrom(container)

NOTE: do not need to specify container as removeFrom() 
will remove the object from its parent.

EXAMPLE
const circle = new Circle(50, red);
circle.addTo(); // adds to stage
// later
circle.removeFrom(); // same as circle.removeFrom(stage)
END EXAMPLE

PARAMETERS
container - (default the object's parent) the container to remove the object from

RETURNS obj for chaining
--*///+47.6
	zim.removeFrom = function(obj, container) {
		z_d("47.6");
		if (zot(obj)) {zogy("zim methods - removeFrom(): please provide object"); return;}
		if (obj.removePhysics) obj.removePhysics();
		if (zot(container)) {
			if (obj.parent) obj.parent.removeChild(obj);
		}
		else container.removeChild(obj);
		return obj;
	};//-47.6

/*--
obj.added = function(call, interval, maxTime)

added
zim DisplayObject method

DESCRIPTION
Calls callback function when object is added to the stage
CreateJS has an "added" event that triggers when an object is added to another container
but this container may not be on the stage.
added polls several times quickly and then every 100ms to see if the object has a stage property
Once it does then it calls the callback and removes the interval

EXAMPLE
const circle = new Circle(50, red);
circle.added(()=>{zog("has stage");});
END EXAMPLE

PARAMETERS
callback - the function to call when added - will call right away if object is already added
	call will receive a reference to the stage and the object as parameters
** these two parameters are depricated as added no longer uses an interval as of ZIM Cat 03 patch
** but rather uses the "added" event and then checks to make sure it was the stage container the target was added to
interval - (default .1) time in seconds to check (also see ZIM TIME constant)
	keeps repeating until stage is there or maxTime is reached
maxTime - (default null) time in seconds to keep checking or forever if not provided

RETURNS id of interval so clearInterval(id) will stop added() from checking for stage
--*///+47.7
	zim.added = function(obj, call, interval, maxTime) {
		z_d("47.7");
		if (zot(obj) || zot(call) || typeof call != "function") return;
		
		// // Can't do it this way as object's container may be added after object is added to container
		// if (obj.stage) (call)(obj.stage, obj);
		// else {
		// 	obj.on("added", function(e) {
		// 		if (obj.stage) {
		// 			(call)(obj.stage, obj);
		// 			e.remove();
		// 		}
		// 	}); 
		// }	
		
		var timeType = getTIME(interval);
		if (zot(interval)) interval = timeType=="s"?.1:100;
		if (obj.stage) {(call)(obj.stage, obj); return;}
		var t = interval*(timeType=="s"?1000:1);
		var mt;
		if (maxTime) {
			checkTIME(maxTime);
			mt = maxTime*(timeType=="s"?1000:1);
		}
		var startTime = Date.now();
		var startCount = 0;
		var startID = setInterval(function() {
			if (startCount > 5) {
				clearInterval(startID);
				return;
			}
			startCount++;
			if (obj.stage) {
				(call)(obj.stage, obj);
				clearInterval(startID);
				clearInterval(id);
			}
		}, 10);
		var id = setInterval(function() {
			if (mt > 0 && startTime-Date.now()>mt) clearInterval(id);
			if (obj.stage) {
				(call)(obj.stage, obj);
				clearInterval(id);
			}
		}, t);
		return id;
		
	};//-47.7

/*--
obj.centerReg = function(container, index, add)

centerReg
zim DisplayObject method

DESCRIPTION
Centers the registration point on the bounds - obj must have bounds set.
Will default to adding the object to the container.
If no container parameter is provided and the object is in a container,
centerReg will center the object in the current container. Thanks Bracer Jack for the suggestion.
If no container and the object is not in a container,
centerReg will center the object on the default frame's stage.
A convenience function for setting both registration points at once.
Also see center() for centering without changing the registration point.
Also see reg(CENTER) for the same effect but without adding to container

SEE: https://zimjs.com/positioning

EXAMPLE
const rect = new Rectangle(100, 100, blue)
	.centerReg() // centers registration, centers and adds to stage
	.animate({obj:{rotation:360}, time:1, ease:"linear", loop:true});

// To just center the registration and not add it to a container
// use rect.centerReg(null, null, false);
// This is different than in the past where leaving out parameters would just center the registration
// The change is to match the default behaviour of addTo() and center() to add to stage without parameters
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
container - (default object's parent or if none, the first frame's stage) centers the object on and adds to the container
index - (default null) if provided will addChildAt the object at the index (0 being bottom)
	will be ignored if the add parameter is false
add - (default true) set to false to only center the object's registration
	setting to false will not remove the object if already added to a container

RETURNS obj for chaining
--*///+48
	zim.centerReg = function(obj, container, index, add) {
		var sig = "obj, container, index, add";
		var duo; if (duo = zob(zim.centerReg, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("centerReg", arguments); return obj.addTo(container, index);}
		z_d("48");
		if (zot(obj) || !obj.getBounds || !obj.getBounds()) {zogy("zim methods - centerReg(): please provide object with bounds set"); return obj;}
		if (zot(add)) add = true;
		if (zot(container) && obj.parent && add) {
			container = obj.parent;
			if (zot(index)) index = obj.parent.getChildIndex(obj);
			obj.parent.removeChild(obj);
		}
		if (!zot(container) && container == obj.parent) {
			if (zot(index)) index = obj.parent.getChildIndex(obj);
			obj.parent.removeChild(obj);
		}
		var oB = obj.getBounds();
		obj.regX = oB.x + oB.width/2;
		obj.regY = oB.y + oB.height/2;
		return add ? zim.center(obj, container, index) : obj;
	};//-48

/*--
obj.center = function(container, index, add)

center
zim DisplayObject method

DESCRIPTION
Centers the object on the container.
Will default to adding the object to the container.
If no container parameter is provided and the object is in a container,
center will center the object in the current container. Thanks Bracer Jack for the suggestion.
If no container and the object is not in a container,
center will center the object on the default frame's stage.
Also see centerReg() for centering registration point at same time.

SEE: https://zimjs.com/positioning

EXAMPLE
var rect = new Rectangle(100, 100, blue)
	.center() 	// centers and adds to stage
				// the below animation will be around the registration point at the top left corner
				// this is usually not desired - see centerReg() when rotating and scaling
	.animate({obj:{rotation:360}, time:1, ease:"linear", loop:true});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
container - (default object's parent or if none, the first frame's stage) centers the object on and adds to the container
index - (default null) if provided will addChildAt the object at the index (0 being bottom)
	will be ignored if the add parameter is false
add - (default true) set to false to only center and not add the object to the container
	setting to false will not remove the object if already added to a container

RETURNS obj for chaining
--*///+48.1
	zim.center = function(obj, container, index, add) {
		var sig = "obj, container, index, add";
		var duo; if (duo = zob(zim.center, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("center", arguments); return obj.addTo(container, index);}
		if (!zim.centerCheck) {z_d("48.1"); zim.centerCheck=true;}
		if (zot(obj) || !obj.getBounds) {zogy("zim.center(): please provide object with bounds"); return obj;}
		if (zot(container)) {
			if (obj.parent) container = obj.parent;
			else if (WW.zdf) container = WW.zdf.stage;
		}
		if (zot(container) || !container.getBounds)  {zogy("zim.center(): please provide container with bounds"); return obj;}

		var oB = obj.getBounds();
		var cB = container.getBounds();

		if (zot(add)) add = true;

		var resetCheck = false;
		if (zot(cB)) {
			container.setBounds(0,0);
			cB = container.getBounds();
			resetCheck = true;
		}

		if (add && container.addChild) {
            if (zot(index) || (typeof index === 'number' && isNaN(index))) {
				if (!obj.parent || obj.parent!=container) container.addChild(obj);
				// if (!container.contains(obj)) container.addChild(obj);
            } else {
                container.addChildAt(obj, index);
            }
        }
		if (zot(oB)) {
			obj.x = cB.x+cB.width/2;
			obj.y = cB.y+cB.height/2;
			return obj;
		}

		var zeroX = false;
		var zeroY = false;
		if (container.scaleX == 0) {
			zeroX = true;
			container.scaleX=.00001;
		}
		if (container.scaleY == 0) {
			zeroY = true;
			container.scaleY=.00001;
		}

		// get registration point of object in coordinates of the container
		var reg = obj.localToLocal(obj.regX, obj.regY, container);

		// get bounds of the object in global space even if object is rotated and scaled
		// this makes a rectangle surrounding a rotated object - so bigger but parallel edges to the x and y
		var glob = zim.boundsToGlobal(obj);

		// now project this rectangle into the container coordinates
		// passing in a rectangle (glob) will make this act on the rectangle rather than the bounds
		// flip (true) means we go from global to local in the container
		var loc = zim.boundsToGlobal(container, glob, true);

		if (zeroX) container.scaleX=0;
		if (zeroY) container.scaleY=0;

		// the positions are all in the container coordinate so do the calculation
		obj.x = cB.x + cB.width/2 - loc.width/2  + (reg.x-loc.x);
		obj.y = cB.y + cB.height/2 - loc.height/2  + (reg.y-loc.y);

		if (!add && container.getStage && container.stage && obj.parent) {
			var p = container.localToLocal(obj.x, obj.y, obj.parent);
			obj.x = p.x;
			obj.y = p.y;
		}
		if (resetCheck) container.setBounds(null);

		return obj;
	};//-48.1

/*--
obj.place = function(id)

place
zim DisplayObject method

DESCRIPTION
Sets the object to drag and logs to the console the x and y.
Also can use keyboard arrows for moving 1 pixel
and SHIFT keyboard arrows for moving 10 pixels.
This is for when building you can move an object around to position it
then when positioned, look at the console for the positioning code.
In your code, set the reported x and y and delete the place call.

EXAMPLE
circle.place("circle"); // lets you drag circle around - then see console
END EXAMPLE

PARAMETERS
id - (default null) the name of the object so that the log gives you complete code

RETURNS obj for chaining
--*///+49
	zim.place = function(obj, id) {
		z_d("49");
		if (zot(obj)) return;
		if (zot(id)) id = "obj";
		zim.lastPlace = obj;
		function report() {
			zogy(id+".x = " + Math.round(obj.x) +  "; "+id+".y = " + Math.round(obj.y) + ";");
			zogy(id+".loc(" + Math.round(obj.x) +  ", " + Math.round(obj.y) + ");");
		}
		zim.drag({obj:obj, currentTarget:true, dragCursor:"crosshair"});
		obj.on("mousedown", function () {
			zim.lastPlace = obj;
		});
		var frame = WW.zdf;
		if (frame) {
			frame.on("keydown", function (e) {
				if (obj != zim.lastPlace) return;
				var k = e.keyCode;
				if (k>=37 && k<=40) {
					var a = e.shiftKey?10:1;
					obj.mov(k==37?-1*a:k==39?1*a:0, k==38?-1*a:k==40?1*a:0);
					report();
					if (obj.stage) obj.stage.update();
				}
			});
		}
		zogy("place "+id+" - to get new position (" + obj.type + ")");
		obj.on("click", report);
		return obj;
	};//-49

/*--
obj.placeReg = function(id)

placeReg
zim DisplayObject method

DESCRIPTION
Gives draggable indicator to position a registration point in an object
This is for when building and when positioned, look at the console
for registration code and delete the placeReg call.

EXAMPLE
myContainer.placeReg("myContainer"); // lets you drag an indicator around - then see console
END EXAMPLE

PARAMETERS
id - (default null) the name of the object so that the log gives you complete code

RETURNS obj for chaining
--*///+49.5
	zim.placeReg = function(obj, id) {
		z_d("49.5");
		if (zot(obj)) return;
		var stage = obj.stage;
		if (zot(stage)) {zogy("zim.placeReg() - add object to stage before calling placeReg()");	return obj;}
		if (zot(id)) id = "obj";
		function report() {
			var p = obj.globalToLocal(cursor.x, cursor.y);
			zogy(id+".regX = " + Math.round(p.x) +  "; "+id+".regY = " + Math.round(p.y) + ";");
			zogy(id+".reg(" + Math.round(p.x) +  ", " + Math.round(p.y) + ");");
		}
		var p = obj.parent.localToGlobal(obj.x, obj.y);
		var cursor = new zim.Shape(-25, -25, 50, 50,null,false).addTo(stage).pos({x:p.x, y:p.y, reg:true});
		cursor.graphics.s("white").mt(-25,0).lt(25,0).mt(0,-25).lt(0,20);
		cursor.compositeOperation = "difference";
		cursor.expand(0);
		zim.drag({obj:cursor});
		zogy("place cursor to get new registration point location");
		stage.on("stagemouseup", report);
		return obj;
	};//-49.5

// SUBSECTION SHORT CHAINABLE

/*--
obj.pos = function(x, y, horizontal, vertical, container, index, add, reg, regX, regY)

pos
zim DisplayObject method

DESCRIPTION
Chainable convenience function to position an object and optionally add to a container
pos() provides easy positioning around the edges of a container.

pos() has gone through three versions:
VERSION 1 - positioned the registration point and has been replaced with loc()
VERSION 2 - positioned left, right top or bottom with right and bottom being specified with boolean true
VERSION 3 - positions left, right, center, top and bottom with ZIM positioning constants

pos() positions objects from the edges of the container or on the stage if no container provided
This defaults to the left of the object from the left and the top of the object from the top
If the horizontal parameter is set to RIGHT it will position the right of the object from the right of the container
If the vertical parameter is set to BOTTOM it will position the bottom of the object from the bottom of the container
If CENTER is provided, it centers the object on the axis and then moves it the x or y provided
Setting reg (or regX, regY) to true will position to the registration point - also see POSREG constant

SEE: https://zimjs.com/positioning

EXAMPLE
// 1. adds circle to default stage moves left and top of circle to 100, 100
circle1.pos(100, 100);

// 2. adds circle to box and positions right and bottom of circle 100 and 200
// from right and bottom of box bounds
circle2.pos(100, 200, RIGHT, BOTTOM, box)
// or
circle2.pos(100, 200, RIGHT, "bottom", box)
// or
circle2.pos(100, 200, true, true, box);

// 3. centers the circle in x and moves 100 and places circle 200 from bottom
circle3.pos(100, 200, CENTER, BOTTOM);

// 4. adds to stage and puts registration point at x=200 and y=0
circle4.pos({x:200, reg:true});

// 5. adds to stage and puts registration point at x=200 and y=radius (not y=0)
circle5.pos({x:200, regX:true});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
x - (default null or 0 for right) the x distance in the container to the left or right side of the object
	which side, depends on the right parameter
	if reg or regX is true then it is the distance to the registration point not the side
y - (default null or 0 for bottom) the y distance in the container to the top or bottom of the object
	which one, depends on the bottom parameter
	if reg or regY is true then it is the distance to the registration point not the top or bottom
horizontal - (default LEFT) LEFT will position the left side to the left side of the container bounds
 	set to RIGHT to postion the right side from the right of the container bounds
	if reg or regX is true then it is the distance to the registration point not the side
	set to CENTER or MIDDLE to center object and move amount provided in x
	if reg or regX is true then centers the registration point and moves the amount provided in x
	set to START to position LEFT for ZIM DIR constant is "ltr" or RIGHT when DIR="rtl" - END is the opposite
vertical - (default TOP) TOP will position the top side to the top side of the container bounds
 	set to BOTTOM to postion the bottom side from the bottom of the container bounds
	if reg or regY is true then it is the distance to the registration point not the side
	set to CENTER or MIDDLE to center object and move amount provided in y
	if reg or regY is true then centers the registration point and moves the amount provided in y
container - (default current container or zdf stage) the Container to add the obj to and position
index - (default null) if provided will addChildAt the object at the index (0 being bottom)
add - (default true) add to container - set to false to not add
reg - (default false) set to true to position to the registration point rather than sides, top or bottom
	See: POSREG contant - set POSREG=true; to change the default pos() to position the registration point
	This is good to adjust legacy code - or if the original pos setting is preferred.
regX - (default reg) set to true to position x to the registration point rather than the sides
	will override reg if provided
regY - (default reg) set to true to position y to the registration point rather than the top or bottom
	will override reg if provided

PROPERTIES
zimPos - added to the obj and holds an object with the initial pos() parameter values as follows:
	{x,y,h,v,i} for x, y, horizontal, vertical and index.
	note: to get the container ask for the obj parent property
		
RETURNS obj for chaining
--*///+41.5
	zim.pos = function(obj, x, y, horizontal, vertical, container, index, add, reg, regX, regY) {
		var sig = "obj, x, y, horizontal, vertical, container, index, add, reg, regX, regY";
		var duo; if (duo = zob(zim.pos, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("pos", arguments); return obj.addTo(container, index);}
		z_d("41.5");
		
		// handle DIR effect 
		if ((WW.DIR && WW.DIR=="rtl") || (!WW.DIR && zim.DIR=="rtl")) {
			if (horizontal=="start") horizontal="right";
			else if (horizontal=="end") horizontal="left";
		} else {
			if (horizontal=="start") horizontal="left";
			else if (horizontal=="end") horizontal="right";
		}

		// converting to version 2 format with right and bottom boolean parameters
		// still will need to deal with new version 3 center values
		var right = false;
		if (horizontal == "right") right = true;
		var bottom = false;
		if (vertical == "bottom") bottom = true;

		var PR = zim.POSREG;
		if (WW.POSREG != null) PR = WW.POSREG;
		if (zot(reg)) reg = PR;

		if (zot(obj)) return;
		if (zot(reg) && zot(regX)) regX = false; // regX and regY override reg
		if (zot(reg) && zot(regY)) regY = false;
		if (!zot(reg) && zot(regX)) regX = reg;
		if (!zot(reg) && zot(regY)) regY = reg;

		if (zot(add)) add = true;
		if (!zot(container) && !container.addChild) container = null;
		if (!obj.getBounds && !obj.getBounds()) {regX = regY = false;}

		obj.zimPos = {x:x,y:y,h:horizontal,v:vertical,i:index};

		if (zot(container)) {
			if (obj.parent) container = obj.parent;
			else if (WW.zdf) container = WW.zdf.stage;
		}

		if (!obj.parent && zot(x)) x = 0;
		if (!obj.parent && zot(y)) y = 0;

		var resetObjCheck = false;
		if (!obj.getBounds()) {
			obj.setBounds(0,0);
			resetObjCheck = true;
		}

		var resetContainerCheck = false;
		if (container && !container.getBounds()) {
			container.setBounds(0,0);
			resetContainerCheck = true;
		}

		function addMe() {
			if (zot(index) || (typeof index === 'number' && isNaN(index))) {
				if (!container.contains(obj)) container.addChild(obj);
			} else {
				container.addChildAt(obj, index);
			}			
		}
		if (!zot(container) && container.addChild && add) {
			var lastBounds = container.getBounds().clone();			
			addMe();
			var currentBounds = container.getBounds();
			if (
				lastBounds.width!=currentBounds.width ||
				lastBounds.height!=currentBounds.height ||
				lastBounds.x!=currentBounds.x ||
				lastBounds.y!=currentBounds.y
			) {
				obj.removeFrom();
				container.setBounds(lastBounds.x, lastBounds.y, lastBounds.width, lastBounds.height); // lock bounds
				resetContainerCheck = true; // to set bounds to flex later
				addMe();
			}
		}
				
		// deal with version 3 center values
		if (!regX && !regY) {
			if ((horizontal == "center" || horizontal == "middle") && (vertical == "center" || vertical == "middle")) {
				obj.center({container:container});
				obj.mov(x, y);
				if (resetObjCheck) obj.setBounds(null);
				if (resetContainerCheck) container.setBounds(null);
				return obj;
			}
		}
		if (horizontal == "center" || horizontal == "middle") {
			if (regX) obj.x = container.width / 2;
			else {
				var yy = obj.y;
				obj.center();
				obj.y = yy;
			}
			obj.mov(x);
			x = null;
			horizontal = null;
		} else {
			if (horizontal === true) right = true;
		}
		if (vertical == "center" || vertical == "middle") {
			if (regY) obj.y = container.height / 2;
			else {
				var xx = obj.x;
				obj.center();
				obj.x = xx;
			}
			obj.mov(0,y);
			y = null;
			vertical = null;
		} else {
			if (vertical === true) bottom = true;
		}
		// end version 3 adjust

		function getTransformedBounds () {
			var bounds = obj.getBounds();
			var x = bounds.x, y = bounds.y, width = bounds.width, height = bounds.height, mtx = obj._props.matrix;
			mtx = obj.getMatrix(mtx);
			if (x || y) { mtx.appendTransform(0,0,1,1,0,0,0,-x,-y); }
			var x_a = width*mtx.a, x_b = width*mtx.b;
			var y_c = height*mtx.c, y_d = height*mtx.d;
			var tx = mtx.tx, ty = mtx.ty;
			var minX = tx, maxX = tx, minY = ty, maxY = ty;
			if ((x = x_a + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((x = x_a + y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((x = y_c + tx) < minX) { minX = x; } else if (x > maxX) { maxX = x; }
			if ((y = x_b + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			if ((y = x_b + y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			if ((y = y_d + ty) < minY) { minY = y; } else if (y > maxY) { maxY = y; }
			return {x:minX, y:minY, width:maxX-minX, height:maxY-minY};
		}

		if (obj.parent && obj.parent.getBounds) {
			container = obj.parent;

			if (zot(x) && right==true) x = 0;
			if (zot(y) && bottom==true) y = 0;

			if (!zot(x)) obj.x = x;
			if (!zot(y)) obj.y = y;
			if (zot(x) && zot(y) && !right && !bottom) {
				if (resetObjCheck) obj.setBounds(null);
				if (resetContainerCheck) container.setBounds(null);
				return obj;
			}

			var shiftX = 0;
			var shiftY = 0;
			
			if (obj.getBounds()) {
				// var projected = obj.getTransformedBounds(); // copy of CreateJS version but without setting bounds
				var projected = getTransformedBounds(); // copy of CreateJS version but without setting bounds
			
				if (!zot(x)) {
					var local;
					if (!right) {
						local = new zim.Point(projected.x, projected.y);
					} else {
						local = new zim.Point(projected.x+projected.width, projected.y+projected.height);
					}
					shiftX = local.x-x;
				}
				if (!zot(y)) {
					if (!bottom) {
						local = new zim.Point(projected.x, projected.y);
					} else {
						local = new zim.Point(projected.x+projected.width, projected.y+projected.height);
					}
					shiftY = local.y-y;
				}

				var b = container.getBounds();
				if (!zot(x)) {
					if (right) {
						if (regX) obj.x = b.width+b.x-x;
						else obj.x = b.width+b.x-x-shiftX;
					} else {
						if (regX) obj.x = x;
						else obj.x = x-shiftX;
						obj.x += b.x;
					}
				}
				if (!zot(y)) {
					if (bottom) {
						if (regY) obj.y = b.height+b.y-y;
						else obj.y = b.height+b.y-y-shiftY;
					} else {
						if (regY) obj.y = y;
						else obj.y = y-shiftY;
						obj.y += b.y;
					}
				}
			}
			// obj.x+=b.x*2;
			// obj.y+=b.y*2;
		}
		if (resetObjCheck) obj.setBounds(null);
		if (resetContainerCheck) container.setBounds(null);
		if (!add) obj.removeFrom();
		return obj;
	};//-41.5

/*--
obj.loc = function(target|x, y, container, index, add, localToLocal)

loc
zim DisplayObject method

DESCRIPTION
locates obj registration at registration of provided target
or at x and y if numbers are provided
This is like the original pos() where the registration is used
But it a single object with x y properties can be passed as a parameter
Will calculate localToLocal if target is provided
Also can add to container at an index

SEE: https://zimjs.com/positioning

EXAMPLE
const circle1 = new Circle().pos(100,100);
const circle2 = new Circle().loc(circle1); // adds on top of circle1
END EXAMPLE

EXAMPLE
new Circle().loc(400, 400); // places reg of circle at 400, 400
// note, this is different than pos(400, 400) which would place left top of circle at 400, 400
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
target | x - (default null) an object with x and y properties such as any ZIM Display Object (Rectangle, Button, etc)
	or a zim Point(100, 100) object or {x:100, y:300}, etc.
	or an Array with an x and y value [100,300]
	or can be a Number for an x value - in which case, a y value might be expected too
y - (default null) an optional y value
container - (default current container or zdf stage) the Container to add the obj to and position
index - (default null) if provided will addChildAt the object at the index (0 being bottom)
add - (default true) add to container - set to false to not add
localToLocal - (default true) if target is provided, the obj will be placed on the target matching locations across coordiate spaces

RETURNS obj for chaining
--*///+41.55
	zim.loc = function(obj, target, y, container, index, add, localToLocal, x) {
		var sig = "obj, target, y, container, index, add, localToLocal, x";
		var duo; if (duo = zob(zim.loc, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("loc", arguments); return obj.addTo(container, index);}
		z_d("41.55");
		if (zot(obj)) return;
		if (typeof target == "number") {
			x = target;
			target = null;
		}
		if (!zot(target)) {
			if (Array.isArray(target)) {
				x = target[0];
				y = target[1];
			} else {
				if (!zot(target.x)) x = target.x;
				if (!zot(target.y)) y = target.y;
			}
		}
		if (zot(x) && zot(target)) x = obj.x;
		if (zot(y) && zot(target)) y = obj.y;

		if (zot(add)) add = true;
		if (zot(container)) {
			if (obj.parent) container = obj.parent;
			else if (WW.zdf) container = WW.zdf.stage;
		}
		if (add && container) {
			if (!obj.parent || container != obj.parent) {
				if (zot(index) || isNaN(index)) {container.addChild(obj);}
				else {
					container.addChildAt(obj, index);
				}
			} else if (!zot(index)) {
				container.addChildAt(obj, index);
			}
		}
		if (zot(localToLocal)) localToLocal = true;
		if (target && target.parent && obj.parent && localToLocal) {
			var point = target.parent.localToLocal(x, y, obj.parent);
			x = point.x;
			y = point.y;
		}
		obj.x = x;
		obj.y = y;
		return obj;
	};//-41.55

/*--
obj.mov = function(x, y)

mov
zim DisplayObject method

DESCRIPTION
Move the object over in the x and/or y
Equivalant to obj.x += x and obj.y += y
Pass in 0 for no shift in x if you just want to shift y
Gives chainable relative position

SEE: https://zimjs.com/positioning

EXAMPLE
new Circle().center().mov(50); // move to right 50
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
x - (default 0) the distance in x to move (can be negative)
y - (default 0) the distance in y to move (can be negative)

RETURNS obj for chaining
--*///+41.6
	zim.mov = function(obj, x, y) {
		var sig = "obj, x, y";
		var duo; if (duo = zob(zim.mov, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("mov", arguments); return obj;}
		z_d("41.6");
		if (zot(obj)) return;
		if (!zot(x)) obj.x += x;
		if (!zot(y)) obj.y += y;
		return obj;
	};//-41.6

/*--
obj.sca = function(scale, scaleY)

sca
zim DisplayObject method

DESCRIPTION
Chainable convenience function to do scaleX and scaleY in one call.
If you pass in just the scale parameter, it scales both x and y to this value.
If you pass in scale and scaleY then it scales x and y independently.
Also see scaleTo(), fit() and Layout().

EXAMPLE
circle.sca(.5); // x and y scale to .5
circle.sca(.5, 2); // x scale to .5 and y scale to 2
END EXAMPLE

PARAMETERS
scale - the scale (1 being full scale, 2 being twice as big, etc.)
scaleY - (default null) pass this in to scale x and y independently

RETURNS obj for chaining
--*///+41.97
	zim.sca = function(obj, scale, scaleY) {
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("sca", arguments); return obj;}
		z_d("41.97");
		if (zot(obj) || zot(obj.scaleX)) return obj;
		if (zot(scale)) scale = obj.scaleX;
		if (zot(scaleY)) scaleY = scale;
		obj.scaleX = scale; obj.scaleY = scaleY;
		return obj;
	};//-41.97

/*--
obj.alp = function(alpha)

alp
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set the alpha
See also the CreateJS set({prop:val, prop2:val}) method;
See also vis() and visible to keep hitTests as alp(0) does not

EXAMPLE
circle.alp(.5);
END EXAMPLE

PARAMETERS
alpha - (default null) the alpha between 0 and 1

RETURNS obj for chaining
--*///+41.7
	zim.alp = function(obj, alpha) {
		z_d("41.7");
		if (zot(obj)) return;
		if (!zot(alpha)) {
			obj.alpha = obj.hovOriginal = alpha;			
			if (obj.tag && obj.tag.style) {
				if (obj.type!="Loader") obj.tag.style.opacity = alpha;
				if (alpha == 0) obj.tag.style.display = obj.tag.zimDisplay = "none";
				else obj.tag.style.display = obj.tag.zimDisplay = "inline-block";			
			}
		}
		return obj;
	};//-41.7
	
/*--
obj.vis = function(visible)

vis
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set the visible
Also see alp() and alpha

EXAMPLE
circle.vis(false);
END EXAMPLE

PARAMETERS
visible - (default true) boolean for visibility

RETURNS obj for chaining
--*///+41.71
	zim.vis = function(obj, visible) {
		z_d("41.71");
		if (zot(obj)) return;
		obj.visible = visible;
		if (obj.tag && obj.tag.style) {
			if (!visible) obj.tag.style.display = obj.tag.zimDisplay = "none";
			else obj.tag.style.display = obj.tag.zimDisplay = "inline-block";			
		}
		return obj;
	};//-41.71

/*--
obj.ble = function(blendMode)

ble
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set the blendMode (compositeOperation)

Also see:
https://developer.mozilla.org/en-US/docs/Web/API/CanvasRenderingContext2D/globalCompositeOperation

EXAMPLE
new Circle(100, red).center().ble("difference");

// note: a blendMode will not work against the background color of the canvas  
// if this is desired, add a rectangle onto the stage to start
new Rectangle(W, H, F.color).addTo();
new Circle(100, red).center().ble("difference");
END EXAMPLE

PARAMETERS
blendMode - (default "difference") the blendMode string:
		normal, multiply, screen, overlay, darken, lighten
		color-dodge, color-burn,  hard-light, soft-light
		difference, exclusion, hue, saturation, color, luminosity
	OR the compositeOperation string:	
		source-over, source-in, source-out, source-atop, 
		destination-over, destination-in, destination-out, destination-atop, 
		copy, xor

RETURNS obj for chaining
--*///+41.72
	zim.ble = function(obj, blendMode) {
		z_d("41.72");
		if (zot(obj)) return;
		if (zot(blendMode)) blendMode = "difference";
		obj.compositeOperation = blendMode;
		if (obj.type == "Blob" || obj.type == "Squiggle") obj.update();
		return obj;
	};//-41.72

/*--
obj.dye = function(color)

dye
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set the color of a shape 
or the backgroundColor of an object with backgroundColor
Also see color and backgroundColor properties

EXAMPLE
circle.dye(red); // same as circle.color = red; 
button.dye(blue); // same as button.backgroundColor = blue;
END EXAMPLE

PARAMETERS
color - a ZIM or HTML color - green, "blue", "#333", etc.

RETURNS obj for chaining
--*///+41.73
	zim.dye = function(obj, color) {
		z_d("41.73");
		if (zot(obj)) return;
		// FIX in ZIM ZIM 02
		// if (obj.hasOwnProperty("backgroundColor") && obj.type != "Label") obj.backgroundColor = color;
		if (obj.hasOwnProperty("backgroundColor")) obj.backgroundColor = color;
		else if (obj.hasOwnProperty("color")) obj.color = color;
		return obj;
	};//-41.73

/*--
obj.hov = function(value, prop)

hov
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set the rollover (hover) property of an object
This defaults to alpha if a number and color if a string
But the type of property can also be set - for multiple properties, use a Button
This sets mouseover and mouseout events on the object
It will also set the cursor of the object to "pointer"
This can be changed with the cursor property or the cur() method

EXAMPLE
new Circle().center().alp(.5).hov(.8);
new Rectangle(100,100,blue).center().hov(green);
new Triangle().center().hov(1.5, "scale");
END EXAMPLE

PARAMETERS
value - (default 1) the hover value of the property
	if a number, the default property is alpha
	if a string, the default property is color
	passing in -1 will remove the hover
prop - (default alpha or color as stated above) the property to change to the value on hover

RETURNS obj for chaining
--*///+41.75
	zim.hov = function(obj, value, type) {
		z_d("41.75");
		if (zot(obj)) return;
		if (zot(value)) value = 1;
		if (zot(type)) type = (typeof value == "number") ? "alpha" : "color";
		if (obj.hovMouseover) {
			obj.off("mouseover", obj.hovMouseover);
			obj.off("mouseout", obj.hovMouseout);
		}
		if (value == -1) {
			obj.cur("default");
			if (!zot(obj.hovOld)) obj[obj.hovType] = obj.hovOld;
			obj.hovOld = null;
			if (obj.stage) obj.stage.update();
			return obj;
		}
		obj.cur();
		obj.hovOld = obj[type];
		obj.hovNew = value;
		obj.hovType = type;
		obj.hovMouseover = obj.on("mouseover", function () {
			obj[type] = obj.hovNew;
			if (obj.stage) obj.stage.update();
		});
		obj.hovMouseout = obj.on("mouseout", function () {
			obj[type] = obj.hovOld;
			if (obj.stage) obj.stage.update();
		});
		return obj;
	};//-41.75

/*--
obj.rot = function(rotation, x, y)

rot
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set the rotation
See also the CreateJS set({prop:val, prop2:val}) method;

EXAMPLE
new Rectangle().center().rot(180);
END EXAMPLE

PARAMETERS
rotation - (default null) the rotation in degrees
x - (default regX) set an x value to rotate about
y - (default regY) set a y value to rotate about

RETURNS obj for chaining
--*///+41.8
	zim.rot = function(obj, rotation, x, y) {
		z_d("41.8");
		if (zot(obj)) return;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("rot", arguments); return obj;}
		if (!zot(rotation)) {
			if (obj.parent && (!zot(x) || !zot(y))) {
				if (zot(x)) x = obj.x;
				if (zot(y)) y = obj.y;
				var inside = obj.parent.localToLocal(x, y, obj);
				var outside = new zim.Point(obj.x, obj.y);
				obj.reg(inside.x, inside.y);
				obj.rotation=rotation;
				obj.x = x;
				obj.y = y;
				var backPoint = obj.parent.localToLocal(outside.x, outside.y, obj);
				obj.reg(backPoint.x, backPoint.y);
				obj.x = outside.x;
				obj.y = outside.y;
			} else {
				obj.rotation=rotation;
			}
		}
		return obj;
	};//-41.8

/*--
obj.siz = function(width, height, only)

siz
zim DisplayObject method

DESCRIPTION
Chainable convenience function to set width and height in one call.
If you pass in just the width or height parameter, it keeps the aspect ratio.
If you want to set only the width or height, then set only to true.
If you pass in both the width and height then it sets both.
Note: that width and height will adjust the scaleX and scaleY of the object.
Also see width, height, widthOnly, heightOnly.

EXAMPLE
const rect = new Rectangle(100,200,blue).addTo();
rect.siz(200); // sets width to 200 and height to 400
rect.siz(200, null, true); // sets width to 200 and leaves height at 200
rect.siz(200, 100); // sets width to 200 and height to 100
END EXAMPLE

PARAMETERS
width - (default null) the width of the object
	setting only the width will set the widht and keep the aspect ratio
	unless the only parameter is set to true
height - (default null) the height of the object
	setting only the width will set the widht and keep the aspect ratio
	unless the only parameter is set to true
only - (default false) - defaults to keeping aspect ratio when one dimension set
 	set to true to scale only a single dimension (like widthOnly and heightOnly properties)

RETURNS obj for chaining
--*///+41.85
	zim.siz = function(obj, width, height, only) {
		z_d("41.85");
		if (zot(obj)) return;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("siz", arguments); return obj;}
		if (zot(only)) only = false;
		if (!zot(width) && !zot(height)) {
			obj.widthOnly = width; obj.heightOnly = height;
		} else if (!zot(width)) {
			if (only) {obj.widthOnly = width;} else {obj.width = width;}
		} else if (!zot(height)) {
			if (only) {obj.heightOnly = height;} else {obj.height = height;}
		}
		return obj;
	};//-41.85

/*--
obj.ske = function(skewX, skewY)

ske
zim DisplayObject method

DESCRIPTION
Chainable convenience function to skewX and skewY (slant)
See also the CreateJS set({prop:val, prop2:val}) method;

EXAMPLE
new Circle().center().ske(20);
END EXAMPLE

PARAMETERS
skewX - (default null) the x skew
skewY - (default null) the y skew

RETURNS obj for chaining
--*///+41.9
	zim.ske = function(obj, skewX, skewY) {
		z_d("41.9");
		if (zot(obj)) return;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("ske", arguments); return obj;}
		if (!zot(skewX)) obj.skewX = skewX;
		if (!zot(skewY)) obj.skewY = skewY;
		return obj;
	};//-41.9

/*--
obj.reg = function(regX, regY, still)

reg
zim DisplayObject method

DESCRIPTION
Chainable convenience function to regX and regY (registration point)
The registration point is the point the object is positioned with
and the object scales and rotates around the registration point
See also the CreateJS set({prop:val, prop2:val}) method;
See also centerReg()

NOTE: most rectangular objects have their registration at the top left 
whereas most circular objects (not images, though) have their registration point in the center.
But this registration point can be moved anywhere. 

See: https://codepen.io/zimjs/pen/qBEjYZV

EXAMPLE
new Circle().reg(200, 200).center().outline(); // the circle in the outline() shows the registration point
END EXAMPLE

EXAMPLE
new Rectangle().reg(RIGHT,BOTTOM).center(); // place reg at the bottom right corner
END EXAMPLE

PARAMETERS
regX - (default null) the x registration as a number 
	or use LEFT, CENTER, RIGHT, START, END (for START and END, see DIR setting)
	use CENTER with no regY to center both regX and regY 
	use CENTER for regX and DEFAULT for regY to only center regX
regY - (default null) the y registration as a number
	or use TOP, CENTER, BOTTOM
still - (default false) set to true to move the object to counter the registration change
	this will let you set the registration point without moving the object

RETURNS obj for chaining
--*///+41.95
	zim.reg = function(obj, regX, regY, still) {
		z_d("41.95");
		if (zot(obj)) return;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("reg", arguments); return obj;}
		var lastRegX = obj.regX;
		var lastRegY = obj.regY;
		var originalX = regX;
		var DIR = WW.DIR || zim.DIR || "ltr";
		var bounds;
		if (regX=="default") regX = null;
		
		// handle constants
		if (typeof regX == "string") {
			bounds = obj.getBounds();
			if (!bounds) regX = null; 
			else {				
				if (regX=="start") regX=DIR=="ltr"?"left":"right";
				if (regX=="end") regX=DIR=="ltr"?"right":"left";
				if (regX=="left") regX = bounds.x;
				else if (regX=="right") regX = bounds.x+bounds.width;				
				else if (regX=="center"||regX=="middle") regX = bounds.x+bounds.width/2;
			}			
		} 
		if (typeof regY == "string") {
			if (!bounds) bounds = obj.getBounds();
			if (!bounds) regY = null;
			else if (regY=="top") regY = bounds.y;
			else if (regY=="bottom") regY = bounds.y+bounds.height;
			else if (regY=="center"||regY=="middle") regY = bounds.y+bounds.height/2;
		} else if (zot(regY) && (originalX=="center"||originalX=="middle")) {
			if (!bounds) bounds = obj.getBounds();
			if (!bounds) regY = null;
			else regY = bounds.y+bounds.height/2;			
		}		
		if (regY == "default") regY = null;
		
		if (!zot(regX)) obj.regX = regX;
		if (!zot(regY)) obj.regY = regY;
		if (still && obj.parent) {
			var p = obj.localToLocal(lastRegX, lastRegY, obj.parent);
			obj.x -= p.x-obj.x;
			obj.y -= p.y-obj.y;
		}
		return obj;
	};//-41.95

/*--
obj.top = function()

top
zim DisplayObject method

DESCRIPTION
Places object on top layer in container - if in a container
returns the object for chaining
Can also just addTo(container) to re-add to top
NOTE for some situations this will break code
so a safer way is obj.parent.setChildIndex(obj, obj.parent.numChildren-1);
which is what this method uses

EXAMPLE
const circle = new Circle(100, red).center();
new Rectangle(200,200,blue).center();
circle.top(); // brings circle to the top of parent container - in this case, the stage
END EXAMPLE

RETURNS obj for chaining
--*///+41.62
	zim.top = function(obj) {
		z_d("41.62");
		if (zot(obj) || !obj.parent) return obj;
		obj.parent.setChildIndex(obj, obj.parent.numChildren-1);
		return obj;
	};//-41.62

/*--
obj.bot = function()

bot
zim DisplayObject method

DESCRIPTION
Places object on bottom layer in container - if in a container
returns the object for chaining

EXAMPLE
new Rectangle(200,200,blue).center();
new Circle(100, red).center().bot(); // put circle on bottom layer (0) of parent container
END EXAMPLE

RETURNS obj for chaining
--*///+41.63
	zim.bot = function(obj) {
		z_d("41.63");
		if (zot(obj) || !obj.parent) return obj;
		obj.parent.setChildIndex(obj, 0);
		return obj;
	};//-41.63

//
/*--
obj.ord = function(num)

ord
zim DisplayObject method

DESCRIPTION
Moves object layer order in container - if in a container
returns the object for chaining

EXAMPLE
circle.bot().ord(1); // put circle one layer up from bottom of parent container
circle.top().ord(-2); // put circle two layers down from top (third highest layer)
END EXAMPLE

PARAMETERS
num - (default 0) the number of levels (layers) up or down to move the object
	1 will move the object one level higher, -1 will move it one level lower
	2 will move the object two levels higher, -2 will be two levels lower, etc.

RETURNS obj for chaining
--*///+41.64
	zim.ord = function(obj, num) {
		z_d("41.64");
		if (zot(obj) || !obj.parent) return;
		if (zot(num)) num = 0;
		obj.parent.setChildIndex(obj, zim.constrain(obj.parent.getChildIndex(obj)+num, 0, obj.parent.numChildren-1));
		return obj;
	};//-41.64

/*--
obj.cur = function(type)

cur
zim DisplayObject method

DESCRIPTION
Chainable function that sets the object's cursor to the type provided - same as CSS cursors.

NOTE: if using drag(), it will set its own cursor, so use the dragCursor parameter in that case.

NOTE: there are also custom cursors as the cursors property of Frame.

EXAMPLE
const circle = new Circle(10, red).center().cur(); // "pointer"
circle.on("click", ()=>{zog("yes");});
END EXAMPLE

PARAMETERS
type - (default "pointer") the CSS cursor to set
	https://developer.mozilla.org/en-US/docs/Web/CSS/cursor
	Common cursors are "default", "pointer", "none", "Wait", "move", "grab", "grabbing", "zoom-in", "zoom-out", and various resize like "ew-resize"

RETURNS obj for chaining
--*///+41.1
	zim.cur = function(obj, type) {
		z_d("41.1");
		if (zot(obj)) {zogy("zim methods - cur(): please provide object"); return obj;}
		if (zot(type)) type = "pointer";

		var f = WW.zdf;
		if (obj.stage) f = obj.stage.frame;
		
		if (f.cursors) {
			// set cursor to none and record desired in cursorList
			if (f.cursors[type]) {
				obj.cursor = "none";
				obj._cursor = type;
				f.cursorList.add(obj, type);
				return obj;
			}
		} 

		// set that cursor is to be adjusted but keep as true
		if (f.cursorList) f.cursorList.add(obj, true);

		obj.cursor = type;
		return obj;
	};//-41.1

/*--
obj.sha = function(color||Shadow, offsetX, offsetY, blur)

sha
zim DisplayObject method

DESCRIPTION
Chainable function that sets the object's drop shadow to a CreateJS Shadow indirectly or directly

EXAMPLE
// indirectly set the CreateJS Shadow
// with sha(color, offsetX, offsetY, blur)
const circle = new Circle(10, red).center().sha("rgba(0,0,0,.2)", 10, 5, 5);

// directly set the CreateJS Shadow
// with sha(new createjs.Shadow())
const shadow = new createjs.Shadow("rgba(0,0,0,.2)", 10, 5, 5);
const circle1 = new Circle(10, "pink").center().mov(-30).sha(shadow);
const circle2 = new Circle(10, "yellow").center().mov(30).sha(shadow);
END EXAMPLE

PARAMETERS
color||Shadow (default "rgba(0,0,0,.3)") the CSS color for the shadow - "red", dark, etc.
	or pass a single parameter that is a CreateJS Shadow object https://www.createjs.com/docs/easeljs/classes/Shadow.html
	pass in -1 to remove a shadow - remember to S.update()
offsetX (default .08 the width or 5 if no width) the distance in the x that the shadow is moved over - can be negatitve
offsetY (default .08 the height or 5 if no height) the distance in the y that the shadow is moved over - can be negatitve
blur (default .16 the width or 10 if no width) the distance the shadow is blurred

RETURNS obj for chaining
--*///+41.2
	zim.sha = function(obj, color, offsetX, offsetY, blur) {
		z_d("41.2");
		if (zot(obj)) {zogy("zim methods - sha(): please provide object"); return obj;}
		if (zot(color)) color = "rgba(0,0,0,.3)";
		if (color.blur) {obj.shadow = color; return obj;} // a Shadow is passed as first parameter
		if (zot(offsetX)) offsetX = obj.width ? obj.width *.08 : 5;
		if (zot(offsetY)) offsetY = obj.height ? obj.height *.08 : 5;
		if (zot(blur)) blur = obj.width ? obj.width *.16 : 10;
		if (color == -1) obj.shadow = null;
		else obj.shadow = new createjs.Shadow(color, offsetX, offsetY, blur);
		return obj;
	};//-41.2

/*--
obj.dep = function(depth)

dep
zim DisplayObject method

DESCRIPTION
A chainable method to set the depth property of a Display object for use with ZIM VR().
When the object is added to VR it will be cloned into two channels and shifted left and right based on its depth.
A depth of 0 will not shift the object and this will appear flat on the screen.
A depth of 20 will shift 20 pixels left and right and appear to come out of the screen.
A depth of -20 will appear to go into the screen.
Depending on the VR parallax settings, depth can also affect parallax.
A negative depth does not unless negativeParallax is set to true in the VR parameters.

EXAMPLE
new Circle().center().dep(10);
END EXAMPLE

PARAMETERS
depth - (default 0) the apparent depth in ZIM VR - or set the depth property

RETURNS obj for chaining
--*///+41.65
	zim.dep = function(obj, depth) {
		z_d("41.65");
		if (zot(obj)) return;
		if (zot(depth)) depth = 0;
		obj.depth = depth;
		return obj;
	};//-41.65

/*--
obj.nam = function(name)

nam
zim DisplayObject method

DESCRIPTION
A chainable method to set the name property of a DisplayObject.
The object can then be accessed with object("name") (or zim.object("name") if zns is true)

BACKGROUND
CreateJS provides Containers with a name property and a getChildByName() method
but you have to remember to ask the parent container for the child and it is a little lengthy.
In ZIM Cat 01, nam() and object() were introduced as a global way to handle object names.
Usually, a variable name is used to reference objects but the name offers an alternative.

Note: naming an object with the same name will overwrite earlier names accessible through object()
This will NOT remove the name property from the previous object
So it is possible that the previous object can still be accessed with parent.getChildByName()
parent.getChildByName() will find the first child with that name in the container
object() will find the last named object with that name anywhere
We could remove previous name properties with the same name but we decided not to
Let us know your thoughts at https://forum.zimjs.com

EXAMPLE
new Circle().nam("ball").center();

// see what names there are:
zog(object.getNames()); // ["ball"] - if only "ball" has been named

if (mobile()) object("ball").sca(2);
else object("ball").dispose();

zog(object.getNames()); // [] - if only "ball" has been named

object("ball").tap(e=>{
	zog(e.target.name); // "ball"
});
END EXAMPLE

PARAMETERS
name - a String to set the name property of the object

RETURNS obj for chaining
--*///+41.67
	zim.nam = function(obj, name) {
		z_d("41.67");
		if (zot(obj) || zot(name)) return;
		obj.name = name;
		// decided not to remove any existing same-name properties
		// would have to add this to name properties too
		// if (var o = zim.zimObjectIDs[name]) o.name = null;
		zim.zimObjectIDs[name] = obj;
		return obj;
	};//-41.67

// SUBSECTION INTERACTIONS, EFFECTS AND PHYSICS



/*--
obj.movement = function(call)

movement
zim DisplayObject method

DESCRIPTION
Chainable convenience method that captures mouse movement over an object.
This triggers when a mouseover is active and stagemousemovement dispatches.
It also triggers when a pressmove dispatches - so good for mobile.
A callback function is called on movement.

NOTE: set an object's noMovement property to true to remove these events

SEE: noMovement() as well

EXAMPLE
const pic = new Pic("picture.jpg").center().movement(()=>{
	mask.widthOnly = F.mouseX-pic.x;
	S.update();
});
const mask = new Rectangle(pic.width, pic.height, F.color).loc(pic).ord(-1);
pic.setMask(mask, true); // dynamic
END EXAMPLE


RETURNS obj for chaining
--*///+47.75
	zim.movement = function(obj, call, immediate) {
		z_d("47.75");
		var stage = obj.stage||WW.zdf.stage;

		function motioning() {
			stage = obj.stage;
			obj.zimMovementStage = stage;
			if (obj.zimMovementEvent) stage.off("stagemousemove", obj.zimMovementEvent);
			obj.zimMovementEvent = stage.on("stagemousemove", function (e) {
				call(e);
			});
			obj.on("mouseout", function () {
				if (obj.zimMovementEvent) stage.off("stagemousemove", obj.zimMovementEvent);
			}, null, true); 
		}
		if (zim.mobile()) {
			if (obj.zimMovementEvent) stage.off("pressmove", obj.zimMovementEvent);
			obj.zimMovementEvent = obj.on("pressmove", function (e) {
				call(e);
			});
		} else {
			if (obj.zimMouseoverEvent) obj.off("mouseover", obj.zimMouseoverEvent);
			obj.zimMouseoverEvent = obj.on("mouseover", motioning);			
			if (immediate) motioning();
		}
		return obj;
	};//-47.75

/*--
obj.noMovement = function()

noMovement
zim DisplayObject method

DESCRIPTION
removes the events added with movement()

EXAMPLE
if (timer < 5) pic.noMovement();
END EXAMPLE

RETURNS obj for chaining
--*///+47.76
	zim.noMovement = function(obj) {
		z_d("47.9");
		if (zot(obj)) return;
		if (obj.zimMouseoverEvent) obj.off("mouseover", obj.zimMouseoverEvent);
		if (obj.zimMovementEvent && obj.zimMovementStage) obj.zimMovementStage.off("stagemousemove", obj.zimMovementEvent);
		return obj;
	};//-47.76

/*--
obj.tap = function(call, distance, time, once, dbl, dblTime, call2, call3, call4)

tap
zim DisplayObject method

DESCRIPTION
Chainable convenience method that adds a mousedown and mouseup event to the object
that requires the to move less than distance parameter
This is more like a proper click - down up without dragging.
This method works on desktop or mobile, etc.
An optional time parameter is provided if a minimum time is desired.
Note that a click event also works on mobile as a "tap"
but click also allows dragging between down and up presses - so really is a mouseup.
This will automatically add a cursor of "pointer"
which can be changed with the cursor property or cur() method

When dbl is set to true call will be called when a double tap occurs
With this setting, tap also handles either a single or double tap by providing call3 or call4.
call3 will call if a single tap happens regardless of whether there is a double tap or not 
call4 will call if a single tap happens and there is no double tap 
this means it waits for the double tap time to fail and then calls call4 
To give a more responsive single tap it reduces the default dblTime value

NOTE: tap() ignores List titleBar and organizer as to not conflict with tapping on actual list
NOTE: set an object's noTap property to true to avoid activating a hold on an object

SEE: noTap() as well

EXAMPLE
new Circle(50, red).tap(e=>{
	e.target.alpha = .5;
	S.update();
});
END EXAMPLE

EXAMPLE
new Button().tap(()=>{
	zgo("https://zimjs.com", "_blank"); // open ZIM site in new tab
});
END EXAMPLE

EXAMPLE
// wanting to do one thing on single tap and another thing on double tap on same object
// this will set the default dblTime to .5 seconds (rather than 1 second)
new Rectangle().center().tap({
	dbl:true,
	call:()=>{
		// do double tap code
		S.update();
	},
	call4:()=>{
		// do single tap code
		S.update();
	}
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
call - the function to call when clicked
	call will receive the event object as a parameter (with target, currentTarget, etc. properties)
distance - (default 5 or 10 if dbl is true) distance in pixels within which the mouseup must occur for a click to be counted
	if dbl is true it will lengthen the default distance to give an easier double tap
time - (default 8) time in seconds within which the mouseup must occur for a click to be counted - also see TIME constant
once - (default false) set to true to capture only one click then auto-remove listeners
dbl - (default false) set to true to capture a double click - this works on mobile where dblclick may not
dblTime - (default 1 or .5 if call4) time in seconds from first pressup to pressup a second time to count as a double tap - also see TIME constant
	if call4 is provided it will shorten the default dbl tap time to give a more responsive single tap alternative
call2 - (default null) a function to call on pressup if a tap is not made
call3 - (default null) with dbl set to true, a function to call on single tap regardless of a double tap or not 
call4 - (default null) with dbl set to true, a function to call on single tap only if double tap fails

RETURNS obj for chaining
--*///+47.8
	zim.tap = function(obj, call, distance, time, once, dbl, dblTime, call2, call3, call4) {
		var sig = "obj, call, distance, time, once, dbl, dblTime, call2, call3, call4";
		var duo; if (duo = zob(zim.tap, arguments, sig)) return duo;
		z_d("47.8");
		if (zot(obj) || zot(call) || typeof call != "function") return;
		if (zot(distance)) distance = dbl?10:5;
		var timeType = getTIME(time);
		if (zot(time)) time = timeType=="s"?8:8000;
		if (zot(once)) once = false;
		if (zot(dbl)) dbl = false;
		if (zot(dblTime)) {
			if (call4) {
				dblTime = timeType=="s"?.5:500;
			} else {
				dblTime = timeType=="s"?1:1000;
			}
		}
		obj.cur("pointer");
		var firstTap = false;
		var doubleCheck = false;
		var firstUp;
		
		if (dbl) {
			obj.zimDblClickDownEvent = obj.on("mousedown", function (e) {
				firstUp = false;
				if (firstTap) { firstTap = false; return; }
				firstTap = true;
				if (e.currentTarget.type == "List") {
					if (e.target.type == "WindowBacking") return;
					var local = e.currentTarget.globalToLocal(e.stageX / zim.scaX, e.stageY / zim.scaY);
					if (local.y <= 0) return; // avoid titleBar and organizer
				}
				var lastX = e.stageX / zim.scaX;
				var lastY = e.stageY / zim.scaY;
				var startTime = Date.now();
				var upStageX;
				var upStageY;
				doubleCheck = true;
				if (obj.zimDoubleTimeout) clearTimeout(obj.zimDoubleTimeout);
				obj.zimDoubleTimeout = setTimeout(function () {
					doubleCheck = false;
					firstTap = false;
					if (obj.zimDblClickUpEvent) obj.off("pressup", obj.zimDblClickUpEvent);
					if (firstUp && call4) {
						if (Math.abs(lastX + lastY - upStageX / zim.scaX - upStageY / zim.scaY) < distance) {
							if (obj.excludeTap) return;
							call4(e);
						} else if (call2) call2(e);
					}
				}, timeType == "s" ? dblTime * 1000 : dblTime);
				obj.zimDblClickUpEvent = obj.on("pressup", function (e) {
					upStageX = e.stageX; // upstage added by Xuntar
					upStageY = e.stageY;
					firstUp = true;
					if (firstTap) {
						if (call3) call3(e);
						return;
					} else if (!doubleCheck) return;
					if (Math.abs(lastX + lastY - e.stageX / zim.scaX - e.stageY / zim.scaY) < distance && Date.now() - startTime < (timeType == "s" ? time * 1000 : time)) {
						if (obj.excludeTap) return;
						clearTimeout(obj.zimDoubleTimeout);
						call(e);
						if (once) {
							obj.off("mousedown", obj.zimDblClickDownEvent);
							obj.zimDblClickDownEvent = null;
							if (obj.cursor) obj.cur("default");
						}
					} else if (call2) call2(e);
					e.remove();
				});
			});
		} else {
			obj.zimClickDownEvent = obj.on("mousedown", function (e) {		
				if (e.currentTarget.type == "List") {
					if (e.target.type == "WindowBacking") return;
					var local = e.currentTarget.globalToLocal(e.stageX / zim.scaX, e.stageY / zim.scaY);
					if (local.y <= 0) return; // avoid titleBar and organizer
				}
				var lastX = e.stageX / zim.scaX;
				var lastY = e.stageY / zim.scaY;
				var startTime = Date.now();
				obj.zimClickUpEvent = obj.on("pressup", function (e) {	
					// commented does not work on 45 degree - hahaha - was still activating tap on 45 degree sliding list	
					// if (Math.abs(lastX + lastY - e.stageX / zim.scaX - e.stageY / zim.scaY) < distance && Date.now() - startTime < (timeType=="s"?time*1000:time)) {
					if (Math.abs(lastX - e.stageX / zim.scaX) < distance && Math.abs(lastY - e.stageY / zim.scaY) < distance && Date.now() - startTime < (timeType=="s"?time*1000:time)) {
						if (obj.excludeTap) return;
						call(e);
						if (once) {
							obj.off("mousedown", obj.zimClickDownEvent);
							obj.zimClickDownEvent = null;
							if (obj.cursor) obj.cur("default");
						}
					} else if (call2) call2(e);
					e.remove();					
				});
			});
		}
		
		return obj;
	};//-47.8

/*--
obj.noTap = function()

noTap
zim DisplayObject method

DESCRIPTION
removes the mousedown and mouseup events added with tap()

EXAMPLE
let num = 0;
const circle = new Circle(50, red).center().tap(e=>{
	num++;
	e.target.alpha -= .2;
	if (num == 2) circle.noTap();
	S.update();
});
END EXAMPLE

RETURNS obj for chaining
--*///+47.9
	zim.noTap = function(obj) {
		z_d("47.9");
		if (zot(obj)) return;
		if (obj.cursor) obj.cur("default");
		if (obj.zimClickDownEvent) obj.off("mousedown", obj.zimClickDownEvent);
		if (obj.zimClickUpEvent) obj.off("pressup", obj.zimClickUpEvent);
		if (obj.zimDoubleTimeout) clearInterval(obj.zimDoubleTimeout);
		return obj;
	};//-47.9

/*--
obj.hold = function(call, distance, time, once)

hold
zim DisplayObject method

DESCRIPTION
Chainable convenience method that adds a press and hold event to the object
The callback function will run after the object is held for a certain time without moving the object
This method can be used on mobile to replace shift keys, etc.
This will automatically add a cursor of "pointer" - although mobile will not see it
which can be changed with the cursor property or cur() method

NOTE: set an object's noHold property to true to avoid activating a hold on an object

SEE: noHold() as well

EXAMPLE
// remove circle if held for 1000 ms (one second)
new Circle(50, red).hold(e=>{
	e.target.removeFrom();
	S.update();
});
END EXAMPLE

PARAMETERS
call - the function to call after hold time
	call will receive the event object as a parameter (with target, currentTarget, etc. properties)
distance - (default 5) distance in pixels within which the mouseup must occur for a hold to be counted
time - (default 1.5) time in seconds before hold is activated
once - (default false) set to true to capture only one click then auto-remove listeners

RETURNS obj for chaining
--*///+47.87
	zim.hold = function(obj, call, distance, time, once) {
		z_d("47.87");
		if (zot(obj) || zot(call) || typeof call != "function") return;
		if (zot(distance)) distance = 5;
		var timeType = getTIME(time);
		if (zot(time)) time = timeType=="s"?1.5:1500;
		if (zot(once)) once = false;
		obj.cur("pointer");
		var stage;
		obj.zimClickHoldDownEvent = obj.on("mousedown", function (e) {
			if (!stage) stage = e.target.stage;
			if (!stage) return;
			if (zot(stage.frame)) stage.frame = WW.zdf;
			if (zot(stage.frame) || !stage.frame.mousemoveEvent) { // not recording frame mouseX and mouseY
				if (zot(stage.frame)) stage.frame = {};
				stage.frame.mouseX = e.stageX/zim.scaX;
				stage.frame.mouseY = e.stageY/zim.scaY;
				if (stage.frame.mouseholdEvent) stage.off("stagemousemove", stage.frame.mouseholdEvent);
				stage.frame.mouseholdEvent = stage.on("stagemousemove", function (e) {
					stage.frame.mouseX = e.stageX/zim.scaX;
					stage.frame.mouseY = e.stageY/zim.scaY;
				});
			}
			if (e.currentTarget.type == "List") {
				if (e.target.type == "WindowBacking") return;
				var local = e.currentTarget.globalToLocal(e.stageX / zim.scaX, e.stageY / zim.scaY);
				if (local.y <= 0) return; // avoid titleBar and organizer
			}
			var lastX = e.stageX / zim.scaX;
			var lastY = e.stageY / zim.scaY;
			clearInterval(obj.zimHoldInterval);
			var count = 0;
			obj.zimHoldInterval = setInterval(function () {
				if (count < 10) { // if location has gone outside distance then not a hold
					if (Math.abs(lastX + lastY - stage.frame.mouseX - stage.frame.mouseY) > distance) {
						clearInterval(obj.zimHoldInterval);
					}
				} else {
					if (Math.abs(lastX + lastY - stage.frame.mouseX - stage.frame.mouseY) < distance) {
						if (obj.excludeHold) return;
						call(e);
					}
					clearInterval(obj.zimHoldInterval);
				}
				count++;
			}, time / 10 * (timeType == "s" ? 1000 : 1));
			obj.zimClickHoldUpEvent = obj.on("pressup", function () {
				clearInterval(obj.zimHoldInterval);
				if (stage && stage.frame.mouseholdEvent) {
					stage.off("stagemousemove", stage.frame.mouseholdEvent);
				}
			}, null, true); // just once
		}, null, once);
		return obj;
	};//-47.87

/*--
obj.noHold = function()

noHold
zim DisplayObject method

DESCRIPTION
removes the mousedown and mouseup events added with hold()

EXAMPLE
const circle = new Circle(50, red).hold(e=>{
	e.target.removeFrom();
	S.update();
});
if (score > 10) circle.noHold();
END EXAMPLE

RETURNS obj for chaining
--*///+47.88
	zim.noHold = function(obj) {
		z_d("47.88");
		if (zot(obj)) return;
		if (obj.cursor) obj.cur("default");
		obj.off("mousedown", obj.zimClickHoldDownEvent);
		obj.off("pressup", obj.zimClickHoldUpEvent);
		if (obj.stage && obj.stage.frame.mouseEvent) {
			obj.stage.off("stagemousemove", obj.stage.frame.mouseEvent);
		}
		clearInterval(obj.zimHoldTimeout);
		return obj;
	};//-47.88

/*--
obj.change = function(call, once)

change
zim DisplayObject method

DESCRIPTION
Chainable convenience method that adds a change event to the object
This only works for components that dispatch a change event ;-)

SEE: noChange() as well

EXAMPLE
new Tabs().change(e=>{
	zog(e.target.text); // the text of the selected tab
});
END EXAMPLE

PARAMETERS
call - the function to call when changed
	call will receive the event object as a parameter (with target, currentTarget, etc. properties)
once - (default false) set to true to capture only one click then auto-remove listeners

RETURNS obj for chaining
--*///+47.85
	zim.change = function(obj, call, once) {
		z_d("47.85");
		if (zot(obj) || zot(call) || typeof call != "function") return;
		if (zot(once)) once = false;
		obj.zimChangeEvent = obj.on("change", function (e) {
			call(e);
		}, null, once);
		return obj;
	};//-47.85

/*--
obj.noChange = function()

noChange
zim DisplayObject method

DESCRIPTION
removes the change event added with change()

EXAMPLE
const tabs = new Tabs().change(()=>{
	zog(tabs.text);
});
if (score > 10) tabs.noChange(); // removes change event
END EXAMPLE

RETURNS obj for chaining
--*///+47.95
	zim.noChange = function(obj) {
		z_d("47.95");
		if (zot(obj)) return;
		obj.off("mousedown", obj.zimChangeEvent);
		return obj;
	};//-47.95

/*--
obj.drag = function(boundary, axis, overCursor, dragCursor, all, swipe, localBoundary, onTop, surround, slide, slideFactor, slideSnap, slideSnapDamp, reg, removeTweens, startBounds, rect, currentTarget, offStage, immediateBoundary, singleTouch)

drag
zim DisplayObject method

DESCRIPTION
Adds drag and drop to an object with a variety of options.
Handles scaled, rotated nested objects.
Also see draggable property for setting a default drag() and noDrag()
and to indicate whether a drag has been set.

NOTE: drag() will stop ZIM Swipe() from triggering a swipe event.
Set the overridNoSwipe parameter of ZIM Swipe() to true to capture swipe events.

NOTE: also see the draggable property - set to true for basic drag() and false for noDrag()

EXAMPLE
const radius = 50;
const circle = new Circle(radius, red);
circle.center();
circle.drag();

// OR with chaining
new Circle(radius, red).center().drag();

// OR with ZIM DUO
circle.drag({slide:true});

// BOUNDARY
// circle has its registration point in the middle
// keep registration point within rectangle starting at x=100, y=100
// and drag within a width of 500 and height of 400
const boundary = new Boundary(100,100,500,400);
circle.drag(boundary);

// or keep circle on the stage with the following
const boundary = new Boundary(0,0,W,H).contract(radius);
circle.drag(boundary); // drag within stage

// or by passing the stage (or a Container as a boundary)
circle.drag(S); // drag within stage
END EXAMPLE

EXAMPLE
// dragging only horizontal or vertical at a time 
const circle = new Circle(50,red).center().drag();
circle.on("mousedown", ()=>{
	const start = {x:circle.x, y:circle.y};
	circle.on("pressmove",()=>{
		timeout(.01, ()=>{ // works without but this gives a little better feel
			let horizontal = Math.abs(circle.x-start.x) >= Math.abs(circle.y-start.y);
			let boundary = horizontal?new Boundary(0, start.y, W, 0):new Boundary(start.x, 0, 0, H);   
			circle.dragBoundary(boundary);      
		});             
	}, null, true); // once
});
circle.on("pressup", ()=>{circle.dragBoundary()});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
boundary - (default null) a ZIM Boundary object for the drag boundary
 	or a ZIM DisplayObject including stage
		If the boundary is a display object then ZIM will keep the shape of the dragged object inside the bounds.
		If the boundary object is a Blob then the dragged object will stay within the Blob (experimental).
		If the boundary object is a Circle then the registration point of the dragged object will stay within the circle
		If the object being dragged is a Pic() then make sure it is preloaded or has dimensions before adding a drag boundary
		If the drag is on a container and the "all" parameter is false
		then ZIM will call drag methods on each child so the bound calculations are easier.
		The drags will be applied after a .05 second delay allowing items to be added directly after.
		Alternatively, drag() can be placed on the container AFTER the objects are added
		and the immediateBoundary parameter set to true. Or drag() can be applied manually on each child.
		a boundary with 0 width will drag vertically.  A boundary with 0 height will drag horizontally 
		or see the axis parameter
	note: boundary will only work in 90-degree-rotated containers - as such, do slant Window and List, etc.
	If surround is true then it will make sure the obj surrounds the boundary rather than stays within it
	This boundary is relative to the stage (global).
	If a boundary relative to the object's parent is desired then set the localBoundary parameter to true.
	Rectangle, Stage, StageGL - will keep object fully inside the bounds (based on bounds of object when adding drag).
axis - (default BOTH) or HORIZONTAL or VERTICAL - set the axis of the drag 
	also see the boundary parameter where the width can be set to 0 for vertical dragging with a limit of y and the height
	or the height can be set to 0 for horizontal dragging with limit of x and the width
overCursor - (default "pointer") the CSS cursor property as a string for rolling over the object
dragCursor - (default "pointer") the CSS cursor property as a string for pressing and dragging the object
all - (default false) set to true to drag a whole container rather than its parts (was called currentTarget)
	eg. container.drag(); will drag any object within the container
	container.drag({all:true}) will drag the whole container
	See: DRAGALL contant - set DRAGALL=true; to change the default drag to drag a whole container
swipe - (default false) which prevents a swipe from triggering when dragging
localBoundary - (default false) which means the rect is global - set to true for a rect in the object parent frame
onTop - (default true) brings the dragged object to the top of the container - unless Keyboard at top.
	// to drag on top of keyboard, set the type property of the keyboard to "LowerKeyboard" - or anything other than Keyboard
surround - (default false) is for dragging a big object that always surrounds the boundary
slide - (default false) will let you throw the object and dispatch a slidestop event when done
slideFactor - (default .9) is the factor multiplied by dragging velocity (1 no slowing, .7 fast slowing)
slideSnap - (default true) lets the object go outside and snap back to bounds - also VERTICAL, HORIZONTAL, and false
slideSnapDamp - (default .1) the damping to snap back to boundary
reg - (default false) when set to true will snap the registration of the object to the mouse position
removeTweens - (default true) will automatically remove any tweens that have an x and y set unless set to false
	if, for example, animate() has a rotation and an x set, then both will be canceled 
	but if an animate() call to rotation and another to x is set then only the x would be canceled and rotation would continue 
	if after dropping, the animation in x should continue, then a new animate() in x will need to be called
	this avoids conflict between dragging and animating position which is very confusing for beginner coders
startBounds - (default true) set to false to ignore bound rect before dragging (sometimes handy when putting drag on container)
rect - (depreciated) same as boundary - kept for backwards compatibility when using config object
currentTarget - (default false) same as the all parameter - kept for backwards compatibility when using config object
offStage - (default false) set to true to be able to drag object off stage (thanks Shammi!)
immediateBoundary - (default false) set to true to add bounds immediately when drag() is set on a Container.
 	this is normally set to false for a .05 second delay to allow objects to be added to Container before setting bounds.
singleTouch - (default false) set to true to let only one touch operate the drag 
	also see Frame() singleTouch setting - but setting on drag will only affect that object's drag

note: will not update stage if OPTIMIZE is set to true
unless Ticker.update is set to true or you run Ticker.always(stage) see zim.Ticker

PROPERTIES 
adds a dragPaused property to get or set the pause of the drag - which allows setting to be kept
	see also noDrag() where settings will be removed

EVENTS
Adds a "slidestart" event to the drag object that is dispatched when the object starts sliding - if slide is true
Adds a "slidestop" event to the drag object that is dispatched when the object comes to rest after sliding - if slide is true

RETURNS obj for chaining
--*///+31
	zim.drag = function(obj, boundary, axis, overCursor, dragCursor, all, swipe, localBoundary, onTop, surround, slide, slideFactor, slideSnap, slideSnapDamp, reg, removeTweens, startBounds, rect, currentTarget, offStage, immediateBoundary, singleTouch) {
		var sig = "obj, boundary, axis, overCursor, dragCursor, all, swipe, localBoundary, onTop, surround, slide, slideFactor, slideSnap, slideSnapDamp, reg, removeTweens, startBounds, rect, currentTarget, offStage, immediateBoundary, singleTouch";
		var duo; if (duo = zob(zim.drag, arguments, sig)) return duo;
		z_d("31");

		if (zot(obj) || !obj.on) return;

		
		var DA = zim.DRAGALL;
		if (WW.DRAGALL != null) DA = WW.DRAGALL;
		if (zot(all) && zot(currentTarget)) all = DA;
		if (zot(all) && zot(currentTarget)) currentTarget = false;
		else if (!zot(all)) currentTarget = all;
		else if (zot(currentTarget)) currentTarget = false;
		if (obj.type == "Tag" || obj.type == "TextArea" || obj.type == "Loader") currentTarget = true;

		if (boundary && boundary.getBounds && (obj.type=="Container" || obj.type=="Tile") && obj.mouseChildren==true && !all) {
			// recall drags individually on objects
			var args = Array.prototype.slice.call(arguments);
			args[4] = true; // all		
			setTimeout(function () {
				obj.loop(function (o) {
					args[0] = o; // replace container with each child
					zim.drag.apply(null, args);
				});
			}, immediateBoundary?0:50);								
			return obj;
		}
		if (zot(axis) || axis=="all" || (axis!="horizontal" && axis!="vertical")) axis = "both";
		if (obj.zimDown) obj.noDrag(); // clear any previous drags
		

		if (obj.cur) obj.cur(zot(overCursor) ? "pointer" : overCursor);
		else obj.cursor = zot(overCursor) ? "pointer" : overCursor;

		if (zot(swipe)) swipe = false;		
		if (zot(localBoundary)) localBoundary = false;
		if (zot(onTop)) onTop = true;
		if (zot(surround)) surround = false;
		if (zot(slide)) slide = false;
		if (zot(slideFactor)) slideFactor = .9;
		if (zot(slideSnap)) slideSnap = true;
		var snapOptions = ["horizontal", "vertical", "auto"];
		if (slideSnap !== true && snapOptions.indexOf(slideSnap) < 0) slideSnap = false;
		if (slideSnap == "auto") slideSnap = true;
		if (zot(slideSnapDamp)) slideSnapDamp = .1;
		if (zot(reg)) reg = false;
		if (zot(removeTweens)) removeTweens = true;
		if (zot(startBounds)) startBounds = true;
		if (zot(boundary) && !zot(rect)) boundary = rect;
		if (zot(singleTouch)) singleTouch = false;
		
		obj.dragPaused = false;
		
		if (slide) {
			// set up damping for slide and variables used to predict future locations
			// these get populated in a setTimeout in the init function

			var dampX;
			var dampY;
			var back; // how many ticks ago to estimate trajectory
			var lastCount;
			var backX;
			var backY;
			var backT;
			var upX; // mouse up translated to local
			var upY;
			var upT;
			var objUpX; // drag object x when mouse up
			var objUpY;
			var lastBackX; // used to calculate trajectory
			var lastBackY;
			var lastBackT;
			var lastX; // used to see if sliding object is still moving
			var lastY;
			var hasMoved;
			var tick = WW.M?20:10; 
			var vX;
			var vY;
			var dX;
			var dY;
			var bX = false;
			var bY = false;
			var vRange = 50;		

		} else {
			obj.zimDragTicker = function(){};
		}

		obj._draggable = true;
		zim.setSwipe(obj, swipe);
		obj.zimBoundary = boundary;
		obj.zimlocalBoundary = localBoundary;
		obj.circleBounds = boundary&&boundary.type=="Circle"?boundary.radius:false;
		obj.downCheck = false;		
		var moveCheck = false;

		var diffX,diffY,r,rLocal,point;

		// initialize happens possibly before added to stage - only checking for parent
		obj.zimAdded = obj.on("added", initializeObject, null, true); // if not added to display list
		obj.zimRemoved = obj.on("removed", unInitializeObject, null, true);
		if (obj.parent) initializeObject();

		function initializeObject() {
			obj.off("added", obj.zimAdded);
			boundary = obj.zimBoundary;
			if (boundary && boundary.getBounds && boundary.type != "Blob") {
				obj.zimlocalBoundary = false;
				if (boundary.type != "Stage" && boundary.type != "StageGL") boundary = boundary.boundsToGlobal();
				else boundary = new zim.Boundary(0,0,boundary.width,boundary.height);
				if (!surround) {
					var bounds = obj.boundsToGlobal();
					point = obj.localToGlobal(obj.regX,obj.regY);
					var tl = new zim.Point(point.x-bounds.x, point.y-bounds.y);
					var bw = obj.borderWidth?obj.borderWidth:0;
					boundary.x += tl.x+bw/2;
					boundary.y += tl.y+bw/2;
					boundary.width -= bounds.width+bw;
					boundary.height -= bounds.height+bw;
				}
				obj.zimBoundary = boundary;
			}
					
			// check position right away if there is a bounding box
			// there is no mousedown so set the diffX and diffY to 0
			diffX = 0; diffY = 0;
			// positionObject() is used as well in the dragmove function
			// where it expects a global x and y
			// so convert obj.x and obj.y positions inside its parent to global:
			if (obj.zimBoundary && obj.zimBoundary.type != "Blob") {
				if (localBoundary) {
					r = zim.boundsToGlobal(obj.parent, obj.zimBoundary);
					if (surround) rLocal = obj.zimBoundary;
				} else {
					r = obj.zimBoundary;
					if (surround) rLocal = zim.boundsToGlobal(obj.parent, obj.zimBoundary, true); // flips to global to local
				}
			}
			if (r && startBounds) {
				point = obj.parent.localToGlobal(obj.x, obj.y);
				positionObject(obj, point.x, point.y);
			}
			if (slide) {
				// little delay to in case position is set directly after drag is called
				setTimeout(function() {
					// set up damping for slide and variables used to predict future locations
					if (slide && slideSnap) {
						dampX = new zim.Damp(null, slideSnapDamp);
						dampY = new zim.Damp(null, slideSnapDamp);
					}					
					obj.zimDragImmediate = function(x, y) {
						objUpX = x;
						objUpY = y;
						vX = vY = 0;
						dX = dY = 0;
						upX = lastBackX = upY = lastBackY = upT = lastBackT = 0;
						if (slide && slideSnap) {
							if (!zot(x)) dampX.immediate(x);
							if (!zot(y)) dampY.immediate(y);
						}
					};
					back = 3; // how many ticks ago to estimate trajectory
					lastCount = 0;
					backX = [];
					backY = [];
					backT = [];
					upX = obj.x; // mouse up translated to local
					upY = obj.y;
					objUpX = obj.x; // drag object x when mouse up
					objUpY = obj.y;
					lastBackX = obj.x; // used to calculate trajectory
					lastBackY = obj.y;
					lastBackT = Date.now();
					lastX = -10000; // used to see if sliding object is still moving
					lastY = -10000;
					obj.zimDragMoving = true;
					setUpSlide();
				}, 50);
			}
			if (!zot(obj.zimMaskDynamic)) obj.zimMaskApply(); // set mask set by zimMask to dynamic
		}

		function unInitializeObject() {
			if (obj.zimDragTicker) zim.Ticker.remove(obj.zimDragTicker);
		}

		var dragObject;

		var stage;
		obj.pointers = {};
		var stCheck = false;
		obj.zimDown = obj.on("mousedown", function(e) {			
			if (!obj.stage || obj.dragPaused) return;
			if (singleTouch && stCheck) {
				e.preventDefault();
				e.stopImmediatePropagation();
				return;
			};	 // breaking if coming back from iframe until next mousedown	

			// obj.zimMove = obj.on("pressmove", obj.zimMove);	// for some reason causing squiggle drag problems
			
			stCheck = true;
			stage = obj.stage;
			if (!obj.zmu) obj.zmu = stage.frame.on("mouseupplus", function(e) {	
				if (obj.downCheck) {
					if (!slide) obj.downCheck = false;						
					doUp(e, true); // true for cancel slide						
				}					
			});		
			obj.dragMouseX = Math.round(e.stageX/zim.scaX)+stage.x;
			obj.dragMouseY = Math.round(e.stageY/zim.scaY)+stage.y;
			var id = "id"+Math.abs(e.pointerID+1);
			obj.pointers[id] = true; // keep track of multitouch to keep object ticker alive
			// e.stageX and e.stageY are global
			// e.target.x and e.target.y are relative to e.target's parent
			// bring stageX and stageY into the parent's frame of reference
			// could use e.localX and e.localY but might be dragging container or contents
			dragObject = (currentTarget)?e.currentTarget:e.target;
			if (obj.zimBoundary && !dragObject.getBounds()) {zogy("zim.drag() - drag object needs bounds set"); return;}
			obj.downCheck = true;
			obj.stage.mouseMoveOutside = true;

			if (!zim.Ticker.has(obj.zimDragTicker)) zim.Ticker.add(obj.zimDragTicker, obj.stage);

			if (removeTweens && obj.zimTweens) {
				for (var tw in obj.zimTweens) {
					var ao = obj.zimTweens[tw];
					if (ao.zimObj && (ao.zimObj.x!=null||ao.zimObj.y!=null)) {
						obj.stopAnimate(tw);
					}
				}
			}

			if (!dragObject.parent) return;
			if (onTop) {
				var nc = dragObject.parent.numChildren-1;
				if (dragObject.parent.getChildAt(nc).type=="Keyboard") nc--;
				dragObject.parent.setChildIndex(dragObject,nc);
				if (dragObject.ZIMoutlineShape) dragObject.outline();
			}
			if (dragObject.parent == obj.stage) point = new zim.Point(e.stageX/zim.scaX, e.stageY/zim.scaY);
			else point = dragObject.parent.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
			if (reg) {
				dragObject.x = point.x;
				dragObject.y = point.y;
			}
			diffX = point.x - dragObject.x;
			diffY = point.y - dragObject.y;

			r = null;
			if (obj.zimBoundary) {
				if (localBoundary) {
					r = zim.boundsToGlobal(dragObject.parent, obj.zimBoundary);
					if (surround) rLocal = obj.zimBoundary;
				} else {
					r = obj.zimBoundary;
					if (surround) rLocal = zim.boundsToGlobal(dragObject.parent, obj.zimBoundary, true); // true flips to global to local
				}
			}
			
			// just a quick way to set a default cursor or use the cursor sent in
			if (obj.cur) obj.cur(zot(dragCursor)?"pointer":dragCursor);
			else obj.cursor = zot(dragCursor)?"pointer":dragCursor;

			// extra slide settings to project where the object will slide to
			if (slide) {
				obj.slideStartX = obj.x;
				obj.slideStartY = obj.y;
				hasMoved = obj.zimDragMoving; // just in case clicking while it is animating back to position

				lastCount = 0;
				backX = [point.x];
				backY = [point.y];
				backT = [Date.now()];
				lastX = -10000; // reset
				lastY = -10000;
				obj.zimDragMoving = true;
			}

			// extra pen drag
			if (obj.type == "Pen") {
				obj.zimDragCheck = true;
				moveCheck = false;
			}

		}, true);

		obj.zimMove = obj.on("pressmove", function(e) {
			if (singleTouch && !obj.pointers["id"+Math.abs(e.pointerID+1)]) {
				e.preventDefault();
				e.stopImmediatePropagation();
				return;
			};	
			if (!obj.downCheck || obj.dragPaused) {
				e.preventDefault();
				e.stopImmediatePropagation();
				return;
			};			
			var x = (offStage?e.rawX:e.stageX)/zim.scaX+stage.x;
			var y = (offStage?e.rawY:e.stageY)/zim.scaY+stage.y;
			obj.dragMouseX = Math.round(x);
			obj.dragMouseY = Math.round(y);
			positionObject(dragObject, x, y);
			if (dragObject.ZIMoutlineShape) dragObject.outline();
			if (obj.type == "Pen" && !moveCheck && obj.drawing) moveCheck = true;
			else if (obj.type == "Tag" || obj.type == "TextArea" || obj.type == "Loader") obj.resize();
		}, true);

		// obj.off("pressmove",obj.zimMove);  // for some reason causing squiggle drag problems

		function positionObject(o, x, y) {

			var diffX_o = diffX;
			var diffY_o = diffY;
			if (zot(o)) o = (dragObject) ? dragObject : obj; // so zim.dragBoundary can use this	

			// x and y are the desired global positions for the object o
			// checkBounds returns the same values if there are no bounds
			// and returns values inside the bounds if there are bounds set
			// or returns a position so that object o surrounds the bounds if surround is true
			// firstly, convert the global x and y to a point relative to the object's parent
			if (!o.parent) return;
			// if (!o.stage) return;

			if (zot(x) || zot(y)) {
				// so zim.dragBoundary can use this to position on change
				// it may be we are resizing before we even drag at all
				// so we need to establish variables that would have been made on drag events
				var p = o.parent.localToGlobal(o.x, o.y);
				diffX = diffY = 0;
				if (obj.zimBoundary) {
					if (localBoundary) {
						r = zim.boundsToGlobal(o.parent, obj.zimBoundary);
						if (surround) rLocal = o.zimBoundary;
					} else {
						r = obj.zimBoundary;
						if (surround) rLocal = zim.boundsToGlobal(o.parent, obj.zimBoundary, true); // flips to global to local
					}
				}
				x = p.x;
				y = p.y;
				if (slide) {
					objUpX = o.x;
					objUpY = o.y;
					dragObject = o;
					// if (dampX) dampX.immediate(objUpX);
					// if (dampY) dampY.immediate(objUpY);
				}
			}

			// TODO only need this if boundary - so try and test for that first...
			var point;
			if (stage && stage.type) point = o.parent.globalToLocal(x, y);
			// case where createjs stage - does not have adjusted globalToLocal
			else point = o.parent.globalToLocal(x*zim.scaX, y*zim.scaY);

			var mX = axis=="both" || axis=="horizontal"; 
			var mY = axis=="both" || axis=="vertical"; 

			var checkedPoint;
			if (slide && slideSnap) {
				if (slideSnap == "vertical") {
					checkedPoint = checkBounds(o,point.x-diffX, point.y-diffY);
					if (mX) o.x = checkedPoint.x;
					if (mY) o.y = point.y-diffY;
				} else if (slideSnap == "horizontal") {
					checkedPoint = checkBounds(o,point.x-diffX, point.y-diffY);
					if (mX) o.x = point.x-diffX;
					if (mY) o.y = checkedPoint.y;
				} else {
					if (mX) o.x = point.x-diffX;
					if (mY) o.y = point.y-diffY;
				}
			} else {
				checkedPoint = checkBounds(o,point.x-diffX, point.y-diffY);
				// now set the object's x and y to the resulting checked local point
				if (mX) o.x = checkedPoint.x;
				if (mY) o.y = checkedPoint.y;
			}
			if (slide && !hasMoved && (o.slideStartX != o.x || o.slideStartY != o.y)) hasMoved = true;
			if (o.downCheck) {
				diffX = diffX_o;
				diffY = diffY_o;
			}
		}

		obj.zimPosition = positionObject;

		obj.zimUp = obj.on("pressup", function(e){doUp(e);}, true);
				
		function doUp(e, outsideUp) {	

			if (singleTouch && !outsideUp && !obj.pointers["id"+Math.abs(e.pointerID+1)]) {
				e.preventDefault();
				e.stopImmediatePropagation();
				return;
			};
			
			stCheck = false;		

			var id = "id"+Math.abs((!zot(e.pointerID)?e.pointerID:0)+1); // avoiding NaN but not sure if correct ZIM 015
			delete obj.pointers[id];

			if (!obj.downCheck || obj.dragPaused) {
				e.preventDefault();
				e.stopImmediatePropagation();
				return;
			};

			if (obj.cur) obj.cur(zot(overCursor)?"pointer":overCursor);
			else obj.cursor = zot(overCursor)?"pointer":overCursor;

			if (e.stageX == null) return; // added for TextureActive drag in 2D view

			if (slide) {				
				dragObject.dispatchEvent("slidestart");
				
				if (dragObject.parent) {
					var x = offStage?e.rawX:e.stageX;
					var y = offStage?e.rawY:e.stageY;
					point = dragObject.parent.globalToLocal(x/zim.scaX, y/zim.scaY);
				} else {
					point = new zim.Point(0,0);
				}							
				
				// Added ZIM 014 to adjust for velocity effect
				upX = point.x;
				upY = point.y;
				upT = Date.now();	
				
				// Added ZIM 015 if mouseuplus triggers first (TextureActive) then there is no event object
				if (isNaN(upX)) upX = -1000;
				if (isNaN(upY)) upY = -1000;

				dX = upX-lastBackX;
				dY = upY-lastBackY;
				var t = upT-lastBackT;

				vX = zim.constrain(dX*tick/t, -vRange, vRange);
				vY = zim.constrain(dY*tick/t, -vRange, vRange);

				bX = false; // for damping on slideSnap
				bY = false;		
				// end add 

				obj.downCheck = false;

				objUpX = dragObject.x;
				objUpY = dragObject.y;

				if (outsideUp) {
					lastBackX = upX = 0;
					lastBackY = upY = 0;
					lastBackT = upT = 0;
				}				

				// if (dampX) dampX.immediate(50);
				// if (dampY) dampY.immediate(0);

			} else {
                obj.downCheck = false; // added ZIM NFT 01
				var pointerCount = 0;
				for (var o in obj.pointers) {
					pointerCount++;
				}
				if (pointerCount == 0) zim.Ticker.remove(obj.zimDragTicker);
				// extra pen drag
				if (obj.type == "Pen") {
					obj.zimDragCheck = false;
					if (moveCheck && obj.drawing) obj.stopCheck(); // added drawing check Cat 04
					// if (moveCheck) obj.stopCheck(); 
				}
			}
			if (obj.stage) obj.stage.update();
		}

		// the bounds check for registration inside the bounds
		// or if surround is set for the whole object staying outside the bounds
		function checkBounds(o, x, y) {
			if (!o.parent) return {x:x,y:y};
			if (r) {
				if (surround) {
					var w = o.getBounds().width;
					var h = o.getBounds().height;
					var bx = o.getBounds().x;
					var by = o.getBounds().y;
					if (w < rLocal.width) {
						// put half way between
						x = rLocal.x + (rLocal.width - w) / 2 + (o.regX-bx);
					} else {
						if (x - (o.regX-bx) > rLocal.x) {
							x = rLocal.x + (o.regX-bx);
						}
						if (x - (o.regX-bx) + w < rLocal.x + rLocal.width) {
							x = rLocal.x + rLocal.width + (o.regX-bx) - w;
						}
					}
					if (o.height < rLocal.height) {
						// put half way between
						y = rLocal.y + (rLocal.height - h) / 2 + (o.regY-by);
					} else {
						if (y - (o.regY-by) > rLocal.y) {
							y = rLocal.y + (o.regY-by);
						}
						if (y - (o.regY-by) + h < rLocal.y + rLocal.height) {
							y = rLocal.y + rLocal.height + (o.regY-by) - h;
						}
					}
				} else {
					if (r.type=="Blob") {
						if (r.shape.hitTestPoint(x,y)) return {x:x,y:y};
						else return {x:obj.x,y:obj.y};
					} else {
						// convert the desired drag position to a global point
						// note that we want the position of the object in its parent
						// so we use the parent as the local frame
						point = o.parent.localToGlobal(x,y);
						// r is the bounds rectangle on the global stage
						// r is set during mousedown to allow for global scaling when in localBoundary mode
						// if you scale in localBoundary==false mode, you will need to reset bounds with dragBoundary()
						
						if (obj.circleBounds) {
							var midX = r.x+r.width/2;
							var midY = r.y+r.height/2;
							var rad = obj.circleBounds;
							if (zim.dist(midX, midY, point.x, point.y) <= rad) {
								x = point.x;
								y = point.y;
							} else {
								var ang = zim.angle(midX, midY, point.x, point.y)*RAD;
								x = midX + rad*Math.cos(ang);
								y = midY + rad*Math.sin(ang);
							}							
						} else {
							x = Math.max(r.x, Math.min(r.x+r.width, point.x));
							y = Math.max(r.y, Math.min(r.y+r.height, point.y));
						}
						// now that the point has been checked on the global scale
						// convert the point back to the obj parent frame of reference
						point = o.parent.globalToLocal(x, y);
						x = point.x;
						y = point.y;
					}
				}
			}
			return {x:x,y:y};
		}
		
		function testMove(o,x,y,desiredX,desiredY) {
			if (Math.abs(o.x-lastX) < .1 && Math.abs(o.y-lastY) < .1) {
				obj.zimDragMoving = false;
				o.x = desiredX; // snap to final resting place
				o.y = desiredY;
				o.slideStartX = null;
				o.slideStartY = null;
				if (hasMoved) {
					o.dispatchEvent("slidestop");
					zim.Ticker.remove(obj.zimDragTicker);
				}
				// extra pen drag
				if (obj.type == "Pen") {
					obj.zimDragCheck = false;
					if (moveCheck && obj.drawing) obj.stopCheck(); // added drawing check Cat 04
					// if (moveCheck) obj.stopCheck(); 
				}
			} else {
				lastX = x;
				lastY = y;
			}
		}

		// we store where the object was a few ticks ago and project it forward
		// then damp until it stops - although the ticker keeps running and updating
		// if it snaps then the object is allowed to go past the bounds and damp back
		// if it is not snapping then the object stops at the bounds when it is slid


		function setUpSlide() {
			obj.zimDragTicker = function() {
				if (zot(obj.slideStartX)) return; // don't stop other things like window scrollbar from moving object

				if (!dragObject) dragObject = obj; // could be risky if intending to drag children
				if (obj.downCheck) {
					var point;
					if (dragObject.parent) {
						point = dragObject.parent.globalToLocal(obj.dragMouseX, obj.dragMouseY);
					} else {
						point = new zim.Point(0,0);
					}
					lastCount++;
					backX.push(point.x);
					backY.push(point.y);
					backT.push(Date.now());
					if (lastCount >= back) {
						lastBackX = backX.shift();
						lastBackY = backY.shift();
						lastBackT = backT.shift();
					} else {
						lastBackX = backX[0];
						lastBackY = backY[0];
						lastBackT = backT[0];
					}
				} else {
					if (!obj.zimDragMoving) return;

					dX = vX;
					dY = vY;

					var desiredX;
					var desiredY;
		
					if (axis==BOTH) {
						desiredX = dragObject.x + dX;
						desiredY = dragObject.y + dY;
					} else if (axis==HORIZONTAL) {
						desiredX = dragObject.x + dX;
						desiredY = dragObject.y;
					} else if (axis==VERTICAL) {
						desiredX = dragObject.x;
						desiredY = dragObject.y + dY;
					}
					
					vX = dX*slideFactor;
					vY = dY*slideFactor;

					var checkedPoint;
					if (r) {
						checkedPoint = checkBounds(dragObject, desiredX, desiredY);						
						
						if (slideSnap===true || slideSnap == "horizontal") {	
							if (Math.round(desiredX) != Math.round(checkedPoint.x)) {
								if (!bX) {
									dampX.immediate(desiredX);
									bX = true;
								}								
								vX = 0;
								desiredX = dampX.convert(checkedPoint.x);								
							}
							if (slideSnap == "horizontal") desiredY = checkedPoint.y;
						}

						if (slideSnap===true || slideSnap == "vertical") {
				
							if (Math.round(desiredY) != Math.round(checkedPoint.y)) {												
								if (!bY) {
									bY = true;
									dampY.immediate(desiredY);										
									vY = 0;																							
								}		
								desiredY = dampY.convert(checkedPoint.y);																					
							}
							if (slideSnap == "vertical") desiredX = checkedPoint.x;
						}

						if (!slideSnap) {
							desiredX = checkedPoint.x;
							desiredY = checkedPoint.y;
						}
					}

					dragObject.x = desiredX;
					dragObject.y = desiredY;

					testMove(dragObject,dragObject.x,dragObject.y,desiredX,desiredY);

				}
			}	
		}
		return obj;
	};//-31

/*--
obj.noDrag = function(recursive)

noDrag
zim DisplayObject method

DESCRIPTION
Removes drag function from an object.
This is not a stopDrag function (as in the drop of a drag and drop).
Dropping happens automatically with the drag() function.
The noDrag function turns off the drag function so it is no longer draggable.

EXAMPLE
circle.noDrag();
END EXAMPLE

PARAMETERS
recursive (default true) - turns off drags on children

RETURNS obj for chaining
--*///+32
	zim.noDrag = function(obj, recursive) {
		z_d("32");
		if (zot(obj) || !obj.on) return;
		if (zot(recursive)) recursive = true;
		if (recursive && obj.numChildren && obj.numChildren > 1) {
			for (var i=0; i<obj.numChildren; i++) {
				var o = obj.getChildAt(i);
				undrag(o);
			}
		}
		undrag(obj); // also undrag the parent to be sure
		function undrag(obj) {
			if (obj.cur) obj.cur("default");
			obj._draggable = false;
			zim.setSwipe(obj, true);
			obj.off("added", obj.zimAdded);
			obj.off("removed", obj.zimRemoved);
			obj.off("mousedown", obj.zimDown);
			obj.off("pressmove", obj.zimMove);
			obj.off("pressup", obj.zimUp);
			if (obj.zmu) {
				if (obj.stage) obj.stage.frame.off("mouseupplus", obj.zmu);
				else WW.zdf.off("mouseupplus", obj.zmu);
			}		
			if (zim.Ticker) {
				if (obj.zimDragSlide) zim.Ticker.remove(obj.zimDragSlide);
				if (obj.zimDragTicker) zim.Ticker.remove(obj.zimDragTicker);
			}
			obj.zimDragMoving=obj.zimAdded=obj.zimRemoved=obj.zimDown=obj.zimMove=obj.zimUp=obj.zimBoundary=obj.zimDragSlide=null;
			obj.slideStartX = obj.slideStartY = obj.zimDragImmediate = null;
			obj.dragMouseX = obj.zimPosition = obj.dragMouseY = obj.zimDown = obj.zimUp = null;
			obj.zimDragTicker = obj.zimDragSlide = null;
		}
		return obj;
	};//-32

/*--
obj.dragBoundary = function(boundary)

dragBoundary
zim DisplayObject method

DESCRIPTION
Dynamically changes or adds a boundary rectangle to the object being dragged with drag().

NOTE: replaces old ZIM dragRect() method

EXAMPLE
const circle = new Circle().center().drag();
// add (or change) a boundary 5 seconds later
timeout(5, ()=>{
	const boundary = new Boundary(100,100,500,400);
	circle.dragBoundary(boundary);
});
END EXAMPLE

PARAMETERS
boundary - is a ZIM Boundary object for the bounds - the local / global does not change from the original drag
	pass in null to remove the boundary - the boundary while dragging and be removed for next mousedown 
	to solve this issue while dragging, set a boundary of the stage size or larger...

RETURNS obj for chaining
--*///+33
	zim.dragBoundary = function(obj, boundary) {
		z_d("33");
		if (zot(obj) || !obj.on) return;
		obj.zimBoundary = boundary;
		obj.zimDragMoving = true;
		if (obj.zimPosition) obj.zimPosition();
		return obj;
	};//-33
	zim.dragRect = zim.dragBoundary; // backwards compatible

/*--
obj.mouse = function()

mouse
zim DisplayObject method

DESCRIPTION
Sets object's mouseChildren and mouseEnabled properties to true
These are the defaults - used primarily to reverse ZIM noMouse()
which can be used to turn off mouseChildren and mouseEnabled

NOTE: just using mouse() does not add cursors or interactivity
see cur(), hov(), drag(), transform(), gesture(), or various mouse events

EXAMPLE
const circle = new Circle().drag();
timeout(1, ()=>{
	circle.noMouse(); // circle cannot not be dragged, etc.
	timeout(1, ()=>{
		circle.mouse(); // circle can be dragged
	});
});
END EXAMPLE

RETURNS obj for chaining
--*///+33.1
	zim.mouse = function(obj) {
		z_d("33.1");
		if (obj.zimLastMouse) obj.mouseChildren = obj.zimLastMouse;
		obj.mouseEnabled = true;
		obj.zimLastMouseEnabled = true;
		return obj;
	};//-33.1

/*--
obj.noMouse = function()

noMouse
zim DisplayObject method

DESCRIPTION
Sets object's mouseChildren and mouseEnabled properties to false
This can be used to save processing on complex objects that do not need interactivity

NOTE: this will prevent interactivity for cur(), hov(), drag(), transform(), gesture()
and any mouse events like mousedown, click, mouseover, etc.

EXAMPLE
const circle = new Circle().drag();
timeout(1, ()=>{
	circle.noMouse(); // circle cannot not be dragged, etc.
	timeout(1, ()=>{
		circle.mouse(); // circle can be dragged
	});
});
END EXAMPLE

RETURNS obj for chaining
--*///+33.15
	zim.noMouse = function(obj) {
		z_d("33.15");
		obj.zimLastMouse = obj.mouseChildren;
		obj.mouseChildren = false;
		obj.mouseEnabled = false;
		obj.zimLastMouseEnabled = false;
		return obj;
	};//-33.15
	
/*--
obj.wire = function(target, prop, twoWay, setSource, filter, call, input)

wire
zim DisplayObject method

DESCRIPTION
The wire() method connects an object (source) property to another object (target) property.
This can be one way (default) or two way with the twoWay parameter set to true.
For instance:
	new Slider().center().wire(circle, "scale"); // note the property as string
will change the scale of the circle as the slider's current value changes.
The currentValue (if the object has one) is the default input followed by selectedIndex.
If the source object has neither currentValue nor selectedIndex
then the input is the same property as the target property.
For instance:
	new Circle().center().wire(circle2, "x", true);
would mean changing either circle's x property would change the other.
Multiple wire() methods can be chained.
For instance:
 	slider.wire(circle, "x").wire(circle, "y");
	slider.wire(circle, "scale").wire(circle2, "scale");

BACKGROUND
The wire system is an alternative to events at 25% the size of traditional JS addEventListener.
It is a single extra conditional in the Ticker that checks to see if a Dictionary list has length.
If it does it cycles through the list to see if input properties have changed
and if so, sets the target property.  Updates are batched to a single stage update
This is the same stage update that is used by any Ticker functions including those by drag, animate, etc.
Basically, wire is same system as events but with a more specific format - adds 1.4 k to ZIM file size.

WIRED
There is also a wired() method that can be be put on the target object
and points to a source object to set a specified property.
This just flips the target and the source and calls the wire() function.
The methods MUST go on the second object made - so using either wire() or wired() covers use cases.
There are also noWire() and noWired() methods to remove connections - with various alternatives.

FILTER AND CALLBACK
wire is also similar to ZIM Bind and bind() but binds within ZIM where bind binds outside of ZIM.
Like Bind, wire uses an optional filter and callback function.
For instance:
	new Dial().center().wire(tone, "volume", null, filter, call);
will call the filter function before setting the target property (tone.volume).
The filter function will receive the data (the input currentValue) as its parameter
and MUST return data to be passed along but the data can be changed or tested.
The call function will be called after the target property is set.

See: https://zimjs.com/cat/wire.html
See: https://zimjs.com/cat/synth.html

EXAMPLE
const circle = new Circle(100, pink, dark).center();
new Dial({step:0, min:1, max:3})
	.center()
	.wire(circle, "scale");

// S.update(); // depending, let the wire() set the stage update
END EXAMPLE

EXAMPLE
// this time the circle (target) starts at a scale of 2
const circle = new Circle(100, pink, dark).sca(2).center();
// so we want the dial (source) to start at 2 as well
// we could use the Dial parameter currentValue:circle.scale
// or we can use the wire setSource to true
new Dial({step:0, min:1, max:3})
	.center()
	.wire(circle, "scale", null, true); // true for setSource to the target value

// S.update(); // depending, let the wire() set the stage update
END EXAMPLE

EXAMPLE
const rect = new Rectangle(100, 100, blue, dark)
	.pos(0,70,CENTER)
	.drag(S);

new Slider({min:0, max:W-100, currentValue:rect.x})
	.pos(0,100,CENTER,BOTTOM)
	.wire(rect, "x", true, null, data=>{
		if (data < 100 || data > W-100-100) rect.color = red;
		return data; // filter must return data - even if not changing it
	}, data=>{
		if (data >= 100 && data <= W-100-100) rect.color = blue;
	});

// timeout(5, ()=>{
// 	slider.noWire(); // remove slider rect wire
// });
END EXAMPLE

EXAMPLE
const person = {num:1, hair:red, eyes:blue}
const shirt = {num:1, color:dark, pocket:dark}
wire(person, shirt, "num"); // will wire person num to shirt num
wired({ // or could use wire() - just showing wired()
	source:person, // will wire person hair property to shirt color property
	input:"hair",
	target:shirt,
	prop:"color"
});
person.num = 3;
person.hair = blue;
// note: could use addWires(person) to add wire and wired methods to person if desired

timeout(.01, ()=>{ // must wait for Ticker to go
	zog(shirt.num); // 3
	zog(shirt.color); // blue
});
END EXAMPLE

EXAMPLE 
// wire a bunch of on/off components together
STYLE = {
	color:blue.darken(.3), 
	backgroundColor:blue.lighten(.3), 
	borderColor:blue.darken(.3),
	always:true, // for RadioButtons
	Toggle:{
		backgroundColor:blue.darken(.3), 
		toggleBackgroundColor:blue.lighten(.3)
	}
}

const radio = new RadioButtons(50,["OFF","ON"]).center();
const check = new CheckBox(50,"ON").center().mov(300);
const toggle = new Toggle(100,50,"ON").center().mov(-300)
Style.add({
	backgroundColor:blue.toAlpha(.3),
	Label:{size:40, backgroundColor:F.color}
});
const selector = new Selector(new Tile({
	obj:[new Label("OFF").centerReg(), new Label("ON").centerReg()],
	cols:2,
	spacingH:30,
	spacingV:20,
	unique:true
})).center().mov(0,200);

radio
	.wire(check, "checked", true, null, convert)
	.wire(toggle, "toggled", true, null, convert)
	.wire(selector, "selectedIndex", true);

// convert true/false to 0/1 and visa versa
function convert(data) {
	if (data===true) data = 1;
	else if (data===false) data = 0;
	else if (data===1) data = true;
	else if (data===0) data = false;
	return data;
}
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
** the current object is called the source - it will be setting the prop on the target
target - the object that has the property to wire to (and change)
prop (default input)- a String name of the property to change on the target
	if no property is provided it assumes the input property if provided
	the only time no prop would be useful is to wire together components
	like a Slider to a Dial where both will default to selectedIndex
twoWay (default false) - also have the change in prop on target change the source object's property
setSource (default false) - initially, by default, wire will change the target value to the source value
	setting setSource to true will initially set the source value to the target value
	this is independent of twoWay - so the twoWay setting does not matter
filter (default null) - a function to call before the prop is changed on the target (or source object if twoWay is true)
	this function receives a data parameter that holds the value of the property that will be changed on the target
	the prop value can be tested or changed
	the filter function MUST return the value whether it is modified or not
call (default null) - a function that is called once the property has been set on the target - receives the value as a parameter
input (default DEFAULTWIRE or "currentValue" or "selectedIndex" or prop) - an optional source property as a String
	wire will usually be used to wire a component to a DisplayObject
	and components usually have a currentValue or selectedIndex property that is changing in a change event, for instance
	so wire by default uses these if available and a change event is no longer needed
	Set ZIM DEFAULTWIRE constant to a String of the desired input if different than above.
	If the source object does not have a currentValue or selectedIndex property
	then the same property name as the target prop is used (unless an input is provided here)

RETURNS obj for chaining
--*///+33.2
	zim.wire = function(obj, target, prop, twoWay, setSource, filter, call, input) {
		var sig = "obj, target, prop, twoWay, setSource, filter, call, input";
		var duo; if (duo = zob(zim.wire, arguments, sig)) return duo;
		z_d("33.2");
		if (zot(zim.Ticker)) if (zon) {zogy("wire() - requires ZIM Frame"); return obj;}
		if (zot(target)) if (zon) {zogy("wire() - requires a target"); return obj;}

		var DW = zim.DEFAULTWIRE;
		if (WW.DEFAULTWIRE != null) DW = WW.DEFAULTWIRE;

		if (!zot(input)) {
			// use input
		} else if (DW && DW != "currentValue" && DW != "selectedIndex") {
			input = DW;
		} else {
			if (DW && Object.prototype.hasOwnProperty.call(obj,DW)) input = DW;
			else {
				if (Object.prototype.hasOwnProperty.call(obj,"currentValue")) input = "currentValue";
				else if (Object.prototype.hasOwnProperty.call(obj,"selectedIndex")) input = "selectedIndex";
				else input = prop;
			}
		}
		if (zot(prop)) prop = input;
		if (obj.addChild) obj.zimWire = true;
		if (target.addChild) target.zimWired = true;
		zim.Ticker.addWire(obj, [target, prop, twoWay, setSource, filter, call, input]);
		return obj;
	};//-33.2

/*--
obj.noWire = function(target, prop, input)

noWire
zim DisplayObject method

DESCRIPTION
turns off a wire() on the object - can optionally filter by target, prop and or input

EXAMPLE
if (circle.hitTestBounds(rect)) {
	slider.noWire();
	// or slider.noWire(circle); // if slider has more than one wire
});
END EXAMPLE

EXAMPLE
timeout(10, ()=>{
	noWire(); // turn off all wires
	// noWire(null, null, "scale"); // turn off all wires adjusting scale
	// noWire({target:mySprite}); // turn off all wires on mySprite
});
END EXAMPLE

RETURNS obj for chaining
--*///+33.25
	zim.noWire = function(obj, target, prop, input) {
		var sig = "obj, target, prop, input";
		var duo; if (duo = zob(zim.noWire, arguments, sig)) return duo;
		z_d("33.25");
		if (zot(zim.Ticker)) if (zon) {zogy("noWire() - requires ZIM Frame"); return obj;}
		zim.Ticker.removeWire(obj, target, prop, input);
		return obj;
	};//-33.25

//
/*--
obj.wired = function(source, prop, twoWay, setSource, filter, call, input)

wired
zim DisplayObject method

DESCRIPTION
Wires an object's property based on a source - see docs for ZIM wire() for details.
A wiring can be added only if the source object and the target object exist.
For instance we CANNOT do (even if we declare circle first):
	new Slider().center().wire(circle, "scale");
	var circle = new Circle().center();

OPTION 1:
	var circle = new Circle().center();
	new Slider().center().wire(circle, "scale");

OPTION 2:
	var slider = new Slider().center();
	new Circle().center().wired(slider, "scale"); // use wired()

wired() just switches the source and target and calls wired()
See the wire() method for parameters and description

EXAMPLE
const slider = new Slider().center();
new Circle().center().wired(slider, "scale");
END EXAMPLE

RETURNS obj for chaining
--*///+33.3
	zim.wired = function(obj, source, prop, twoWay, setSource, filter, call, input) {
		var sig = "obj, source, prop, twoWay, setSource, filter, call, input";
		var duo; if (duo = zob(zim.wired, arguments, sig)) return duo;
		z_d("33.3");
		if (zot(zim.Ticker)) if (zon) {zogy("wired() - requires ZIM Frame"); return obj;}
		zim.wire(source, obj, prop, twoWay, setSource, filter, call, input);
		return obj;
	};//-33.3

/*--
obj.noWired = function()

noWired
zim DisplayObject method

DESCRIPTION
Turns off wired() on the object.

EXAMPLE
if (circle.hitTestBounds(rect)) {
	circle.noWired();
});
END EXAMPLE

RETURNS obj for chaining
--*///+33.35
	zim.noWired = function(obj, source, prop, input) {
		var sig = "obj, source, prop, input";
		var duo; if (duo = zob(zim.noWire, arguments, sig)) return duo;
		z_d("33.35");
		if (zot(zim.Ticker)) if (zon) {zogy("noWired() - requires ZIM Frame"); return obj;}
		zim.Ticker.removeWire(source, obj, prop, input);
		return target;
	};//-33.35

/*--
obj.bind = function(id, props, extra, filter, bindObj)

bind
zim DisplayObject method

DESCRIPTION
Binds the specified object properties to a Bind object's connection.
This could be a connection to localStorage or a server script to a database.
This will allow a cleaner way to save and retrieve data.
See the docs for the ZIM Bind class for more details and examples

See: https://zimjs.com/ten/bind.html

EXAMPLE
// LOCALSTORAGE example
const b = new Bind(); // create a Bind object - defaults to localStorage
// b.clear(); // clear localStorage memory

// bind() will get data remembered in localStorage
// and also set up the binding
const c = new Circle().center().bind("circle", ["x","y"]).drag();

// when we want to update the binding call the to() method
c.on("pressup", function () {b.to();});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
id - a one-word string ID for the bind
	this will be used as the JSON key for the data
props - a property to bind as a string or an array of properties, eg. ["x","y"]
	or an object literal in the form {prop1:TO, prop2:FROM, prop3:BOTH, prop4:TO, etc.}
	by default the property will be bound as BOTH - as in TO and FROM
	this means data would be received on bind.to() calls and sent on bind.from() calls
extra (default null) extra information to be sent to the server (not localStorage)
	this could be an id or a search term, etc. it will have encodeURI() applied
	this can be received in php as $_GET["extra"] or $_POST["extra"] depending on bindType
filter (default null) a function to run before sending and after receiving data
	this will receive (data, command, extra) parameters
	the function must return the data - see Bind masterFilter parameter for more information
	note: the masterFilter if supplied will run as well before the filter
bindObj (default zimDefaultBind) - set to a specific bind object or keep as default
	see also ZIM Bind() setDefault parameter and default property

RETURNS obj for chaining
--*///+33.17
	if (typeof zimDefaultBind == "undefined") var zimDefaultBind;
	zim.bind = function(obj, id, props, extra, filter, bindObj) {
		var sig = "obj, id, props, extra, filter, bindObj";
		var duo; if (duo = zob(zim.bind, arguments, sig)) return duo;
		z_d("33.17");
		if (!zimDefaultBind) {
			if (zon) zogy("bind() - needs a Bind() object created first");
			return obj;
		}
		if (zot(id)) {
			if (zon) zogy("bind() - needs a unique id");
			return obj;
		}
		var b = bindObj||zimDefaultBind;
		b.add(id,obj,props,extra,filter);
		return obj;
	};//-33.17

/*--
obj.noBind = function(props, removeConnectionData, call, bindObj)

noBind
zim DisplayObject method

DESCRIPTION
Removes a binding from an object and its bound data
See: bind() and ZIM Bind();

EXAMPLE
const b = new Bind(); // create a Bind object - defaults to localStorage
const c = new Circle().center().bind("circle", ["x","y"]).drag();
c.on("pressup", ()=>{b.to();});
new Button({label:"REMOVE"}).loc(100,100).tap(()=>{
	// binding will be removed
	// next refresh, circle will be centered
	// but then will be bound again until button is pressed
	c.noBind();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
props - (default null) a property or an array of properties for which to remove the bind
	leaveing this blank will remove all bindings on the object
removeConnectionData (default true) remove connection data
	this will clear removed data from localStorage for LOCALSTORAGE setting
	a "remove" property will be sent to the server for GET or POST
	with a JSON {id1:["prop1","prop2"], id2:["prop3"]} format of removed items
call is a callback function after the data is sent and received
	the callback function will receive a result "success" or "error ..." in its parameter
bindObj - (default zimDefaultBind) a specific bind object to remove from

RETURNS obj for chaining
--*///+33.18
	zim.noBind = function(obj, props, removeConnectionData, call, bindObj) {
		var sig = "obj, props, removeConnectionData, call, bindObj";
		var duo; if (duo = zob(zim.noBind, arguments, sig)) return duo;
		z_d("33.18");
		if (!zimDefaultBind) return obj;
		var b = bindObj||zimDefaultBind;
		b.remove(obj,props,removeConnectionData,call);
		return obj;
	};//-33.18

/*--
obj.transform = function(move, stretchX, stretchY, scale, rotate, allowToggle, visible, onTop, showStretch, showRotate, showScale, showReg, showBorder, borderColor, borderWidth, dashed, customCursors, handleSize, regSize, snapDistance, snapRotation, cache, events, ghostColor, ghostWidth, ghostDashed, ghostHidden, frame, container)

transform
zim DisplayObject method

DESCRIPTION
The transform method adds transform controls to a display object.
The controls allow the user to move, scale, stretch, rotate and change the registration point.
Parameters are available to choose which of these transformations are available.
By default, all the transformations are available to use but
only the scale and registration point controls are showing.
The others work as the user rolls over the edges or the outer corners.
You can optionally set these to be visible as boxes on the sides and circles on the outer corners.

NOTE: works with the ZIM TransformManager() class to handle multiple transforms and saving data for persistence.
NOTE: the transformed object will have its mouseChildren set to false.

CLICK turns off and on the controls if allowToggle parameter is set to true (default is true)
If you use the TransformManager for multiple objects, the allowToggle is automatically set to true
SHIFT rotate snaps to 45
Dropping the registration point will snap to corners or center if close enough - unless CTRL is down
CTRL scale will scale about the registration point
CTRL DBLCLICK will reset scale to 1 and rotation to 0

EXAMPLE
rect.transform(); // shows handles for tranformations
END EXAMPLE

EXAMPLE
rect.transform({ // scale and stretch only
	move:false,
	rotate:false
});

// hide the rectangle's bottom stretch control so only can stretch from top
// note - transform() expects there to be a control so do not remove a control
// also, the controls have a hitArea so setting alpha to 0 will not work
rect.transformControls.stretchYControls.getChildAt(1).sca(0);
// or set its visible to false
rect.transformControls.stretchYControls.getChildAt(1).visible = false;

// Record the transforms and remake transforms when page reloads
// Or see the TransformManager
if (localStorage && localStorage.data) rect.transformControls.setData(localStorage.data, true);
rect.on("transformed", function() {
	if (localStorage) localStorage.data = rect.transformControls.recordData(true);
});

// change the color of the controls
var r = new Rectangle(100,100,grey).center().transform({borderColor:blue})
r.transformControls.scaleControls.loop(function (control) {
	control.color = blue;
	control.updateCache();
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
move - (default true) let user move object
stretchX - (default true) let user stretch object from left and right sides
stretchY - (default true) let user stretch object from top and bottom
scale - (default true) let user scale object from corners - might still be able to stretch from sides - see stretchX and stretchY
rotate - (default true) let user rotate object
allowToggle - (default true) let user hide and show controls with click - set to false not to let user hide controls
visible - (default true) show the controls to start
onTop - (default true) set to false to not move the selected shape to the top of its container
showStretch - (default false - true on mobile) show side boxes for stretching - a cursor will always show if stretchX or stretchY is true
showRotate - (default false - true on mobile) show circles at corners for rotation - a cursor will always show if rotation is true
showScale - (default true) show corner boxes for scaling - a cursor will always show if scale is set to true
showReg - (default true) show round circle for draggable registration point - rotates around registration point
showBorder - (default true) show rectangle border
borderColor - (default brown) any border color (CSS)
borderWidth - (default 1) the width of the border
dashed - (default false) set to true for dashed border
customCursors - (default true - false on mobile) set to false for system cursors (system cursors will not be rotated)
handleSize - (default 20 mobile - 10 desktop) the size of the control squares and circles
regSize - (default 16) the size of the registration point circle
snapDistance - (default 10) registration point will snap to corners and center if within this distance (and CTRL key not down)
snapRotation - (default 5) rotation will snap to angles divisible by this value
	holding CTRL will avoid snapping
	holding SHIFT will rotate only multiples of 45 degrees
cache (default true) - set to false to not cache the controls and cursors
events (default false) - set to true to receive events while controls are being opertated
	otherwise events will only trigger on pressup (not pressmove) - this conserves processing
	events are turned on automatically for obj type Tag, TextArea and Loader
ghostColor (default null) - color of outline when transform tools are not showing
ghostWidth (default null) - width of outline when transform tools are not showing
ghostDashed (default true) - dashed of outline if ghostColor or ghostWidth is set
ghostHidden (default false) - set to true to start with ghostHidden
frame (default zimDefaultFrame) - set to proper frame if on different frame
container (default stage) - set to a container to keep transforms within that container
	normally leave as default so transforms will stay above other objects
	but on occasion such as when using with ZIM TextureActives, a container is required
	as the container is cached and used on a texture

PROPERTIES
toggled - adds a read-only Boolean to the object that is true if controls are showing otherwise false

METHODS
toggle(state - default null) - added to the object
	shows controls if hidden and hides controls if showing (returns the object for chaining)
	or pass in true to show controls or false to hide controls

TRANSFORM CONTROL OBJECT
When tranform() is set on an object, the object receives a transformControls property
This holds the following:

PROPERTIES:
visible - read only whether the controls are visible
ghost - read only as to whether the ghost outline is showing - set with showGhost and hideGhost
ghostEnabled - read only as to whether the ghost outline will be turned on and off - set with addGhost and removeGhost
controls - reference to the Container that holds all the controls
scaleControls - reference to the Container that holds the corner boxes for scaling
stretchXControls - reference to the Container that holds the left and right boxes for stretching
stretchYControls - reference to the Container that holds the top and bottom boxes for stretching
rotateControls - reference to the Container that holds the outer circles for rotating

METHODS:
hide() - hides the controls - returns object for chaining
show() - shows the controls - returns object for chaining
recordData(toJSON) - returns an object with type, x, y, scaleX, scaleY, rotation, skewX, skewY, visible PROPERTIES
	if toJSON (default false) is set to true, the return value is a JSON string
setData(data, fromJSON) - sets the properties to match the data object passed in - this should come from recordData()
	if fromJSON (default false) is set to true, it will assume a JSON string is passed in as data
	returns object for chaining
remove(noHide) - removes the controls - set noHide true if already hidden
add(noShow) - adds the controls back if then have been removed - set noShow true if not wanting to show
allowToggleOn() - sets the show / hide controls on with click
allowToggleOff() - removes the show / hide controls on with click
showGhost() - show the ghost outline - the ghostWidth or ghostColor must be set in initial parameters
hideGhost() - hide the ghost outline
toggleGhost(state) - if ghost is showing will hide ghost and if ghost is hidden will show ghost
	or set state to true to show ghost or false to not show ghost
addGhost() - enable ghost outline functionality - the ghostWidth or ghostColor must be set in initial parameters
removeGhost() - disable ghost outline functionality
disable() - may show the controls if visible but cannot use them
enable() - turns the using of the controls back on
resize(dispatch) - call resize if the object is transformed in ways other than with the controls
	set dispatch to true to dispatch a "transformed" event - if manually adjusted this will save to TransformManager
dispose() - remove all aspects of transform on object

EVENTS
Adds a "transformed" event to obj that is dispatched when pressup on any of the controls or on click
	if the events parameter (or events property on transformControls) is set to true then these happen on pressmove of controls
	the transformed event object has a transformType property
	the transformType property has values of "select" (if not moved), "size", "move", "rotate", "stretch", "reg" "reset"
	the transformed event object also has a pressup property that is true if on pressup and false if from pressmove
	events are turned on automatically for obj type Tag, TextArea and Loader
Adds "transformshow" and "transformhide" events for when click to hide or show controls
If TransformManager() is used there are more events available such as "persistset", etc.

RETURNS obj for chaining
--*///+33.5
zim.transform = function(obj, move, stretchX, stretchY, scale, rotate, allowToggle, visible, onTop, showStretch, showRotate, showScale, showReg, showBorder, borderColor, borderWidth, dashed, customCursors, handleSize, regSize, snapDistance, snapRotation, cache, events, ghostColor, ghostWidth, ghostDashed, ghostHidden, frame, container) {
	var sig = "obj, move, stretchX, stretchY, scale, rotate, allowToggle, visible, onTop, showStretch, showRotate, showScale, showReg, showBorder, borderColor, borderWidth, dashed, customCursors, handleSize, regSize, snapDistance, snapRotation, cache, events, ghostColor, ghostWidth, ghostDashed, ghostHidden, frame, container";
	var duo; if (duo = zob(zim.transform, arguments, sig)) return duo;
	if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("transform", arguments); return obj;}
	z_d("33.5");

	if (zot(obj) || !obj.getBounds) {zogy("zim methods - transform(): please provide object with bounds set"); return obj;}
	if (!obj.getBounds()) {zogy("zim methods - transform(): please setBounds() on object");	return obj;}
	if (!obj.parent) {zogy("zim methods - transform(): object should be on stage first"); return obj;}

	if (zot(move)) move = true;
	if (zot(stretchX)) stretchX = true;
	if (zot(stretchY)) stretchY = true;
	if (obj.width == 0) stretchX = false;
	if (obj.height == 0) stretchY = false;
	if (zot(scale)) scale = true;
	if (zot(rotate)) rotate = true;

	if (zot(allowToggle)) allowToggle = true;
	if (zot(visible)) visible = true;
	if (zot(onTop)) onTop = true;
	if (zot(showStretch)) showStretch = mobile?true:false;
	if (zot(showRotate)) showRotate = mobile?true:false;
	if (zot(showScale)) showScale = true;
	if (zot(showReg)) showReg = true;
	if (zot(showBorder)) showBorder = true;
	if (zot(borderColor)) borderColor = "brown";
	if (zot(borderWidth)) borderWidth = 1;

	if (zot(ghostColor)) ghostColor = null;
	if (zot(ghostWidth)) ghostWidth = null;
	if (ghostColor < 0 || ghostWidth < 0) ghostColor = ghostWidth = null;
	else if (ghostColor!=null && ghostWidth==null) ghostWidth = 1;
	if (zot(ghostDashed)) ghostDashed = true;
	if (zot(ghostHidden)) ghostHidden = false;
	if (zot(frame)) frame = WW.zdf;
	var mobile = WW.M;

	if (zot(customCursors)) customCursors = mobile?false:true;
	if (zot(handleSize)) handleSize = mobile?20:10;
	if (zot(regSize)) regSize = 16;
	if (zot(snapDistance)) snapDistance = 10;
	if (zot(snapRotation)) snapRotation = 5;
	if (zot(cache)) cache = true;
	if (zot(events)) events = false;	
	if (obj.type == "Tag" || obj.type == "TextArea" || obj.type == "Loader") events = true;

	obj.zimMCO = obj.mouseChildren;
	obj.mouseChildren = false;
	var con = obj.getConcatenatedMatrix().decompose();

	var stage = obj.stage?obj.stage:frame.stage;

	if (zot(container)) container = stage;

	if (zot(frame.eventRemove)) {
		stage.enableMouseOver();
		frame.ctrlKey = false;
		frame.shiftKey = false;
		WW.addEventListener("keydown", function(e) {
			frame.altKey = e.altKey;
			frame.ctrlKey = e.ctrlKey;
		});
		WW.addEventListener("keyup", function(e) {
			frame.altKey = e.altKey;
			frame.ctrlKey = e.ctrlKey;
		});
	}

	var oB = obj.getBounds();
	var shape = new zim.Shape({style:false}); // bound rect
	var shapeG = new zim.Shape({style:false}); // ghost rect
	var shapeR = new zim.Shape({style:false}); // registration point
	shapeG.mouseEnabled = false;
	shapeR.controlType = "reg";
	var p = obj.parent;
	var g = shape.graphics;
	var gG = shapeG.graphics;
	var gR = shapeR.graphics;
	var pTL;
	var pTR;
	var pBR;
	var pBL;
	var pR;
	var pMid;
	var cur;
	var mids;
	var corners;
	var controls = new zim.Container({style:false});
	controls.type = "TransformControls";
	var squares = new zim.Container({style:false});
	var sidesH = new zim.Container({style:false});
	var sidesV = new zim.Container({style:false});
	var rotators = new zim.Container({style:false});
	var totalRotation;
	var totalScaleX;
	var totalScaleY;
	var totalSkewX;
	var totalSkewY;

	// HANDLE MASK if there is one
	if (!zot(obj.zimMaskDynamic)) obj.zimMaskApply(); // set mask set by zimMask to dynamic

	function makeCursor(type,moveCursor) {
		if (type==moveCursor) new zim.Triangle(16,12,12,"white",null,null,0).addTo(type).mov(0,-13.5);
		new zim.Triangle(16,12,12,"white",null,null,0).addTo(type).mov(13.5).rot(90);
		if (type==moveCursor) new zim.Triangle(16,12,12,"white",null,null,0).addTo(type).mov(0,13.5).rot(180);
		new zim.Triangle(16,12,12,"white",null,null,0).addTo(type).mov(-13.5).rot(-90);
		if (type==moveCursor) new zim.Triangle(10,7,7,"black",null,null,0).addTo(type).mov(0,-13);
		new zim.Triangle(10,7,7,"black",null,null,0).addTo(type).mov(13).rot(90);
		if (type==moveCursor) new zim.Triangle(10,7,7,"black",null,null,0).addTo(type).mov(0,13).rot(180);
		new zim.Triangle(10,7,7,"black",null,null,0).addTo(type).mov(-13).rot(-90);
		if (cache) type.cache(-20,-20,40,40);
	}
	
	if (customCursors) {
		var moveCursor = new zim.Container({style:false});
		var transformCursor = new zim.Container({style:false});
		makeCursor(moveCursor,moveCursor);
		makeCursor(transformCursor,moveCursor);		
		var ccData = {"nw-resize":45, "ne-resize":-45, "n-resize":90, "e-resize":0};
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// get total existing transforms
	function getTotals() {
		var temp = obj;
		totalRotation = 0;
		totalScaleX = 1;
		totalScaleY = 1;
		totalSkewX = 0;
		totalSkewY = 0;
		while(temp.parent) {
			totalRotation += temp.rotation;
			totalScaleX *= temp.scaleX;
			totalScaleY *= temp.scaleY;
			totalSkewX += temp.skewX;
			totalSkewY += temp.skewY;
			temp = temp.parent;
		}
	}
	getTotals();
	var originalR = totalRotation;

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// make control shapes

	// corners
	var cursors = ["nw-resize","ne-resize","nw-resize","ne-resize"];
	var opposites = [2,3,0,1];
	var rect,i;
	for (i=0; i<4; i++) {
		if (showScale) {
			rect = new zim.Rectangle(handleSize, handleSize, zim.pink, zim.grey, 2, null, null, null, null, false);
			rect.centerReg(squares);
			if (cache) rect.cache(-1,-1,handleSize+2,handleSize+2);
		} else {
			rect = new zim.Rectangle(handleSize, handleSize, "rgba(0,0,0,0)", "rgba(0,0,0,0)", 2, null, null, null, null, false);
			rect.centerReg(squares);
			rect.expand(0);
		}
		rect.rotation = totalRotation;
		cur = customCursors?"none":cursors[i];
		rect.drag({overCursor:cur, dragCursor:cur, onTop:false});
		rect.controlType = "corner";
		rect.cu = cursors[i];
	}
	// run again now that we have all the squares for the opposites
	for (i=0; i<opposites.length; i++) {
		squares.getChildAt(i).op = squares.getChildAt(opposites[i]);
	}

	// edges
	var cursorsSide = ["n-resize","e-resize","n-resize","e-resize"];
	opposites = [1,1,0,0];
	for (i=0; i<4; i++) {
		var w = i%2==0?obj.width/2:handleSize;
		var h = i%2==0?handleSize:obj.height/2;
		if (showStretch) {
			rect = new zim.Rectangle(handleSize, handleSize, zim.fog, zim.dark, 2, null, null, null, null, false);
			rect.centerReg(i%2==0?sidesV:sidesH);
			if (cache) rect.cache(-1,-1,handleSize+2,handleSize+2);
		} else {
			rect = new zim.Rectangle(w, h, "rgba(0,0,0,0)", null, null, null, null, null, null, false);
			rect.centerReg(i%2==0?sidesV:sidesH);
			rect.expand(0);
		}
		rect.rotation = totalRotation;
		cur = customCursors?"none":cursorsSide[i];
		rect.drag({overCursor:cur, dragCursor:cur, onTop:false});
		rect.controlType = "side";
		rect.cu = cursorsSide[i];
	}
	for (i=0; i<opposites.length; i++) {
		var whichSide = i%2==0?sidesV:sidesH;
		whichSide.getChildAt(Math.floor(i/2)).op = whichSide.getChildAt(opposites[i]);
	}

	// rotators
	var cursorsRotators = ["ne-resize","nw-resize","ne-resize","nw-resize"];
	for (i=0; i<4; i++) {

		if (showRotate) {
			rect = new zim.Circle(handleSize, zim.pink, null, null, null, null, null, null, null, false);
			rect.addTo(rotators);
			if (cache) rect.cache(-handleSize,-handleSize,handleSize*2,handleSize*2);
		} else {
			rect = new zim.Circle(handleSize, "rgba(0,0,0,0)", null, null, null, null, null, null, null, false);
			rect.addTo(rotators);
			rect.expand(0);
		}
		cur = customCursors?"none":cursorsRotators[i];
		rect.drag({overCursor:cur, dragCursor:cur, onTop:false});
		rect.controlType = "rotate";
		rect.cu = cursorsRotators[i];
	}
	var offSet = 1.8;
	rotators.alpha = .5;
	setRotators();
	function setRotators() {
		var shiftRX = handleSize*offSet*zim.sign(totalScaleX);
		var shiftRY = handleSize*offSet*zim.sign(totalScaleY);
		rotators.getChildAt(0).reg(shiftRX, shiftRY);
		rotators.getChildAt(1).reg(-shiftRX, shiftRY);
		rotators.getChildAt(2).reg(-shiftRX, -shiftRY);
		rotators.getChildAt(3).reg(shiftRX, -shiftRY);
		stage.update();
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// draw / redraw controls

	function makeControls() {
		g.c();
		gG.c();
		gR.c();
		pTL = obj.localToLocal(oB.x, oB.y, container);
		pTR = obj.localToLocal(oB.x+oB.width, oB.y, container);
		pBR = obj.localToLocal(oB.x+oB.width, oB.y+oB.height, container);
		pBL = obj.localToLocal(oB.x, oB.y+oB.height, container);

		var pTM = obj.localToLocal(oB.x+oB.width/2, oB.y, container);
		var pRM = obj.localToLocal(oB.x+oB.width, oB.y+oB.height/2, container);
		var pBM = obj.localToLocal(oB.x+oB.width/2, oB.y+oB.height, container);
		var pLM = obj.localToLocal(oB.x, oB.y+oB.height/2, container);

		pR = obj.localToLocal(obj.regX, obj.regY, container);
		pMid = obj.localToLocal(oB.x+oB.width/2, oB.y+oB.height/2, container);
		corners = [pTL, pTR, pBR, pBL];
		mids = [pTM, pRM, pBM, pLM];

		if (showBorder) {
			g.s(borderColor);
			if (dashed) g.sd([10, 5], 0);
			g.ss(borderWidth)
				.mt(pTL.x, pTL.y)
				.lt(pTR.x, pTR.y)
				.lt(pBR.x, pBR.y)
				.lt(pBL.x, pBL.y)
				.lt(pTL.x, pTL.y)
				.cp();
		}
		if (!zot(ghostColor)) {
			gG.s(ghostColor);
			if (ghostDashed) gG.sd([10, 5], 0);
			gG.ss(ghostWidth)
				.mt(pTL.x, pTL.y)
				.lt(pTR.x, pTR.y)
				.lt(pBR.x, pBR.y)
				.lt(pBL.x, pBL.y)
				.lt(pTL.x, pTL.y)
				.cp();
		}
		shape.setBounds(pTL.x, pTL.y, pTR.x-pTL.x, pBL.y-pTL.y);

		// circle at registration point
		if (showReg) {
			gR.s("#eee").ss(borderWidth).f("rgba(0,0,0,.1)").dc(0,0,regSize);
			gR.s("#222").ss(borderWidth).dc(0,0,regSize*.3);
		}

		getTotals(); // rotate, scales, etc.

		var skX = Math.min(50,Math.abs(totalSkewX))*zim.sign(totalSkewX);
		var skY = Math.min(50,Math.abs(totalSkewY))*zim.sign(totalSkewY);
		var ro = (totalRotation)*zim.sign(totalScaleX*totalScaleY)*zim.sign(obj.scaleX*obj.scaleY);

		for (var i=0; i<corners.length; i++) {
			var c = corners[i];
			squares.getChildAt(i)
				.loc(c.x, c.y)
				.ske(skX, skY)
				.rot(ro);
			rotators.getChildAt(i)
				.loc(c.x, c.y)
				.rot(ro);
			var m = mids[i];
			var whichSide = i%2==0?sidesV:sidesH;
			whichSide.getChildAt(Math.floor(i/2))
				.loc(m.x, m.y)
				.ske(skX, skY)
				.rot(ro);
			if (!showStretch) {
				whichSide.getChildAt(Math.floor(i/2)).sca(i%2==0?totalScaleX/2:1, i%2==0?1:totalScaleY/2);
			}
		}
		shapeR.x = pR.x;
		shapeR.y = pR.y;
	}
	makeControls();

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// dragger
	var dragger = new zim.Shape(1000,1000,null,null,null,false);
	function drawDragger() {
		dragger.x = 0;
		dragger.y = 0;
		dragger.graphics
			.c()
			.f("rgba(0,0,0,.01)")
			.mt(pTL.x, pTL.y)
			.lt(pTR.x, pTR.y)
			.lt(pBR.x, pBR.y)
			.lt(pBL.x, pBL.y)
			.lt(pTL.x, pTL.y)
			.cp();
		dragger.reg(pR.x, pR.y);
		dragger.x = pR.x;
		dragger.y = pR.y;
	}
	drawDragger();

	controls.on("dblclick", function(e) {
		if (frame.ctrlKey && obj.transformControls.visible) {
			obj.scaleX = 1;
			obj.scaleY = 1;
			obj.rotation = 0;
			// if (customCursors) moveCursor.rot(obj.rotation);
			makeControls();
			drawDragger();
			stage.update();
		}
		pressUp(e, true);
	});

	var toggleControlsEvent = controls.on("mousedown", toggleCheck);
	var toggleObjEvent = obj.on("mousedown", toggleCheck);
	function toggleCheck(e) {
		var underPoint = stage.getObjectUnderPoint(e.stageX, e.stageY, 1);
		// if (obj.hitTestPoint(e.stageX, e.stageY)) {
		if (mobile || (underPoint && ((obj.contains && obj.contains(underPoint)) || (!obj.contains && obj == underPoint)))) {
			if (!obj.transformControls.visible) {
				if (customCursors) {
					dragReady = false; // wait until the first pressup to show custom cursor
					dragger.mouseEnabled = false;
				} else {
					frame.canvas.style.cursor = "move"; // TEST TEST
				}
				obj.transformControls.show();
				obj.dispatchEvent("transformshow");
			}
		} else {
			// if (obj.transformControls.visible && (!underPoint || !controls.contains(underPoint)) && customCursors) {
			if (obj.transformControls.visible && (!underPoint || !controls.contains(underPoint))) {
				obj.transformControls.hide();
				obj.dispatchEvent("transformhide");
			}
		}
	}
	var toggleStageEvent = stage.on("stagemousedown", function(e) {
		if (mCheck) return;
		var underPoint = stage.getObjectUnderPoint(e.stageX, e.stageY, 1);
		var layerPress = (underPoint && underPoint.parent && underPoint.parent.layer && underPoint.parent.layer == obj);

		// if (obj.transformControls.visible && !controls.hitTestPoint(e.stageX, e.stageY)) {
		if (obj.transformControls.visible && (!underPoint || (!controls.contains(underPoint) && !layerPress))) {
			obj.dispatchEvent("transformhide");
			obj.transformControls.hide();
		}
	});
	if (!allowToggle) {
		controls.off("mousedown", toggleControlsEvent);
		obj.off("mousedown", toggleObjEvent);
		stage.off("stagemousedown", toggleStageEvent);
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// scaling
	var startX; // target start x
	var startY; // target start y
	var startSX;
	var startSY;
	var startR; // rotation of object to start
	var startAngle; // angle of mouse down to x axis
	var diffX;
	var diffY;
	var cornerPoint;
	var objStartX; // start object x in parent frame
	var objStartY; // start object x in parent frame
	var objRX; // start object x in global frame
	var objRY; // start object y in global frame
	var rotateCheck = false;
	var mousePress = false;
	var mousemoveEvent;
	var dragmoveEvent;
	var objCursor = obj.cursor;
	var transformEvent;
	var carrier = new zim.Circle(30, "rgba(0,0,0,0)", null, null, null, null, null, null, null, false).expand(20);
	if (customCursors) {

		carrier.mouseEnabled = false;
		carrier.mouseChildren = false;

		// these should be removed when transform is hidden!
		carrier.addChild(transformCursor);
		squares.on("mouseover", showCustomCursor);
		squares.on("mouseout", hideCustomCursor);
		sidesH.on("mouseover", showCustomCursor);
		sidesH.on("mouseout", hideCustomCursor);
		sidesV.on("mouseover", showCustomCursor);
		sidesV.on("mouseout", hideCustomCursor);
		rotators.on("mouseover", showCustomCursor);
		rotators.on("mouseout", hideCustomCursor);
		var carrier2 = new zim.Circle(30, "rgba(0,0,0,0)", null, null, null, null, null, null, null, false).expand(20);
		carrier2.cursor = "none";  // TEST TEST
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// scale corners
	squares.on("mousedown", transformMousedown);
	squares.on("pressmove", scalePressmove);
	squares.on("pressup", pressUp);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// scale sides
	sidesH.on("mousedown", transformMousedown);
	sidesH.on("pressmove", scalePressmove);
	sidesH.on("pressup", pressUp);
	sidesV.on("mousedown", transformMousedown);
	sidesV.on("pressmove", scalePressmove);
	sidesV.on("pressup", pressUp);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// rotate
	rotators.on("mousedown", transformMousedown);
	rotators.on("pressmove", rotatePressmove);
	rotators.on("pressup", pressUp);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// transform functions

	function mOff(current, control) {
		if (control == current) return;					
		if (control.lastChildren==null) control.lastChildren = control.mouseChildren;
		if (control.lastMouse==null) control.lastMouse = control.mouseEnabled;
		control.mouseChildren = false;
		control.mouseEnabled = false;		
	}

	function mOn(current, control) {
		if (control == current) return;					
		if (control.lastChildren!=null) control.mouseChildren = control.lastChildren;
		if (control.lastMouse!=null) control.mouseEnabled = control.lastMouse;
	}

	function offObjects(target) {
		mCheck = true; // stagemouse up does not remove so works with multitouch		
		squares.loop(function(control){mOff(target, control);});
		sidesH.loop(function(control){mOff(target,control);});
		sidesV.loop(function(control){mOff(target, control);});
		rotators.loop(function(control){mOff(target, control);});
		if (target == dragger) return;
		if (dragger && dragger.lastMouse==null) {
			dragger.lastMouse = dragger.mouseEnabled;
			obj.lastMouse = obj.dragPaused;
		}
		dragger.mouseEnabled = false;
		obj.dragPaused = true;
	}

	function onObjects(target) {
		mCheck = false;
		squares.loop(function(control){mOn(target, control);});
		sidesH.loop(function(control){mOn(target,control);});
		sidesV.loop(function(control){mOn(target, control);});
		rotators.loop(function(control){mOn(target, control);});
		if (target == dragger) return;
		if (dragger && dragger.lastMouse!=null) {
			dragger.mouseEnabled = dragger.lastMouse;
			obj.dragPaused = obj.lastMouse;
		}
		dragger.lastMouse = null;
	}

	var mCheck = false;
	function transformMousedown(e) {

		offObjects(e.target);
		
		mousePress = true; // stagemouse up removes... may be broken with multitouch
		if (onTop) {
			upTop();
			// obj.parent.setChildIndex(obj, obj.parent.numChildren-1);
			// stage.addChild(controls);
		}

		if (mousemoveEvent) stage.off("stagemousemove", mousemoveEvent);	

		startX = e.target.x;
		startY = e.target.y;
		objStartX = obj.x;
		objStartY = obj.y;
		startSX = obj.scaleX;
		startSY = obj.scaleY;
		var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		if (e.target.controlType == "rotate") {
			rotateCheck = true;
			startR = obj.rotation;			
			var startRX = pp.x;
			var startRY = pp.y;
			var point = p.localToLocal(objStartX, objStartY, container);
			objRX = point.x;
			objRY = point.y;
			startAngle = Math.atan2(startRY-objRY, startRX-objRX)*180/Math.PI;
		}
		if (frame.ctrlKey || e.target.controlType == "rotate") { // ctrl scale and rotation happen around
			diffX = Math.abs(startX-obj.x);
			diffY = Math.abs(startY-obj.y);
		} else {
			diffX = Math.abs(startX-e.target.op.x);
			diffY = Math.abs(startY-e.target.op.y);
		}

		if (e.target.controlType != "rotate") cornerPoint = e.target.op.parent.localToLocal(e.target.op.x, e.target.op.y, obj.parent); // cornerPoint = {x:e.target.op.x, y:e.target.op.y};
		if (carrier.stage) container.setChildIndex(carrier, container.getChildIndex(controls));
		else carrier.addTo(container, container.getChildIndex(controls)+1);
		carrier.x = pp.x;
		carrier.y = pp.y;
		carrier.cursor = customCursors?"none":e.target.cu; // TEST TEST
		if (customCursors) {
			obj.getConcatenatedMatrix().decompose(con);
			if (!con.rotation) con.rotation = 0;
			transformCursor.rotation = con.rotation*zim.sign(totalScaleX*totalScaleY)*zim.sign(obj.scaleX*obj.scaleY) + ccData[e.target.cu] + originalR;
			if (e.target.controlType != "side" && totalScaleX * totalScaleY < 0) transformCursor.rotation += 90;
			carrier2.addTo(container, 1).pos({x:pp.x, y:pp.y, reg:true});
		}
		dragger.visible = false;
		obj.cursor = "none"; 		
	}

	function scalePressmove(e) {
		var scale=1;
		if (frame.ctrlKey && e.target.controlType == "corner") { // relative to registration point
			scale = (diffX > diffY) ? (e.target.x - objStartX) / (startX-objStartX) : (e.target.y - objStartY) / (startY-objStartY);
		} else { // relative to opposite corner
			// scale = (diffX > diffY) ? (e.target.x - e.target.op.x) / (startX-e.target.op.x) : (e.target.y - e.target.op.y) / (startY-e.target.op.y);
			if (diffX > diffY) {
				if (startX-e.target.op.x) scale = (e.target.x - e.target.op.x) / (startX-e.target.op.x);
			} else {
				if (startY-e.target.op.y) scale = (e.target.y - e.target.op.y) / (startY-e.target.op.y);			
			}		
		}
		
		if (e.target.controlType == "corner") {
			obj.scaleX = scale * startSX;
			obj.scaleY = scale * startSY;
		} else {
			obj.scaleX = (e.target.cu == "e-resize") ? scale * startSX : startSX;
			obj.scaleY = (e.target.cu == "n-resize") ? scale * startSY : startSY;
		}			
		makeControls();
		var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		carrier.x = pp.x;
		carrier.y = pp.y;
		if (customCursors) {carrier2.x = pp.x; carrier2.y = pp.y;}
		if (!frame.ctrlKey || e.target.controlType == "side") { // keep opposite corner at same location
			var newCornerPoint = e.target.op.parent.localToLocal(e.target.op.x, e.target.op.y, obj.parent);
			obj.x -= (newCornerPoint.x-cornerPoint.x) * zim.sign(totalScaleX) * zim.sign(obj.scaleX); // adjust for - scale outside
			obj.y -= (newCornerPoint.y-cornerPoint.y) * zim.sign(totalScaleY) * zim.sign(obj.scaleY);
		}
		makeControls();
		if (obj.transformControls.events) {
			var type = e.target.controlType;
			dispatchEvents(e, type);
		}
	}

	function rotatePressmove(e) {
		var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		var angle = Math.atan2(pp.y-objRY, pp.x-objRX)*180/Math.PI;
		if (frame.shiftKey) {
			obj.rot(Math.round((startR + (angle - startAngle) * zim.sign(totalScaleX) * zim.sign(obj.scaleX))/45)*45);
		} else {
			obj.rot(startR + (angle - startAngle) * zim.sign(totalScaleX) * zim.sign(obj.scaleX));
		}
		makeControls();
		carrier.x = pp.x;
		carrier.y = pp.y;
		if (customCursors) {
			obj.getConcatenatedMatrix().decompose(con);
			if (!con.rotation) con.rotation = 0;
			transformCursor.rotation = con.rotation*zim.sign(totalScaleX*totalScaleY)*zim.sign(obj.scaleX*obj.scaleY) + ccData[e.target.cu] + originalR;
			if (e.target.controlType != "side" && totalScaleX * totalScaleY < 0) transformCursor.rotation += 90;
			carrier2.x = pp.x;
			carrier2.y = pp.y;
		}
		makeControls();
		if (obj.transformControls.events) {
			var type = e.target.controlType;
			dispatchEvents(e, type, null, false);
		}
	}

	function pressUp(e, reset) {

		onObjects(e.target);

		setRotators();
		var type = e ? e.target.controlType : "move";
		if (reset) type = "reset";
		if (customCursors) carrier2.removeFrom();
		dispatchEvents(e, type, true);
		stage.update();
	}

	function dispatchEvents(e, type, pressup, cursors) {
		if (cursors==null) cursors = true;
		var tCheck = false;
		transformEvent = null;
		var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		if (type == "move") {
			if (obj.x != startProperties.x || obj.y != startProperties.y) {
				transformEvent = new createjs.Event("transformed");
				transformEvent.transformType = "move";
			}
			if (cursors) tCheck = dragger.hitTestPoint(pp.x, pp.y);
		} else if (type == "corner") {
			if (obj.scaleX != startProperties.scaleX || obj.scaleY != startProperties.scaleY) {
				transformEvent = new createjs.Event("transformed");
				transformEvent.transformType = "size";
			}
			if (cursors) tCheck = squares.hitTestPoint(pp.x, pp.y);
		} else if (type == "side") {
			if (obj.scaleX != startProperties.scaleX || obj.scaleY != startProperties.scaleY) {
				transformEvent = new createjs.Event("transformed");
				transformEvent.transformType = "stretch";
			}
			if (cursors) tCheck = sidesH.hitTestPoint(pp.x, pp.y) || sidesV.hitTestPoint(pp.x, pp.y);
		} else if (type == "rotate") {
			if (obj.rotation != startProperties.rotation) {
				transformEvent = new createjs.Event("transformed");
				transformEvent.transformType = "rotate";
			}
			if (cursors) tCheck = rotators.hitTestPoint(pp.x, pp.y);
		} else if (type == "reg") {
			if (obj.regX != startProperties.regX || obj.regY != startProperties.regY) {
				transformEvent = new createjs.Event("transformed");
				transformEvent.transformType = "reg";
			}
		} else if (type == "reset") {
			transformEvent = new createjs.Event("transformed");
			transformEvent.transformType = "reset";
		} else {
			transformEvent = new createjs.Event("transformed");
			transformEvent.transformType = "unknown";
		}
		if (cursors && !tCheck) {
			carrier.removeFrom();
			frame.canvas.style.cursor = "default";
			obj.cursor = objCursor; // TEST TEST
		}
		// stage.update();
		if (transformEvent) {
			transformEvent.pressup = pressup;
			if (obj.type == "Tag" || obj.type == "TextArea" || obj.type == "Loader") obj.resize();
			obj.dispatchEvent(transformEvent);
		}
	}

	function showCustomCursor(e) { // not drag
		if (mousePress) return;
		if (carrier.stage) container.setChildIndex(carrier, container.getChildIndex(controls));
		else carrier.addTo(container, container.getChildIndex(controls)+1);
		carrier2.addTo(container, 1);
		
		var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		carrier.x = pp.x;
		carrier.y = pp.y;
		carrier2.x = pp.x;
		carrier2.y = pp.y;
		
		obj.getConcatenatedMatrix().decompose(con);
		
		if (!con.rotation) con.rotation = 0;
		transformCursor.rotation = con.rotation*zim.sign(totalScaleX*totalScaleY)*zim.sign(obj.scaleX*obj.scaleY) + ccData[e.target.cu] + originalR;
		if (e.target.controlType != "side" && totalScaleX * totalScaleY < 0) transformCursor.rotation += 90;
		stage.update();
		
		if (mousemoveEvent) stage.off("stagemousemove", mousemoveEvent);
		
		mousemoveEvent = stage.on("stagemousemove", function(e) {
			var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
			carrier.x = pp.x;
			carrier.y = pp.y;
			stage.update();
		});
	}

	function hideCustomCursor() { // not drag
		stage.off("stagemousemove", mousemoveEvent);
		if (mousePress) return;
		obj.cursor = objCursor; // TEST TEST
		carrier.removeFrom();
		carrier2.removeFrom();
		stage.update();
	}

	function upTop() {
		if (onTop) {
			var nc = p.numChildren-1;
			if (p.getChildAt(nc).type == "Keyboard") nc--;
			p.setChildIndex(obj, nc);
			addControls();
		}
	}

	function addControls() {
		// if the container is the stage add the controls one above the object
		// else add the controls one above the container
		// ADJUSTED stage to container - ZIM 015
		if (p==container) {
			controls.removeFrom();
			container.addChildAt(controls, container.getChildIndex(obj)+1);
		} else {
			var insert = p;
			while (insert.parent && insert.parent!=container) {insert = insert.parent;}
			if (obj.stage) {
				if (controls.parent==container) container.removeChild(controls);
				container.addChildAt(controls, container.getChildIndex(insert)+1);
			}
		}
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// drag registration point

	var point, rPoint;
	shapeR.drag();
	shapeR.on("mousedown", upTop);
	shapeR.on("pressup", function(e) {
		// snap to corners unless the ctrl key is down
		if (!frame.ctrlKey) {
			for (var i=0; i<corners.length; i++) {
				if (zim.dist(shapeR.x, shapeR.y, corners[i].x, corners[i].y) < snapDistance) {
					shapeR.x = corners[i].x;
					shapeR.y = corners[i].y;
					break;
				}
			}
			if (zim.dist(shapeR.x, shapeR.y, pMid.x, pMid.y) < snapDistance) {
				shapeR.x = pMid.x;
				shapeR.y = pMid.y;
			}
		}
		var originalRotation = obj.rotation;
		point = container.localToLocal(shapeR.x, shapeR.y, obj);
		if (p==stage) rPoint = new zim.Point(shapeR.x, shapeR.y);
		else rPoint = container.localToLocal(shapeR.x, shapeR.y, p);
		obj.reg(point.x, point.y);
		obj.rotation = 0;
		obj.x = obj.x + rPoint.x-obj.x;
		obj.y = obj.y + rPoint.y-obj.y;
		obj.rotation = originalRotation;

		makeControls();
		drawDragger();
		pressUp(e);
		stage.update();
	});

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	//  dragger functions
	var dragReady = true;
	cur = customCursors ? "none" : "move";
	dragger.drag({overCursor:cur, dragCursor:cur, onTop:false});
	dragger.controlType = "move";
	if (customCursors) {
		dragger.on("mouseover", draggerOver);
		dragger.on("mouseout", draggerOut);
	}
	function draggerOut() {
		stage.off("stagemousemove", dragmoveEvent);
		if (mousePress) return;
		moveCursor.removeFrom(controls);
		stage.update();
	}
	function draggerOver(e) {
		if (mousePress || !customCursors || !dragReady) return;
		var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
		moveCursor
			.addTo(controls)
			// .rot(obj.rotation*zim.sign(totalScaleX*totalScaleY)*zim.sign(obj.scaleX*obj.scaleY))
			.pos({x:pp.x, y:pp.y, reg:true});
		stage.update();
		if (dragmoveEvent) stage.off("stagemousemove", dragmoveEvent);
		dragmoveEvent = stage.on("stagemousemove", function(e) {
			var pp = container.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
			moveCursor.x = pp.x;
			moveCursor.y = pp.y;
			stage.update();
		});
	}
	dragger.on("mousedown", function(){
		offObjects(dragger);
		upTop();
	});
	dragger.on("pressmove", function(e) {
		if (!obj.transformControls.visible) return;
		var point;
		if (p==stage) point = new zim.Point(dragger.x, dragger.y);
		else point = container.localToLocal(dragger.x, dragger.y, p);
		obj.x = point.x;
		obj.y = point.y;
		makeControls();
		if (obj.transformControls.events) {
			var type = "move";
			dispatchEvents(e, type);
		}
	});
	dragger.on("pressup", function(e){
		onObjects(dragger);
		if (!obj.transformControls.visible) return;
		pressUp(e);
	});

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// Stage Mouse Up
	var stageUpEvent = stage.on("stagemouseup", function() {
		setTimeout(function() {
			if (mCheck) return;
			mousePress = false;
			dragger.mouseEnabled = true;
			if (!dragReady) {
				transformEvent = new createjs.Event("transformed");
				if (obj.x != startProperties.x || obj.y != startProperties.y) {
					transformEvent.transformType = "move";
				} else {
					transformEvent.transformType = "select";
				}
				transformEvent.pressup = true;
				obj.dispatchEvent(transformEvent);
			}
			dragReady = true;
			dragger.visible = true;
			if (rotateCheck) {
				if (!frame.ctrlKey && snapRotation > 1) { // snap if not control
					obj.rotation = Math.round(obj.rotation/snapRotation)*snapRotation;
					makeControls();
				}
			}
			drawDragger();
			dragger.mouseEnabled = true;
			rotateCheck = false;
			stage.update();
		},50);
		
	});

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// add controls to controls container

	function getStartProperies() {
		startProperties = {x:obj.x, y:obj.y, rotation:obj.rotation, regX:obj.regX, regY:obj.regY, scaleX:obj.scaleX, scaleY:obj.scaleY};
	}
	var startProperties;
	getStartProperies();
	var compareObjEvent = obj.on("mousedown", getStartProperies);
	controls.on("mousedown", getStartProperies);

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// add controls to controls container

	controls.addChild(shape);
	if (move) controls.addChild(dragger);
	if (scale) controls.addChild(squares);
	if (stretchX) controls.addChild(sidesH);
	if (stretchY) controls.addChild(sidesV);
	if (rotate) controls.addChild(rotators);
	controls.addChild(shapeR);

	var pressmoveEvent;
	if (move) {
		obj.drag({overCursor:"pointer", dragCursor:"pointer", onTop:false, removeTweens:false});
		pressmoveEvent = obj.on("pressmove", function(e) {
			makeControls();
			drawDragger();
			setRotators();
			if (obj.transformControls.events) {
				var type = "move";
				dispatchEvents(e, type);
			}
		});
	}

	// ~~~~~~~~~~~~~~~~~~~~~~~~~~~
	// control object

	var toggleStart = allowToggle;
	obj.transformControls = {
		visible:visible,
		events:events,
		ghost:!zot(ghostColor),
		ghostEnabled:!zot(ghostColor),
		show:function() {
			if (onTop) upTop();
			// else addControls // taken out in 9.5.0 and made always adding - removed add from upTop
			addControls();
			obj.toggled = true;
			obj.transformControls.visible = true;
			if (shapeG.parent) shapeG.removeFrom();
			stage.update();
			return obj.transformControls;
		},
		hide:function() {
			if (obj.transformControls.ghost) var index = container.getChildIndex(controls);
			container.removeChild(controls);
			if (obj.transformControls.ghost && obj.transformControls.ghostEnabled) container.addChildAt(shapeG, index);
			obj.toggled = false;
			obj.transformControls.visible = false;
			if (customCursors) {
				if (mousemoveEvent) stage.off("stagemousemove", mousemoveEvent);
				if (dragmoveEvent) stage.off("stagemousemove", dragmoveEvent);
				mousePress = false;
				carrier.removeFrom();
				carrier2.removeFrom();
			}
			if (!move) obj.cur(objCursor); // TEST TEST
			stage.update();
			return obj.transformControls;
		},
		remove:function(noHide) {
			if (!noHide) {
				obj.transformControls.hide();
			}
			allowToggle = false;
			if (move) {
				obj.noDrag();
				obj.off("pressmove", pressmoveEvent);
			}
            return obj.transformControls;
		},
		add:function(noShow) {
			if (!noShow) {
				obj.transformControls.show();
			}
			allowToggle = toggleStart;
			if (move) {
				obj.drag({overCursor:"pointer", dragCursor:"pointer", onTop:false, removeTweens:false});
				pressmoveEvent = obj.on("pressmove", pressmoveEvent);
			}
            return obj.transformControls;
		},
		allowToggleOn:function() {
			allowToggle = toggleStart = true;
			toggleControlsEvent = controls.on("mousedown", toggleControlsEvent);
			toggleObjEvent = obj.on("mousedown", toggleObjEvent);
			toggleStageEvent = stage.on("stagemousedown", toggleStageEvent);
            return obj.transformControls;
		},
		allowToggleOff:function() {
			allowToggle = toggleStart = false;
			controls.off("mousedown", toggleControlsEvent);
			obj.off("mousedown", toggleObjEvent);
			stage.off("stagemousedown", toggleStageEvent);
            return obj.transformControls;
		},
		disable:function() {
			controls.mouseChildren = false;
			controls.mouseEnabled = false;
			obj.mouseChildren = obj.zimMCO;
			if (move) {
				obj.noDrag();
				obj.off("pressmove", pressmoveEvent);
			}
            return obj.transformControls;
		},
		enable:function() {
			controls.mouseChildren = true;
			controls.mouseEnabled = true;
			obj.mouseChildren = false;
			if (move) {
				obj.drag({overCursor:"pointer", dragCursor:"pointer", onTop:false, removeTweens:false});
				pressmoveEvent = obj.on("pressmove", pressmoveEvent);
			}
            return obj.transformControls;
		},
		recordData:function(toJSON) {
			var data = { // ES6 would help...
				type:obj.type,
				index:p.getChildIndex(obj),
				x:obj.x, y:obj.y,
				scaleX:obj.scaleX,
				scaleY:obj.scaleY,
				rotation:obj.rotation,
				skewX:obj.skewX,
				skewY:obj.skewY,
				regX:obj.regX,
				regY:obj.regY,
				controls:obj.transformControls.visible
			};
			return toJSON ? JSON.stringify(data) : data;
		},
		setData:function(data, fromJSON) {
			if (zot(data)) return;
			if (fromJSON) data = JSON.parse(data);
			// var visible = data.controls;
			delete data.controls;
			var index = data.index;
			if (zot(index)) index = 0;
			delete data.index;
			for (var i in data) {
				obj[i] = data[i];
			}
			setTimeout(function () { // added 9.5.0 - watch to see if there is an issue - nested positions were not ready
				makeControls();
				drawDragger();
				setRotators();
				p.setChildIndex(obj, index);
				if (obj.transformControls.visible && obj.type != "Layer") obj.transformControls.show();
				else obj.transformControls.hide();
				if (obj.transformControls.ghost && !obj.transformControls.ghostEnabled && !obj.transformControls.visible) container.addChild(shapeG);
			},90);
			return obj.transformControls;
		},
		hideGhost:function() {
			obj.transformControls.ghost = false;
			shapeG.removeFrom();
            return obj.transformControls;
        },
        showGhost:function() {
			obj.transformControls.ghost = true;
			if (obj.transformControls.ghostEnabled && !obj.transformControls.visible) {
				var insert = p;
				while (insert.parent && insert.parent!=container) {insert = insert.parent;}
				if (shapeG.stage) {
					container.setChildIndex(shapeG, container.getChildIndex(insert)+1);
				} else {
					container.addChildAt(shapeG, container.getChildIndex(insert)+1);
				}
			}
            return obj.transformControls;
        },
		addGhost:function() {
			if (ghostWidth > 0) {
				obj.transformControls.ghostEnabled = true;
				obj.transformControls.showGhost();
			}
			else {if (zon) zogy("transform() - ghostWidth must be > 0 when making transform");}
            return obj.transformControls;
        },
        removeGhost:function() {
			obj.transformControls.ghostEnabled = false;
			obj.transformControls.hideGhost();
            return obj.transformControls;
        },
		resize:function(dispatch) {
			p = obj.parent;
			makeControls();
			drawDragger();
			setRotators();
			if (visible) obj.transformControls.show(); // bring on top
			if (dispatch) {
				var transformEvent = new createjs.Event("transformed");
				transformEvent.pressup = true;
				transformEvent.transformType = "resize";
				obj.dispatchEvent(transformEvent);
			}
			return obj.transformControls;
		},
		dispose:function() {
			obj.transformControls.hide();
			allowToggle = false;
			obj.mouseChildren = obj.zimMCO;
			if (move) {
				obj.noDrag();
				obj.off("pressmove", pressmoveEvent);
			}
			obj.transformControls.hideGhost();
			dragger.removeAllEventListeners();
			rotators.removeAllEventListeners();
			shapeR.removeAllEventListeners();
			sidesH.removeAllEventListeners();
			sidesV.removeAllEventListeners();
			squares.removeAllEventListeners();
			controls.removeAllEventListeners();
			if (toggleObjEvent) obj.off("mousedown", toggleObjEvent);
			if (toggleControlsEvent) obj.off("mousedown", toggleControlsEvent);
			if (toggleStageEvent) stage.off("stagemousedown", toggleStageEvent);
			if (mousemoveEvent) stage.off("stagemousemove", mousemoveEvent);
			if (dragmoveEvent) stage.off("stagemousemove", dragmoveEvent);
			if (stageUpEvent) stage.off("stagemouseup", stageUpEvent);
			if (compareObjEvent) obj.off("mousedown", compareObjEvent);
			if (pressmoveEvent) obj.off("pressmove", pressmoveEvent);
			controls = carrier = carrier2 = null;
			obj.transformControls = null;
		},
		controls:controls,
		scaleControls:squares,
		stretchXControls:sidesH,
		stretchYControls:sidesV,
		rotateControls:rotators
	};

	obj.toggle = function(state) {
		if (state===true) obj.transformControls.show();
		else if (state===false) obj.transformControls.hide();
		else if (obj.transformControls.visible) obj.transformControls.hide();
		else obj.transformControls.show();
		return obj;
	};
	if (obj.transformControls.ghost) {
		obj.transformControls.toggleGhost = function(state) {
			if (state===true) obj.transformControls.showGhost();
			else if (state===false) obj.transformControls.hideGhost();
			else if (obj.transformControls.visible) obj.transformControls.hideGhost();
			else obj.transformControls.showGhost();
			return obj;
		};
	}
	if (visible) obj.transformControls.show();
	else if (!ghostHidden && obj.transformControls.ghost) obj.transformControls.showGhost();

	return obj;

};//-33.5


/*--
obj.gesture = function(move, scale, rotate, boundary, minScale, maxScale, snapRotate, localBoundary, slide, slideFactor, regControl, onTop, surround, circularBounds, rect)

gesture
zim DisplayObject method

DESCRIPTION
Sets multi-touch pan, pinch and rotate for position, scale and rotation
Handles scaled and rotated containers
Scale and rotation occur from the pinch point (with optional regControl for about the registration point)
Note - gesture() only works on the currentTarget - not a container's children (like drag() can)
ZIM Frame should have touch set to true (which is the default for mobile)
ALSO: see the noGesture() method to remove some or all gestures
ALSO: see the gestureBoundary() method to set or reset the boundary rectangle dynamically

EXAMPLE
rect.gesture(); // move, scale and rotate with no bounds
END EXAMPLE

EXAMPLE
rect.gesture({
	rotate:false,
	boundary:new Boundary(0,0,W,H),
	minScale:.5,
	maxScale:3,
	slide:true
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
move - (default true) move the object with average of fingers
scale - (default true) scale the object with first two fingers' pinch
rotate - (default true) rotate the object with first two fingers' rotation
boundary - (default null) ZIM Boundary rectangle with (x,y,w,h) to contain bounds of the object
	if surround is true then it will make sure the obj surrounds the boundary rather than stays within it
	See circularBounds parameter to keep circular shapes with boundary
minScale - (default null) a minimum scale
maxScale - (default null) a maximum scale
snapRotate - (default 1) degrees to snap rotation to after rotation is finished
localBoundary - (default false) set to true to make rect for bounds local rather than global
slideFactor - (default 5) how much slide with 0 being no slide and then longer slide times and distance like 10, etc.
regControl (default false) set to true to rotate and scale around registration point rather than pinch point
onTop - (default true) brings the object to the top of the container
surround - (default false) is for dragging a big object that always surrounds the rect
	must specify a rect and currently not supported unless rotate is false
circularBounds - (default false) set to true if object is circular with center registration
	set to true to use radius to calculate rotated object in boundary if boundary is set
rect - (depreciated) same as boundary - kept for backwards compatibility

EVENTS
Adds move, scale and rotate events to obj (when associated gesture parameters are set to true)
If slide is true, obj dispatches a "slidestop" event when sliding stops

RETURNS obj for chaining
--*///+34.5
	zim.gesture = function(obj, move, scale, rotate, boundary, minScale, maxScale, snapRotate, localBoundary, slide, slideFactor, regControl, onTop, surround, circularBounds, rect) {
		var sig = "obj, move, scale, rotate, boundary, minScale, maxScale, snapRotate, localBoundary, slide, slideFactor, regControl, onTop, surround, circularBounds, rect";
		var duo; if (duo = zob(zim.gesture, arguments, sig)) return duo;
		z_d("34.5");

		if (zot(obj) || !obj.on) return;
		if (zot(move)) move = true;
		if (zot(scale)) scale = true;
		if (zot(rotate)) rotate = true;
		if (zot(localBoundary)) localBoundary = false;
		if (zot(snapRotate)) snapRotate = 1;
		if (zot(slide)) slide = false;
		if (zot(slideFactor)) slideFactor = 5;
		if (zot(regControl)) regControl = false;
		if (zot(onTop)) onTop = true;
		if (zot(surround)) surround = false;
		if (surround && rotate) {
			surround = rect = null;
			if (zon) zogy("gesture() - does not support surround when rotate is true");
		}
		if (zot(circularBounds)) circularBounds = false;
		if (zot(boundary) && !zot(rect)) boundary = rect;

		var slideData;
		var slideCount;
		var slideSlice;
		var slideTotal;


		var timeType = getTIME();

		// HANDLE MASK if there is one
		if (!zot(obj.zimMaskDynamic)) obj.zimMaskApply(); // set mask set by zimMask to dynamic

		if (!obj.zimTouch) {

			var dampScaleX = new zim.Damp(obj.scaleX, .05);
			var dampScaleY = new zim.Damp(obj.scaleY, .05);
			var scaleRatio = obj.scaleX/obj.scaleY;

			obj.zimTouch = {
				move:move, // store settings on object to control with noGesture()
				scale:scale,
				rotate:rotate,
				pointers:{}, // holds the current pointer data
				checkBounds:function(x, y) { // used locally and by zim.gestureBoundary
					if (obj.zimTouch.boundary) {
						var boundary = obj.zimTouch.boundary;
						// convert the desired drag position to a global point
						// note that we want the position of the object in its parent
						// so we use the parent as the local frame
						var point = obj.parent.localToLocal(x,y,obj.parent);
						// boundary is the boundary rectangle on the global stage
						// boundary is set during mousedown to allow for global scaling when in localBoundary mode
						// if you scale in localBoundary==false mode, you will need to reset bounds with dragBoundary()
						if (surround) {
							x = Math.min(boundary.x, Math.max(boundary.x+boundary.width, point.x));
							y = Math.min(boundary.y, Math.max(boundary.y+boundary.height, point.y));
						} else {
							x = Math.max(boundary.x, Math.min(boundary.x+boundary.width, point.x));
							y = Math.max(boundary.y, Math.min(boundary.y+boundary.height, point.y));
						}
						// now that the point has been checked on the global scale
						// convert the point back to the obj parent frame of reference
						point = obj.parent.globalToLocal(x, y);
						x = point.x;
						y = point.y;
					}
					return {x:x,y:y};
				}
			};

			if (boundary) {
				obj.zimTouch.boundary = boundary;
				if (localBoundary) obj.zimTouch.boundary = zim.boundsToGlobal(obj.parent, boundary);
				obj.zimTouch.boundaryStartX = obj.zimTouch.boundary.x;
				obj.zimTouch.boundaryStartY = obj.zimTouch.boundary.y;
				obj.zimTouch.boundaryStartW = obj.zimTouch.boundary.width;
				obj.zimTouch.boundaryStartH = obj.zimTouch.boundary.height;
				var result = obj.zimTouch.checkBounds(obj.x, obj.y); // set in bounds to start
				obj.x = result.x;
				obj.y = result.y;
			}

			if (slide) {
				slideSlice = 10;
				slideTotal = 5;
				slideCount = 0;
				slideData = [];

				obj.zimTouch.slideInterval = zim.interval(slideSlice/(timeType=="s"?1000:1),function() {
					slideData[slideCount++%slideTotal] = [obj.x, obj.y];
				});
				obj.zimTouch.slideInterval.pause();
				obj.animate({x:obj.x, y:obj.y}, 10/(timeType=="s"?1000:1), "quadOut"); // for some reason, first throw is smoother if already animated
			}

			var matrixStart;
			var startScaleX;
			var startScaleY;
			var startRotation;
			var startRegX;
			var startRegY;
			var lastPoint;
			var maxTouches;

			obj.zimTouch.mousedown = obj.on("mousedown", function(e) {
				if (zot(maxTouches)) maxTouches = 1;
				else maxTouches++;

				if (onTop) {
					var nc = obj.parent.numChildren-1;
					if (obj.parent.getChildAt(nc).type=="Keyboard") nc--;
					obj.parent.setChildIndex(obj,nc);
					if (obj.ZIMoutlineShape) obj.outline();
				}
				if (!regControl) {
					lastPoint = null;
					startScaleX = obj.scaleX;
					startScaleY = obj.scaleY;
					startRotation = obj.rotation;
					startRegX = obj.regX;
					startRegY = obj.regY;
					obj.reg(0,0);
					matrixStart = obj.getMatrix();
					obj.regX = startRegX;
					obj.regY = startRegY;
				}

				var id = "id"+Math.abs(e.pointerID+1); // some pointers have negative ids
				// convert all pointer x and y to the parent container of the obj
				var local = obj.parent.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
				// we compare current pointer to start pointer (rather than increment as we go)
				obj.zimTouch.pointers[id] = {
					startX:local.x, startY:local.y,
					x:local.x, y:local.y
				};
				if (obj.zimTouch.move || obj.zimTouch.rotate) {
					obj.zimTouch.total = 0;
					zim.loop(obj.zimTouch.pointers, function() {
						obj.zimTouch.total++;
					});
				}
				if (slide && obj.zimTouch.total == 1) obj.zimTouch.slideInterval.pause(false);
				setTouches();
			});

			obj.zimTouch.pressmove = obj.on("pressmove", function(e) {

				var id = "id"+Math.abs(e.pointerID+1);
				var local = obj.parent.globalToLocal(e.stageX/zim.scaX, e.stageY/zim.scaY);
				// update our pointer data with new x and y
				if (obj.zimTouch.pointers[id]) {
					obj.zimTouch.pointers[id].x = local.x;
					obj.zimTouch.pointers[id].y = local.y;
				}

				// average the pointers' movement
				var newX = 0;
				var newY = 0;
				var aveX = 0; // point about which to scale and rotate
				var aveY = 0;
				var deltaX = 0;
				var deltaY = 0;
				zim.loop(obj.zimTouch.pointers, function(id, pointer) {
					newX += pointer.x - pointer.startX;
					newY += pointer.y - pointer.startY;
					aveX += pointer.x;
					aveY += pointer.y;
				});
				if (obj.zimTouch.total == 0) return;
				deltaX = newX / obj.zimTouch.total;
				deltaY = newY / obj.zimTouch.total;
				newX = obj.zimTouch.startX + deltaX;
				newY = obj.zimTouch.startY + deltaY;
				aveX = aveX / obj.zimTouch.total;
				aveY = aveY / obj.zimTouch.total;

				var proxy = {
					x: obj.x,
					y: obj.y,
					scaleX:obj.scaleX,
					scaleY:obj.scaleY,
					rotation:obj.rotation
				}; // will store desired scale and rotation on this object then apply matrix calculations

				if (obj.zimTouch.move) {
					var result = obj.zimTouch.checkBounds(newX, newY); // es6 opportunity
					proxy.x = result.x;
					proxy.y = result.y;
				}

				// if we have multitouch as determined by setTouches()
				if (obj.zimTouch.pair.length == 2) {
					var point1 = obj.zimTouch.pair[0];
					var point2 = obj.zimTouch.pair[1];
					if (obj.zimTouch.scale) {
						// use ratio of distance between fingers to start and then current distance between fingers
						var startDistance = Math.sqrt(Math.pow((point2.startX-point1.startX),2) + Math.pow((point2.startY-point1.startY),2));
						var currentDistance = Math.sqrt(Math.pow((point2.x-point1.x),2) + Math.pow((point2.y-point1.y),2));
						var newScaleX = obj.zimTouch.startSX + (currentDistance / startDistance - 1);
						var newScaleY = obj.zimTouch.startSY + (currentDistance / startDistance - 1);
						proxy.scaleX = newScaleX;
						proxy.scaleY = newScaleY;

						proxy.scaleX = dampScaleX.convert(newScaleX);
						proxy.scaleY = dampScaleY.convert(newScaleY);

						// set to scale min or max if scale would be outside range
						var minBad = (!zot(minScale) && Math.min(newScaleX, newScaleY) < minScale);
						var maxBad = (!zot(maxScale) && Math.max(newScaleX, newScaleY) > maxScale);
						if (minBad || maxBad) {
							if (minBad) {
								if (scaleRatio > 1) {
									proxy.scaleY = minScale;
									proxy.scaleX = minScale*scaleRatio;
								} else {
									proxy.scaleX = minScale;
									proxy.scaleY = minScale/scaleRatio;
								}
							} else if (maxBad) {
								if (scaleRatio > 1) {
									proxy.scaleX = maxScale;
									proxy.scaleY = maxScale/scaleRatio;
								} else {
									proxy.scaleY = maxScale;
									proxy.scaleX = maxScale*scaleRatio;
								}
							}
							dampScaleX.immediate(proxy.scaleX);
							dampScaleY.immediate(proxy.scaleY);
						}

					}
					if (obj.zimTouch.rotate) {
						// rotate based on the difference of angle between the fingers at start and at current
						var startAngle = Math.atan2((point1.startY - point2.startY), (point1.startX - point2.startX)) * (180 / Math.PI);
						var currentAngle = Math.atan2((point1.y - point2.y), (point1.x - point2.x)) * (180 / Math.PI);
						var deltaR = currentAngle - startAngle;
						proxy.rotation = obj.zimTouch.startR + deltaR;
					}

					if (regControl) {
						obj.scaleX = proxy.scaleX;
						obj.scaleY = proxy.scaleY;
						obj.rotation = proxy.rotation;
						if (obj.zimTouch.move) {
							obj.x = proxy.x;
							obj.y = proxy.y;
						}
					} else {
						// transformations seem to ignore registration so need to set to 0 then reset after transformations
						obj.reg(0,0);

						// need global data - the transformation about the pinch point is an adjustment of the system
						// originally we wanted calculations in the container of the object
						// these calculations were probably used for min and max of things, etc. so just leaving them
						// and instead, bringing the calculations back into the global - and then eventually into the local for the transformations
						var adjust = obj.parent.localToGlobal(aveX, aveY);
						aveX = adjust.x;
						aveY = adjust.y;

						// unfortunately, system goes haywire after a while without adjusting for minor shifts
						// saving the location of the center back to global after the transformation seems to correct this
						// we set lastPoint down below after the transformation
						var point = zot(lastPoint) ? obj.globalToLocal(aveX, aveY) : obj.globalToLocal(lastPoint.x, lastPoint.y);

						// the classic Matrix transformation - translate to the pinch point, scale and rotate, and then translate back
						// var matrix = new createjs.Matrix2D()
						var matrix = matrixStart.clone()
							.translate(point.x, point.y)
							.rotate(proxy.rotation-startRotation)
							.scale(proxy.scaleX/startScaleX,proxy.scaleY/startScaleY)
							.translate(-(point.x), -(point.y));
							// .prependMatrix(matrixStart) // would use if started new Matrix each time

						matrix.decompose(obj);

						if (obj.zimTouch.move) {
							obj.x += deltaX;
							obj.y += deltaY;
						}

						// correcting for minor shifts which can magnify and set the system haywire
						lastPoint = obj.localToGlobal(point.x, point.y);

						obj.reg(startRegX, startRegY);
					}

					if (obj.zimTouch.scale) obj.dispatchEvent("scale");
					if (obj.zimTouch.rotate) obj.dispatchEvent("rotate");
					if (obj.zimTouch.move) obj.dispatchEvent("move");

				} else {
					obj.x = proxy.x;
					obj.y = proxy.y;
					if (obj.zimTouch.move) obj.dispatchEvent("move");
				}
				if (obj.type == "Tag" || obj.type == "TextArea" || obj.type == "Loader") obj.resize();

				if (obj.ZIMoutlineShape) obj.outline();
				if (obj.getStage && obj.stage) obj.stage.update();
			});

			obj.on("mousedown", function() {
				// if an object is removed that is touched, the touch will still be registered
				// this code makes sure that no ghost touches are left by counting stagemousedown and stagemouseup events
				var mouseCount = 1;
				obj.stage.on("stagemousedown", function() {
					mouseCount++;
				});
				obj.stage.on("stagemouseup", function() {
					mouseCount--;
					if (mouseCount == 0) {
						setTimeout(function() {
							if (obj.zimTouch) obj.zimTouch.total = 0;
							if (obj.zimTouch) obj.zimTouch.pointers = {};
							maxTouches = null;
						}, 50);
					}
				});
			}, null, true); // once

			obj.zimTouch.pressup = obj.on("pressup", function(e) {
				var id = "id"+Math.abs(e.pointerID+1);
				// remove touch data for pointer
				delete obj.zimTouch.pointers[id];
				if (obj.zimTouch.move || obj.zimTouch.rotate) obj.zimTouch.total--;
				if (rotate && !zot(snapRotate) && obj.zimTouch.total == 0) {
					if (snapRotate > 0) {
						obj.rotation = Math.round(obj.rotation/snapRotate)*snapRotate;
					} else if (snapRotate == 0) {
						obj.rotation = Math.round(obj.rotation);
					}
				}
				// spinning was throwing slide off so just slide with single touch for now...
				if (slide && obj.zimTouch.total == 0 && maxTouches == 1) {
					obj.zimTouch.slideInterval.pause();
					var startSlide = slideData[(slideCount+1)%slideData.length];
					var currentSlide = slideData[(slideCount)%slideData.length];
					var newX = obj.x + (startSlide[0]-currentSlide[0]) * slideFactor;
					var newY = obj.y + (startSlide[1]-currentSlide[1]) * slideFactor;
					var result = obj.zimTouch.checkBounds(newX, newY); // es6 opportunity
					// if it is being thrown past the bounds, need to reduce time by percentage of blocked movement
					var newT = slideTotal*slideSlice*slideFactor * Math.min((obj.x-result.x)/(obj.x-newX)||1, (obj.y-result.y)/(obj.y-newY)||1);
					obj.animate({x:result.x, y:result.y}, newT/(timeType=="s"?1000:1), "quadOut", function(){obj.dispatchEvent("slidestop");});
				}
				if (obj.zimTouch.total == 0) maxTouches = null;
				if (obj.getStage && obj.stage) obj.stage.update();
				setTouches();
			});
			
			if (boundary) {
				remakeBoundary();
				obj.on("move", remakeBoundary);
			}
		}
		
		function setTouches() {
			// anytime we add or remove a pointer we reset the start positions
			// this handles cases where single touch would change the start position
			// and handles removing of one of the active pairs of pointers
			// to be replaced with another current pointer
			obj.zimTouch.pair = [];
			zim.loop(obj.zimTouch.pointers, function(id, pointer, i) {
				pointer.startX = pointer.x;
				pointer.startY = pointer.y;
				// just record the first two pointers
				// keep looping as mov uses all pointers
				if (i <= 1) obj.zimTouch.pair.push(pointer);
			});
			// record the start position, scale and rotation
			obj.zimTouch.startX = obj.x;
			obj.zimTouch.startY = obj.y;
			obj.zimTouch.startSX = obj.scaleX;
			obj.zimTouch.startSY = obj.scaleY;
			obj.zimTouch.startR = obj.rotation;
		}
		
		function remakeBoundary() {
			var p = obj.localToGlobal(obj.regX, obj.regY);
			var b;
			if (circularBounds) {
				// assuming cropped if Bitmap and width==height
				var leftTop = obj.parent.localToGlobal(obj.x-obj.width/2, obj.y-obj.height/2);
				var botRight = obj.parent.localToGlobal(obj.x+obj.width/2, obj.y+obj.height/2);
				b = {
					x:leftTop.x,
					y:leftTop.y,
					width:botRight.x-leftTop.x,
					height:botRight.y-leftTop.y
				};
			} else {
				b = obj.boundsToGlobal();
			}
			var r = {
				x:obj.zimTouch.boundaryStartX+p.x-b.x,
				y:obj.zimTouch.boundaryStartY+p.y-b.y,
				width:obj.zimTouch.boundaryStartW-b.width,
				height:obj.zimTouch.boundaryStartH-b.height
			};
			obj.gestureBoundary(r, false); // do not update the original rect
		}
		
		return obj;
	};//-34.5

/*--
obj.noGesture = function(move, scale, rotate)

noGesture
zim DisplayObject method

DESCRIPTION
Removes multi-touch pan, pinch and rotation gestures from an object.
If all three are removed then deletes the zimTouch object and touch events from obj

EXAMPLE
rect.noGesture(); // removes all gestures
// or
rect.noGesture(true, true, false); // would leave rotation
// or with ZIM DUO
rect.noGesture({rotation:false}); // would leave rotation
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
move - (default true) - set to false not to remove move gesture
scale - (default true) - set to false not to remove scale gesture
rotate - (default true) - set to false not to remove rotate gesture

RETURNS obj for chaining
--*///+34.6
	zim.noGesture = function(obj, move, scale, rotate) {
		var sig = "obj, move, scale, rotate";
		var duo; if (duo = zob(zim.noGesture, arguments, sig)) return duo;
		z_d("34.6");

		if (zot(obj) || !obj.on || !obj.zimTouch) return;
		if (zot(move)) move = true;
		if (zot(scale)) scale = true;
		if (zot(rotate)) rotate = true;
		obj.zimTouch.move = !move;
		obj.zimTouch.scale = !scale;
		obj.zimTouch.rotate = !rotate;
		if (!obj.zimTouch.move && !obj.zimTouch.scale && !obj.zimTouch.rotate) {
			obj.off("mousedown", obj.zimTouch.mousedown);
			obj.off("pressmove", obj.zimTouch.pressmove);
			obj.off("pressup", obj.zimTouch.pressup);
			delete obj.zimTouch;
		}

		return obj;
	};//-34.6

/*--
obj.gestureBoundary = function(boundary, new)

gestureBoundary
zim DisplayObject method

DESCRIPTION
Dynamically changes or adds a boundary rectangle to the object being dragged with gesture().

EXAMPLE
const boundary = new Boundary(100,100,500,400); // x,y,w,h
circle.gestureBoundary(boundary);
END EXAMPLE

PARAMETERS
boundary - is a ZIM Boundary rectangle - the local / global does not change from the original gesture setting
update - (default true) reset base drag boundary

RETURNS obj for chaining
--*///+34.7
	zim.gestureBoundary = function(obj, boundary, update) {
		z_d("34.7");
		if (zot(obj) || !obj.on) return;
		if (zot(boundary) || !obj.zimTouch) return;
		if (obj.zimTouch.localBoundary && obj.parent) {
			obj.zimTouch.boundary = zim.boundsToGlobal(obj.parent, boundary);
		} else {
			obj.zimTouch.boundary = boundary;
		}
		if (zot(update)) update = true;
		if (update) {
			obj.zimTouch.boundaryStartX = boundary.x;
			obj.zimTouch.boundaryStartY = boundary.y;
			obj.zimTouch.boundaryStartW = boundary.width;
			obj.zimTouch.boundaryStartH = boundary.height;
		}
		var result = obj.zimTouch.checkBounds(obj.x, obj.y);
		obj.x = result.x;
		obj.y = result.y;
		return obj;
	};//-34.7
	
//
/*--
obj.effect = function(effect, x, y, width, height)

effect
zim DisplayObject method

DESCRIPTION
Adds an effect to a DisplayObject such as:
blur, glow, shadow, color and alpha mask effects.
Also see hue, saturation, brightness and contrast convenience effects 
that are available as properties directly on the DisplayObject.

SEE: https://zimjs.com/cat/effects.html

BATCHING
Effects are processor heavy.  Too many can slow down the application.
ZIM uses effect() to allow multiple effects to be added at once. 
These are then internally batched and updated with a single update
rather than making each effect a stand-alone method requiring individual updates.

EFFECTS PROPERTY
The effects added with effect() are stored on the object's effects property.
The effects themselves have properties that can be changed to change the effect.
If an effect is changed the updateEffects() method needs to be called.
ZIM does not do this automatically, allowing the changes to be batched with one call.
See updateEffects() - also see noEffect() to remove effects.

The effect properties and convenience effects can be animated and wiggled.
In this case, the effects will be automatically updated by ZIM.

CREATEJS FILTERS
ZIM Effects wrap the CreateJS filters array and cache/updateCache system. 
Using effect() will overwrite manual usage of CreateJS filters array. 
The ZIM Effects system remembers effects in the effects property 
and overwrites the filters array each time an effect is added or updated.
To update an effect, all the effects need to be re-applied regardless
and all this is automatically handled by ZIM.

EFFECT OBJECTS
The following Effect objects can be passed into effect()
These all have parameters that accept ZIM DUO, VEE and OCT. 
See the Doc entries under Controls > Effects.
	new BlurEffect() - apply blur
	new GlowEffect() - apply glow and knock out - thanks kudox.jp 
	new ShadowEffect() - apply drop shadows and knock out - thanks kudox.jp
	new ColorEffect() - change colors
	new MultiEffect() - combination of hue, saturation, brightness, and contrast
	new AlphaEffect() - apply alpha mask
	
EFFECT IDS
The effects are referred to by id and have ids as follows (case insensitve):
	blur, glow, shadow, color, multi, alpha
The id is the property name used to identify the effect
in the object's effects property (plural s):
	obj.effects.glow.strength = 20; // using the glow id
	obj.updateEffects(); // this must be called to see the change
Effect ids are used when animating (and wiggling):
	props:{"effects.blur.blurX":200} // no update is needed
To remove effects use noEffect (singular) and use the id as follows:
	obj.noEffect(); // remove all effects (except convenience effects - see below)
	obj.noEffect("glow"); // remove the glow effect
	obj.noEffect(["glow", "color"]); // remove glow and color effects

CONVENIENCE EFFECTS
hue, saturation, brightness, contrast can be used directly on the object
	obj.hue = 100; // no need to updateEffects()
	// or
	obj.hueBatch = 100; // will set the effect 
	obj.updateEffects(); // but updateEffects must be called to see the change
Convenience effects can also be accessed through the multi id:
	obj.effects.multi.hue = 100;
Any of the four properties can be removed by setting them to 0 
	obj.hue = 0;  
Convenience effects can also ALL be removed together with:
	obj.noEffect("multi");
The following will NOT remove the convenience effects:
	obj.noEffect(); // will not remove hue, saturation, brightness and contrast
	
NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: when applying effects to rtl fonts make sure the DIR = "rtl" is set.
	
EXAMPLE
// create a Label with a GlowEffect that shows through to the image below
new Pic("background.jpg").center();
new Label("WOW", 200, "impact")
	.center()
	.effect(new GlowEffect({
		color:red,
		blurX:50,
		blurY:50,
		strength:2,
		quality:2,
		knockout:true
	}));
END EXAMPLE	

EXAMPLE
// add a glow and shadow effect
// remove only the glow when pressed
const circle = new Circle(100,blue)
	.center()	
	.effect([ // apply two effects in an array		
		new GlowEffect({color:purple, blurX:100, inner:true}),		
		new ShadowEffect(20) // 20 is distance
	]); 
circle.on("mousedown", ()=>{	
	// specify type of effect to remove - otherwise removes all
	circle.noEffect("glow"); 
	S.update();
});
END EXAMPLE

EXAMPLE
// add a 200 blurX effect and animate it to 0 rewind and looping
STYLE = {blurX:200} // just showing using style...
new Pic("image.png") // preloaded asset
	.center()
	.effect(new BlurEffect())
	.animate({
		// the blur effect is stored on the effects property of the object 
		// and available through the effect id (blur)
		// we are animating the blurX of that 
		// note the quotes around the DOT property format
		props:{"effects.blur.blurX":0},
		time:.7,
		rewind:true,
		rewindWait:.5,
		loop:true
	});
END EXAMPLE
	 
EXAMPLE 
// wiggle the saturation of an image asset stored in pic
// so its saturation goes from 50-100 negative or positive in 1-3 seconds
// here we use a convenience effect (hue, saturation, brightness, contrast)
pic.wiggle("saturation", 0, 50, 100, 1, 3);

// This is the same as the following (so may as well use above)
pic.effect(new MultiEffect()).wiggle("effects.multi.saturation", 0, 50, 100, 1, 3);
END EXAMPLE

PARAMETERS 
effect - (default null) a ZIM Effect object as detailed above
	or an array of ZIM Effect objects.
	Effects of a specific type are not compounded. 
	For example, adding two blur effects will just use the last blur effect added.
x - (default null) the x position of the cache bounds - will cache object bounds by default
y - (default null) the y position of the cache bounds - will cache object bounds by default
width - (default null) the width of the cache bounds - will cache object bounds by default 
height - (default null) the height of the cache bounds - will cache object bounds by default 

RETURNS obj for chaining
--*///+33.16
	zim.effect = function(obj, effect, x, y, width, height) {
		z_d("33.16");				
		if (zot(effect)) return obj;		
		
		if (zot(obj.effects)) obj.effects = {};
        if (!Array.isArray(effect)) effect = [effect];   
        var customCount = 0;     
        for (var j=0; j<effect.length; j++) {
            var eff = effect[j];
			if (!eff.type) {
				if (eff instanceof createjs.BlurFilter) eff.type = "BlurEffect";
				else if (eff instanceof createjs.ColorFilter) eff.type = "ColorEffect";
				else if (eff instanceof createjs.AlphaMaskFilter) eff.type = "AlphaEffect";
				else if (eff instanceof createjs.ColorMatrixFilter) eff.type = "MultiEffect";		
				else if (zot(eff.type)) eff.type = "custom"+customCount++;
			}
			var e = eff.type.replace(/effect/i, "");
            obj.effects[e.toLowerCase()] = eff;
        }
        obj.filters = [];
        for (var i in obj.effects) {
            obj.filters.push(obj.effects[i]);
        } 
		
        obj.cache(x,y,width,height,null,{adjustBounds:true},null,(WW.DIR && WW.DIR=="rtl")); 
		return obj;
	};//-33.16
	
/*--
obj.updateEffects = function(redoChache)

updateEffects
zim DisplayObject method

DESCRIPTION
Updates an effect when its property or the object's internals are changed.
For example a Sprite changes frame.  Not needed for position, alpha, scale or rotation. 
This basically updates the cache on the object so the effects are applied.

Note: setting hue, saturation, brightness and contrast directly on the object will update automatically.
These can be batched by using hueBatch, saturationBatch, etc. which will change but not update 
until an obj.updateEffects() is called.

EXAMPLE
// make an object more blurry in x each time it is pressed
const rect = new Rectangle(200,200,red)
	.center()
	.effect(new BlurEffect(10, 0)); // set to 0 in y otherwise it would take default blurY
rect.on("mousedown", ()=>{
	rect.effects.blur.blurX += 20;
	rect.updateEffects();
	S.update();
});
END EXAMPLE

PARAMETERS 
redoCache - (default false) set to true to remake the cache the size of the bounds of the object 
	if some other size is desired, use obj.cache(width, height) or obj.cache(x,y,width,height) instead of updateEffects()

RETURNS obj for chaining
--*///+33.163
	zim.updateEffects = function(obj, redoChache) {
		z_d("33.163");
		if (obj.updateCache) {
			if (!redoChache) obj.updateCache();
			else obj.cache();
		}
		if (obj.effects && obj.effects.alpha && obj.effects.alpha.alphaMask.updateCache) {			
			obj.effects.alpha.alphaMask.updateCache();
		}
		return obj;
	};//-33.163

/*--
obj.noEffect = function(effects, cache)

noEffect
zim DisplayObject method

DESCRIPTION
Removes the effects or specified effects from an object.

EXAMPLE
// add a glow and shadow effect
// remove only the glow when pressed
const circle = new Circle(100,blue)
	.center()	
	.effect([ // apply two effects in an array		
		new GlowEffect({color:purple, blurX:100, inner:true}),		
		new ShadowEffect(20) // 20 is distance
	]); 
circle.on("mousedown", ()=>{	
	// specify type of effect to remove - otherwise removes all
	circle.noEffect("glow"); 
	S.update();
});
END EXAMPLE

PARAMETERS 
effects - (default null) will remove all effects applied with effect() unless 
 	an effect string or array of effect strings is provided 
	Effect strings are (case insensitive):
	"blur", "glow", "shadow", "multi", "alpha" 
	alternately, "Effect" can be added such as "BlurEffect"
	To remove hue, saturation, brightness and contrast set the object property to 0
	for instance obj.hue = 0;
	Or to remove all four then can explicitly use obj.noEffect("multi")
cache - (default false) will uncache object if all effects are gone 
 	set to true to leave object cached

RETURNS obj for chaining
--*///+33.165
	zim.noEffect = function(obj, effects, cache) {
		z_d("33.165");
		if (zot(cache)) cache = false;
		if (zot(effects)) {
			var storeMulti;
			if (obj.effects.multi) storeMulti = obj.effects.multi;
			obj.effects = {};		
			if (storeMulti) obj.effects.multi = storeMulti;	
		} else {
			if (!obj.effects) obj.effects = {};
			if (!Array.isArray(effects)) effects = [effects];   
				for (var j=0; j<effects.length; j++) {
				var e = effects[j].replace(/effect/i, "");
				delete obj.effects[e.toLowerCase()];
			}			
		}
		obj.filters = [];
		for (var i in obj.effects) {
			obj.filters.push(obj.effects[i]);
		} 
		if (cache || obj.filters.length > 0) {
			if (obj.updateCache) obj.updateCache();
		} else {
			if (obj.uncache) obj.uncache();
		}
		return obj;
	};//-33.165

/*--
obj.addPhysics = function(dynamic, contract, shape, friction, linear, angular, density, bounciness, maskBits, categoryBits, physics, restitution, sensor)

addPhysics
zim DisplayObject method

DESCRIPTION
Add Physics to a DisplayObject.  DisplayObject should be centerReg() on the stage (or in non-transformed Container at 0,0 on stage)
The Physics world can be set up with the ZIM Physics() class in the Controls module.
Box2D and ZIM physics JavaScript helper module need to be imported.
If no physics world has been created, the addPhysics() method will create a default world.
The default world will have a borders around the stage and gravity of 10.
See: https://zimjs.com/physics/

NOTE: Adding physics also adds more methods and properties to the DisplayObject
See the Physics() docs for all the details

EXAMPLE
new Circle().center().addPhysics(); // circle will fall with gravity to the floor
END EXAMPLE

EXAMPLE
// create a world with no gravity (viewed from top like air-hockey)
const physics = new Physics(0);

// create physics objects using the addPhysics() method
const circle = new Circle(50,blue,grey).center().addPhysics({bounciness:1.1});

// make sure to reg(CENTER) or centerReg() any rectangular objects
const rect = new Rectangle(30,400).reg(CENTER).pos(70,0,LEFT,CENTER).addPhysics(false); // static - do not move
const tri = new Triangle(150,150,150,green,grey).pos(200,0,LEFT,CENTER).addPhysics({linear:10}); // does not slide easily

// turn on dragging
physics.drag(); // note: to add a boundary use the borders parameter of Physics()
END EXAMPLE

PARAMETERS
dynamic - (default true) - set to false to not move the physics body (static)
contract - (default 0) - make the physics body smaller (or bigger with negative) than bounds
shape - (default object shape) - "rectangle" for any object other than Circle, Dial and Triangle
 	but can specify a "circle" for a Sprite or Bitmap, for instance - to try and match shape
	custom polygon bodies can also be made with manual Box2D and then use physics.addMap()
	but the only shapes available automatically are "rectangle", "circle", "triangle"
friction - (default .8) - how sticky will the body act - set to 0 to slide.
linear - (default .5) - linear damping which slows the movement - set to 0 for no damping
angular - (default .5) - angular damping which slows the rotation - set to 0 for no damping
density - (default 1) - the density that can affect what happens with collisions
bounciness - (default 0) - how bouncy the object is - 0 is not bouncy 4 is crazy bouncy (was restitution)
maskBits - (default null) - used with categoryBits to determine which bodies will collide with which other bodies
	as soon as maskBits is specified, the body will collide only with the categoryBits provided to the maskBits parameter
	1 will collide with bodies that do not have categoryBits specified including the borders
	to test collision with bodies that have categoryBits specified, use the pipe (|) as follows:
	1|2 will also collide with bodies having categoryBits of 2 specified
	so if another body has categoryBits of 4 then the bodies would not collide.
	1|2|4 would also collide with 4 but not bodies with categoryBits of 8, etc.
	2|4 would pass through any bodies without categoryBits of 2 or 4 including the borders
categoryBits - (default 1) - a collision category - by default, bodies are in category 1
	use with maskBits to say which bodies will collide with which other bodies
	the values are bit fields https://en.wikipedia.org/wiki/Bit_field so can have the following values:
	can be 2, 4, 8, 16, 32, 64, 128, 256, etc. up to 15 powers of 2
physics - (default zimDefaultPhysics)
restitution - (default bounciness) - replaced by bounciness - kept for backwards compatibility
sensor - (default false) - set to true to turn object into a sensor - will not interact but will report contact
	this is like a Box2D hitTest for non contacting object
	see also physics.contact()

RETURNS obj for chaining
--*///+34.8

	zim.addPhysics = function(obj, dynamic, contract, shape, friction, linear, angular, density, bounciness, maskBits, categoryBits, physics, restitution, sensor) {
		var sig = "obj, dynamic, contract, shape, friction, linear, angular, density, bounciness, maskBits, categoryBits, physics, restitution, sensor";
		var duo; if (duo = zob(zim.addPhysics, arguments, sig)) return duo;
		z_d("34.8");

		if (zot(physics)) {
			if (typeof(zimPhysics) == "undefined") {if (zon) {zogy("ZIM Physics module must be imported");} return obj;}
			if (zot(WW.zimDefaultPhysics)) WW.zimDefaultPhysics = new zim.Physics();
			physics = WW.zimDefaultPhysics;
		}
		obj.physics = physics;
		var defaultShape = "rectangle";
		if (obj.type == "Circle" || obj.type == "Dial") defaultShape = "circle";
		else if (obj.type == "Triangle") defaultShape = "triangle";
		else if (obj.type == "Blob") defaultShape = "poly";
		if (zot(shape)) shape = defaultShape;
		if (zot(bounciness)) bounciness = restitution;
		setPhysics(obj, dynamic, contract, shape, friction, linear, angular, density, bounciness, maskBits, categoryBits, sensor);

		return obj;
	};//-34.8

/*--
obj.removePhysics = function()

removePhysics
zim DisplayObject method

DESCRIPTION
Remove Physics from a DisplayObject.
This removes various methods and properties that addPhysics() added
The object can be added back to the physics world with addPhysics()

EXAMPLE
obj.removePhysics(); // ;-)
END EXAMPLE

RETURNS obj for chaining
--*///+34.85
	zim.removePhysics = function(obj) {
		z_d("34.85");
		if (zot(obj.physics)) return obj;
		if (obj == obj.physics.followObj) obj.physics.follow(null);
		obj.follow = obj.noFollow = obj.control = obj.noControl = obj.sleep = obj.wake = null;
		obj.impulse = obj.force = obj.spin = obj.torque = null;
		obj.physics.remove(obj.body);
		obj.physics = null;
		return obj;
	};//-34.85

// SUBSECTION HIT TESTS

/*--
obj.hitTestPoint = function(x, y, boundsCheck)

hitTestPoint
zim DisplayObject method

DESCRIPTION
See if shape of obj is hitting the global point x and y on the stage.

EXAMPLE
const circle = new Circle().loc(100,100).drag();
circle.on("pressmove", ()=>{
	if (circle.hitTestPoint(W/2, H/2)) {
		if (circle.alpha == 1) {
			circle.alpha = .5;
			S.update();
		}
	} else {
		if (circle.alpha == .5) {
			circle.alpha = 1;
			S.update();
		}
	}
});
END EXAMPLE

PARAMETERS
x and y - the point we are testing to see if it hits the shape of the object
boundsCheck (default true) do a bounds check first (faster) but if bounds are wrong - might not work

RETURNS a Boolean true if hitting, false if not
--*///+35
	zim.hitTestPoint = function(obj, x, y, boundsCheck) {
		if (!zim.zimhtp) {z_d("35"); zim.zimhtp=true;}
		if (!obj.stage || zot(x) || zot(y)) return false;
		if (zot(obj) || !obj.globalToLocal) return;
		if (zot(boundsCheck)) boundsCheck = true;
		if (boundsCheck) {
			var bounds = obj.getBounds();
			if (bounds) { // faster to check if point is in bounds first
				var boundPoint = obj.globalToLocal(x,y);
				if (boundPoint.x > bounds.x + bounds.width || boundPoint.x < bounds.x) return false;
				if (boundPoint.y > bounds.y + bounds.height || boundPoint.y < bounds.y) return false;
			}
		}
		var point = {x:x, y:y};
		if (obj.image || obj.spriteSheet || obj.type == "Shape") point = obj.globalToLocal(point.x, point.y);
		else point = obj.globalToLocal(point.x*zim.scaX,point.y*zim.scaY);
		return obj.hitTest(point.x, point.y);
	};//-35

/*--
obj.hitTestReg = function(other, boundsCheck)

hitTestReg
zim DisplayObject method

DESCRIPTION
See if the shape shape of an object is hitting the registration point of object (other).

EXAMPLE
const circle = new Circle(50, red).center().drag();
const rect = new Rectangle(100, 100, blue).loc(100,100);
circle.on("pressmove", ()=>{
	if (circle.hitTestReg(rect)) {
		S.removeChild(rect);
		S.update();
	}
})
END EXAMPLE

PARAMETERS
other - the object whose registration point we are checking against
boundsCheck (default true) do a bounds check first (faster) but if bounds are wrong - might not work

RETURNS a Boolean true if hitting, false if not
--*///+36
	zim.hitTestReg = function(a, b, boundsCheck) {
		if (!zim.zimhtr) {z_d("36"); zim.zimhtr=true;}
		if (!a.stage || !b.stage) return false;
		if (zot(a) || zot(b) || !a.localToLocal || !b.localToLocal) return;
		if (zot(boundsCheck)) boundsCheck = true;

		var point = b.localToGlobal(b.regX,b.regY);
		var bounds = a.getBounds();
		if (boundsCheck && bounds) { // faster to check if point is in bounds first
			// note, bounds get pre-scaled x and y - only hitTest() needs scaled
			var boundPoint = a.globalToLocal(point.x,point.y);
			if (boundPoint.x > bounds.x + bounds.width || boundPoint.x < bounds.x) return false;
			if (boundPoint.y > bounds.y + bounds.height || boundPoint.y < bounds.y) return false;
		}
		if (a.image || a.spriteSheet || a.type == "Shape") point = a.globalToLocal(point.x, point.y);
		else point = a.globalToLocal(point.x*zim.scaX,point.y*zim.scaY);
		return a.hitTest(point.x, point.y);
	};//-36

/*--
obj.hitTestRect = function(other, num, boundsCheck, inside)

hitTestRect
zim DisplayObject method

DESCRIPTION
See if a shape of an object is hitting points on a rectangle of another object.
The rectangle is based on the position, registration and bounds of object (other).
num is how many points on the edge of the rectangle we test - default is 0.
The four corners are always tested as well as the very middle of the rectangle.

EXAMPLE
const circle = new Circle(50, red).center().drag();
const rect = new Rectangle(100, 100, blue).loc(100,100);
circle.on("pressmove", ()=>{
	if (circle.hitTestRect(rect)) {
		S.removeChild(rect);
		S.update();
	}
});
END EXAMPLE

PARAMETERS
other - the object whose bounding rectangle we are checking against
num - (default 0) the number of points along each edge to check
	1 would put a point at the middle of each edge
	2 would put two points at 1/3 and 2/3 along the edge, etc.
	there are always points at the corners
	and one point in the middle of the rectangle
boundsCheck (default true) do a bounds check first (faster) but if bounds are wrong - might not work
inside (default false) check if other object is completely inside shape

RETURNS a Boolean true if hitting, false if not
--*///+37
	zim.hitTestRect = function(a, b, num, boundsCheck, inside) {
		if (!zim.zimhtr) {z_d("37"); zim.zimhtr=true;}
		if (!a.stage || !b.stage) return false;
		if (zot(a) || zot(b) || !a.hitTest || !b.getBounds) return;
		if (zot(num)) num = 0;
		if (zot(boundsCheck)) boundsCheck = true;
		var bounds = b.getBounds();
		if (!bounds) {
			if (zon) zogy("hitTestRect():\n please setBounds() on param b object");
			return;
		}
		if (boundsCheck) {
			var bounds2 = a.getBounds();
			if (bounds2 && !zim.hitTestBounds(a,b)) return false; // bounds not hitting
		}
		function test(point) {
			if (a.image || a.spriteSheet || a.type == "Shape") point = a.globalToLocal(point.x, point.y);
			else point = a.globalToLocal(point.x*zim.scaX,point.y*zim.scaY);
			if (a.hitTest(point.x, point.y)) return true;
		}
		var centerX = bounds.x+bounds.width/2;
		var centerY = bounds.y+bounds.height/2;
		var point = b.localToGlobal(centerX, centerY);		

		var shiftX, shiftY;
		//num = 0;  1/1
		//num = 1;  1/2  2/2
		//num = 2;  1/3  2/3  3/3
		//num = 3;  1/4  2/4  3/4  4/4

		if (inside) {
			if (!test(point)) return false;
			for (var i=0; i<=num; i++) {
				shiftX = bounds.width  * (i+1)/(num+1);
				shiftY = bounds.height * (i+1)/(num+1);
				point = b.localToGlobal(bounds.x+shiftX, bounds.y);
				if (!test(point)) return false;
				point = b.localToGlobal(bounds.x+bounds.width, bounds.y+shiftY);
				if (!test(point)) return false;
				point = b.localToGlobal(bounds.x+bounds.width-shiftX, bounds.y+bounds.height);
				if (!test(point)) return false;
				point = b.localToGlobal(bounds.x, bounds.y+bounds.height-shiftY);
				if (!test(point)) return false;
			}
			return true;
		} else {
			if (test(point)) return true; // check hit on center of Rectangle
			for (var i=0; i<=num; i++) {
				shiftX = bounds.width  * (i+1)/(num+1);
				shiftY = bounds.height * (i+1)/(num+1);
				point = b.localToGlobal(bounds.x+shiftX, bounds.y);
				if (test(point)) return true;
				point = b.localToGlobal(bounds.x+bounds.width, bounds.y+shiftY);
				if (test(point)) return true;
				point = b.localToGlobal(bounds.x+bounds.width-shiftX, bounds.y+bounds.height);
				if (test(point)) return true;
				point = b.localToGlobal(bounds.x, bounds.y+bounds.height-shiftY);
				if (test(point)) return true;
			}
		}		
	};//-37

/*--
obj.hitTestCircle = function(other, num, boundsCheck, inside)

hitTestCircle
zim DisplayObject method

DESCRIPTION
See if the shape of an object is hitting points on a circle of another object.
The circle is based on the position, registration and bounds of object (other).
num is how many points around the circle we test - default is 8
Also checks center of circle hitting.

EXAMPLE
var circle = new Circle(50, red).center().drag();
var triangle = new Triangle(100, 100, 100, blue).loc(100,100);
circle.on("pressmove", function() {
	if (triangle.hitTestCircle(circle)) {
		S.removeChild(triangle);
		S.update();
	}
});
END EXAMPLE

PARAMETERS
other - the object whose circle based on the bounding rect we are using
num - (default 8) the number of points evenly distributed around the circle
	and one point in the middle of the circle
boundsCheck (default true) do a bounds check first (faster) but if bounds are wrong - might not work
inside (default false) check if other object is completely inside shape

RETURNS a Boolean true if hitting, false if not
--*///+38
	zim.hitTestCircle = function(a, b, num, boundsCheck, inside) {
		if (!zim.zimhtc) {z_d("38"); zim.zimhtr=true;}
		z_d("38");
		if (!a.stage || !b.stage) return;
		if (zot(a) || zot(b) || !a.hitTest || !b.getBounds) return;
		if (zot(num)) num = 8;
		if (zot(boundsCheck)) boundsCheck = true;
		var bounds = b.getBounds();
		if (!bounds) {
			if (zon) zogy("hitTestCircle():\n please setBounds() on param b object");
			return;
		}
		var bounds2 = a.getBounds();
		if (boundsCheck && bounds2 && !zim.hitTestBounds(a,b)) return false; // bounds not hitting
		function test(point) {
			if (a.image || a.spriteSheet || a.type == "Shape") point = a.globalToLocal(point.x, point.y);
			else point = a.globalToLocal(point.x*zim.scaX,point.y*zim.scaY);
			if (a.hitTest(point.x, point.y)) return true;
		}
		var centerX = bounds.x+bounds.width/2;
		var centerY = bounds.y+bounds.height/2;
		var point = b.localToGlobal(centerX, centerY);		
		var radius = (bounds.width+bounds.height)/2/2; // average diameter / 2
		var angle, pointX, pointY;
		if (inside) {
			if (!test(point)) return false; 
			for (var i=0; i<num; i++) {
				angle = i/num * 2*Math.PI; // radians
				pointX = centerX + (radius * Math.cos(angle));
				pointY = centerY + (radius * Math.sin(angle));
				point = b.localToGlobal(pointX, pointY);
				if (!test(point)) return false;
			}
			return true;
		} else {
			if (test(point)) return true; // check hit on center of circle
			for (var i=0; i<num; i++) {
				angle = i/num * 2*Math.PI; // radians
				pointX = centerX + (radius * Math.cos(angle));
				pointY = centerY + (radius * Math.sin(angle));
				point = b.localToGlobal(pointX, pointY);
				if (test(point)) return true;
			}
		}		
		return false;

	};//-38

/*--
obj.hitTestCircleRect = function(other, margin)

hitTestCircleRect
zim DisplayObject method

DESCRIPTION
Uses an equation to see if a circlular object is hitting the rectangle of another object.
DO NOT use with a rotated rectangle object - for that use hitTestRect() or hitTestCircle().
This is faster than hitTests on shapes - so will have the speed of hitTestBounds, hitTestCircles and hitTestGrid.
The circle is based on a the object radius if there is one
and if no radius then the average of the width and height divided by two.
A margin parameter is provided to tweak the hitTest
The rect is based on the bounds of the second object projected globally as a rectangle
If the second object bounds are rotated, the global bounds will be bigger to keep parallel to the axes

EXAMPLE
const ball = new Circle(50, red).center().drag();
const box = new Rectangle(100, 100, blue).loc(100,100);
ball.on("pressmove", ()=>{
	if (ball.hitTestCircleRect(box)) {
		zog("points!");
	}
});
END EXAMPLE

PARAMETERS
other - the object whose bounds are used to see if circle shape is hitting
margin (default 0) pixels the distance between the circle and the bounds is increased or decreased to effect the hit

RETURNS a Boolean true if hitting, false if not
--*///+38.2
	zim.hitTestCircleRect = function(a, b, margin) {
		if (!zim.zimhtcr) {z_d("38.2"); zim.zimhtcr=true;}
		if (!a.stage || !b.stage) return;
		var stage = a.stage;
		if (zot(a) || zot(b) || !a.getBounds || !b.getBounds) return;
		var aBounds = a.getBounds();
		var bBounds = b.getBounds();
		if (!aBounds || !bBounds) {
			if (zon) zogy("hitTestCircleRect():\n please setBounds() on both objects");
			return;
		}
		if (zot(margin)) margin = 0;
		
		var radius = (a.radius?a.radius:(aBounds.width+aBounds.height)/2)+margin;
		var sX = a.getConcatenatedMatrix().decompose().scaleX;
		radius *= sX/stage.scaleX;
		
		var rect = b.boundsToGlobal();
        var point = a.localToGlobal(0,0);
		var cx = point.x;
		var cy = point.y;
		var left = rect.x;
		var top = rect.y;
		var right = rect.x+rect.width;
		var bottom = rect.y+rect.height;

		var closestX = (cx < left ? left : (cx > right ? right : cx));
		var closestY = (cy < top ? top : (cy > bottom ? bottom : cy));
		var dx = closestX - cx;
		var dy = closestY - cy;
		return ( dx * dx + dy * dy ) <= radius * radius;

	};//-38.2

/*--
obj.hitTestCircles = function(other, margin)

hitTestCircles
zim DisplayObject method

DESCRIPTION
Uses an equation to see if two circles are intersecting.
This is faster than hitTests on shapes - so will have the speed of hitTestBounds and hitTestGrid.
The circles are based on the bounds of the two objects - it does not matter on which object the method is placed.
If the bounds are not square then half the average length of the sides is used as the radius.
A margin parameter is provided to tweak the hitTest

EXAMPLE
const ball = new Circle(50, red).center().drag();
const basket = new Circle(100, blue).loc(100,100);
ball.on("pressmove", ()=>{
	if (ball.hitTestCircles(basket)) {
		zog("points!");
	}
});
END EXAMPLE

PARAMETERS
other - the object whose circle based on the bounding rect we are using
margin (default 0) pixels the distance between circles is increased or decreased to effect the hit

RETURNS a Boolean true if hitting, false if not
--*///+38.5
	zim.hitTestCircles = function(a, b, margin) {
		if (!zim.zimhtcs) {z_d("38.5"); zim.zimhtcs=true;}
		if (!a.stage || !b.stage) return;
		var stage = a.stage;
		if (zot(a) || zot(b) || !a.hitTest || !a.getBounds || !b.getBounds) return;
		var aBounds = a.getBounds();
		var bBounds = b.getBounds();
		if (!aBounds || !bBounds) {
			if (zon) zogy("hitTestCircles():\n please setBounds() on both objects");
			return;
		}
		if (zot(margin)) margin = 0;
		var p1 = a.localToGlobal(aBounds.x + aBounds.width/2, aBounds.y + aBounds.height/2);
		var p2 = b.localToGlobal(bBounds.x + bBounds.width/2, bBounds.y + bBounds.height/2);
		var m1 = a.getConcatenatedMatrix();
		var m2 = b.getConcatenatedMatrix();
		// getConcatenatedMatrix still seems to need scale adjust
		var scale1X = Math.sqrt((m1.a/stage.scaleX * m1.a/stage.scaleX) + (m1.c/stage.scaleX * m1.c/stage.scaleX));
		var scale1Y = Math.sqrt((m1.b/stage.scaleY * m1.b/stage.scaleY) + (m1.d/stage.scaleY * m1.d/stage.scaleY));
		var scale2X = Math.sqrt((m2.a/stage.scaleX * m2.a/stage.scaleX) + (m2.c/stage.scaleX * m2.c/stage.scaleX));
		var scale2Y = Math.sqrt((m2.b/stage.scaleY * m2.b/stage.scaleY) + (m2.d/stage.scaleY * m2.d/stage.scaleY));
		var d = Math.sqrt(Math.abs(Math.pow(p1.x-p2.x, 2)+Math.pow(p1.y-p2.y, 2)));

		if (aBounds.width*Math.max(scale1X, scale1Y)/2 + bBounds.width*Math.max(scale2X, scale2Y)/2 >= d-margin) return true;
		else return false;

	};//-38.5

/*--
obj.hitTestBounds = function(other, margin, boundsShape)

hitTestBounds
zim DisplayObject method

DESCRIPTION
See if obj.getBounds() is hitting other.getBounds().
Margin can be adjusted to tweak the hitTest.
Pass in a boundsShape shape if you want a demonstration of where the bounds are.

EXAMPLE
const circle = new Circle(50, red).center().drag();
const rect = new Rectangle(100, 100, blue).loc(100,100);
circle.on("pressmove", ()=>{
	if (circle.hitTestBounds(rect)) {
		S.removeChild(rect);
		S.update();
	}
});
END EXAMPLE

PARAMETERS
other - another object whose rectanglular bounds we are testing
margin (default 0) shifted distance in pixels before hit is counted - can be positive or negative
boundsShape - (default null) an empty Shape or createjs.Shape
	you would need to add the boundsShape to the stage

RETURNS a Boolean true if hitting, false if not
--*///+39
	zim.hitTestBounds = function(a, b, margin, boundsShape) {
		if (!zim.zimhtb) {z_d("39"); zim.zimhtb=true;}
		if (!a.stage || !b.stage) return;
		if (zot(a) || zot(b) || !a.getBounds || !b.getBounds) return;
		var boundsCheck = false;
		if (boundsShape && boundsShape.graphics) boundsCheck=true;

		var aB = a.getBounds();
		var bB = b.getBounds();
		if (!aB || !bB) {
			if (zon) zogy("hitTestBounds():\n please setBounds() on both objects");
			return;
		}
		if (zot(margin)) margin = 0;
		var adjustedA = zim.boundsToGlobal(a);
		var adjustedB = zim.boundsToGlobal(b);

		if (boundsCheck) {
			var g = boundsShape.graphics;
			g.c();
			g.ss(1).s("blue");
			g.r(adjustedA.x, adjustedA.y, adjustedA.width, adjustedA.height);
			g.s("green");
			g.r(adjustedB.x, adjustedB.y, adjustedB.width, adjustedB.height);
			boundsShape.stage.update();
		}
		return zim.rectIntersect(adjustedA, adjustedB, margin);

	};//-39

/*--
obj.hitTestPath = function(other, num, showPoints, returnPoints)

hitTestPath
zim DisplayObject method

DESCRIPTION
See if the shape of an object is hitting points on a path of a Squiggle or Blob.
num is how many points between each point on the path we test - default is 2
SEE: https://zimjs.com/hittestpath.html

EXAMPLE
const path = new Blob().center();
const circle = new Circle(50, purple).pos(100,100).drag();
circle.on("pressmove", ()=>{
	if (circle.hitTestPath(path, 3, true)) {
		circle.alpha -= .02;
		S.update();
	}
});
END EXAMPLE

PARAMETERS
other - the path (Squiggle or Blob) to test to see if the object shape is hitting
num - (default 2) the number of points added to the path roughly between each point
	this gets totalled - so num*numPoints and then distributed along the path
showPoints (default false) will draw small circles along the path where the hits will be tested
returnPoints (default false) set to true to return an array of {x,y} points that are hitting (or false)
returnPercent (default false) set to true to return a percent along the path the first hit occurs - unless overridden by returnPoints

RETURNS a Boolean true if hitting (or an array of {x,y} points if returnPoints is true), false if not
--*///+37.5
	zim.hitTestPath = function(a, b, num, showPoints, returnPoints, returnPercent) {
		if (!zim.zimhtpa) {z_d("37.5"); zim.zimhtpa=true;}
		if (!a.stage || !b.stage) return;
		if (zot(a) || zot(b) || !a.hitTest) return;
		if (b.type != "Squiggle" && b.type != "Blob") return;
		var aB = a.getBounds();
		if (zot(num)) num = 2;
		if (zot(showPoints)) showPoints = false;
		if (zot(returnPoints)) returnPoints = false;
		if (zot(returnPercent)) returnPercent = false;

		var pointsHitting = [];
		var percentHitting;
		function test(point) {
			var p;
			if (a.image || a.spriteSheet || a.type == "Shape") p = a.globalToLocal(point.x, point.y);
			else p = a.globalToLocal(point.x*zim.scaX,point.y*zim.scaY);
			if (a.hitTest(p.x, p.y)) {
				if (returnPoints) pointsHitting.push({x:Math.round(point.x),y:Math.round(point.y)});
				else if (returnPercent) percentHitting = i/points.length*100; 
				else return true;				
			}
		}
		var points = b.interpolate(num, null, true, null, true);
		var i,point;
		if (showPoints) {
			if (!b.hitPathPoints) b.hitPathPoints = new zim.Container().addTo();
			else b.hitPathPoints.removeAllChildren();
			b.hitPathPoints.top();
			for (i=0; i<points.length; i++) {
				point = points[i];
				point = b.localToGlobal(point.x, point.y);
				new zim.Circle(3).loc(point.x, point.y, b.hitPathPoints);
			}
		}
		if (aB) {
			var bounds = zim.boundsAroundPoints(points);
			if (!zim.rectIntersect(a.boundsToGlobal(aB), b.boundsToGlobal(bounds))) return false;
		}

		for (i=0; i<points.length; i++) {
			point = points[i];
			point = b.localToGlobal(point.x, point.y);
			if (test(point)) return true;
			if (percentHitting!=null) return percentHitting;
		}
		if (pointsHitting.length > 0) return pointsHitting;
		return false;
	};//-37.5

/*--
obj.hitTestGrid = function(width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type)

hitTestGrid
zim DisplayObject method

DESCRIPTION
Converts an x and y point to an index in a grid.
If you have a grid of rectangles, for instance, use this to find out which rectangle is beneath the cursor.
This technique will work faster than any of the other hit tests.

EXAMPLE
const tile = new Tile(new Rectangle(100,100),5,4,10,10).center();
const circle = new Circle(10,green).pos(10,10).drag();
circle.on("pressmove", ()=>{
	var index = tile.hitTestGrid(tile.width, tile.height, 5, 4, circle.x, circle.y,0,0,10,10);
	zog(index);
});
END EXAMPLE

PARAMETERS
width and height - the overall dimensions
cols and rows - how many of each (note it is cols and then rows)
x and y - where you are in the grid (eg. e.stageX and e.stageY)
offsetX and offsetY - (default 0) the distances the grid starts from the origin of the obj
spacingX and spacingY - (default 0) spacing between grid cells 
	null will be returned if x and y within spacing unless the type is set to "open"
	spacing is only between the cells and is to be included in the width and height (but not outside the grid)
local - (default false) set to true to convert x and y to local values
type - (default index) which means the hitTestGrid returns the index of the cell beneath the x and y point
	starting with 0 at top left corner and counting columns along the row and then to the next row, etc.
	set type to "col" to return the column and "row" to return the row
	set to "array" to return all three in an Array [index, col, row]
	set to "open" allow x and y to be in spacing and still return Array [index, col, row] 
		these will report depending on less than half the spacing or more than half the spacing between cells

RETURNS an index Number (or undefined) | col | row | an Array of [index, col, row]
--*///+41
	zim.hitTestGrid = function(obj, width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type) {
		if (!zim.zimhtg) {z_d("41"); zim.zimhtg=true;}
		if (!obj.stage) return false;
		if (!zot(obj) && !local) {
			var point = obj.globalToLocal(x,y);
			x=point.x; y=point.y;
		}
		if (zot(offsetX)) offsetX = 0;
		if (zot(offsetY)) offsetY = 0;
		if (zot(spacingX)) spacingX = 0;
		if (zot(spacingY)) spacingY = 0;

		width += spacingX;
		height += spacingY;
		
		// assume spacing is to the right and bottom of a cell
		// turning this into an object would avoid the size calculations
		// but hopefully it will not be noticed - and then hitTests are all functions
		var sizeX = width / (cols);
		var sizeY = height / (rows);
		
		// calculate col and row
		// var col = Math.min(cols-1,Math.max(0,Math.floor((x-offsetX)/sizeX)));
		// var row = Math.min(rows-1,Math.max(0,Math.floor((y-offsetY)/sizeY)));
		// fixed in ZIM Cat 03
		var col = Math.min(cols-1,Math.max(0,Math.floor((x-offsetX+spacingX/2)/sizeX)));
		var row = Math.min(rows-1,Math.max(0,Math.floor((y-offsetY+spacingY/2)/sizeY)));

		// check if within cell
		if (type != "open") {
			if ((x-offsetX)>sizeX*(col+1)-spacingX || (x-offsetX)<sizeX*(col)) return;
			if ((y-offsetY)>sizeY*(row+1)-spacingY || (y-offsetY)<sizeY*(row)) return;
		}
		
		var index = row*cols + col;

		if (zot(type) || type=="index") return index;
		if (type == "col") return col;
		if (type == "row") return row;
		if (type == "array" || type=="open") return [index, col, row];
	};//-41

// SUBSECTION ANIMATE, WIGGLE, LOOP

/*--
obj.animate = function(props, time, ease, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startCall, startParams, animateCall, animateParams, sequence, sequenceCall, sequenceParams, sequenceReverse, sequenceRatio, ticker, cjsProps, css, protect, override, from, set, id, events, sequenceTarget, dynamic, drag, clamp, startPaused, clean, obj, seriesWait, sequenceWait, rate, pauseOnBlur, easeAmount, easeFrequency, timeUnit, timeCheck, noAnimateCall, pathDamp)

animate
zim DisplayObject method
powered by createjs.Tween (TweenJS)

DESCRIPTION
Animate object properties in time (s).
You can set various types of easing like bounce, elastic, back, linear, sine, etc.
Handles callbacks, delays, loops, rewinds, relative, series and sequences of animations.
SEE: https://zimjs.com/animation

Shape Animation
ZIM animate() lets you animate one Squiggle to another or one Blob to another
See the props parameter under the convenience properties for shape and blobShift

Advanced Animation
ZIM animate() lets you animate along a path made with a zim Squiggle or Blob
These paths can be edited by the user and the animation will still work
The paths themselves can be animated or wiggled.
Orient and Flipping are available.
Dynamic speed can be set with percentSpeed and tied in to Accelerator and MotionController.
Scrubbing animation and path animation is also supported with percentComplete.
This can be used with a Slider, Dial, MotionController, Parallax or general coding.
Dragging along a path is as easy as setting the drag parameter to true.
This can be done with while animating or with the animation paused.
ZIM EXTRA! provides animation based on animation.
This allows for setting zoom, depth, speed, fade, etc. based on target y value while animating on a path
but EXTRA! also opens up endless possibilities as the input and output does not have to be the target.
This means that animation can also control properties of other objects.
SEE: https://zimjs.com/nio/

NOTE: to temporarily prevent animations from starting set ANIMATE to false
NOTE: see pauseAnimate(state, ids) and stopAnimate(ids) for controlling tweens when running
NOTE: set mouseEnabled of target before calling animate as animate itself sets mouseEnabled and then resets to original after a delay

EXAMPLE
const circle = new Circle(50, red)
	.center()
	.alp(0)
	.sca(0)
	.animate({alpha:1, scale:1}, .7, null, done);
	
function done(target) {
	// target is circle if params is not set
	target.drag();
}

// or with ZIM DUO and from parameter:
const circle = new Circle(50, red)
	.center()
	.animate({
		props:{alpha:0, scale:0}, 
		time:.7, 
		from:true
	});

// note: there was no need to set alpha and scale to 0 before the animation
// because from will animate from property values in props {alpha:0, scale:0}
// to the present set values - which are 1 and 1 for the default scale and alpha.
// This allows you to place everything how you want it to end up
// and then easily animate to this state.
// An extra advantage of this is that you can use the ANIMATE constant to skip animations while building
// See the https://zimjs.com/ornamate.html example

// RELATIVE animation
// rotate the rectangle 360 degrees from its current rotation
rectangle.animate({rotation:"360"});

// pulse circle
var circle = new Circle(50, red)
	.center()
	// pulse circle from scale 0 - 1 every second (use ZIM DUO)
	.animate({
		props:{scale:0}, 
		time:.5, 
		loop:true, 
		rewind:true, 
		from:true
	});
// toggle pause the circle when stage is pressed
S.on("stagemousedown", function() {
	circle.pauseAnimate(!circle.paused);
});
END EXAMPLE

EXAMPLE
// using ZIM VEE value:
// this will animate the alpha to between .5 and 1 in either 1 second or 2 seconds
circle.animate({alpha:{min:.5, max:1}}, [1, 2]);
END EXAMPLE

EXAMPLE
// Dynamic Animation
const rect = new Rectangle(200,200,red)
	.centerReg()
	.animate({
		props:{rotation:360},
		loop:true,
		time:2,
		ease:"linear",
		dynamic:true,
		set:{percentSpeed:0} // no speed to start
	});

// example using a Slider to set speed from 0 to 5 times as fast
const slider = new Slider(0,500)
	.pos(100, 100)
	.change(()=>{
		rect.percentSpeed = slider.currentValue;
	});

// example using an Accelerator and MotionController
// to set speed from -200 to 200 percent
// depending on mouse position
// multiple targets including Dynamo and Scroller objects can be added to Accelerator
// if adding multiple objects, use an array new Accelerator([rect, otherObject, anotherObject])
new MotionController({
	target:new Accelerator(rect),
	type:"mousemove",
	minPercentSpeed:-200,
	maxPercentSpeed:200
});
END EXAMPLE

EXAMPLE
// Series example animating a circle in square formation
// Also showing that the series can include multiple targets
// Click on the stage to pause or unpause the animation

const rect = new Rectangle({color:pink})
	.centerReg()
	.sca(0); // hiding it to start

const circle = new Circle({color:purple}) // chaining the rest
	.addTo(stage)
	.pos(400,300)
	.animate({ // circle will be the default object for the inner animations
		props:[
			// an array of animate configuration objects
			{props:{x:600, y:300, scale:2}},
			{props:{x:600, y:500, scale:1}, call:function(){zog("part way");}},
			{props:{x:400, y:500}, time:.5, ease:"quadInOut"},
			{target:rect, props:{scale:3}, time:1, rewind:true, ease:"quadInOut"},
			{props:{x:400, y:300}}
		],
		time:1, // will be the default time for the inner animations
		ease:"backOut", // will be the default ease for the inner animations
		id:"square", // will override any id set in the inner animations
		loop:true,
		loopCount:3,
		// note - no rewind or from parameters
		call:() => {zog("done");}
	});

	var paused = false;
	S.on("stagemousedown", () => {
			paused = !paused;
			pauseAnimate(paused, "square");
	});
END EXAMPLE

EXAMPLE
// sequence example to pulse two circles
const circles = new Container(W, H).addTo(stage);
const circle1 = new Circle(50, red).center(circles);
const circle2 = new Circle(50, blue).center(circles).mov(70);
circles.animate({
	props:{scale:1},
	time:.5,
	loop:true,
	rewind:true,
	from:true,
	sequence:.5
});
END EXAMPLE

EXAMPLE
// animate() can animate any object property
// just use the animate function and pass in the object as the first parameter:

const obj = {age:10}
animate(obj, {age:20}, 1);
interval(.05, ()=>{
	zog(obj.age);
});

// or if you have a THREEJS mesh
// use quotes to animate a dot property:
animate(mesh, {"rotation.y":360*RAD}, 50);

// or CSS properties - see the CSS parameter for setup info
zss("tagID").opacity = 1; // set this even if it is default
animate(zid("tagID"), {opacity:0}, 2); // etc.
END EXAMPLE

EXAMPLE
// Animate along a Squiggle or Blob path
// see https://zimjs.com/nio/ examples
// see https://zimjs.com/explore/squiggleAnimate.html for more
// see https://zimjs.com/explore/blobAnimate.html for more
// see https://zimjs.com/explore/blobAnimate2.html for more
const line = new Squiggle().center();
new Circle(10, red).addTo().animate({path:line}, 1);
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function

props - the object literal holding properties and values to animate
	Basic examples: {x:200} or {rotation:360, alpha:0} or {scale:4} or {x:300, y:300, scale:"2"} (relative scale)
	There are custom options below including Convenience, ZIM VEE, Relative, and Series properties.
	** Before ZIM 7.1, this parameter was called obj - as to not conflict with CreateJS TweenJS props (now renamed cjsProps)
	   obj is still available as a parameter name for backwards compatibility when using a ZIM DUO configuration object
	CONVENIENCE PROPERTIES
		scale - for scaleX and scaleY
		color - on ZIM shapes for setColorRange() and animate colorRange from 0-1
	 		** this property cannot be run in a series - rather animate in a call function to accomplish a series of color changes
		note - animate from one note to another when animating a ZIM Synth tone()
			note ("A", "C2", "C#" or "Bf", etc.) is coverted to frequency
		shape - animate from one ZIM Squiggle to another or one ZIM Blob to another
			for now, the matching Sqiggle or Blob must have the same number of points
			to pause or stop a shape tween use the animate id parameter
		blobShift - a number of points to shift the points of a Blob in clockwise direction
			this is when using a shape tween that is a Blob - can be negative
		path - pass in a Blob or Squiggle to animate along path
			https://zimjs.com/nio/path.html
			If the shape has lockControls set to false (the default) then the animation will be dynamic
			and adjust as the shape is changed.
			If a set animation path is desired then set the shape's lockControls to true
			NOTE: Do not re-amimate an object that is being animated on a path
			use a Container and animate the container on the path
			and animate the object inside the container - otherwise percentComplete conflicts
		startPercent - (default 0) set to a percent for where to start the target animating
			ZIM Bead objects will be given a startPercent that matches their start percentage
			currently not supported when dragging on path - it is very complicated
		percent - (default 100) how much percent to animate from the startPercent
			by default, the target will travel once along the path from its start position (startPercent)
			this can be less than the startPercent to make animation travel backwards on the path
			the percent can also be bigger than 100 as well as less than 0
			so a percent:300 will travel three times along the path - and then rewind if rewind is set
			and a percent of -150 will travel one and half times backwards along the path from the startPercent
			currently not supported when dragging on path - it is very complicated
		orient - an object with x and y to aim the target at
			https://zimjs.com/nio/orient.html
			when a path is used this will default to rotate to orient to path
			(for a Sprite, add the Sprite to a Container and animate the Container)
			can set to false for no rotation
			can set to any object with an x, y point such as a circle on the stage - or {x:0, y:0} or a new zim Point, etc.
		flip - default true when orient is true
			true will flip the object horizontally when its x direction goes negative
			https://zimjs.com/nio/flip.html
			this will also work with orient to make sure the target is not upside down
			if object is pre-rotated then 90,-90,270 should work as ZIM will swap the the scaleX and scaleY
			but any unusual starting angles may not flip as desired - so put these in a Container and animate the container
		flipVertical - setting flipVertical to true will flip the object vertically when its y direction goes negative
			this will also work with orient to make sure the target is not upside down

		EXTRA! - the following convenience properties are available for ZIM EXTRA! (also see extra below)
			https://zimjs.com/nio/extra.html
			zoom - an array that represents scale proportions based on target's y position
				[inputMin, inputMax, outputMin(default 0), outputMax(default H)] the outputs will be constrained to the provided values
				zoom:[.5,1.5] scales the target based on its y position - animating y or along a path will show scaling
				zoom:10 - is like zoom:[0,10]
				zoom:true - is like zoom:[0,1]
				zoom:[1,3,H/2-100,H/2+200] would scale from 1 to 3 in this region and stay at 1 or 3 outside this region
			speed - an array that represents animation percentSpeed based on target's y position
				[inputMin, inputMax, outputMin(default 0), outputMax(default H)] the outputs will be constrained to the provided values
				speed:[20,100] sets percentSpeed based on target y position - animating y or along a path will have changing speed
				speed:40 - is like speed:[0,40]
				speed:true - is like speed:[0,100]
				** will set dynamic property to true - as percentSpeed needs dynamic property set to true
			layer - an array that represents ratio of layer proportions based on target's y position
				[inputMin, inputMax, outputMin(default 0), outputMax(default H)] the outputs will be constrained to the provided values
				layer:[0,1] sets current layer based on target y position - animating y or along a path will have changing layers
				layer:1 - is like layer:[0,1]
				layer:true - is like layer:[0,target.parent.numChildren-1]
			fade - an array that represents ratio of alpha based on target's y position
				[inputMin, inputMax, outputMin(default 0), outputMax(default H)] the outputs will be constrained to the provided values
				fade:[.5,1] sets current alpha based on target y position - animating y or along a path will have changing alpha
				fade:1 - is like fade:[0,1]
				fade:true - is like fade:[0,1]
				fade:[0,1,H/2-100,H/2+200] - would change alpha in this y region
		extra - in addition to the convenience properties above, ZIM EXTRA! has a more general and complete format:
			Pass in a single EXTRA! object or an array of EXTRA! objects: extra:{} or extra:[{},{},{}]
			The object has the following properties - all are optional except the outputProp which is required:
			|ZIM VEE| - each object below optionally accepts a ZIM VEE value for Pick.choose() to pick randomly from
				inputObj - (default target) - the object with the input property - probably the animation target but could be any object
				inputProp - (default "y") - a string of the property name for the input - "x", "rotation", etc.
				inputMin - (default 0) - the minimum input value for the calculation - also see constrain
				inputMax - (default W if x inputProp else H) - the maximum input value for the calculation - also see constrain
				outputObj - (default target) - the object whose output property is being changed - probably the animation target but could be any object
				outputProp - (default "scale") - a string of the property name of the output - "scale", "layer", "rotation", etc.
				outputMin - (default 0) - the minimum output value for the calculation - also see constrain
				outputMax - (default 1) - the maximum output value for the calculation - also see constrain
				factor - (default 1) setting factor to -1 will reverse the direction of the animation
				outputRound - (default false) set to true to receive rounded output values
				constrain - (default true) constrain the output value to outputMin and outputMax
					set to false to let values go beyond provided mins and maxes
					this is quite usual when a proportion is easily figured at a certain range
					and continued increase or decrease is desired outside the range - just turn constrain to false.
			EXAMPLES:
			extra:{outputProp:"scaleX"} would animate the scaleX of the target from 0-1 over the stage height
			extra:{outputObj:circle, outputProp:"alpha"} would animate the alpha of circle based on the animated target's y position
			extra:{inputObj:circle, inputProp:"x", inputMax:W, outputProp:"level"} would animate the target's child index as the circle's x goes across the screen
			** in the last two examples, circle is a different object than the target of the animation - circle might be animating independently or based on a Slider value, etc.
	|ZIM VEE| - each props property value optionally accepts a ZIM VEE value for Pick.choose() to pick randomly from (except the EXTRA! properties which accept ZIM VEE values inside)
		these will be picked again if the loopPick parameter is true (default false)
	RELATIVE VALUES: you can pass in relative values by putting the numbers as strings
		rotation:"360" will animate the rotation of the object 360 degrees from its current rotation
		whereas rotation:360 will animate the rotation of the object to 360 degrees
	DOT PROPERTIES: you can animate properties on properties using quotes:
		Here is animate used as a function to animate a threejs mesh
			animate(mesh, {"rotation.y":360*RAD}, 5000);
			note that the from parameter is not currently supported with dot properties (difficult bug)
	CSS PROPERTIES: animate can animate CSS properties
		ZIM's CreateJS 1.3.2 has the CreateJS CSS Pluging installed
		Set the css parameter to true and see the CSS parameter for more details
	ANIMATION SERIES: if you pass in an array for the props value, then this will run an animation series
		The array must hold animate configuration objects:
		[{props:{scale:2}, time:1, rewind:true}, {target:different, props:{x:100}}, etc.]		
		If you run animate as a method on an object then this is the default object for the series
		but you can specify a target to override the default
		By default, each animation runs after the other, but a negative wait can be set 
		eg. if wait:-1 is set on the third animation in the series it starts 1 second before the second animation ends
		The default time and tween are as provided in the main parameters
		but you can specify these to override the default
		The id of the main parameters is used for the whole series and cannot be overridden
		The override parameter is set to false and cannot be overridden
		All other main parameters are available except rewind, sequence and from
		(rewind and from are available on the inner tweens - for sequence: the initial animation is considered)
		You currently cannot nest animation series
		Note: if any of the series has a loop and loops forever (a loopCount of 0 or no loopCount)
		then this will be the last of the series to run
		Note: color cannot be animated in a series - rather animate in a call function to accomplish a series of color changes
		Note: a sequence cannot be seriesed and a series cannot be sequenced
time - |ZIM VEE| (default 1) the time for the tween in seconds (also see ZIM TIME constant)
	see also the rate parameter and property to dynamically change the time the animation takes (its speed)
ease - |ZIM VEE| (default "quadInOut") the equation type for easing ("bounceOut", "elasticIn", "backInOut", "linear", etc)
	also ZIM preset eases: "snapIn", "snapOut", "snapInOut", "ballisticIn", "ballisticOut", "ballisticInOut", "slowmoIn", "slowmoOut", "slowmoInOut"
	** CUSTOM EASE: see https://zimjs.com/ease for custom ease which can be passed in here as a value like so:
		ease:zimEase([.2,.4,.6,.8]) // would be linear  
		ease:zimEase([[1.45,-0.57,0.67,0.55], [0.34,0.44,1.43,-0.31]]) // is the same as "snapInOut"
		// see the zimEase() function in the docs for the Code module
	see CreateJS easing: https://www.createjs.com/docs/tweenjs/classes/Ease.html
	also see easeAmount and easeFrequency parameters to adjust certain eases like back and elastic
call - (default null) the function to call when the animation is done
params - (default target) a single parameter for the call function (eg. use object literal or array)
wait - |ZIM VEE| (default 0) seconds to wait before doing animation
	can be negative for series to start animation before previous animation ends
waitedCall - (default null) calls function after wait is done if there is a wait
waitedParams - (default target) parameters to send waitedCall function
loop - (default false) set to true to loop animation
loopCount - |ZIM VEE| (default 0) if loop is true how many times it will loop (0 is forever)
loopWait - |ZIM VEE| (default 0) seconds to wait before looping - will automatically set loop to true
loopCall - (default null) calls function after loop and loopWait (not including last loop)
loopParams - (default target) parameters to send loopCall function
loopWaitCall - (default null) calls function after at the start of loopWait
loopWaitParams - (default target) parameters to send loopWaitCall function
loopPick - (default false) remake any ZIM VEE (Pick) props for the next loop (thanks GSAP)
rewind - |ZIM VEE| (default false) set to true to rewind (reverse) animation (doubles animation time)
rewindWait - |ZIM VEE| (default 0) seconds to wait in the middle of the rewind 
rewindCall - (default null) calls function at middle of rewind after rewindWait
rewindParams - (default target) parameters to send rewindCall function
rewindWaitCall - (default null) calls function at middle of rewind before rewindWait
rewindWaitParams - (default target) parameters to send rewindCall function
rewindTime - (default time) set the time in seconds for the rewind portion of an animation
rewindEase - (default null) overwrite the ease for the rewind direction
	this assumes that In is at the start of the rewind and Out is at the end of the rewind
	so setting rewindEase:"bounceOut" will bounce back at the start of the animation
	note - setting ease:"bounceOut" will bounce at the end of the animation
	this allows for a normal start with a bounce and then a normal start at rewind and a bounce

startCall - (default null) calls function at the start of actual animation and after any wait (and waitedCall)
	this is basically the same as the waitedCall but will also be called at the start of animation when there is no waitedCall
startParams - (default target) parameters to send startCall function
animateCall - (default null) calls function every animation
	this runs an alternate Ticker so does not aversely affect animate without an animateCall 
	alternatively, can set events:true and capture an "animation" event - but that is only for animations on ZIM objects
	wherease animateCall will always be available
	for instance, if using the animate() function on object literals, HTML/CSS tags or threejs objects, etc.
animateParams - (default target) parameters to send animateCall function
sequence - (default 0) the delay time in seconds to run on children of a container or an array of target animations
	with the addition of ZIM VEE object to the target, you must noPick the array
	for example, target = container or target = {noPick:[a,b,c]} and sequence = 1
	would run the animation on the first child and then 1 second later, run the animation on the second child, etc.
	or in the case of the array, on element a and then 1 second later, element b, etc.
	If the loop prop is true then sequenceCall below would activate for each loop
	For an array, you must use the zim function with a target parameter - otherwise you can use the ZIM 4TH method
	Note: a sequence cannot be seriesed and a series cannot be sequenced
	Note: for a sequence animate() give the animate() an id and pauseAnimate() or stopAnimate() that id.
sequenceCall - (default null) the function that will be called for each sequence animation 
	Note: the value of the sequenceCall parameter will be the object that just ended animation unless there is a sequenceParams value
sequenceParams - (default null) a parameter sent to the sequenceCall function
sequenceReverse - |ZIM VEE| (default false) set to true to sequence through container or array backwards
sequenceRate - (default null) set to a value to adjust the rate based on item ratio property
    see https://zimjs.com/016/normalize.html
	see Container() ratio property and normalize() method which give a ratio property.
	This will automatically set sequence to 0 so that each item in the container (or tile) is animated individually
	the sequenceRate value will be multiplied by the item's ratio and then added to the rate (see rate parameter)
	So if the sequenceRate is 2 and the rate is the default 1, 
	then an item with a ratio property of 0 would be at rate 1 
	and items with a ratio property of .5 would be at rate 1+2*.5 = 2 
	and items with a ratio property of 1 would be at rate 1+2*1 = 3
ticker - (default true) set to false to not use an automatic Ticker function
cjsProps - (default {override: true}) legacy - allows you to pass in CreateJS TweenJS configuration properties
css - (default false) set to true if there is no Frame
	ZIM's CreateJS 1.3.2 has the CreateJS CSS Pluging installed
	But other CreateJS versions will need the plugin available here:
		https://d309knd7es5f10.cloudfront.net/CSSPlugin01.js
		Add that at the top of your code in a script tag
		and at the top of the main script install:
		createjs.CSSPlugin.install();
	<script>
		// other versions of CreateJS need to import and install CSS Plugin
		// createjs.CSSPlugin.install();
		// the property must be set before you can animate
		zss("tagID").opacity = 1; // set this even if it is default
		animate(zid("tagID"), {opacity:0}, 2); // etc.
		// for transform styles use:
		zss("tagID").transform = "translate(20px, 30px)"; // set this even if it is default   
		animate({
		    target:zid("tagID"), 
		    props:{transform:"translate(100px, 150px)"}, 
		    time:2,
		    loop:true,
		    rewind:true
		});
	</script>
protect - (default false) protects animation from being interrupted before finishing
 	unless manually interrupted with stopAnimate()
	protect will default to true if loop or rewind parameters are set
	but this can be overriden if protect is set to false
override - (default true) subesequent tweens of any type on object cancel all earlier tweens on object
	set to false to allow multiple tweens of same object
from - |ZIM VEE| (default false) set to true to animate from obj properties to the current properties set on target
	note that from is not supported with dot properties such as "rotation.x" with threejs (a difficult bug)
set - |ZIM VEE| (default null) an object of properties to set on the target to start (but after the wait time)
id - (default null) set to String to use with pauseAnimate(state, id) and stopAnimate(id) - thanks Sean Berwick for typo catch
	series animate gets only one overall id - so no id per animation object
events - (default false) set to true to receive an "animation" event on the target (or Container with a Container sequence)
sequenceTarget - (default null) used internally for processing sequence animations
dynamic - (default false) set to true to turn on dynamic speed animation via the percentSpeed property
	setting perecentSpeed (default 100) will adjust the speed of the animation
	to change speed with a Slider, Dial, MotionController, Accelerator, etc.
	use target.animate({props:{rotation:360}, dynamic:true, set:{percentSpeed:0}}); to start off with no animation
drag - (default false) used with path in props to drag along path
	This can be done while animating or while the animation is paused
	Setting drag to true will set startPaused to true as well - set startPaused to false to animate and drag
	With rewind set, drag lets you change the direction of an animation while animating
	To turn drag off use the pause() method that animate() adds to the target
clamp - (default true) used with dynamic and non-looping - set to false to let time pass beyond animation start and end
startPaused - (default false - true if drag is true) Boolean - set to true to start the animation in the paused state
	Good for animating manually with the percentComplete property
clean - (default true) set to false to not delete animation ids etc. at end of animate()
	Could then use percentComplete to position tween and pauseTween(false) to start animating again
	Note... once tween has waited, percentComplete does not include wait period
	So clean cannot be used to restart an animation with a wait after the animation has waited
	Use the replayTween() method of the target to restart the latest animation on a target
	NOTE: clean will be set to true if loop is true (even if loopCount is set)
	So to scrub after a loopCount of 2 then remake the animate() in the call callback with a pauseAnimate()
obj - (depreciated) the old version of props - kept for backwards compatibility
seriesWait - (internal) used internally to hold setting relative values in correct series order
sequenceWait - (internal) used internally to tie sequence in to the animation chain for pauseAnimate and stopAnimate
rate - |ZIM VEE| (default 1) change the speed at which the animation runs
	set to .5 to run at half the speed and 2 to run at twice the speed
	a ZIM VEE here will update each loop if loopPick is set to true
	to change the speed (time) of the animation for each loop
pauseOnBlur - (default true) as of ZIM 10.8.0, animate defaults to pause all animations on blur
	blur is when the window is reduced or a different tab gains focus on the Browser
	animate uses requestAninationFrame which slows down when the window is not in focus
	this can cause animations to go out of sync - pauseOnBlur will prevent this
	Can also set zim.pauseAnimateOnBlur=false or true to change this at any time
easeAmount - |ZIM VEE| (default null) set to change the tween effect
	Ease amounts are as follows:
	quad (default 2) - exponent - this is the default ZIM tween
	cubic (default 3) - exponent
	quart (default 4) - exponent
	quint (default 5) - exponent
	back (default 1.7) - strength
	elastic (default 1) - amplitude - also see easeFrequency
	linear, bounce, circ, sin - no affect
	Note: used mostly with back and elastic (backIn, backOut, backInOut, etc.)
	as setting the tween to quadInOut and then easeAmount to 5
	would be the same as a quintInOut.
easeFrequency - |ZIM VEE| (default .3 elasticIn and elasticOut or .3*1.5 elasticInOut)
	set to change the elastic ease frequency
	so tween:"elasticOut", easeFrequency:.2 is a faster elastic
	the time may also need to be increased or decreased as desired
	also see easeAmount where easeAmount:3 would be a larger elastic
timeUnit - (default TIME) override the TIME setting to "seconds" / "s" or "milliseconds" / "ms"
timeCheck - (default true) set to false to not have animate() warn of potentially wrong time units - see also TIMECHECK
noAnimateCall - (default true) set to false to not call the callback function if ANIMATE is set to false
pathDamp - (default .15) damping for drag along path

PROPERTIES - zim.animate() adds the following properties to any object it animates:
	animating - read-only - true when animating (including when waiting) 
		see paused (the opposite) and waiting properties
	paused - read-only - when animating, paused is set to false
		When paused with pauseAnimate() then paused is set to true
		When stopped or before animation, paused is undefined or null
		There is only one paused property per object so pausing a specific id
		on an object with multiple animations will set paused to true
		even if other animations are still running.
		Pausing multiple objects should work fine.
		See the tweenState property to test which ids are animating or paused
		For a sequence animate() give the animate() an id and pauseAnimate() or stopAnimate() that id.
	waiting - read-only - true when animation is waiting in wait, rewindWait, loopWait
	tweenState - an object with tween ids as properties along with an all property (unless no tweens anymore)
		these properties are true if animating and false if paused 
		if all is true then all are animating except for the ids that hold false
		if all is false then all are not animating except for the ids that hold true
		this is used for pauseAnimateOnBlur to keep track of animations to set back to true when un-blurring
	percentSpeed - get or set the percent of the animation speed
		100% is regular time, 50% is half as fast, 200% is twice as fast -100% is reverse normal speed, etc.
		use target.animate({props:{rotation:360}, dynamic:true, set:{percentSpeed:0}}); to start off with no animation
	rate - changes the speed of the animation with 1 as a ratio
		so 1 is the default speed (time), .5 would be half the speed, 2 twice the speed, etc.
		does what percentSpeed does by changing the CreateJS timeScale property
		this does not require dynamic to be set and is probably more efficient
		rate might also be affected by sequenceRate
	percentComplete - get or set percent complete (0-100)  **
		this allows you to scrub through an animation with a Slider, Dial, MotionController, etc.
		should probably set startPaused parameter of animate() to true
		Setting percentComplete to 100 may cause the animation to start at the beginning
		but can set rewind:true and then set percentComplete to 50 - this will animate "backwards"
		Can use animation event and a test of percentComplete to stop animation at a percentage
		see  https://zimjs.com/explore/squigglepart.html
		** NOTE: As of ZIM 015, percentComplete includes the wait time
		and spans across all animations on the object including animation series.
		A percentComplete has also been added to the CreateJS tweens for individual control.
		The individual tweens can be found in the zimTweens object 
		or the latestTween will give access to the latest tween running.
		So for setting percentComplete on an animation with a wait you can access the latestTween 
		in the waited call back function. 

METHODS - see pauseAnimate() and stopAnimate() under the METHODS module
	Also - zim.animate() adds a pause(state, time) method to the target IF dynamic is set to true (or drag is true)
	This matches the pause() of Dynamo and Scroller and is used by Accelerator
	   state - (default true) true pauses and setting the state to false will unpause the dynamic animation
	   time - (default 0) time in milliseconds to slow the animation down if pausing or speed it up if unpausing
	endTween(callType) - stops the animation and sets the target to the properties at the end of the tween - returns target for chaining
		callType defaults to "all" which will run the call function and all the call functions in a series
		setting callType to "none" will not run the call function and not run any call function in a series
		setting callType to "main" will run the call function but not the call functions in a series
		note: any remaining rewindCall and loopCall functions will not be called when using endTween()
		note: endTween is complicated with ids, multiple animations, series, sequences, etc.
		if there is a problem, try adding the target to a Container and controlling separate animations on container and target
	resetTween() - sets the target back to the state at the start of the last animate() call - returns target for chaining
		note: resetTween is complicated with ids, multiple animations, series, sequences, etc.
		if there is a problem, try adding the target to a Container and controlling separate animations on container and target
	replayTween() - resets and runs the last animate() on the target - calls the animate function with the same parameters as the last time - returns target for chaining
		note: replayTween is complicated with ids, multiple animations, series, sequences, etc.
		if there is a problem, try adding the target to a Container and controlling separate animations on container and target
		if there is a series with more than one target then replayTween will only work on the main target
		instead, store the series in an object literal: const mySeries = {animation object} and call obj.animate(mySeries) and then later call it again obj.animate({mySeries})
EVENTS - zim animate() will add an "animation" event to the target IF the events parameter is set to true (default is false)
	alternatively, see the animateCall and animateParams parameters of animate()
 	or the "animation" event will be added to the Container for a sequence in a Container
	or the "animation" event is added to the targets of an animation series
	If dynamic is set to true, will dispatch a "pause" event when animate is paused - could be delayed but time passed in to pause()

RETURNS the target for chaining (or null if no target is provided and run on zim with series)
--*///+45
	zim.animate = function(target, props, time, ease, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startCall, startParams, animateCall, animateParams, sequence, sequenceCall, sequenceParams, sequenceReverse, sequenceRatio, ticker, cjsProps, css, protect, override, from, set, id, events, sequenceTarget, dynamic, drag, clamp, startPaused, clean, obj, seriesWait, sequenceWait, rate, pauseOnBlur, easeAmount, easeFrequency, timeUnit, timeCheck, noAnimateCall, pathDamp) {
		var sig = "target, props, time, ease, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startCall, startParams, animateCall, animateParams, sequence, sequenceCall, sequenceParams, sequenceReverse, sequenceRatio, ticker, cjsProps, css, protect, override, from, set, id, events, sequenceTarget, dynamic, drag, clamp, startPaused, clean, obj, seriesWait, sequenceWait, rate, pauseOnBlur, easeAmount, easeFrequency, timeUnit, timeCheck, noAnimateCall, pathDamp";

		if (target && (target.props || target.obj)) {
			var duo; if (duo = zob(zim.animate, arguments, sig)) return duo;
		}
		if (target.type=="AC"&&WW.zdf) {WW.zdf.ac("animate", arguments); return target;}
		if (!zim.animateCheck) {z_d("45"); zim.animateCheck=true;}

		if (!target) return; // 10.9.0 ?
		var AN = zim.ANIMATE;
		if (WW.ANIMATE != null) AN = WW.ANIMATE;
		if (!AN) {
			if (zot(noAnimateCall)) noAnimateCall = true;
			if (call && noAnimateCall && typeof call == "function") call(zot(params)?target:params);
			return target;
		}

		if (zot(timeCheck)) timeCheck = true;
		// last param is noWarning - sent internal as false by wiggle for instance
		var timeType = getTIME(null, timeUnit, null, null, zot(timeCheck)?false:!timeCheck);

		if (loopCount || loopCall || loopWait) loop = true;
		if (rewindTime || rewindCall || rewindTime || rewindEase || rewindWait) rewind = true;

		var i, prop, currentCount;
		var startArguments = arguments;
		var startParameters = Array.prototype.slice.call(arguments);

		if (zot(props) && !zot(obj)) props = obj; // conversion of 7.1 props parameter to pre 7.1 obj parameter
		obj = props;
		if (zot(obj)) {if (zon) {zogy("animate() - need props");} return target;}

		if (!zot(sequenceRatio)) sequence = 0;

		// added ZIM 10.7.0
		if (target.type == "BeadsContainer") {
			if (zot(sequence)) sequence = 0;
		}

		// added ZIM 10.8.0 Added a rate parameter near the end of animate() to change the rate of speed of the animation
		if (target.type == "Tone") pauseOnBlur = false;
		if (pauseOnBlur === false) zim.pauseAnimateOnBlur = false; // adjusted for ZIM ZIM 01 - it would be good to do individual perhaps
		else if (pauseOnBlur || (zot(pauseOnBlur) && zim.pauseAnimateOnBlur !== false)) {
			if (zot(zim.blurCheck)) zim.setBlurDetect();
			zim.pauseAnimateOnBlur = true;
		}
		

		// zik supports passing array of options or an object with min, max, integer, negative properties and zik will pick or calculate a random value
		if (!zot(sequence) && target.addChild) {
			// do not process ZIM VEE until individual animates are called
		} else {
			time = zim.Pick.choose(time);
			ease = zim.Pick.choose(ease);
			wait = zim.Pick.choose(wait);
			loopCount = zim.Pick.choose(loopCount);
			loopWait = zim.Pick.choose(loopWait);
			rewind = zim.Pick.choose(rewind);
			rewindWait = zim.Pick.choose(rewindWait);
			if (zot(rewindTime)) rewindTime = time;
			else rewindTime = zim.Pick.choose(rewindTime);
			sequenceReverse = zim.Pick.choose(sequenceReverse);
			from = zim.Pick.choose(from);
			set = zim.Pick.choose(set);
			// when sequence recalls animate() some of have been put in cjsProps and not in main params like above
			var zikTypes = ["loopCount","loopWait","rewind","rewindWait"];
			for (prop in cjsProps) {
				if (zikTypes.indexOf(prop) >= 0) cjsProps[prop] = zim.Pick.choose(cjsProps[prop]);
			}
		}

		// CJSPROPS
		// convert loop and rewind properties into the legacy cjs props object 
 
		var newProps = {override: zot(override) ? ((!zot(target) && !zot(target.zimX) && !zot(obj.x)) || (!zot(target) && !zot(target.zimY) && !zot(obj.y))) : override};
   
		if (!zot(loop)) newProps.loop = loop;
		if (!zot(loopCount)) newProps.count = loopCount; // note prop is count
		if (!zot(loopWait)) newProps.loopWait = loopWait;
		if (!zot(loopCall)) newProps.loopCall = loopCall;
		if (!zot(loopWaitParams)) newProps.loopWaitParams = loopWaitParams;
		if (!zot(loopWaitCall)) newProps.loopWaitCall = loopWaitCall;
		if (!zot(loopParams)) newProps.loopParams = loopParams;
		if (!zot(loopPick)) newProps.loopPick = loopPick;
		if (!zot(rewind)) newProps.rewind = rewind;
		if (!zot(rewindWait)) newProps.rewindWait = rewindWait;
		if (!zot(rewindCall)) newProps.rewindCall = rewindCall;
		if (!zot(rewindParams)) newProps.rewindParams = rewindParams;
		if (!zot(rewindWaitCall)) newProps.rewindWaitCall = rewindWaitCall;
		if (!zot(rewindWaitParams)) newProps.rewindWaitParams = rewindWaitParams;

		if (!zot(startCall)) newProps.startCall = startCall;
		if (!zot(startParams)) newProps.startParams = startParams;
		if (!zot(animateCall)) newProps.animateCall = animateCall;
		if (!zot(animateParams)) newProps.animateParams = animateParams;

		if (zot(rate)) rate = 1;	

		if (!zot(props)) newProps = zim.merge(newProps, cjsProps); // cjsProps to overwrite
		cjsProps = newProps;
		
		// convert dot property format
		zim.loop(obj, function (o, v) {
			if (typeof o == "string") {
				var sp = o.split("."); // add a dot at start for CreateJS dot plugin
				if (sp.length > 1 && o.substr(0,1)!=".") {
					obj["."+o] = v;
					delete obj[o];
					o = "."+o;
				}
				// handle createjs needing + sign (sigh) for dot plugin
				if (sp.length > 1 && typeof v == "string") {
					var sub = v.substr(0,1);
					if (sub != "+" && sub != "-") obj[o] = "+" + v;
				}
			}
		});

		// handle getting value with dot property format
		// (target, "rotation.x") for instance
		function getValue(what, prop) {
			if (prop.substr(0,1) == ".") {
				var dots = prop.split(".");
				var lastdot = what;
				for (var i=1; i<dots.length; i++) {
					lastdot = lastdot[dots[i]];
				}
				return lastdot;
			} else {
				if (prop=="transform" && what.style) {
					return what.style.transform;
				}
				return what[prop];
			}
		}

		// handle setting value with dot property format
		// (target, "rotation.x", 200) for instance
		function setValue(what, prop, val) {			
			if (prop.substr(0,1) == ".") {
				var dots = prop.split(".");
				var lastdot = what;
				for (var i=1; i<dots.length-1; i++) {
					lastdot = lastdot[dots[i]];
				}
				lastdot[dots[dots.length-1]] = val;
			} else {
				what[prop] = val;
			}
		}

		// this was down below but meant series was always starting from last tween's zimTweenOriginals
		target.zimTweenOriginals = {};
		
		// SEQUENCE HANDLING
		// handle multiple targets first if there is an array
		// this just recalls the animate function for each element delayed by the sequence parameter
		// if (zot(sequence)) sequence = 0;

		
		
		if (!zot(sequence) && target.addChild) { // container with sequence so convert target to array
			var newTarget = [];
			for (i=0; i<target.numChildren; i++) {
				newTarget.push(target.getChildAt(i));
			}
			sequenceTarget = target;
			target = newTarget;
		}

		// PREPARE ZIK RANDOM VALUES PASSED IN AS ARRAY OR RAND OBJECT {min, max, integer, negative}
		var extraTypes = ["extra", "zoom", "speed", "layer", "fade"];
		var extraLookup = {zoom:target.type=="Pen"?"size":"scale", speed:"percentSpeed", layer:"layer", fade:"alpha"};

		if (target instanceof Array) {
			if (sequenceReverse) target.reverse();
			
			for (i=0; i<target.length; i++) {

				var tar = target[i];
				if (from) {
					var val;
					tar.zimObj = {};
					for (prop in obj) {
						if (extraTypes.indexOf(prop) >= 0) val = obj[prop];
						else val = zim.Pick.choose(obj[prop]);
						tar.zimObj[prop] = tar[prop];

						// calculate relative -- ZIM 10.7.1 patch
						if (typeof val == "string" && prop != "transform") {
							var newStart;
							if (tar.zimLastObj && !zot(tar.zimLastObj[prop])) newStart = tar.zimLastObj[prop];
							else newStart = tar[prop];
							val = newStart + Number(val.replace(/\s/g,""));
						}
						if (tar.zimLastObj) tar.zimLastObj[prop] = rewind?tar.zimTweenOriginals[prop]:obj[prop];
						tar[prop] = val;
					}
				} else {
					tar.zimObj = {};
					for (prop in obj) {
						if (extraTypes.indexOf(prop) >= 0) tar.zimObj[prop] = obj[prop];
						// else tar.zimObj[prop] = zim.Pick.choose(obj[prop]);
						else tar.zimObj[prop] = obj[prop]; // let pick go through... 10.8.0
					}
				}
				var rrr = rate;
				if (!zot(sequenceRatio)) {
					rrr = rate + (tar.ratio?tar.ratio:0);
				}
				var seqTime = i*sequence;
				if (i==0 && sequence!=0) seqTime = timeType=="s"?.02:20; // patched in 10.7.0 and 10.7.1				
				zim.animate(tar, tar.zimObj, time, ease, (i==target.length-1?call:null), (i==target.length-1?params:null), wait, waitedCall, waitedParams, null, null, null, null, null, null, null, loopPick, null, null, null, null, null, null, rewindTime, rewindEase, startCall, startParams, animateCall, animateParams, null, sequenceCall, sequenceParams, null, null, ticker, zim.copy(cjsProps), css, protect, override, null, set, id, events, sequenceTarget, dynamic, drag, clamp, startPaused, clean, obj, seriesWait, seqTime, rrr, pauseOnBlur, easeAmount, easeFrequency, timeUnit, timeCheck, noAnimateCall, pathDamp); // do not send from!
	
			}
			return sequenceTarget;
		} 


		// DEFAULTS
		var t = time;
		var t2 = rewindTime;
		if (zot(t)) t = timeType=="s"?1:1000;
		if (zot(rewindTime)) rewindTime = t2 = t;
		if (zot(ease)) ease = "quadInOut";
		if (zot(wait)) wait = 0;
		if (zot(rewindWait)) rewindWait = 0;
		if (zot(cjsProps)) cjsProps = {override: (!zot(target.zimX) && !zot(obj.x) || !zot(target.zimY) && !zot(obj.y))};
		if (zot(params)) params = target;
		if (zot(ticker)) ticker = true;
		if (zot(css)) css = false;
		var originalProtect = protect;
		if (zot(protect)) protect = false;
		if (zot(from)) from = false;
		if (zot(set)) set = {};
		if (set.scale) {set.scaleX = set.scaleY = set.scale; delete set.scale;}
		if (!zot(override)) cjsProps.override = override;
		if (zot(drag)) drag = false;
		if (zot(startPaused)) startPaused = drag?true:false;
		if (zot(dynamic)) dynamic = false;
		if (zot(clamp)) clamp = true;
		if (zot(clean)) clean = true;
		if (zot(pathDamp)) pathDamp = .15;
		
		
		// tweens are separated - this is used to set the CreateJS timeScale	
		// the rate parameter is not used after this 
		// the rate property sets the target.futureRate 
		// but also applies the timeScale to all tweens on the object
		// individual timeScale can be set by using target.zimTweens[id].timeScale = 2; 
		// after the rate has been called
		target.futureRate = rate; 
		
		var tween;
		var idSet;
		var providedID;		

		// ANIMATION SERIES HANDLING
		// if an array is passed in to animate() as the obj
		// then animate treats this as an animation series
		// [{target:circle, obj:{alpha:0}, time:1}, {target:rect, obj:{alpha:0}, time:1},]

		if (obj instanceof Array) {
			currentCount = 1;
			if (obj.length == 0) return this;
			var starts;
			var lastParamTarget;

			prepareSeries();
			prepareIds();
			runMaster();
		
			return target;
		} // end series
		
		function runMaster() { // one day might consider reverse... or do this by animating percentComplete backwards
			if (target.zimLastObj) {
				zim.loop(target.zimLastObj, function (i) {
					if (zot(target.zimTweenOriginals[i])) return; // next in loop
					target[i] = target.zimTweenOriginals[i];
					target.zimLastObj[i] = target.zimTweenOriginals[i];
				});
			}
			var o; // inner obj
			var w = wait; // time for wait before starting animation
			var lastEnd = 0; // time of last label end
			var duration; // time of each label animation not including initial wait
			var durationRewind;
			for (var i=0; i<obj.length; i++) {
				o = obj[i];
				if (zot(o.target)) continue;
				if (zot(o.time)) o.time = t;
				w += (o.wait?o.wait:0);
				duration = o.time;

				if (animateCall) {
					if (o.animateCall) {
						-function() {
							var originalCall = o.animateCall;
							var originalParams = o.animateParams;
							var generalCall = animateCall;
							var generalParams = animateParams;
							o.animateCall = function(target) {
								originalCall(originalParams||target);
								generalCall(generalParams||target);
							}
						}();						
					} else {
						o.animateCall = animateCall;
						o.animateParams = animateParams;
					}
				}
				
				durationRewind = (zot(o.rewindTime)?duration:o.rewindTime);
				if (o.rewind) duration = duration + durationRewind + (o.rewindWait?o.rewindWait:0);
				if (o.loop) {
					// if loopCount is 0 (forever) then prepare series makes this the last animation
					duration *= o.loopCount;
					duration += (o.loopCount-1) * (o.loopWait?o.loopWait:0);
				}
				if (zot(o.params)) o.params = o.target;
				lastParamTarget = o.target;
				if (w < 0) {
					lastEnd += w;
					w = 0;
				}
				var currentObj = {
					target:o.target,
					obj:zim.copy(o.obj),
					seriesWait:lastEnd,
					wait:w,
					waitedCall:o.waitedCall,
					waitedParams:o.waitedParams,
					time:o.time,
					ease:o.ease,
					from:o.from,
					rewind:o.rewind,
					call:o.call,
					params:o.params,
					loop:o.loop, loopCount:o.loopCount, loopWait:o.loopWait,
					loopCall:o.loopCall, loopParams:o.loopParams,
					loopWaitCall:o.loopWaitCall, loopWaitParams:o.loopWaitParams,
					loopPick:o.loopPick,
					rewindWait:o.rewindWait,
					rewindCall:o.rewindCall, rewindParams:o.rewindParams,
					rewindWaitCall:o.rewindWaitCall, rewindWaitParams:o.rewindWaitParams,
					rewindTime:o.rewindTime, rewindEase:o.rewindEase,
					startCall:o.startCall,
					startParams:o.startParams,
					animateCall:o.animateCall,
					animateParams:o.animateParams,
					set:zim.copy(o.masterSet),
					events:events,
					rate:target.futureRate,
					pauseOnBlur:o.pauseOnBlur,
					easeAmount:o.easeAmount, easeFrequency:o.easeFrequency,
					override:false,
					id:id,
					clean:(loop||o.loop)?true:clean // need to clean if looping
				};
				if (i == obj.length-1) {
					endSeries(currentObj);
				}					
				zim.animate(currentObj);
				lastEnd += w + duration;
				w = 0;
			}
		}
		function endSeries(currentObj) {
			var savedCall = currentObj.call;
			var savedParams = currentObj.params;
			if (cjsProps.loop && (!cjsProps.count || currentCount < cjsProps.count)) {
				currentObj.call = function() {					
					if (savedCall && typeof savedCall == 'function') {(savedCall)(savedParams||target);}
					if (cjsProps.loopCall && typeof cjsProps.loopCall == 'function') {(cjsProps.loopCall)(cjsProps.loopParams||target);}
					if (cjsProps.loopWait) {
						if (zot(target.zimTweens)) target.zimTweens = {};
						tween = target.zimTweens[id] = target.zimTween = createjs.Tween.get(target, {override:cjsProps.override}).wait(cjsProps.loopWait, true).call(goNext);
						tween.timeScale = target.futureRate;	
					} else {						
						goNext();
					}
					function goNext() {
						for (var k=0; k<starts.objects.length; k++) {
							if (starts.objects[k].set) starts.objects[k].set(starts.values[k]);
						}
						if (cjsProps.loopWaitCall && typeof cjsProps.loopWaitCall == 'function') {(cjsProps.loopWaitCall)(cjsProps.loopWaitParams||target);}
						runMaster();
					}
				};
			} else {	
				currentObj.call = function() {
					if (savedCall && typeof savedCall == 'function') {(savedCall)(savedParams);}
					if (zot(params)) params = lastParamTarget;
					if (call && typeof call == 'function') {(call)(params);}
					// endTween(id); // removed ZIM 015 to support Timeline - do not think this is needed...
					target.zimLastObj = null; // ami fix 10.7.1
				};
			}
			currentCount++;
		}
		function prepareSeries() {

			// store all props in seriesTweens for target
			// and all the calls in seriesCalls (including last call)
			// used in endTween() method
			if (target && !target.seriesTweens) {
				target.seriesTweens = [];
				target.seriesCalls = [];
				target.seriesParams = [];
			}
			var o;
			for (var i=0; i<obj.length; i++) {
				o = obj[i];
				if (o.target) {
					if (!o.target.seriesTweens) o.target.seriesTweens = [];
					if (!o.target.seriesCalls) o.target.seriesCalls = [];
					if (!o.target.seriesParams) o.target.seriesParams = [];
					o.target.seriesTweens.push(o.props);
					o.target.seriesCalls.push(o.call);
					o.target.seriesParams.push(o.params);
				} else {
					target.seriesTweens.push(o.props);
					target.seriesCalls.push(o.call);
					target.seriesParams.push(o.params);
				}
			}
			target.seriesCalls.push(call);
			target.seriesParams.push(params);

			// loop backwards and get original properties
			// only works if series of same object (most common)
			o = obj[0];
			var ttar;
			if (!target) ttar = o.target;
			else ttar = target;
			ttar.zimSeriesOriginals = {};
			for (i=obj.length-1; i>=0; i--) {
				o = obj[i];
				if (zot(o.props) && !zot(o.obj)) o.props = o.obj;
				o.obj = o.props;
				zim.loop(o.obj, function (oo) {
					// using string property name on zimTweenOriginals (just storing)
					if (oo == "path") ttar.zimSeriesOriginals[oo] = obj[oo];
					else ttar.zimSeriesOriginals[oo] = getValue(ttar, oo); // dot property
				});
			}

			var froms = new zim.Dictionary();
			starts = new zim.Dictionary();
			for (i=0; i<obj.length; i++) {
				o = obj[i];
				if (!target) target = o.target;
				if (zot(o.target)) o.target = target;
				if (zot(o.ease)) o.ease = ease;
				if (zot(o.target)) continue;

				if (i==0) o.target.zimSeriesArgs = startArguments;

				if (zot(o.props) && !zot(o.obj)) o.props = o.obj;
				o.obj = o.props;
				if (o.loop && (zot(o.loopCount) || o.loopCount <= 0)) {
					o.loopCount = 0;
					// this object is looping forever so no point in keeping any next objects
					obj.splice(i+1, obj.length); // obj.length may be too much but it works
				}
				if (!zot(o.obj.scale)) {
					o.obj.scaleX = o.obj.scaleY = o.obj.scale;
					delete o.obj.scale;
				}

				if (o.from) {
					var firstFrom = froms.at(o.target);
					if (firstFrom) {
						if (o.set) {
							// all properties from obj go to set
							// matching firstFrom properties to to obj
							// matching set properties override firstFrom on obj
							var temp = zim.copy(o.obj);
							var merged = zim.merge(firstFrom, o.set);
							o.obj = getFroms(o.target, o.obj, merged);
							o.set = zim.merge(o.set, temp);
						} else {
							o.set = zim.copy(o.obj);
							o.obj = getFroms(o.target, o.obj, firstFrom);
						}
						o.from = false;
					} else {
						// any set properties override target properties
						froms.add(o.target, getFroms(o.target, o.obj, o.set));
					}
				}
				var startProps = {};
				for (var iii in o.obj) {
					startProps[iii] = o.set?(o.set[iii]?o.set[iii]:o.target[iii]):o.target[iii];
				}
				if (zot(starts.at(o.target))) starts.add(o.target, {});
				var newEntry = zim.merge(starts.at(o.target), startProps);
				starts.remove(o.target);
				starts.add(o.target, newEntry);
				o.masterSet = zim.copy(o.set);
			}
			if (zot(target.zimTweens)) target.zimTweens = {};
		} // end prepareSeries

		if (obj) {
			if (obj.x) target.zimX = true;
			if (obj.y) target.zimY = true;
		}


		// SHAPE TWEEN
		if (!zot(obj.shape) && obj.shape.type == target.type && (target.type=="Blob" || target.type == "Squiggle")) {
			var targetPoints = target.pointObjects;
			var shapePoints = obj.shape.pointObjects;
			if (targetPoints.length != shapePoints.length) {
				if (zon) zogy("animate() - shapes must be of same number of points");
				delete obj.shape;
			} else {
				// var shape = obj.shape;
				delete obj.shape;
				var blobShift = zot(obj.blobShift)?0:obj.blobShift;
				delete obj.blobShift;
				var first = true;
				for (i=0; i<targetPoints.length; i++) {
					var targetPoint = targetPoints[i];
					var shapePoint = shapePoints[(targetPoints.length*20000+i+blobShift)%targetPoints.length];
					// loop through the first four elements of the points array
					// the first element is the point container
					// the second is the circle inside (we leave this alone)
					// the third and forth are the two control rectangles
					for (j=0; j<4; j++) {
						if (j==1) continue;
						var controls = targetPoint[j];
						// var shapeControls = shapePoint[j];
						// animate the control to the location of shapePoint
						// this will animate the whole control container when j=0
						// and the two rectangle control handles when j=2 and j=3
						var animateParameters = zim.copy(startParameters);
						animateParameters[0] = controls;
						animateParameters[1] = {x:shapePoint[j].x, y:shapePoint[j].y, rotation:shapePoint[j].rotation};
						// ~~~~~~~~~~~~~~
						// this needs to be changed if parameter order changes!
						// ~~~~~~~~~~~~~~
						if (first) {
							animateParameters[37] = true; // events
							if (controls.animateEvent) controls.off("animation", controls.animateEvent);
							controls.animateEvent = controls.on("animation", function () {
								target.update();
							});
						}
						first = false;
						zim.animate.apply(zim.animate, animateParameters);
					}
				}
				if (zim.isEmpty(obj)) return target;
			}
		}


		// -----------------------------
		// NORMALIZED TWEEN COMING THROUGH
				
		if (zot(target)) return;		
		if (!target.tweenStates) target.tweenStates = {all:true};	

		var fromCheck = false;

									
		// Handle notes
		if (obj.note) {
			if (Array.isArray(obj.note)) { // random
				zim.loop(obj.note, function (n, i) {
					if (typeof n == "string") obj.note[i] = zim.Synth.note(n);
				});
			} else if (obj.note.min) { // range
				obj.note.min = zim.Synth.note(obj.note.min);
				obj.note.max = zim.Synth.note(obj.note.max);
			} else if (obj.note.array) { // series
				zim.loop(obj.note.array, function (n, i) {
					if (typeof n == "string") obj.note.array[i] = zim.Synth.note(n);
				});
			} else if (typeof obj.note == "function") {
				if (zon) {zogy("animate() - use frequency in ZIM VEE functions not note"); return target;}
			} else {
				obj.note = zim.Synth.note(obj.note);
			}
			obj.frequency = obj.note;
			delete obj.note;
		}


		function isGetter (obj, prop) {
			return !!Object.getOwnPropertyDescriptor(obj, prop)['get'];
		}


		if (target.type == "Sprite" || !Object.prototype.hasOwnProperty.call(target,"paused")) {
			Object.defineProperty(target, 'paused', {
				get: function() {
					return target.animatePaused;
				},
				set: function(value) {
					target.animatePaused = value;
				}
			});
			if (target.type != undefined) target.paused = true;
			target.animating = false;
		}	
		
		// FOR END, RESET AND START of TWEEN
		target.endTween = function(callType, ids) {
			target.stopAnimate(ids);

			if (callType != "all" && callType != "main" && callType != "none") callType = "all";

			if (!target.seriesTweens) {
				zim.loop(target.zimLastObj, function (o) {
					if (typeof target.zimLastObj[o] == "string" && o != "transform") {
						target.zimLastObj[o] = target[o] + Number(target.zimLastObj[o].replace(/\s/g,""));
					}
					setValue(target, o, target.zimLastObj[o]);
				});
				// zim.loop(obj, function (o) {
				// 	if (typeof obj[o] == "string") {
				// 		obj[o] = target[o] + Number(obj[o].replace(/\s/g,""));
				// 	}
				// 	setValue(target, o, obj[o]);
				// });
				if (callType != "none" && call) call(params);
			} else {

				zim.loop(target.seriesTweens, function(objSeries, i) {
					zim.loop(objSeries, function (o) {
						if (typeof objSeries[o] == "string" && o != "transform") {
							objSeries[o] = target[o] + Number(objSeries[o].replace(/\s/g,""));
						}
						setValue(target, o, objSeries[o]);
					});
					if (callType == "all") {
						if (target.seriesCalls[i]) target.seriesCalls[i](target.seriesParams[i]);
					}
				});
				if (callType != "none") {
					var lastCall = target.seriesCalls[target.seriesCalls.length-1];
					if (lastCall) lastCall(target.seriesParams[target.seriesParams.length-1]);
				}
				target.seriesTweens = null;
				target.seriesCalls = null;
				target.seriesParams = null;
			}

			if (target.stage) target.stage.update();
			return target;
		};
		var effectCheck = false;
		zim.loop(obj, function (o, v) {
			// using string property name on zimTweenOriginals (just storing)
			if (o == "path") target.zimTweenOriginals[o] = obj[o];
			else target.zimTweenOriginals[o] = getValue(target, o); // dot property
			// if (target.effects) {	// commented because might be animating property before ever setting it		
				// replacing property that auto updates with property (Batch) that does not auto update - so we later batch the update
				if (o.match("hue")) {obj["hueBatch"] = v; delete obj.hue; effectCheck = true;}
				else if (o.match("saturation")) {obj["saturationBatch"] = v; delete obj.saturation; effectCheck = true;}
				else if (o.match("brightness")) {obj["brightnessBatch"] = v; delete obj.brightness; effectCheck = true;}
				else if (o.match("contrast")) {obj["contrastBatch"] = v; delete obj.contrast; effectCheck = true;}
				else if (o.match(/^.effects/)) {effectCheck = true;}
			// } 
		});
		
			
		target.resetTween = function(paused) {
			if (zot(paused)) paused = true;
			target.pauseAnimate();
			target.percent = null; // added ZIM Cat 04 patch
			target.startPercent = null;
			var origins = target.zimSeriesOriginals?target.zimSeriesOriginals:target.zimTweenOriginals;
			zim.loop(origins, function (o) {
				// actually needing to set real property on target
				if (o == "path") {
					target.percentComplete = 0;
					target.zimPath = origins[o];
					var startPoint;
					// if using traverse, a zimStartPercent is available
					if (target.zimStartPercent) startPoint = target.zimPath.getCurvePoint(target.zimStartPercent/100);
					else startPoint = target.zimPath.getCurvePoint(target.zimStartPercent/100);
					// target.zimPath.pointCircles[0]; // first point
					target.loc(startPoint.x, startPoint.y);
				}
				else setValue(target, o, origins[o]);
			});
			target.zimLastObj = null; // otherwise relative is wrong
			// need to actually put target at start point in case animation is done
			if (target.stage) target.stage.update();

			target.stopAnimate();
			// path is removed from original object so add it back
			if (target.zimPath) startParameters[1].path = target.zimPath;
			if (!zot(target.zimStartRotation)) target.rotation = target.zimStartRotation;
			target.zimStartRotation = null;
			if (!zot(target.zimStartScaleX)) target.scaleX = target.zimStartScaleX;
			target.zimStartScaleX = null;
			if (!zot(target.zimStartScaleY)) target.scaleY = target.zimStartScaleY;
			target.zimStartScaleY = null;
			zim.animate.apply(null, target.zimSeriesArgs?target.zimSeriesArgs:startParameters);
			target.pauseAnimate(paused);
			return target;
		};

		target.replayTween = function() {
			target.resetTween(false);
			return target;
		};
		if (obj.path || dynamic) {
			// can't risk turning percentComplete off when animation ends as only one per all animations
			// instead, evaluate how percentComplete is set when starting an animation
			// if there is a value and no getter setter or a value has been changed when not tweening
			// (this last is because the getter setter may have previously been set - once set, it is not removed)
			// then assumes percentComplete is desired else sets to 0 when starting an animation
			// the startPercentComplete is then examined once the animation starts
			var startPercentComplete;
			if (target.requestedPercentComplete) startPercentComplete = target.requestedPercentComplete;
			else if (target.percentComplete && !isGetter(target, "percentComplete")) startPercentComplete = target.percentComplete;
			// the below did not work as expected with the first value being assigned if true - weird - so made above
			// var startPercentComplete = target.requestedPercentComplete //|| (target.percentComplete && !isGetter(target, "percentComplete"))?target.percentComplete:null;
			target.requestedPercentComplete = null;
			if (zot(startPercentComplete)) startPercentComplete = 0;
			target.pathRatio = 0; // could be wrong setting this to 0
			target.zimStartRotation = target.rotation;
			target.percent = null; // added ZIM Cat 04 patch
			if (!(target.parent && target.parent.type=="BeadsContainer")) target.startPercent = null; // NFT patch of Cat 04 patch
		}

		if (css) ticker = false;
		if (zot(target.zimTweens)) target.zimTweens = {};

		var stage;
		if (!css) {
			if (!target.stage) {
				if (WW.zdf) stage = WW.zdf.stage;
				else css = true;
			} else {
				stage = target.stage;
			}
		}

		// convert color tween - added protect for colorRange in ZIM 016
		var colorBusy = target.zimBusy && target.zimBusy.colorRange; 
		if (!colorBusy) {
			if (target.setColorRange && !zot(obj.color)) {
				var color = obj.color;
				delete obj.color;
				obj.colorRange = 1;
				target.setColorRange(target.color, color);
				target.colorRange = 0;
			} else if (obj.color && (target.material || target.isMaterial)) {	
				if (target.isMaterial) {
					zogy("ZIM animate - please animate the color on the mesh not the material");
					return target;
				}
				var coTarget = target;
				if (coTarget.cT) {zim.Ticker.remove(coTarget.cT);}
				target = {val:0, zimTweens:{}, ticker:coTarget.cT};
				var startColor = coTarget.material.color.getHexString();
				var endColor = obj.color;
				obj = {val:1};			
				coTarget.cT = zim.Ticker.add(function() {
					var cc = zim.colorRange("#"+startColor, endColor, target.val);
					coTarget.material.color.set(cc);
				});
				if (call) {
					var oldCall = call;
					call = function() {
						if (coTarget.cT == target.ticker) { 
							oldCall(callParams||coTarget);
							zim.Ticker.remove(coTarget.cT);
							coTarget.cT = null;
							target = null;
						}
					}
				} else {
					call = function() {
						if (coTarget.cT == target.ticker) {
							zim.Ticker.remove(coTarget.cT);
							coTarget.cT = null;
							target = null;
						}
					}
				}
			}
		} else {
			if (obj.color) { // just to handle protect
				delete obj.color;
				obj.colorRange = 1;
			}
		}


		// moved these to before protect (to catch scale convert) - ZIM Cat
		// PREPARE ZIK RANDOM VALUES PASSED IN AS ARRAY OR RAND OBJECT {min, max, integer, negative}
		var savedPicks = {};
		for (i in obj) {
			// zogb(i)
			if (extraTypes.indexOf(i) >= 0) continue; // skip for extras
			savedPicks[i] = zim.copy(obj[i]); // store pre picked to use if loopPick is true
			obj[i] = zim.Pick.choose(obj[i], null, target);
		}
		if (!zot(obj.scale)) {
			obj.scaleX = obj.scaleY = zim.Pick.choose(obj.scale, null, target);
			delete obj.scale;
		}


		// PROTECT LOOPS AND REWINDS WITH BUSY
		// if protected or a loop or rewind is currently running for any of these properties
		// then remove the property from obj as it is currently busy
		for(var o in obj) {
			if (!target.zimBusy) break;
			if (target.zimBusy[o]) delete obj[o];
		}
		if (zim.isEmpty(obj)) return; // nothing left to animate
		if (target.type != "Sprite") {
			if (target.type != undefined) target.paused = false;
			target.animating = true;
		} else { // sprite - adjusted in ZIM 015 patch... do not animate sprite if told to go to a specific frame... but not sure...
			for (var pro in obj) {
				if (pro != "normalizedFrame") {
					target.animating = true;
					break;
				}
			}
		}
		function addZimBusy() {
			if (originalProtect === false) return; 
			if (!target.zimMouseEnabledCheck) {
				target.zimMouseEnabledCheck = true;
				target.zimLastMouseEnabled = target.mouseEnabled;
			}
			target.mouseEnabled = false;
			setTimeout(function() {
				if (!target.zimBusy) target.zimBusy = {};
				for(var o in obj) {
					target.zimBusy[o] = true;
				}
				target.zimMouseEnabledCheck = null;
				target.mouseEnabled = target.zimLastMouseEnabled;
			}, 70);
		}
		if (protect || cjsProps.loop || cjsProps.rewind) addZimBusy();



		// IDS and IDSETS
		// this is for ids and idSets on this target
		// a single tween for an id does not get an idSet
		// a second tween for the same id gets an idSet
		// the original id is the id for the idSet
		prepareIds();
		function prepareIds() {
			if (zot(id)) {
				id = zim.makeID(null,10);
			} else {
				id = String(id);
				providedID = id;
			}
			if (zot(target.zimIdSets)) target.zimIdSets = {};
			if (!zot(target.zimIdSets[id])) { // already an idSet
				idSet = id;
				id = zim.makeID(null,10);
				target.zimIdSets[idSet].push(id);
			} else if (target.zimTweens && !zot(target.zimTweens[id])) { // not an idSet but already a tween so make an idSet
				idSet = id;
				id = zim.makeID(null,10);
				// var idSet = target.zimTweens[id].zimIdSet;
				target.zimIdSets[idSet] = [idSet]; // add original into set
				target.zimTweens[idSet].zimIdSet = idSet; // reference back to idSet
				target.zimIdSets[idSet].push(id); // push the second one in
			} // else nothing - id is not currently part of idSet
		}

		extraTypes.shift(); // take off extra for later
		for (i in set) set[i] = zim.Pick.choose(set[i], null, target);
		for (i in cjsProps) {
			if (i=="waitedCall" || i=="waitedParams" || i=="loopCall" || i=="rewindCall" || i=="loopWaitCall" || i=="rewindWaitCall" || i=="startCall" || i=="animateCall") continue;
			cjsProps[i] = zim.Pick.choose(cjsProps[i], null, target);
		}

		// In ZIM Cat 00 we moved prepareRelative to tween section to handle loopPick 
		// In ZIM Cat 02 patch we moved getFrom() to at end of preparing relative to fix froms based on relative
		// In ZIM Cat 03 we repatched Cat 02 and 03 because if a series is set then we need to getFrom() before the wait in tweens
		// so we call prepareRelative2() later in the tweens to both set relatives and froms after loopPick
		prepareRelative();
		function prepareRelative() {
			// PREPARE RELATIVE VALUES PASSED IN AS STRINGS
			relativeAdjust();
			relativeSetAdjust();
			if (target.seriesTweens) target.seriesTweens[0] = obj;			
			if (from && !fromCheck) obj = getFroms(target, obj, set, true);
		}
		function prepareRelative2() {
			relativeAdjust();			
			if (from && !fromCheck) obj = getFroms(target, obj, set, true);
		}

		function relativeAdjust() {
			var newStart;
			if (!target.zimLastObj) target.zimLastObj = {};
			for (i in obj) {
				if (typeof obj[i] == "string" && i != "transform") {
					// ZIM ZIM 02 repatch to handle negative relative values for both dot properties and regular properties with from
					if (i.substring && i.substring(0,1)==".") { 
						if (obj[i].substr(0,1)=="+"||obj[i].substr(0,1)=="-") continue; 
					} else {
						if (obj[i].substr(0,1)=="+") continue; // let createjs relative through
					}
					if (obj[i].substr(0,3)=="rgb") continue;
					if (target.zimLastObj && !zot(target.zimLastObj[i])) newStart = target.zimLastObj[i];
					else newStart = target[i];
					obj[i] = newStart + Number(obj[i].replace(/\s/g,""));
				}
				target.zimLastObj[i] = rewind?target.zimTweenOriginals[i]:obj[i];
			}
		}

		function relativeSetAdjust() {
			var newStart;
			for (i in set) {
				if (typeof set[i] == "string" && i != "transform") {
					if (i.substring && i.substring(0,1)==".") {
						if (set[i].substr(0,1)=="+"||set[i].substr(0,1)=="-") continue; 
					} else {
						if (set[i].substr(0,1)=="+") continue; // let createjs relative through
					}
					if (set[i].substr(0,3)=="rgb") continue;
					if (target.zimLastObj && !zot(target.zimLastObj[i])) newStart = target.zimLastObj[i];
					else newStart = target[i];
					set[i] = newStart + Number(set[i].replace(/\s/g,""));
				}
				target.zimLastObj[i] = rewind?target.zimTweenOriginals[i]:obj[i];
			}
		}	
		

		// start NIO updates 1
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		// PERCENT COMPLETE SETUP
		// if (target.getBounds && zot(target.percentCompleteCheck)) {
		if (zot(target.percentCompleteCheck)) {
			target.percentCompleteCheck = true;		
			target._percentComplete = 0;
			Object.defineProperty(target, 'percentComplete', {
				get: function() { 		
					if (target.paused) return target._percentComplete;
					if (target.tweenStartTime && target.tweenEndTime) {	
						// return if paused and however long is paused gets added to target.tweenStartTime and target.tweenEndTime
						// but then how does this affect the timeline?
						// maybe target.percentComplete is always based on time and it ignores pause 
						// whereas tween.percentComplete is based on the animation
						// maybe target.percentComplete should be percentTime 
						var dn = Date.now();	
						var nt;
						// loop is based on latest tween set
						if (cjsProps.loop && dn > target.tweenEndTime) {
							nt = (dn - target.tweenStartTime) % (target.tweenEndTime - target.tweenStartTime);
						} else {
							nt = dn - target.tweenStartTime;
						}		
						var v = Math.max(0, Math.min(100, nt / (target.tweenEndTime - target.tweenStartTime) * 100));
						target._percentComplete	= v;										
						return  v;
					} else {
						return 0;
					}
				},
				set: function(value) {	
					if (this.zimTween) {
						// STICK ON PATH BEFORE DRAG FIX
						immediateCheck = true;
						setPercent(value, true);
					} else {
						// to handle being set prior to a subsequent animation
						this.requestedPercentComplete = value;
					}					
					target._percentComplete = value;
					if (animateCall && typeof animateCall == "function") animateCall(animateParams||target);
				}
			});
	

			Object.defineProperty(target, 'percentCompleteNoAngle', {
				get: function() {					
					if (target.paused) return target._percentComplete; // needed to match percentComplete?  015
					if (target.tweenStartTime && target.tweenEndTime) {	
						var dn = Date.now();	
						var nt;
						// loop is based on latest tween set
						if (cjsProps.loop && dn > target.tweenEndTime) {
							nt = (dn - target.tweenStartTime) % (target.tweenEndTime - target.tweenStartTime);
						} else {
							nt = dn - target.tweenStartTime;
						}	
						var v = Math.max(0, Math.min(100, nt / (target.tweenEndTime - target.tweenStartTime) * 100));
						target._percentComplete	= v;						
						return  v;	
					} else {
						return 0;
					}
				},
				set: function(value) {
					if (this.zimTween) {
						setPercent(value, false);
					} else {
						// to handle being set prior to a subsequent animation
						this.requestedPercentComplete = value;
					}
					target._percentComplete = value;					
				}
			});
		}

		Object.defineProperty(target, 'rate', {
			get: function() {
				return target.futureRate;
			},
			set: function(value) {
				target.futureRate = value;
				zim.loop(target.zimTweens, function(id,tw) {
					tw.timeScale = value;
				});				
			},
			configurable: true // not sure why we need to?
		});

		function setPercent(value, setAngle) {
			target.zimTween.startPaused = false;			
			// if (!this.paused) this.pauseAnimate(true, id);
			if (!dynamic) {
							
				if (target.zimTweens) {										
					zim.loop(target.zimTweens, function(id,tw,i) {		
						var tim = target.tweenStartTime + (target.tweenEndTime - target.tweenStartTime) * value / 100;	
						var nt;
						if (tw.zimLoop && tim <= tw.startTime) {
							nt = 0	
						} else if (tw.zimLoop && tim > tw.startTime + tw.duration) { // && !target.waiting) {
							nt = (tim - tw.startTime) % tw.duration;
						} else {
							nt = tim - tw.startTime; 
						}	
						tw.percentComplete = Math.max(0, Math.min(100, nt/tw.duration * 100));		
					}, true);					

				} else {						
					target.zimTween.setPosition(Math.round(value*target.zimTween.duration/100));
				}
			} else {
				if (!zot(target.zimTween.currentTime)) {
					target.zimTween.currentTime = target.zimTween.currentTime - target.zimTween.position + value*target.zimTween.duration/100;
				}
			}
			if (setAngle && pathObject && obj.orient !== false && pathObject.getCurvePoint) {		
				target.rotation = pathObject.getCurvePoint(target.pathRatio, null, null, true).angle + (startAngle?startAngle:0);
			}

			// STICK ON PATH BEFORE DRAG FIX
			if (immediateCheck && typeof pathPercent != "undefined") pathPercent = value;
			if (target.handlePath) target.handlePath();
		}


		// PATH ANIMATION SETUP
		var pathObject,newPoint,locPoint,segments;
		if (!zot(obj.path) && obj.path.segmentPoints) {
			if (zot(obj.orient)) obj.orient = true;
			if (obj.orient && zot(obj.flip)) obj.flip = true;
			if (target.type == "Pen") target.infinite = true;
			target.zimOnPath = true;
			if (zot(target.pathRatio)) target.pathRatio = 0;
			if (obj.orient===true) {
				obj.orient = obj.path;
			}
			if (obj.orient) {
				obj.startOrient = obj.rotation; // ?
			}
			pathObject = obj.path;
			// ZIM 10.7.0 ---
			if (drag) {
				delete obj.path;
				delete obj.percent;
				if (zon && (target.startPercent && target.startPercent>0) || (target.percent && target.percent!=100)) zogy("ZIM.animate() - startPercent and percent currently not supported with drag on path");
				// old code from 10.6.1 -
				newPoint = pathObject.getCurvePoint(target.pathRatio, percents, segments);
				if (newPoint) {
					// latestSegmentIndex = newPoint.z; // point on path before the calculated point - used with drag
					locPoint = target.parent.globalToLocal(newPoint.x, newPoint.y);
					target.x = locPoint.x;
					target.y = locPoint.y;
				}
			} else {
				if (zot(target.startPercent)) {
					target.startPercent = zim.Pick.choose(!zot(obj.startPercent)?obj.startPercent:0, null, target);
				}
				if (zot(target.percent)) {
					target.percent = zim.Pick.choose(!zot(obj.percent)?obj.percent:100, null, target);
				}
				delete obj.path;
				delete obj.percent;
			}
			// ---
			var dynamicPath = !pathObject.lockControls;
			delete obj.path;
			obj.pathRatio = 1; // this is what we are animating to
		}

		// !!!!! fix for dot values

		// PREPARE START VALUES - now that pathRatio is set
		// moved to prepareRelative
		// if (from) obj = getFroms(target, obj, set, true);
		function getFroms(target, obj, set, update) {
			fromCheck = true;
			// animating based on pathRatio - but API is percentComplete
			// with from set, this causes problems - so add pathRatio equal to percentComplete to set
			if (pathObject && (!zot(target.percentComplete) || (set && !zot(set.percentComplete)))) {
				if (!set) set = {};
				if (zot(set.pathRatio)) set.pathRatio = !zot(set.percentComplete) ? set.percentComplete/100 : target.percentComplete/100;
			}
			var newObj = {};
			for (i in obj) {
				if (set && !zot(set[i])) {
					newObj[i] = set[i];
				} else {
					newObj[i] = target[i];
				}
				if (update) target[i] = obj[i];
			}
			return newObj;
		}

		// var lastPercentComplete = target.percentComplete;
		var flipCheck = true; // if we can flip - not same as pathFlip
		var mouseCheck = false;
		var activeCheck = true;
		// var latestSegmentIndex = 0;

		var redirect=true;
		if (!zot(obj.redirect)) {
			redirect=obj.redirect;
			delete obj.redirect;
		}

		// CONTINUE PATH ANIMATION SETUP
		
		function getPathPercent(e) {
			var point = pathObject.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
			var mousePlace = currentDist;
			// do not change currentForward if no change in dirSamples
			if (pathObject.type == "Blob") {
				if (dirSamples[0] < dirSamples[4]) currentForward = true;
				else if (dirSamples[0] > dirSamples[4]) currentForward = false;
				if (mousePlace < 10 && !currentForward) {
					targetDist = currentDist = mousePlace = length-5;
					dampPercent.immediate(targetDist/length*100);
					dirSamples=[length-1,length-2,length,length-3,length-4];
				} else if (mousePlace > length-10 && currentForward) {
					targetDist = currentDist = mousePlace = 5;
					dampPercent.immediate(targetDist/length*100);
					dirSamples=[0,0,0,0,0];
				}
			}
			// thanks https://codepen.io/eliCrow/pen/MLdddR
			var dPoint = {x:point.x, y:point.y, r:mousePlace};
			testPoints.sort(function (a, b) {
				var aPoint = {x:a.x, y:a.y, r:a.r*length};
				var bPoint = {x:b.x, y:b.y, r:b.r*length};
				var aDiff = Math.sqrt(Math.pow(dPoint.x-aPoint.x, 2)+Math.pow(dPoint.y-aPoint.y, 2)+Math.pow(dPoint.r-aPoint.r, 2));
				var bDiff = Math.sqrt(Math.pow(dPoint.x-bPoint.x, 2)+Math.pow(dPoint.y-bPoint.y, 2)+Math.pow(dPoint.r-bPoint.r, 2));
				return aDiff-bDiff;
			});
			targetDist = testPoints[0].r*length;
			pathPercent = targetDist/length*100;
			pathPercent = zim.constrain(pathPercent,0,99.95); // get rid of end glitch
			if (rewind) { // handle rewind
				pathPercent/=2;
				if (tween.position > tween.duration/2) pathPercent = 100-pathPercent;
			}
            target._percentComplete = pathPercent
		}	
		
		if (pathObject) {
			var percents;
			if (!dynamicPath) {
				segments = zim.copy(pathObject.segmentPoints);
				percents = zim.copy(pathObject.segmentRatios);
			}
			// drag does not pay attention to this...
			target.currentPercent = target.startPercent + target.percent*target.pathRatio;
			var newPointRatio = ((1000000+target.currentPercent)%100)/100;
			newPoint = pathObject.getCurvePoint(newPointRatio, percents, segments);

			if (target.parent && newPoint) {
				locPoint = target.parent.globalToLocal(newPoint.x, newPoint.y);
				target.x = locPoint.x;
				target.y = locPoint.y;
			}

			// DRAG SETUP
			// Fairly complex system - to implement damping on drag
			// dragging can be done when animation is on or off
			// dragging with rewind turned on lets you drag and release to redirect animation
			// dragging with animation off lets you throw the animation

			function getP(target) {
				if (target.latestTween) return target.latestTween.percentComplete;
				return target.percentComplete;
			}
			function setP(target, percent) {
				if (!target) return;
				if (target.zimTween) target.zimTween.startPaused = false;	
				if (target.latestTween) target.latestTween.percentComplete = percent;
				if (immediateCheck && typeof pathPercent != "undefined") pathPercent = value;
				if (target.handlePath) target.handlePath();
			}
						
			if (drag) {
				ease = "linear";
				target.cur("pointer");
				var pathPercent;
				if (obj.startPercent != null) {
					pathPercent = obj.startPercent;
				} else {
					pathPercent = 0;
				}
				// var pathPercent = getP(target); // taken out in 015
				var pathDownCheck = false;
				// var lastPause = startPaused?startPaused:target.paused;
				var lastForward = true;
				var currentForward = true;
				var lastPathPercent = pathPercent;
				
				var pixels = 10;
				segments = zim.copy(pathObject.segmentPoints);
				var length = 0;
				zim.loop(segments, function (point) {
					length+=zim.distanceAlongCurve(point);
				});
				var numPoints = Math.round(length/segments.length/pixels);
				var testPoints = pathObject.interpolate(numPoints, null, true, null, true);
				var currentDist = (pathPercent?pathPercent:0)/100*length;
				var targetDist = currentDist;
				// var dirTest = 0;
				pathObject.zimAnimateChanged = false;
				// var segmentRatios = zim.copy(pathObject.segmentRatios);
				target.zimAnimatePathChange = pathObject.on("change", function() {pathObject.zimAnimateChanged = true;});

				// 10.6.0 patch to turn move target along path if not animating
				target.zimAnimatePathDown = pathObject.on("mousedown", function() {pathDownCheck=true; if (target.paused==true) mouseCheck = true;});
				target.zimAnimatePathUp = pathObject.on("pressup", function() {mouseCheck = false;});

				
				target.zimAnimateDragDown = target.on("mousedown", function (e) {					
					stage = e.target.stage;
					if (!target.amu) target.amu = stage.frame.on("mouseupplus", function() {					
						mouseCheck = false;				
					});		
					stage.mouseMoveOutside = true;
					flipCheck = false; // sometimes picking up target changes its direction - not good
					activeCheck = true;
					setTimeout(function() {
						flipCheck = true;
					}, 50);
					mouseCheck = true;

					if (pathObject.zimAnimateChanged) {
						segments = zim.copy(pathObject.segmentPoints);
						length = 0;
						zim.loop(segments, function (point) {
							length+=zim.distanceAlongCurve(point);
						});
						numPoints = Math.round(length/segments.length/pixels);
						testPoints = pathObject.interpolate(numPoints, null, true, null, true);
						// segmentRatios = zim.copy(pathObject.segmentRatios);
					}

					pathObject.zimAnimateChanged = false;
					pathPercent = getP(target);
					dampPercent.immediate(pathPercent);
					// var calcPercent = dirTest = pathPercent;
					var calcPercent = pathPercent;
					if (rewind) { // handle rewind
						if (tween.position > tween.duration/2) calcPercent = (100-pathPercent)*2;
						else calcPercent = pathPercent*2;
					}
					currentDist = (calcPercent?calcPercent:0)/100*length;
					targetDist = currentDist;
				});

				var movingCheck = false;
				target.zimAnimateDragPress = target.on("pressmove", function(e) {movingCheck=true; getPathPercent(e);});

				target.animateReturn = function() {
					if (!rewind) {
						if (zon) zogy("animate() - animateReturn() needs rewind set to true");
						return;
					}
					lastForward = false;
					currentForward = false;
					if (getP(target) < 50) setP(target, 100-getP(target));
					target.pauseAnimate(false);
				};

				target.zimAnimateDragUp = target.on("pressup", function () {
					if (target.paused==false) mouseCheck = false;
					flipCheck = false;
					setTimeout(function() {
						flipCheck = true;
					}, 50);
					// do not change currentForward if no change in dirSamples
					if (dirSamples[0] < dirSamples[4]) currentForward = true;
					else if (dirSamples[0] > dirSamples[4]) currentForward = false;
					if (!target.paused && rewind && redirect && currentForward != lastForward) {						
						setP(target, 100-getP(target));
						lastForward = currentForward;
						// can't seem to get this to change direction when
						// dragging when paused and then unpausing direction
					}
				});

				var dampPercent = new zim.Damp(pathPercent, pathDamp);
				var lastPercent = 0;
				var dirCount = 0;
				var dirSamples = [0,0,0,0,0];

				// STICK ON PATH BEFORE DRAG FIX
				var immediateCheck = false;

				target.zimDragAnimateTicker = zim.Ticker.add(function () {
					var newPercent;
					if (!drag) return; // might be paused
					if (++dirCount%20) {
						dirSamples.push(targetDist);
						dirSamples.shift();
					}
					currentDist = targetDist;
					// this was still running (due to easing) when unpaused so set mouseCheck to false in pause() script to solve

					// 10.6.0 patch to make pauseAnimate work again after breaking in 10.4.0 (there is another part to this patch too)
					// mouseCheck = true;

					if (pathDownCheck) pathPercent = getP(target); // ZIM Cat fix

					if (mouseCheck || (activeCheck && target.paused==true)) {
						// STICK ON PATH BEFORE DRAG FIX (immediateCheck added)
						if (pathDownCheck || immediateCheck || (pathObject.type == "Blob" && Math.abs(lastPercent-pathPercent)>(rewind?45:90))) {
							pathDownCheck = false;
							newPercent = pathPercent;
							dampPercent.immediate(newPercent);
							immediateCheck = false;
						} else {
							newPercent = dampPercent.convert(pathPercent);
						}
						// target.percentComplete = newPercent;
						if (Math.abs(lastPercent-newPercent)>.1) {
							setP(target, newPercent);
							lastPercent = newPercent;
						} else {
							setP(target, newPercent);
							//if (!mouseCheck) {
								activeCheck = false;
							//}
							movingCheck = false;
						}
					} else {
						activeCheck = false; // otherwise goes to last drag after animation turned off
					}

				}, stage);
			}
		}

		// ORIENTATION SETUP
		var pathOrient;
		if (obj.orient) {
			if (obj.orient === true) {
				var oPoint = target.parent.localToGlobal(!zot(obj.x)?obj.x:target.x, !zot(obj.y)?obj.y:target.y);
				obj.orient = {x:oPoint.x, y:oPoint.y};
			}
			pathOrient = obj.orient;
			delete obj.orient;

			var startAngle = target.rotation;
			target.rotation = pathObject.getPointAngle(0) + startAngle;

			if (pathOrient != pathObject) {
				var orientPoint;
				if (pathOrient.parent) {
					orientPoint = pathOrient.parent.localToLocal(pathOrient.x, pathOrient.y, target.parent);
				} else {
					orientPoint = target.parent.globalToLocal(pathOrient.x, pathOrient.y);
				}
				target.rotation = zim.angle(target.x, target.y, orientPoint.x, orientPoint.y)+startAngle;
			}
		}

		// // FLIP SETUP
		// var pathFlip;
		// var startFlip;
		// if (obj.flip) {
		// 	pathFlip = obj.flip;
		// 	delete obj.flip;
		// 	startFlip = target.scaleX;
		// }
		// var pathFlipVertical;
		// var startFlipVertical;
		// if (obj.flipVertical) {
		// 	pathFlipVertical = obj.flipVertical;
		// 	delete obj.flipVertical;
		// 	startFlipVertical = target.scaleY;
		// }
		// 
		// var lastX=target.x;
		// var lastY=target.y;
		
		
		
		// FLIP SETUP
		var startFlip = target.scaleX,
			startFlipVertical = target.scaleY,
			pathFlip = obj.flip != undefined ? obj.flip : false,
			pathFlipVertical = obj.flipVertical != undefined ? obj.flipVertical : false;

		var lastX=target.x;
		var lastY=target.y;
		
		
		// end NIO updates
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		// LOOP AND REWIND SETUP
		var count = 0;
		if (cjsProps.loop) {
			if (!zot(cjsProps.count)) {
				count = cjsProps.count;
				delete cjsProps.count;
				currentCount = 1;
			}
		}
		var wait3 = 0;
		if (cjsProps.loopWait) {
			wait3 = cjsProps.loopWait;
			loopWait = cjsProps.loopWait; // for dynamic
			delete cjsProps.loopWait;
		}
		var call3;
		if (cjsProps.loopCall) {
			call3 = cjsProps.loopCall;
			delete cjsProps.loopCall;
		}
		var params3 = target;
		if (cjsProps.loopParams) {
			params3 = cjsProps.loopParams;
			delete cjsProps.loopParams;
		}
		
		// checkTIME will test to make sure they are in the right units probably
		if (WW.TIMECHECK && timeCheck) {
			if (t) checkTIME(t, timeType);
			if (t2) checkTIME(t2, timeType);
			if (wait) checkTIME(wait, timeType);
			if (wait2) checkTIME(wait2, timeType);
			if (wait3) checkTIME(wait3, timeType);
			if (loopWait) checkTIME(loopWait, timeType);
			if (cjsProps.rewindWait) checkTIME(cjsProps.rewindWait, timeType);
			if (seriesWait) checkTIME(seriesWait, timeType);
			if (sequenceWait) checkTIME(sequenceWait, timeType);
		}

		// convert times if needed
		if (timeType == "s") {
			if (t) t *= 1000;
			if (t2) t2 *= 1000;
			if (wait) wait *= 1000;
			if (wait2) wait2 *= 1000;
			if (wait3) wait3 *= 1000;
			if (loopWait) loopWait *= 1000;
			if (cjsProps.rewindWait) cjsProps.rewindWait *= 1000;
			if (seriesWait) seriesWait *= 1000;
			if (sequenceWait) sequenceWait *= 1000;
		}

		var ttt = t;
		if (cjsProps.rewind) ttt += t2;
		// else ttt += t; // error?  removed in ZIM 015

		target.zimTweenArgs = {
			time:ttt,
			wait:wait,
			wait2:wait2,
			wait3:wait3,
			loopWait:loopWait,
			rewindWait:cjsProps.rewindWait,
			seriesWait:seriesWait,
			sequenceWait:sequenceWait
		}

		function doLoopCall() {
			if (wait3>0) target.waiting = false;
			if (!cjsProps.loop) return; // added Cat 03 - was being called even if not looping
			if (sequenceCall && typeof sequenceCall == 'function') {				
				var sp = zot(sequenceParams) ? target : sequenceParams;
				(sequenceCall)(sp);
			}
			if (call3 && typeof call3 == 'function') {(call3)(params3||target);}			
			// added 10.8.0 for loopPick
			if (loopPick) {

				// can't seem to get time to adjust - so use rate which sets createjs timeScale
				// tween.step.prev.t = 0
				// tween.step.prev.d = 2000
				// tween.step.t = 2000
				// tween.step.d = 2000
				// tween.step.prev.next.t = 0
				// tween.step.prev.next.d = 2000

				var r = zim.Pick.choose(target.futureRate, null, target);
				if (!zot(target.futureRate)) tween.timeScale = r;

				var adjustedScale;
				if (!zot(savedPicks.scale)) {
					adjustedScale = zim.Pick.choose(savedPicks.scale, null, target);
				}

				if (!from) {
					if (tween.step && tween.step.prev && tween.step.prev.props) {
						for (var i in tween.step.prev.props) {
							if (extraTypes.indexOf(i) >= 0) continue; // skip for extras
							var p = zim.Pick.choose(savedPicks[i], null, target);

							// also handle relative
							if (typeof p == "string" && i != "transform") {
								if (p.substr(0,1) != "+" && p.substr(0,1) != "-") {
									var newStart;
									if (target.zimLastObj && !zot(target.zimLastObj[i])) newStart = target.zimLastObj[i];
									else newStart = target[i];
									p = newStart + Number(p.replace(/\s/g,""));
								}
							}
							target.zimLastObj[i] = rewind?target.zimTweenOriginals[i]:p;
							// end handle relative

							// ZIM ZIM 02 patch to make non-rewind work with loopPick
							// the difference seems to be using tween.step.prev for rewind and tween.step for non-rewind
							// we had tween.step.prev for both since the beggining - we must not have tested on a non-rewind
							if (rewind) {
								if (!zot(savedPicks[i])) tween.step.prev.props[i] = p;
								if (i=="scaleX" && !zot(adjustedScale)) tween.step.prev.props.scaleX = adjustedScale;
								if (i=="scaleY" && !zot(adjustedScale)) tween.step.prev.props.scaleY = adjustedScale;
							} else {
								if (!zot(savedPicks[i])) tween.step.props[i] = p;
								if (i=="scaleX" && !zot(adjustedScale)) tween.step.props.scaleX = adjustedScale;
								if (i=="scaleY" && !zot(adjustedScale)) tween.step.props.scaleY = adjustedScale;
							}	
						}
					}
				} else {
					// can't seem to get from to work
					// at the moment sequence is not passing in from as it switches ahead of time
					// but just a plain from should work - just can't override the CreateJS tween
					// maybe it is a rewind issue...
					// if (tween.step && tween.step.props) {
					// 	for (var i in tween.step.props) {
					// 		if (extraTypes.indexOf(i) >= 0) continue; // skip for extras
					// 		if (!zot(savedPicks[i])) tween.step.props[i] = target[i] = zim.Pick.choose(savedPicks[i]);
					// 		if (i=="scaleX" && !zot(adjustedScale)) tween.step.props.scaleX = target.scaleX = adjustedScale;
					// 		if (i=="scaleY" && !zot(adjustedScale)) tween.step.props.scaleY = target.scaleY = adjustedScale;
					//
					// 	}
					// }
				}
			}			
		}
		var call4;
		if (cjsProps.loopWaitCall) {
			call4 = cjsProps.loopWaitCall;
			delete cjsProps.loopWaitCall;
		}
		var params4 = target;
		if (cjsProps.loopWaitParams) {
			params4 = cjsProps.loopWaitParams;
			delete cjsProps.loopWaitParams;
		}
		function doLoopWaitCall() {
			if (call4 && typeof call4 == 'function') {(call4)(params4||target);}
		}

		// START

		var call6;
		if (cjsProps.startCall) {
			call6 = cjsProps.startCall;
			delete cjsProps.startCall;
		}
		var params6;
		if (cjsProps.startParams) {
			params6 = cjsProps.startParams;
			delete cjsProps.startParams;
		}
		function doStartCall(tween) {
			if (tween.startCalled) return;
			tween.startCalled = true;
			if (call6 && typeof call6 == 'function') {(call6)(params6||target);}
		}

		// PERCENT TIME ADJUSTMENTS ZIM 015
		
		function setLatestTween(tween) {
			target.latestTween = tween;
			if (target.waiting) tween.startTime = Date.now();
			else tween.startTime = setStartTime;
			tween.zimLoop = loop;
			if (!target.animating) {
				target.pauseAnimate(true);
			}
			// if (zot(tween.percentComplete)) {
				Object.defineProperty(tween, 'percentComplete', {
					get: function() {
						return this.position / this.duration*100;
					},
					set: function(value) {
						this.setPosition(value*this.duration/100);
					}
				});
			// }
		}		

		// set the startTime of the actual tween based on a potential wait and series wait
		// also get a new target.tweenEndTime if there is a later end
		var dn = Date.now();
		if (!target.tweenStartTime) target.tweenStartTime = dn;
		if (!target.tweenEndTime) target.tweenEndTime = dn;
		var setStartTime = dn + (wait?wait:0) + (seriesWait?seriesWait:0);
		var newEnd = setStartTime + (ttt?ttt:0);
		if (newEnd > target.tweenEndTime) target.tweenEndTime = newEnd;
		
		
		// ADJUST EASE
		
		var customEases = [
			"ballisticIn", "ballisticOut", "ballisticInOut", 
			"snapIn", "snapOut", "snapInOut", 
			"slowmoIn", "slowmoOut", "slowmoInOut", 
		];
		if (customEases.indexOf(ease) != -1) {
			ease = assignEase(ease);
		}
		function assignEase(ease) {
			var ba = [0.4,0.75,0.9,.95];
			var sn = [0.99,-0.69,0.53,0.014];	
			var sm = [1.18,0.69,1,0.96];		
			
			if (ease == "ballisticIn") ease = zik(zim.zimEase(ba));
			else if (ease == "ballisticOut") ease = zik(zim.zimEase(ba).reverse());
			else if (ease == "ballisticInOut") ease = zik(zim.zimEase(ba, null, true)); // mirror
			else if (ease == "snapIn") ease = zik(zim.zimEase(sn));
			else if (ease == "snapOut") ease = zik(zim.zimEase(sn).reverse());
			else if (ease == "snapInOut") ease = zik(zim.zimEase(sn, null, true)); // mirror
			else if (ease == "slowmoIn") ease = zik(zim.zimEase(sm));
			else if (ease == "slowmoOut") ease = zik(zim.zimEase(sm).reverse());
			else if (ease == "slowmoInOut") ease = zik(zim.zimEase(sm, null, true)); // mirror
			return ease;
		}
		var ease2, finalEase, finalEase2
		if (cjsProps.rewind) {
			
			// flip second ease			
			if (ease) {				
				if (ease instanceof Function) { // zimEase
					ease2 = zik(ease.reverse());
				} else {
					// backIn backOut backInOut
					ease2 = ease;
					if (ease2.indexOf("InOut") == -1) {
						if (ease2.indexOf("Out") != -1) {
							ease2 = ease2.replace("Out", "In");
						} else if (ease2.indexOf("In") != -1) {
							ease2 = ease2.replace("In", "Out");
						}
					}
				}
			}
			if (rewindEase) {
				ease2 = rewindEase;
				if (customEases.indexOf(ease2) != -1) {
					ease2 = assignEase(ease2);
				}
			}
		}

		if (ease instanceof Function) {			
			finalEase = ease;
		} else {
			var equation = "get" + ease.charAt(0).toUpperCase()+ease.slice(1);
			var ea = zik(easeAmount);
			var ef = zik(easeFrequency);
			if ((!zot(ea) || !zot(ef)) && createjs.Ease[equation]) {
				if (!zot(ef) && zot(ea)) ea = 1;
				if (!zot(ea) && zot(ef)) ef = .3*1.5;
				finalEase = createjs.Ease[equation](ea, ef);
			} else {
				finalEase = createjs.Ease[ease];
			}
			
		}
		if (ease2) {
			if (ease2 instanceof Function) {
				finalEase2 = ease2;
			} else {
				equation = "get" + ease2.charAt(0).toUpperCase()+ease2.slice(1);
				ea = zik(easeAmount);
				ef = zik(easeFrequency);
				if ((!zot(ea) || !zot(ef)) && createjs.Ease[equation]) {
					if (!zot(ef) && zot(ea)) ea = 1;
					if (!zot(ea) && zot(ef)) ef = .3*1.5;
					finalEase2 = createjs.Ease[equation](ea, ef);
				} else {
					finalEase2 = createjs.Ease[ease2];
				}
			}
		}

		// ZIM 016 - HANDLE RE-ANIMATE - animating the same as already animating 
		// might override the tween so the previous does not finish 
		// and would not endTween() which removes tweens at id and turns off Ticker.
		// endTween(id);

		var oAr = [];
		for (var o in obj) {oAr.push(o);}
		oAr = oAr.sort().toString();
		if (!target.z_twpr) target.z_twpr = {};
		else if (!seriesWait > 0 && !wait > 0) { // adjusted in ZIM 016 patch to allow series to work
			var matchID = target.z_twpr[oAr];
			if (matchID) {
				endTween(matchID, true); // true prevents stopping all tweens in endTween
			}
		}		
		target.z_twpr[oAr] = id;

		// REWIND TWEENS
		
		function doRewindCall() {
			if (wait2>0) target.waiting = false;
			if (call2 && typeof call2 == 'function') {(call2)(params2);}
		}
		function doRewindWaitCall() {
			if (wait2>0) target.waiting = true;
			if (call5 && typeof call5 == 'function') {(call5)(params5);}
		}

		function preTween1(lastTween) {			
			prepareRelative2();					
			if (wait>0) {
				target.waiting = true;
				tween = target.zimTweens[id] = target.zimTween = createjs.Tween.get(target, {override:cjsProps.override}).wait(wait, true).call(function(){
					target.waiting = false;
					wait = 0;
					tween1(tween);				
					if (waitedCall && typeof waitedCall == 'function') {(waitedCall)(zot(waitedParams)?target:waitedParams);}
				});			
				tween.timeScale = target.futureRate;
				if (lastTween) transferIds(lastTween, tween);
				setLatestTween(tween);
			} else {
				tween1(lastTween);	
			}
		}
		
		function tween1(lastTween) {			
			var obj2 = getStart();			
			if (target.set && !from) target.set(set);				
			tween = target.zimTweens[id] =  target.zimTween = createjs.Tween.get(target, cjsProps)
				.call(doStartCall)	
				.to(obj, t, finalEase)				
				.call(doRewindWaitCall)
				.wait(wait2, true)
				.call(doRewindCall)
				.to(obj2, t2, finalEase2)
				.call(doneAnimating)
				.wait(wait3, true)
				.call(doLoopCall);
			tween.timeScale = target.futureRate;
			if (lastTween) transferIds(lastTween, tween);
			setZimTweenProps();
			setLatestTween(tween);
			
		}

		// // This was calling wait tween even if wait is 0 - not sure if we need it... maybe
		// // switched as part of ZIM 015 changes - same with preTween1

		// function preTween2(lastTween) {
		// 	prepareRelative2();		
		// 	if (wait > 0) target.waiting = true;
		// 	tween = target.zimTweens[id] = target.zimTween = createjs.Tween.get(target, {override:cjsProps.override}).wait(wait, true).call(function(){
		// 		wait = 0;
		// 		target.waiting = false;
		// 		tween2(tween);
		// 		if (waitedCall && typeof waitedCall == 'function') {(waitedCall)(zot(waitedParams)?target:waitedParams);}
		// 	});
		// 	tween.timeScale = target.futureRate;			
		// 	if (lastTween) transferIds(lastTween, tween);
		// 	setLatestTween(tween);
		// }
		function preTween2(lastTween) {			
			prepareRelative2();		
			if (wait > 0) {
				target.waiting = true;
				tween = target.zimTweens[id] = target.zimTween = createjs.Tween.get(target, {override:cjsProps.override}).wait(wait, true).call(function(){
					wait = 0;
					target.waiting = false;
					tween2(tween);
					if (waitedCall && typeof waitedCall == 'function') {(waitedCall)(zot(waitedParams)?target:waitedParams);}
				});
				tween.timeScale = target.futureRate;			
				if (lastTween) transferIds(lastTween, tween);
				setLatestTween(tween);
			} else {
				tween2(lastTween);
			}
		}
		function tween2(lastTween) {
			if (target.set && !from) {target.set(set);}
			tween = target.zimTweens[id] =  target.zimTween = createjs.Tween.get(target, cjsProps)
				.call(doStartCall)
				.to(obj, t, finalEase)				
				.call(doneAnimating)
				.wait(wait3, true)
				.call(doLoopCall);						
			tween.timeScale = target.futureRate;			
			if (lastTween) transferIds(lastTween, tween);
			setZimTweenProps();
			setLatestTween(tween);
		}
		
		if (cjsProps.rewind) {

			var wait2 = 0;
			delete cjsProps.rewind;

			// if need to access it later in dynamic
			rewind = true;
			rewindWait = cjsProps.rewindWait;

			if (cjsProps.rewindWait) {
				wait2 = cjsProps.rewindWait;
				delete cjsProps.rewindWait; // not a createjs prop so delete
			}

			var call2;
			if (cjsProps.rewindCall) {
				call2 = cjsProps.rewindCall;
				var params2 = cjsProps.rewindParams;
				if (zot(params2)) params2 = target;
				delete cjsProps.rewindCall;
				delete cjsProps.rewindParams;
			}			
			var call5;
			if (cjsProps.rewindWaitCall) {
				call5 = cjsProps.rewindWaitCall;
				var params5 = cjsProps.rewindWaitParams;
				if (zot(params5)) params5 = target;
				delete cjsProps.rewindWaitCall;
				delete cjsProps.rewindWaitParams;
			}			
			if (seriesWait > 0 || sequenceWait > 0 || wait > 0) { // do not want wait as part of future loops (use loopWait)
				if (seriesWait > 0 || sequenceWait > 0) {
					target.waiting = true;
					tween = target.zimTweens[id] = target.zimTween = createjs.Tween.get(target, {override:cjsProps.override})
						.wait(seriesWait>0?seriesWait:0, true)
						.wait(sequenceWait>0?sequenceWait:0, true)
						// .call(function(){
						// 	if (sequenceCall && typeof sequenceCall == 'function') {(sequenceCall)(zot(sequenceParams)?target:sequenceParams);}
						// })
						.call(function(target){
							target.waiting = false;
							sequenceWait = seriesWait = 0;
							preTween1(tween);
						});
					tween.timeScale = target.futureRate;
					setLatestTween(tween);
				} else {
					preTween1();
				}
			} else {
				prepareRelative2();
				tween1();
			}

		} else {  // NOT REWIND TWEENS

			if (seriesWait > 0 || sequenceWait > 0 || wait > 0) { // do not want wait as part of future loops (use loopWait)
				
				if (seriesWait > 0 || sequenceWait > 0) {		
					target.waiting = true;					
					tween = target.zimTweens[id] = target.zimTween = createjs.Tween.get(target, {override:cjsProps.override})
						.wait(seriesWait>0?seriesWait:0, true)
						.wait(sequenceWait>0?sequenceWait:0, true)
						// .call(function(){
						// 	if (sequenceCall && typeof sequenceCall == 'function') {(sequenceCall)(zot(sequenceParams)?target:sequenceParams);}
						// })
						.call(function(){
							sequenceWait = seriesWait = 0;
							target.waiting = false;
							preTween2(tween);
						});
						tween.timeScale = target.futureRate;
						setLatestTween(tween);
				} else {
					preTween2();
				}
			} else {
				prepareRelative2();	
				tween2();
			}			
		}

		function transferIds(lastTween, tween) {
			tween.zimIdSet = lastTween.zimIdSet; // know we need this one - not sure about the rest 10.4.0
			tween.zimObj = lastTween.zimObj;
			tween.zimTicker = lastTween.zimTicker;
			tween.zimExtraTickers = lastTween.zimExtraTickers;
			tween.requestID = lastTween.requestID;
		}

		tween.startPaused = startPaused; // turned off by pause(false) or pauseAnimate(false) or setting percentComplete
		tween.rewinding = false;

		if (!zot(rate)) tween.timeScale = zim.Pick.choose(rate, null, target);

		// ANIMATE CALL
		if (cjsProps.animateCall) {
			animateCall = cjsProps.animateCall;
			delete cjsProps.animateCall;
		}
		if (cjsProps.animateParams) {
			animateParams = cjsProps.animateParams;
			delete cjsProps.animateParams;
		}

		// SET TICKER
		var zimTicker;
		if (!css && ticker) {
			// moved this to after Tween has started so rewind is taken into account, etc.
			// do not want to reset percentComplete at the end incase dragging
			// so just reset it to 0 if at 100
			// means to purposely start at end, must set rewind true and start at 50% and animate to 100% for instance
			if (startPercentComplete) {
				target.pathRatio = (target.percentComplete && Math.round(target.percentComplete) != 100)?target.percentComplete/100:0;
				target.percentCompleteNoAngle = Math.round(startPercentComplete) != 100?startPercentComplete:0;
			}
            
			if (events && !zot(sequenceTarget) && sequenceTarget.dispatchEvent) {
				zimTicker = zim.Ticker.add(function(){
					if (effectCheck) target.updateEffects();
					if (pathObject || pathOrient || pathFlip || pathFlipVertical) {handlePath();}
					sequenceTarget.dispatchEvent("animation");
				}, stage);
			} else if (events && target.dispatchEvent) {
				zimTicker = zim.Ticker.add(function(){
					if (effectCheck) target.updateEffects();
					if (pathObject || pathOrient || pathFlip || pathFlipVertical) {handlePath();}
					target.dispatchEvent("animation");
				}, stage);
			} else if (animateCall && typeof animateCall == "function") {
				zimTicker = zim.Ticker.add(function(){
					if (effectCheck) target.updateEffects();					
					if (pathObject || pathOrient || pathFlip || pathFlipVertical) {handlePath();}
					animateCall(animateParams||target);
				}, stage);
			} else {		                	
				zimTicker = zim.Ticker.add(function(){
					if (effectCheck) target.updateEffects();					
					if (pathObject || pathOrient || pathFlip || pathFlipVertical) {handlePath();}
				}, stage);
			}
		}
		
		function totalArr(arr) {
			if(!Array.isArray(arr)) return;
			var totalNumber = 0;
			for (var i=0,l=arr.length; i<l; i++) {
				totalNumber+=arr[i];
			}
			return totalNumber;
		}

		var forwardStack = [1,1,1];
		// var lastAA = 0; // commented out in path animation
		// var adjustA = 1;
		
				
		var handlePath = function () {
			if (!target.parent || tween.passive || tween.startPaused) return;
			if (drag && rewind && ((lastPathPercent < 50 && target.percentComplete > 50) || (lastPathPercent > 50 && target.percentComplete < 50))) {
				lastForward = target.percentComplete<50;
			}
			lastPathPercent = target.percentComplete;

			if (pathObject) {
				if (dynamicPath) {
					segments = pathObject.segmentPoints;
					percents = pathObject.segmentRatios;
				}

				if (drag) {
					var newPoint = pathObject.getCurvePoint(target.pathRatio, percents, segments);
				} else {
					target.currentPercent = target.startPercent + target.percent*target.pathRatio;
					var newPointRatio = ((1000000+target.currentPercent)%100)/100;
					if (target.pathRatio==1) newPointRatio+=target.percent>0?1:0;
					newPoint = pathObject.getCurvePoint(newPointRatio, percents, segments);
				}

				if (newPoint) {
					// latestSegmentIndex = newPoint.z; // point on path before the calculated point - used with drag
					var locPoint = target.parent.globalToLocal(newPoint.x, newPoint.y);
					target.x = locPoint.x;
					target.y = locPoint.y;
				}
			}
			var diffX = Math.abs(lastX - target.x),
			diffY = Math.abs(lastY - target.y);	
			var opposite = (startAngle==90||startAngle==270||startAngle==-90);
			// if (pathFlip && flipCheck) {
			// 	if (diffX < .01 && zim.sign(opposite?target.scaleY:target.scaleX) != zim.sign(startFlip)) {opposite?target.scaleY*=-1:target.scaleX*=-1;}
			// 	else if (Math.round(lastX) > Math.round(target.x) && diffX > .01 && zim.sign(opposite?target.scaleY:target.scaleX) == zim.sign(startFlip)) {opposite?target.scaleY*=-1:target.scaleX*=-1;}
			// 	else if (Math.round(lastX) < Math.round(target.x) && diffX > .01 && zim.sign(opposite?target.scaleY:target.scaleX) != zim.sign(startFlip)) {opposite?target.scaleY*=-1:target.scaleX*=-1;}
			// }
			// if (pathFlipVertical && flipCheck) {
			// 	if (Math.round(lastY) > Math.round(target.y) && diffY > .01 && zim.sign(opposite?target.scaleX:target.scaleY) == zim.sign(startFlipVertical)) opposite?target.scaleX*=-1:target.scaleY*=-1;
			// 	if (Math.round(lastY) < Math.round(target.y) && diffY > .01 && zim.sign(opposite?target.scaleX:target.scaleY) != zim.sign(startFlipVertical)) opposite?target.scaleX*=-1:target.scaleY*=-1;
			// }

			if (pathFlip && flipCheck) {
				if (lastX > target.x && diffX > .01 && zim.sign(opposite?target.scaleY:target.scaleX) == zim.sign(startFlip)) {opposite?target.scaleY*=-1:target.scaleX*=-1;}
				else if (lastX < target.x && diffX > .01 && zim.sign(opposite?target.scaleY:target.scaleX) != zim.sign(startFlip)) {opposite?target.scaleY*=-1:target.scaleX*=-1;}
				else if ((target.percentComplete < 99 && target.percentComplete > 1) && diffX < .01 && diffY > .01 && zim.sign(opposite?target.scaleY:target.scaleX) != zim.sign(startFlip)) {opposite?target.scaleY*=-1:target.scaleX*=-1;}
			}
			if (pathFlipVertical && flipCheck) {
				if (lastY > target.y && diffY > .01 && zim.sign(opposite?target.scaleX:target.scaleY) == zim.sign(startFlipVertical)) {opposite?target.scaleX*=-1:target.scaleY*=-1;}
				else if (lastY < target.y && diffY > .01 && zim.sign(opposite?target.scaleX:target.scaleY) != zim.sign(startFlipVertical)) {opposite?target.scaleX*=-1:target.scaleY*=-1;}
				else if ((target.percentComplete < 99 && target.percentComplete > 1) && diffY < .01 && diffX > .01 && zim.sign(opposite?target.scaleX:target.scaleY) != zim.sign(startFlipVertical)) {opposite?target.scaleX*=-1:target.scaleY*=-1;}
			}

			var aa;
			if (pathOrient && diffX > .05 || pathOrient && diffY > .05) {
				if (pathObject==pathOrient) {
					aa = zim.angle(lastX, lastY, target.x, target.y)+startAngle;
				} else {
					var orientPoint;
					if (pathOrient.parent) {
						orientPoint = pathOrient.parent.localToLocal(pathOrient.x, pathOrient.y, target.parent);
					} else {
						orientPoint = target.parent.globalToLocal(pathOrient.x, pathOrient.y);
					}
					aa = zim.angle(target.x, target.y, orientPoint.x, orientPoint.y)+startAngle;
				}

				if (aa != 0) {
					if (!target.paused || movingCheck) {
						if (pathFlip && lastX-target.x > .01) aa += 180;
						var aaa = aa;
						// if (!pathFlip && lastX-target.x > 0 && pathFlipVertical) aaa = aa-180;
						target.rotation = Math.round(aaa==startAngle?target.rotation:aaa);			
						if (rewind && target.percentComplete > 50 && !pathFlip) target.rotation += 180
					}
				}
			}
		
		

		// var handlePath = function () {	
		// 	if (!target.parent || tween.passive || tween.startPaused) return;
		// 	if (drag && rewind && ((lastPathPercent < 50 && target.percentComplete > 50) || (lastPathPercent > 50 && target.percentComplete < 50))) {
		// 		lastForward = target.percentComplete<50;
		// 	}
		// 	lastPathPercent = target.percentComplete;
		// 
		// 	if (pathObject) {
		// 		if (dynamicPath) {
		// 			segments = pathObject.segmentPoints;
		// 			percents = pathObject.segmentRatios;
		// 		}
		// 
		// 		if (drag) {
		// 			var newPoint = pathObject.getCurvePoint(target.pathRatio, percents, segments);
		// 		} else {
		// 			target.currentPercent = target.startPercent + target.percent*target.pathRatio;
		// 			var newPointRatio = ((1000000+target.currentPercent)%100)/100;
		// 			if (target.pathRatio==1) newPointRatio+=target.percent>0?1:0;
		// 			newPoint = pathObject.getCurvePoint(newPointRatio, percents, segments);
		// 		}
		// 
		// 		if (newPoint) {
		// 			// latestSegmentIndex = newPoint.z; // point on path before the calculated point - used with drag
		// 			var locPoint = target.parent.globalToLocal(newPoint.x, newPoint.y);
		// 			target.x = locPoint.x;
		// 			target.y = locPoint.y;
		// 		}
		// 	}
		// 	var opposite = (startAngle==90||startAngle==270||startAngle==-90);
		// 
		// 	var adjust = .05;
		// 
		// 	// if (pathFlip && flipCheck) {
		// 	// 	if (lastX > target.x+adjust && zim.sign(opposite?target.scaleY:target.scaleX) == zim.sign(startFlip)) opposite?target.scaleY*=-1:target.scaleX*=-1;
		// 	// 	if (lastX < target.x-adjust && zim.sign(opposite?target.scaleY:target.scaleX) != zim.sign(startFlip)) opposite?target.scaleY*=-1:target.scaleX*=-1;
		// 	// }
		// 	// if (pathFlipVertical && flipCheck) {
		// 	// 	if (lastY > target.y+adjust && zim.sign(opposite?target.scaleX:target.scaleY) == zim.sign(startFlipVertical)) opposite?target.scaleX*=-1:target.scaleY*=-1;
		// 	// 	if (lastY < target.y-adjust && zim.sign(opposite?target.scaleX:target.scaleY) != zim.sign(startFlipVertical)) opposite?target.scaleX*=-1:target.scaleY*=-1;
		// 	// }
		// 
		// 	if (pathFlip && flipCheck) {
		// 	    if (lastX == target.x) {target.scaleX = startFlip}
		// 	    else if (Math.round(lastX) < Math.round(target.x) && target.scaleX != startFlip) {target.scaleX*=-1;}
		// 	    else if (Math.round(lastX) > Math.round(target.x) && target.scaleX == startFlip) {target.scaleX*=-1;}
		// 	}
		// 
		// 	var aa;
		// 	if (pathOrient) {
		// 		if (pathObject==pathOrient) {
		// 			aa = zim.angle(lastX, lastY, target.x, target.y)+startAngle;
		// 		} else {
		// 			var orientPoint;
		// 			if (pathOrient.parent) {
		// 				orientPoint = pathOrient.parent.localToLocal(pathOrient.x, pathOrient.y, target.parent);
		// 			} else {
		// 				orientPoint = target.parent.globalToLocal(pathOrient.x, pathOrient.y);
		// 			}
		// 			aa = zim.angle(target.x, target.y, orientPoint.x, orientPoint.y)+startAngle;
		// 		}
		// 
		// 		if (aa != 0) {
		// 			if (!target.paused || movingCheck) {
		// 				if (pathFlip && lastX-target.x > .05) aa += 180;
		// 				var aaa = aa;
		// 				// if (!pathFlip && lastX-target.x > 0 && pathFlipVertical) aaa = aa-180;
		// 				target.rotation = aaa==startAngle?target.rotation:aaa;			
		// 				if (rewind && target.percentComplete > 50 && !pathFlip) target.rotation += 180
		// 			}
		// 		}
		// 	}
				
			// if (pathOrient) {
			// 
			// 	var aa;
			// 	if (pathObject==pathOrient) {
			// 		aa = zim.angle(lastX, lastY, target.x, target.y)+startAngle;
			// 	} else {
			// 		var orientPoint;
			// 		if (pathOrient.parent) {
			// 			orientPoint = pathOrient.parent.localToLocal(pathOrient.x, pathOrient.y, target.parent);
			// 		} else {
			// 			orientPoint = target.parent.globalToLocal(pathOrient.x, pathOrient.y);
			// 		}
			// 		aa = zim.angle(target.x, target.y, orientPoint.x, orientPoint.y)+startAngle;
			// 	}
			// 
			// 	aa = (aa+360*100000)%360;								
			// 	if (aa != 0) { //  || !target.zimAnimateDragDown) {					
			// 		if (!target.paused || movingCheck) {						
			// 			var sid = (aa>0&&aa<180)?1:-1;	
			// 			var rever = (rewind && target.percentComplete > 50)?-1:1;											
			// 			var aaa = lastAA+360*100000-(aa+360*100000);
			// 			if (aaa != -180 && aaa != 180) {
			// 				if (aaa > 1) adjustA = -1;
			// 				if (aaa < -1) adjustA = 1;
			// 			}	
			// 			lastAA = aa;
			// 			if (pathFlip && lastX-target.x > .05*sid*rever*adjustA) aa += 180;						
			// 			target.rotation = aa;
			// 			if (rever && !pathFlip) target.rotation += 180
			// 		}
			// 	}
			// }
			// picking up target can sway results so take average of last three
			// could possibly use this with flip to make it less jittery when dropping

			if (drag) {
				var diff = target.x-lastX + target.y-lastY;
				if (Math.abs(diff) > 2) {
					forwardStack.push(zim.sign(diff));
					forwardStack.shift();
					// tween.forward = forwardStack.reduce((a,b) => a+b, 0) > 0;
					tween.forward = totalArr(forwardStack);
				}
			}

			lastX = target.x;
			lastY = target.y;
		};
		
		
		// there is only one percentComplete on a target
		// this will overwrite the handlePath function used by that percentComplete
		// so that the proper drag scope is used - complex - fixed in 10.6.1
		// will not be able to animate properly after a drag - use containers
		if (pathObject || pathOrient || pathFlip || pathFlipVertical) target.handlePath = handlePath;


		// SET MASK TO DYNAMIC
		if (!zot(target.zimMaskDynamic)) target.zimMaskApply(); // set mask set by zimMask to dynamic


		// ANIMATION DONE AND HELPER FUNCTIONS
		function doneAnimating() {
			if (target.seriesTweens) target.seriesTweens.shift();
			if (target.seriesCalls) target.seriesCalls.shift();
			if (target.seriesParams) target.seriesParams.shift();
			if (target.paused && target.type != "Sprite") {
				// ZIM 015 - not sure why we want to call this when paused 
				// as it activates the animation if in series
				// if (call && typeof call == 'function') {(call)(params);}
				return;
			}
			if (cjsProps.loop) {
				if (count > 0) {
					if (currentCount < count) {
						if (wait3>0) target.waiting = true;
						doLoopWaitCall();
						currentCount++;
						return;
					} else {
						if (rewind) {
							if (target.set) target.set(getStart());
						} else {							
							if (target.set) target.set(obj);
						}
					}
				} else {
					if (wait3>0) target.waiting = true;
					doLoopWaitCall();
					return;
				}
			}

			// ZIM 015 - this was the first thing we tried to scrub a series with percentComplete 
			// there were lots of other things too to make it work.
			// Leaving the seriesTween test in here... but probably not doing much			
			if (clean) endTween(id);
			else {
				if (target.seriesTweens) {
					if (target.seriesTweens.length == 0) target.pauseAnimate(true, id);
				} else {
					target.pauseAnimate(true, id);
				}
			}

			// calling sequenceCall in loop as well so don't call here if looping - ZIM Cat 03
			if (!cjsProps.loop && sequenceCall && typeof sequenceCall == 'function') {
				var sp = zot(sequenceParams) ? target : sequenceParams;
				(sequenceCall)(sp);
			}
			if (call && typeof call == 'function') {(call)(params);}
		}
		function getStart() {
			// for rewind, we need to know the start value
			// which could be modified by the set parameter
			var startObj = {};
			for (var i in obj) {
				if (css && target.style) {
					if (!zot(set[i]) && !from) {
						startObj[i] = set[i];
					} else {
						if (i=="transform") startObj[i] = target.style[i];
						else startObj[i] = zum(target.style[i]);
					}
				} else {
					if (!zot(set[i]) && !from) {
						// !!!!!! maybe fix for dot plugin
						startObj[i] = set[i];
					} else {
						if (i.substr(0,1) == ".") {
							var dots = i.split(".");
							var lastdot = target;
							for (var j=1; j<dots.length; j++) {
								lastdot = lastdot[dots[j]];
							}
							startObj[i] = lastdot;
						} else {
							startObj[i] = target[i];
						}
					}
				}
			}
			return startObj;
		}
		function removeBusy(obj) {
			if (!target.zimBusy) return;
			for (var o in obj) {
				delete target.zimBusy[o];
			}
			if (zim.isEmpty(target.zimBusy)) target.zimBusy = null;
		}

		// PAUSE AND STOP MANAGEMENT
		var zimPaused = false;
		setZimTweenProps();
		function setZimTweenProps() {
			// used to keep track of tweens for various ids
			// for pauseAnimate() and stopAnimate() down below
			tween.zimObj = obj;
			tween.zimTicker = zimTicker;
			tween.zimPaused = zimPaused;
			if (idSet) tween.zimIdSet = idSet;
			if (providedID) {
				// add to zim.idSets for global animation pause and stop by id
				// zim.idSets = {id:[target, target], id:[target, target, target]}
				// watchout - global idSet works on provided IDS
				// local idSets work on multiple ids that are the same
				// so an object with one tween under a provided id is not locally an idSet
				if (zot(zim.idSets)) zim.idSets = {};
				if (zot(zim.idSets[providedID])) {
					zim.idSets[providedID] = [target];
				} else {
					if (zim.idSets[providedID].indexOf(target) < 0) zim.idSets[providedID].push(target); // ES6 needed
				}
			}
			if (!zim.animatedObjects) zim.animatedObjects = new zim.Dictionary(true);
			zim.animatedObjects.add(target, true);
		}
		function endTween(id, overrideEnd) {            
			if (target.tweenStates && target.tweenStates[id]) delete target.tweenStates[id];
			if (zot(target.zimTweens) || zot(target.zimTweens[id])) return;
			target.zimX = null;
			target.zimY = null;
			removeBusy(target.zimTweens[id].zimObj);
			target.zimTweens[id].paused = true;
			endTicker(id);
			var idSet = target.zimTweens[id].zimIdSet;
			if (!zot(idSet) && target.zimIdSets) {
				var sets = target.zimIdSets[idSet];
				if (sets) sets.splice(sets.indexOf(id), 1);
				if (sets && sets.length == 0) {
					delete target.zimIdSets[idSet];
					if (zim.isEmpty(target.zimIdSets)) delete target.zimIdSets;
				}
			}
            
			//target.pathRatio = null;
			if (target.type == "Pen" && target.zimOnPath) {target.stop(); target.zimOnPath = false;}
			delete target.zimTweens[id];
			
			target.zimLastObj = null; // added ZIM NFT 01 patch

			// BUG
			// fast consecutive overlapping animates are not clearing zimTweens
			// so the pause is not being set - need to fix somehow - still broken
			// For instance animating something on a click and then tripple clicking really fast
			// Where this is an issue in app, prevent fast multiple activations of animate
			// For instance set object to mouseEnabled = false until animate is complete
			// then set object to mouseEnabled = true in call function
			if (!overrideEnd && zim.isEmpty(target.zimTweens)) {
				target.stopAnimate(null,null,null,false,true); // last true is internal
			}           

			// handle zim.idSets
			// very tricky - the originating id for an idSet does not get an idSet
			// but rather its id is used by subsequent tweens for the tween.idSets
			// the originating id may create a zim.idSets if it was provided as a parameter
			if ((target.zimTweens && target.zimTweens[id]) ||
				(target.zimIdSets && target.zimIdSets[idSet?idSet:id])) {
					// leave zim.idSets alone
			} else {
				if (zim.idSets && zim.idSets[idSet?idSet:id]) {
					zim.idSets[idSet?idSet:id];
					var targetIndex = zim.idSets[idSet?idSet:id].indexOf(target);
					if (targetIndex >= 0)  zim.idSets[idSet?idSet:id].splice(targetIndex, 1);
					if (zim.idSets[idSet?idSet:id].length <= 0) {
						delete zim.idSets[idSet?idSet:id];
						if (zim.isEmpty(zim.idSets)) delete zim.idSets;
					}
				}
			}
		}
		function endTicker(id) {
			// need a little delay to make sure updates the last animation
			// and to help call function have a stage update
			// store reference to ticker function in a closure
			// as we may delete the zimTweens reference before the 200 ms is up
			-function() {
				var ticker = target.zimTweens[id].zimTicker;
				if (target.zimTweens[id].extraTickers) {
					for (var k=0; k<target.zimTweens[id].extraTickers.length; k++) {
						zim.Ticker.remove(target.zimTweens[id].extraTickers[k]);
					}
				}
				// if (ticker) zim.Ticker.remove(ticker); ticker = null;
				if (target.zimTweens[id].requestID) cancelAnimationFrame(target.zimTweens[id].requestID);				
				if (ticker) {
					setTimeout(function(){
						if (ticker) zim.Ticker.remove(ticker); ticker = null;
					},200);
				}
			}();
		}
		function pauseTicker(id, paused) {
			
			var tween = target.zimTweens[id];
			tween.paused = paused;
			if (paused == tween.zimPaused) return;			
			tween.zimPaused = paused;

			if (paused) {					
				if (tween.zimTicker) tween.zimAnimateTimeout = setTimeout(function(){zim.Ticker.remove(tween.zimTicker);},200);
				// if (target.zimZoomTicker) zim.Ticker.remove(target.zimZoomTicker);
			} else {		
				tween.startPaused = false;
				clearTimeout(tween.zimAnimateTimeout);				
				if (tween.zimTicker) tween.zimTicker = zim.Ticker.add(tween.zimTicker, stage);
				// if (target.zimZoomTicker) target.zimZoomTicker = zim.Ticker.add(target.zimZoomTicker, stage);
			}
		}
		function expandIds(ids) {
			// turn any idSets into ids
			var actualIds = [];
			for (var i=0; i<ids.length; i++) {
				if (target.zimIdSets && !zot(target.zimIdSets[ids[i]])) {
					actualIds = actualIds.concat(target.zimIdSets[ids[i]]);
				} else {
					actualIds.push(ids[i]);
				}
			}
			return actualIds;
		}

		// METHODS ADDED TO TARGET
		
		if (!target.stopAnimate || !target.stopAnimate.real) { // empty method gets added by default
			target.stopAnimate = function(ids, toEnd, include, command, internal) {
				var id;
				target.dynamicAnimation = null;	
							
				if (internal && drag) { // zim 10.7.1 fix to still drag if done animating
					target.pauseAnimate();
					return;
				}
				
				if (zot(ids)) {
					target.tweenStates = {}; // all are off
				}
				
				if (toEnd) {
					target.endTween(null, ids);
					return target;
				}
				// can't risk turning percentComplete off as only one per all animations
				// instead, evaluate how percentComplete is set when starting an animation
				// if there is no getter setter or a value has been changed when not tweening
				// then assumes percentComplete is desired else sets to 0 when starting an animation
				// if (internal) target.percentComplete = target.pathRatio = 0;

				if (zot(command)) command = true;
				if (target.pan == undefined) {
					if (target.type != undefined) target.paused = true;
					target.animating = false;
				}
				if (target.type == "Pen" && target.zimOnPath) {target.stop(); target.zimOnPath = false;}
				if (zot(include)) include = true;
				if (command && drag) {
					if (pathObject) pathObject.off("change", target.zimAnimatePathChange);
					target.off("mousedown", target.zimAnimateDragDown);
					target.off("pressmove", target.zimAnimateDragPress);
					target.off("pressup", target.zimAnimateDragUp);
					if (target.amu) stage.frame.off("mouseupplus", target.amu);	
					zim.Ticker.remove(target.zimDragAnimateTicker);
				}
				if (zot(ids)) {
					if (!include) return target; // would be exclude all ids
					target.zimBusy = null; // clear any busy properties
					createjs.Tween.removeTweens(target);
					for (id in target.zimTweens) {
						endTicker(id);						
					}
					target.zimTweens = null;
					target.zimIdSets = null;
					target.zimTween = null;
					// NOT SURE WHAT ID SHOULD BE REFERENCED BELOW - ZIM ZIM 00
					if (zim.idSets && zim.idSets[idSet?idSet:id]) {
						delete zim.idSets[idSet?idSet:id];
						if (zim.isEmpty(zim.idSets)) delete zim.idSets;
					}
					zim.animatedObjects.remove(target);	
					
				} else {
					if (!Array.isArray(ids)) ids = [ids];
					// expand any idSets into ids
					var actualIds = expandIds(ids);
					for (id in target.zimTweens) {
						if (target.zimTweens[id].requestID) {
							cancelAnimationFrame(target.zimTweens[id].requestID);
						}
						if (include && actualIds.indexOf(id) >= 0) {
							endTween(id, command);							
						}
						if (!include && actualIds.indexOf(id) < 0) {
							endTween(id, command);
						}
					}
				}
				
				// if (zimTicker) zim.Ticker.remove(zimTicker);
				// zog(target)
				return target;
			};
			target.stopAnimate.real = true; // record this as real method instead of empty method
			target.pauseAnimate = function(paused, ids, include, ignoreDynamic) {				
				if (paused!==false) target.percentComplete; // run the percentComplete before setting pause
				var id;			
				if (ids=="pauseOnBlur") {	
					ids = null;
				} else if (zot(ids)) {
					target.tweenStates = {all:paused===false?true:false}; // either all on or all off 
				}
				
				if (target.type == "Pen") {
					if (paused === false) {
						if (target.zimOnPath) target.infinite = true;
					} else {
						target.stop();
					}
				}
				if (usingDynamic && !ignoreDynamic) {
					if (zot(ids)) { // want all ids	
						// added in ZIM NFT 00 patch - not sure about it...
						// it matches what we do when not dynamic
						// works but jumps to new value too quickly in speed? 
						// due to extra tickers?
						for (id in target.zimTweens) {pauseTicker(id, paused);}
					} else {
						target.pause(paused, ids);
					}					
					return target;
				}

				if (zot(paused)) paused = true;
				mouseCheck = false;
				if (target.type != undefined) target.paused = paused; 
				target.animating = !paused;
				if (zot(include)) include = true;
				if (zot(ids) && !include) return target; // would exclude all ids
				if (zot(ids)) { // want all ids
					for (id in target.zimTweens) {pauseTicker(id, paused);}
				} else {
					if (!Array.isArray(ids)) ids = [ids];
					// expand any idSets into ids
					var actualIds = expandIds(ids);
					for (id in target.zimTweens) {
						if (include && actualIds.indexOf(id) >= 0) {
							pauseTicker(id, paused);
							target.tweenStates[id] = !paused;
						}
						if (!include && actualIds.indexOf(id) < 0) {
							pauseTicker(id, paused);
							target.tweenStates[id] = !paused;
						}
					}
				}		
				if (target.type=="Sprite") {
					if (!target.running) target.stop();
				}			
				return target;
			};
		}

		// start NIO updates 2
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		if (startPaused) target.pauseAnimate(true, id, null, true); // last true overrides dynamic check

		// EXTRA SETUP
		var extra;
		if (obj.extra) {
			extra = obj.extra;
			delete obj.extra;
			if (!Array.isArray(extra)) extra = [extra];
		}
		// handle incoming convenience properties:
		for (i=0; i<extraTypes.length; i++) {
			var type = extraTypes[i];
			if (obj[type]) {
				if (zot(extra)) extra = [];
				makeExtra(type, obj[type]);
				delete obj[type];
			}
		}
		function makeExtra(prop, arr) {
			if (arr === true) extra.push({outputProp:extraLookup[prop]});
			else if (Array.isArray(arr)) extra.push({outputProp:extraLookup[prop], outputMin:arr[0], outputMax:arr[1], inputMin:arr[2], inputMax:arr[3]});
			else extra.push({outputProp:extraLookup[prop], outputMax:arr});
		}

		if (extra) {
			target.zimStartScaleX = target.scaleX;
			target.zimStartScaleY = target.scaleY;
			tween.extraTickers = [];
			var extraProportion;
			for (i=0; i<extra.length; i++) {
				var eObj = extra[i];
				if (zot(eObj.inputObj)) eObj.inputObj = target;
				if (zot(eObj.inputProp)) eObj.inputProp = "y";
				if (zot(eObj.inputMin)) eObj.inputMin = 0;
				if (zot(eObj.inputMax)) eObj.inputMax = eObj.inputProp=="x"?stage.width:stage.height;
				if (zot(eObj.outputObj)) eObj.outputObj = target;
				if (zot(eObj.outputProp)) eObj.outputProp = "scale";
				if (zot(eObj.outputMin)) eObj.outputMin = 0;
				if (zot(eObj.outputMax)) eObj.outputMax = eObj.outputMin + 1;
				if (zot(eObj.constrain)) eObj.constrain = true;

				// ZIK all property values!
				for (var j in eObj) {
					obj[j] = zim.Pick.choose(obj[j], null, target);
				}
				if (eObj.outputProp == "percentSpeed") dynamic = true;

				extraProportion = new zim.Proportion(
					eObj.inputMin, eObj.inputMax,
					eObj.outputMin, eObj.outputMax,
					eObj.factor, eObj.outputRound
				);
				var func = function() { // closure
					var eO = eObj;
					var eP = extraProportion;
					return function () {
						var newValue;
						var eTarget = eO.outputObj;
						// adjusted for local to global ZIM 10.7.0
						var iV = eO.inputObj[eO.inputProp];
						if (eO.inputProp == "x" || eO.inputProp == "y") {
							if (eO.inputObj.parent) {
								var ppp = eO.inputObj.parent.localToGlobal(iV,iV);
								iV = ppp[eO.inputProp];
							}
						}
						if (eO.constrain) newValue = zim.constrain(eP.convert(iV), eO.outputMin, eO.outputMax);
						else newValue = eP.convert(iV);
						if (Number.isNaN(newValue)) newValue = eO.outputMin!=null?eO.outputMin:0;

						// if (eO.constrain) newValue = zim.constrain(eP.convert(eO.inputObj[eO.inputProp]), eO.outputMin, eO.outputMax);
						// else newValue = eP.convert(eO.inputObj[eO.inputProp]);
						// various convenience properties and exceptions
						if (eO.outputProp == "scale") {
							eTarget.scaleX = zim.sign(eTarget.scaleX)*newValue;
							eTarget.scaleY = zim.sign(eTarget.scaleY)*newValue;
						} else if (eO.outputProp == "scaleX") {
							eTarget.scaleX = zim.sign(eTarget.scaleX)*newValue;
						} else if (eO.outputProp == "scaleY") {
							eTarget.scaleY = zim.sign(eTarget.scaleY)*newValue;
						} else if (eO.outputProp == "layer") {
							if (!eTarget.parent) return;
							var newLayer = zim.constrain(Math.round(newValue),0,eTarget.parent.numChildren-1);
							if (newLayer != eTarget.parent.getChildIndex(eTarget)) eTarget.parent.setChildIndex(eTarget, newLayer);
						} else if (eO.outputProp == "percentSpeed") {
							eTarget[eO.outputProp] = newValue*100;
						} else {
							eTarget[eO.outputProp] = newValue;
						}
					};
				}();
				func();
				tween.extraTickers.push(zim.Ticker.add(func, stage));
			}
		}
		// DYNAMIC ANIMATION
		var usingDynamic;
		function advanceTween() {
			tween.requestID = requestAnimationFrame(advanceTween);
			if (!dynamic || (tween.startPaused && target.percentSpeed==0)) return;					
			tween.startPaused = false;
			if (tween != myTween) {
				myTween = tween;
				tween.currentTime = 0;
				target.pauseAnimate(true, id, null, true);
				if (target.type != undefined) target.paused = false;
				target.animating = true;
				setToMiddle = (!sequenceWait && !seriesWait && !wait && !count && cjsProps.loop);
			}
			if (setToMiddle) {
				tween.currentTime += 10000 * calculatedDuration;
				tween.setPosition(tween.currentTime, true);
				setToMiddle = false;
			}

			var newTime = tween.currentTime+baseSpeed*target.percentSpeed/100;
			if (clampEnd && wait==0) newTime = zim.constrain(newTime, 0, clampEnd);
			tween.currentTime = newTime;

			tween.setPosition(tween.currentTime);
			if (pathObject || pathOrient || pathFlip || pathFlipVertical) {handlePath();}
			stage.update();
		}
		if (dynamic) target.dynamicAnimation = true;
		if (dynamic || target.zimAnimateDragDown) {
			if (dynamic) {		
				usingDynamic = true;
				target.pauseAnimate(true, id, null, true); // last true overrides dynamic check
				if (target.type != undefined) target.paused = false;
				target.animating = true;
				tween.currentTime = 0;
				var myTween = tween;
				if (zot(target.percentSpeed)) target.percentSpeed = tween.startPaused?0:100;
				var baseSpeed = 1000/60;
				tween.currentTime = 0;
				var setToMiddle = (!sequenceWait && !seriesWait && !wait && !count && cjsProps.loop);
				if (clamp && cjsProps.loop && !count) clamp = false;
				var calculatedDuration = time + (rewind?(rewindTime?rewindTime:time):0) + (rewindWait?rewindWait:0) + (loopWait?loopWait:0);
				calculatedDuration *= timeType=="s"?1000:1;
				var clampMultiplier = 1;
				if (cjsProps.loop && count) clampMultiplier = count;
				var clampEnd;
				if (clamp) clampEnd = calculatedDuration*clampMultiplier;				
				advanceTween();
			}
		
		
			var lastSpeed;
			// var pausing = false;
			target.pause = function(state, time) {
				if (zot(state)) state = true;
				if (zot(time)) time = 0;
				if (state) {
					if (target.zimAnimateDragDown) {
						drag = false;
						target.cur("default");
						if (pathObject) pathObject.off("change", target.zimAnimatePathChange);
						target.off("mousedown", target.zimAnimateDragDown);
						target.off("pressmove", target.zimAnimateDragPress);
						target.off("pressup", target.zimAnimateDragUp);
						if (!dynamic) return;
					}					
					lastSpeed = target.percentSpeed;
					if (time > 0) {
						// pausing = true;
						zim.animate({target:target, props:{percentSpeed:0}, override:false, ticker:false, time:time, call:function() {
							// pausing = false;
							target.percentSpeed = 0;		
							if (target.type != undefined) target.paused = true;
							target.animating = false;
							dynamic = false;
							target.dispatchEvent("pause");
						}});
					} else {
						tween.startPaused = false;
						// pausing = false;
						target.percentSpeed = 0;		
						if (target.type != undefined) target.paused = true;
						target.animating = false;
						dynamic = false;
						setTimeout(function() {target.dispatchEvent("pause");}, 10);
					}
				} else {
					if (target.zimAnimateDragDown) {
						drag = true;
						target.cur("pointer");
						if (pathObject) target.zimAnimatePathChange = pathObject.on("change", target.zimAnimatePathChange);
						target.zimAnimateDragDown = target.on("mousedown", target.zimAnimateDragDown);
						target.zimAnimateDragPress = target.on("pressmove", target.zimAnimateDragPress);
						target.zimAnimateDragUp = target.on("pressup", target.zimAnimateDragUp);
						if (!dynamic && startPaused != false) return;
					}
					mouseCheck = false;
					tween.currentTime = tween.position;
					if (time > 0) {
						// pausing = true;
						zim.animate({
							target:target,
							props:{percentSpeed:lastSpeed},
							override:false,
							ticker:false,
							time:time,
							call:function() {
								// pausing = false;
								target.percentSpeed = lastSpeed;
								target.paused = false;
								target.animating = true;
								dynamic = true;
							}
						});
					} else {
						// pausing = false;
						target.percentSpeed = lastSpeed;
						if (target.type != undefined) target.paused = false;
						target.animating = true;
						dynamic = true;
					}
				}
				return target;
			};
		}

		// end NIO updates
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

		return target;
	};//-45

/*--
obj.stopAnimate = function(ids, toEnd)

stopAnimate
zim function - and Display object function

DESCRIPTION
Stops tweens with the passed in id or array of ids.
If no id is passed then this will stop all tweens.
The id is set when using animate() or a Sprite id parameter.
An animation series will have the same id for all the animations inside.
To stop a Shape tween, set an id in the animate call and use that id to stop the shape tween
this is because the shape tween animation is not on the shape but on its many control points
See also pauseAnimate()

NOTE: for a sequence animate() give the animate() an id and pauseAnimate() or stopAnimate() that id.

NOTE: formerly stopZimAnimate - which still works but is depreciated

NOTE: calling stopAnimate(id) stops tweens with this id on all objects
calling object.stopAnimate(id) stops tweens with this id on the target object

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// We have split the tween in two so we can control them individually
// Set an id parameter to stop or pause
// You can control multiple tweens at once by using the same id (the id is for a tween set)
// Note the override:true parameter
const rect = new Rectangle(200, 200, pink)
	.centerReg()
	.animate({obj:{scale:2}, time:2, loop:true, rewind:true, id:"scale"})
	.animate({obj:{rotation:360}, time:4, loop:true, ease:"linear", override:false});
rect.cur("pointer");
rect.on("click", ()=>{rect.stopAnimate()}); // will stop all tweens on rect
// OR
rect.on("click", ()=>{rect.stopAnimate("scale");}); // will stop scaling tween

stopAnimate("scale") // will stop tweens with the scale id on all objects

stopAnimate(); // will stop all animations
END EXAMPLE

PARAMETERS
ids - (default null) pass in an id or an array of ids specified in animate, move and Sprite
toEnd - (default false) set to true to call endTween() on targets to go to end of tween values
	warning: setting to true will make targets to go to the end of all their animations
	which could have the effect of ignoring ids for specific animations therefore stopping them as well

PROPERTIES
paused - zim.stopAnimate() will set paused property of stopped objects to null

RETURNS null if run as stopAnimate() or the obj if run as obj.stopAnimate()
--*///+45.12
	zim.stopAnimate = function(ids, toEnd) {
		z_d("45.12");
		var i;
		if (zot(ids)) {
			if (zim.animatedObjects) {
				for (i=zim.animatedObjects.length-1; i>=0; i--) {
					zim.animatedObjects.objects[i].stopAnimate(null, toEnd);
				}
			}
			return;
		}
		if (!Array.isArray(ids)) ids = [ids];
		if (!zim.idSets) return;
		for (var j=0; j<ids.length; j++) {
			var idSet = ids[j];
			if (zim.idSets[idSet]) {
				var idLength = zim.idSets[idSet].length-1;
				for (i=idLength; i>=0; i--) {
					zim.idSets[idSet][i].stopAnimate(idSet, toEnd);
				}
			}
		}
	};//-45.12

/*--
obj.stopZimAnimate = function(ids)

stopZimAnimate
This is replaced by stopAnimate()
--*///+45.1
	zim.stopZimAnimate = function(ids) {
		z_d("45.1");
		zim.stopAnimate(ids);
	};//-45.1

/*--
obj.pauseAnimate = function(state, ids)

pauseAnimate
zim function - and Display object function

DESCRIPTION
Pauses or unpauses tweens with the passed in id or array of ids.
If no id is passed then this will pause or unpause all tweens.
The id is set as a animate, move, Sprite parameter.
An animation series will have the same id for all the animations inside.
To pause a Shape tween, set an id in the animate call and use that id to pause the shape tween
this is because the shape tween animation is not on the shape but on its many control points
See also stopAnimate

NOTE: for a sequence animate() give the animate() an id and pauseAnimate() or stopAnimate() that id.

NOTE: formerly pauseZimAnimate - which still works but is depreciated

NOTE: calling pauseAnimate(true, id) pauses tweens with this id on all objects
calling object.pauseAnimate(true, id) pauses tweens with this id on the target object

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circle = new Circle().center().animate({obj:{alpha:0}, loop:true, rewind:true});
circle.on("mousedown", ()=>{
	circle.pauseAnimate(!circle.paused);
});
END EXAMPLE

EXAMPLE
// We have split the tween in two so we can control them individually
// Set an id parameter to stop or pause
// You can control multiple tweens at once by using the same id (the id is for a tween set)
// note the override:true parameter
const rect = new Rectangle(200, 200, pink)
	.centerReg()
	.animate({obj:{scale:2}, time:2, loop:true, rewind:true, id:"scale"})
	.animate({obj:{rotation:360}, time:4, loop:true, ease:"linear", override:false});
rect.cur("pointer");
rect.on("click", ()=>{rect.pauseAnimate()}); // will pause all tweens on rect
// OR
let paused = false;
rect.on("click", ()=>{
	paused = !paused;
	rect.pauseAnimate(paused, "scale");
}); // will toggle the pausing of the scaling tween

pauseAnimate(false, "scale") // will unpause tweens with the scale id on all objects

pauseAnimate(); // will pause all animations
END EXAMPLE

PARAMETERS
state - (default true) will pause tweens - set to false to unpause tweens
ids - (default null) pass in an id or an array of ids specified in animate, move and Sprite

PROPERTIES
paused - zim.stopAnimate() will set paused property of paused objects to the value of the state parameter

RETURNS null if run as pauseAnimate() or the obj if run as obj.pauseAnimate()
--*///+45.22
	zim.pauseAnimate = function(state, ids) {
		z_d("45.22");
		if (zot(state)) state = true;
		var i;
		if (zot(ids) || ids=="pauseOnBlur") {
			if (zim.animatedObjects) {
				for (i=zim.animatedObjects.length-1; i>=0; i--) {
					zim.animatedObjects.objects[i].pauseAnimate(state, ids);
				}
			}
			return;
		}
		if (!Array.isArray(ids)) ids = [ids];
		if (!zim.idSets) return;
		for (var j=0; j<ids.length; j++) {
			var idSet = ids[j];
			if (zim.idSets[idSet]) {
				for (i=zim.idSets[idSet].length-1; i>=0; i--) {
					zim.idSets[idSet][i].pauseAnimate(state, idSet);
				}
			}
		}
	};//-45.22

/*--
obj.pauseZimAnimate = function(state, ids)

pauseZimAnimate
This is replaced by pauseAnimate()
--*///+45.2
	zim.pauseZimAnimate = function(state, ids) {
		z_d("45.2");
		zim.pauseAnimate(state, ids);
	};//-45.2

/*--
obj.wiggle = function(property, baseAmount, minAmount, maxAmount, minTime, maxTime, totalTime, type, ease, integer, id, startType, ticker, wait, pauseOnBlur, endOnStart)

wiggle
zim DisplayObject method

DESCRIPTION
Wiggles the property of the target object between a min and max amount to either side of the base amount
in a time between the min and max time.
Uses animate() so to pause or stop the wiggle use pauseAnimate and stopAnimate
either on the object or using an id that you pass in as a parameter

NOTE: calling pauseAnimate(true, id) pauses tweens with this id on all objects
calling target.pauseAnimate(true, id) pauses tweens with this id on the target object

EXAMPLE
const ball = new Circle().centerReg();
ball.wiggle("x", ball.x, 10, 100, .5, 1);
// wiggles the ball 10-100 pixels to the left and right of center taking .5-1 s each time

ball.pauseAnimate(); // will pause the wiggle
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function

NOTE: if using wiggle as a zim function the first parameter is:
target - the object to wiggle
property - the property name as a String that will be width-indicatorLength-edgeLeft-edgeRight
baseAmount - |ZIM VEE| (default the property's current amount) the center amount for the wiggle
	wiggle will go to each side of this center unless type is "positive" or "negative"
minAmount - |ZIM VEE| the min amount to change to a side of center
maxAmount - |ZIM VEE| (default minAmount) the max amount to change to a side of center
minTime - |ZIM VEE| (default 1) the min time in seconds to go from one side to the other (also see ZIM TIME constant)
maxTime - |ZIM VEE| (default minTime) the max time in seconds to go from one side to the other (also see ZIM TIME constant)
totalTime - (default forever) the total time in seconds until a stopAnimate is called on wiggle (also see ZIM TIME constant)
	adds a wiggleTimeout property to the wiggle target that holds the setTimeout id for cancelation of totalTime
type - (default "both") set to "positive" to wiggle only the positive side of the base or "negative" for negative side (or "both" for both)
ease - (default "quadInOut") the ease to apply to the animation
integer - (default false) tween to an integer value between min and max amounts
id - (default random id) the id to use for pauseAnimate() or stopAnimate()
startType - (default "both") set to "positive" to start wiggle in the positive side of the base or "negative" for negative side (or "both" for either)
ticker - (default true) set to false if wiggling a value other than a Display object property
wait - |ZIM VEE| (default 0) time in seconds to wait between each wiggle - in addition to time set for wiggle
pauseOnBlur - (default true) as of ZIM 10.8.0, animate defaults to pause all animations on blur
	blur is when the window is reduced or a different tab gains focus on the Browser
	animate uses requestAninationFrame which slows down when the window is not in focus
	this can cause animations to go out of sync - pauseOnBlur will prevent this
	Can also set zim.pauseOnBlur=false or true to change this at any time
endOnStart - (default true) - set to false to not end at the same property value as the wiggle started - if totalTime is set 

EVENTS
if totalTime is set, target will dispatch a wigglestop event when the wiggle stops

RETURNS target for chaining
--*///+45.25
	zim.wiggle = function(target, property, baseAmount, minAmount, maxAmount, minTime, maxTime, totalTime, type, ease, integer, id, startType, ticker, wait, pauseOnBlur, endOnStart) {
		var sig = "target, property, baseAmount, minAmount, maxAmount, minTime, maxTime, totalTime, type, ease, integer, id, startType, ticker, wait, pauseOnBlur, endOnStart";
		var duo; if (duo = zob(zim.wiggle, arguments, sig)) return duo;
		z_d("45.25");
		if (zot(target) || zot(property) || zot(minAmount)) return target;
		if (zot(maxAmount)) maxAmount = minAmount;
		if (zot(baseAmount)) baseAmount = target[property];
		var timeType = getTIME(minTime, null, 40);
		if (zot(minTime)) minTime = timeType=="s"?1:1000;
		if (zot(maxTime)) maxTime = minTime;
		checkTIME(maxTime, timeType, 40);
		if (zot(ease)) ease = "quadInOut";
		if (zot(integer)) integer = false;
		if (zot(id)) id = zim.makeID();
		if (zot(type)) type = "both";
		if (zot(startType)) startType = "both";
		if (zot(ticker)) ticker = true;
		if (zot(wait)) wait = 0;
		if (zot(endOnStart)) endOnStart = true;

		checkTIME(totalTime, timeType, 40);
		if (!zot(totalTime)) target.wiggleTimeout = setTimeout(function() {
			target.stopAnimate(id);
			if (endOnStart) {
				var obj = {};
				obj[property]=zim.Pick.choose(baseAmount);
				zim.animate({target:target, obj:obj, time:0});
			}
			target.dispatchEvent("wigglestop");
		}, totalTime*(timeType=="s"?1000:1));

		var count = 0;
		var lastWiggle;
        
        if (totalTime > 0 && endOnStart) {
            var startTime = Date.now();
            var endTime = startTime + totalTime*(timeType=="s"?1000:1);
            var maxMilli = maxTime*(timeType=="s"?1000:1) * (type=="negative"||type=="positive"?2:1);
        }
		function wiggleMe() {
            var time;
            
            if (endTime && endTime-Date.now() <= maxMilli) {
                time = (endTime-Date.now()) / (timeType=="s"?1000:1) * (type=="negative"||type=="positive"?.5:1);
            } else time = zim.rand(zim.Pick.choose(minTime), zim.Pick.choose(maxTime), false); // now with seconds - want no integer!
			var obj = {};
			var set = {};
			var wiggle;
			set[property] = zim.Pick.choose(baseAmount);
			// to start go from center
			if (type == "negative" || (count==0 && startType == "negative")) {
				wiggle = - zim.rand(zim.Pick.choose(minAmount),zim.Pick.choose(maxAmount),integer);
			} else if (type == "positive" || (count==0 && startType == "positive")) {
				wiggle = zim.rand(zim.Pick.choose(minAmount),zim.Pick.choose(maxAmount),integer);
			} else {
				if (count == 0) {
					wiggle = zim.rand(zim.Pick.choose(minAmount),zim.Pick.choose(maxAmount),integer,true); // negative or positive
				} else {
					wiggle = zim.rand(zim.Pick.choose(minAmount),zim.Pick.choose(maxAmount),integer)*zim.sign(lastWiggle)*-1;
				}
			}
            if (endTime && endTime-Date.now() < maxMilli) wiggle = 0;
			obj[property]=zim.Pick.choose(baseAmount)+wiggle;
			if (count == 0) time = time/2;
			lastWiggle = wiggle;
			count++;
			var objRate = target.futureRate; // transfer over target rate - ZIM NFT 00 patch
			if (type == "negative" || type == "positive") {
				zim.animate({target:target, obj:obj, set:set, ease:ease, time:time*2, wait:zik(wait), rewind:true, override:false, call:wiggleMe, id:id, ticker:(target.stage?true:false), timeCheck:false, pauseOnBlur:pauseOnBlur});
			} else {
				zim.animate({target:target, obj:obj, ease:ease, time:time, wait:zik(wait), override:false, call:wiggleMe, id:id, ticker:(target.stage?true:false), timeCheck:false, pauseOnBlur:pauseOnBlur});
			}
			if (objRate) target.futureRate = objRate;
		}
		if (target.addTo && !target.stage && !target.type=="Uniforms") {
			target.added(wiggleMe);
		} else wiggleMe();
		return target;
	};//-45.25

/*--
obj.loop = function(call, reverse, interval, step, start, end, immediate, complete, completeParams)

loop
zim DisplayObject method
NOTE: overrides earlier loop function with added container loop
so that we can use earlier loop function without createjs

DESCRIPTION
The loop function (see the CODE module for loop) lets you loop through:
1. If you pass in a Number for obj then loop() does function call that many times
2. If you pass in an Array then loop() loops through the array
3. If you pass in an Object literal or ZIM Dictionary then loop() loops through the object
4. If you pass in an String then loop() loops through the letters
5. If you pass in an HTML NodeList or HTMLCollection then loop() loops through the tags

The loop method lets you loop through a Container
NOTE: you can also pass the container as the first parameter of the loop function

6. The loop method loops through all the children of the container
and does the function for each one passing the child, currentIndex, totalLoops, startIndex, endIndex, obj.
So this is like for(i=0; i<obj; i++) {var child = obj.getChildAt(i);} loop
or for (var i in container.children) {var child = container.children[i];}

NOTE: If you pass in true for reverse, the loop is run backwards counting to 0 (by default)
NOTE: use return to act like a continue in a loop and go to the next loop
NOTE: use return NEXT when in interval mode to go immediately to the next interval - as opposed to return which goes to next but after another interval
NOTE: return a value to return out of the loop completely like a break (and return a result if desired)

EXAMPLE
var container = new Container().alp(.1).addTo();
// LOOP FUNCTION - for more examples see the CODE Module loop() function
loop(1000, i=>{ // gets passed an index i, totalLoops 1000, startIndex 0, endIndex 999, obj 1000
	// make 1000 rectangles
	new Rectangle().loc(rand(W-100), rand(H-100), container);
});

// LOOP METHOD
// loop through children of the container
container.loop((child, i)=>{ // gets passed the child, index, total, start, end and obj
	child.x += i*2;
	child.y += i*2;
}, true); // true would reverse - so highest in stack to lowest, with i going from numChildren-1 to 0
END EXAMPLE

EXAMPLE 
// looping with the interval setting 

// loop through an array every 1 second 
loop(10, i=>{zog(i);}, null, 1);

// loop through a Container every .01 seconds 
const tile = new Tile(new Rectangle(26,26,[green, blue, pink]), 10, 10, -1, -1)
	.reg(CENTER)
	.pos(0,100,CENTER,BOTTOM)
	.loop(item=>{
		item.color = darker;
		S.update();
	}, null, .01);
END EXAMPLE 

PARAMETERS supports DUO - parameters or single object with properties below
call - the function to call
	the function will receive (as its final parameters) the index, total, start, end, obj
		where the index is the current index, total is how many times the loop will run
		start is the start index, end is the end index and obj is the object passed to the loop
	the starting parameters vary depending on the type of obj:
	if the obj is a number then the first parameter is the index (no extra starting parameters given)
	if the obj is an array then the first parameter is the element at the current index
	if the obj is an object literal then the first and second parameters are the property name and property value at the current index
	if the obj is a string then the first parameter is the letter at the current index
	if the obj is a container then the first parameter is the child of the container at the current index
	if the obj is an HTMLCollection then the first parameter is the tag
reverse - (default false) set to true to run the loop backwards to 0
interval - (default 0) set to a number of seconds between each loop
	use return NEXT to go immediately to the next interval 
	use return to just leave current interval then wait another interval to continue
	return a value (other than NEXT) to exit the loop and clear the inverval 
	the interval object is provided at the end of the loop function parameters - but will probably not be needed
step - (default 1) each step will increase by this amount (positive whole number - use reverse to go backwards)
start - (default 0 or length-1 for reverse) index to start
end - (default length-1 or 0 for reverse) index to end
immediate - (default true) set to false to not start the loop right away, but rather wait for a first interval
complete (default null) - a callback function to call when complete
completeParams (default null) - paramater to pass complete callback

RETURNS any value returned from the loop - or true if no value is returned from a loop
--*///+45.3
	zim.loop = function(obj, call, reverse, interval, step, start, end, immediate, complete, completeParams) {
		var sig = "obj, call, reverse, interval, step, start, end, immediate, complete, completeParams";
		var duo; if (duo = zob(zim.loop, arguments, sig)) return duo;
		
		if (!zim.zimLoopCheck) z_d("45.3");
		zim.zimLoopCheck = true;
		if (zot(obj) || zot(call)) return undefined;
		if (zot(reverse)) reverse = false;		
		if (zot(interval)) interval = 0;
		if (zot(step) || step <= 0) step = 1;
		if (zot(immediate)) immediate = true;

		if (obj.constructor === Number) obj = Number(obj);
		if (obj.constructor === String) obj = String(obj);

		var comp = interval===0 && complete && typeof complete=="function";	

		var type = typeof obj=="number"?"number":(obj.constructor === Array?"array":(obj.constructor === {}.constructor?"object":(obj instanceof NodeList?"nodelist":(typeof obj == "string"?"string":(obj instanceof HTMLCollection?"htmlcollection":(obj.type&&obj.type=="Dictionary"?"Dictionary":"invalid"))))));

		if (type == "container" && !obj.addChild) {
			return undefined;
		}

		var length,i,total,r;
		if (type == "number" || type == "string" || type == "array" || type == "nodelist" || type == "htmlcollection" || type == "Dictionary") {
			if (type == "Dictionary") {
				var vals = zim.copy(obj.values);
				obj = zim.copy(obj.objects);
			}
			length = type=="number"?obj:obj.length;
			total = getTotal(length-1);
			if (total == 0) return;
			if (reverse) {
				if (interval === 0) {
					for(i=start; i>=end; i-=step) {
						if (type=="number") {
							r = call(i, total, start, end, obj);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist
							r = call(obj.item(i), i, total, start, end, obj);
						}
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count;
						if (!immediate) i--;
						if (step) i *= step;
						i = start-i;
						if (type=="number") {
							r = call(i, total, start, end, obj);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist
							r = call(obj.item(i), i, total, start, end, obj);
						}					
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			} else {
				if (interval === 0) {
					for(i=start; i<=end; i+=step) {
						if (type=="number") {
							r = call(i, total, start, end, obj);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist // htmlcollection
							r = call(obj.item(i), i, total, start, end, obj);
						}
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count + start;
						if (!immediate) i--;
						if (step != 1) i = -start + i*step;
						
						if (type=="number") {
							r = call(i, total, start, end, obj, io);
						} else if (type=="array" || type=="string") {
							r = call(obj[i], i, total, start, end, obj, io);
						} else if (type=="Dictionary") {
							r = call(obj[i], vals[i], i, total, start, end, obj);
						} else { // nodelist or htmlcollection
							r = call(obj.item(i), i, total, start, end, obj, io);
						}
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			}
			if (comp) complete(completeParams);
			return true;
		} else if (type == "object") {
			length = 0;
			var props = [];
			for (i in obj) {
				length++;
				props.push(i);
			}
			total = getTotal(length-1);
			if (total == 0) return;
			if (reverse) {
				if (interval === 0) {
					for(i=start; i>=end; i-=step) {
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						if (typeof r != 'undefined' && r != "next") return r;
					}					
				} else {
					zim.interval(interval, function(io) {
						i = io.count;
						if (!immediate) i--;
						if (step) i *= step;
						i = start-i;
						
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			} else {
				if (interval === 0) {
					for(i=start; i<=end; i+=step) {
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count + start;
						if (!immediate) i--;
						if (step != 1) i = -start + i*step;
						
						r = call(props[i], obj[props[i]], i, total, start, end, obj);
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			}
			if (comp) complete(completeParams);
			return true;
		} else {
			total = getTotal(obj.numChildren-1);
			if (total == 0) return;
			if (reverse) {
				if (interval === 0) {
					for(i=start; i>=end; i-=step) {
						r = call(obj.getChildAt(i), i, total, start, end, obj);
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count;
						if (!immediate) i--;
						if (step) i *= step;
						i = start-i;
						
						r = call(obj.getChildAt(i), i, total, start, end, obj);
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			} else {
				if (interval === 0) {
					for(i=start; i<=end; i+=step) {
						r = call(obj.getChildAt(i), i, total, start, end, obj);
						if (typeof r != 'undefined' && r != "next") return r;
					}
				} else {
					zim.interval(interval, function(io) {
						i = io.count + start;
						if (!immediate) i--;
						if (step != 1) i = -start + i*step;
						
						r = call(obj.getChildAt(i), i, total, start, end, obj);
						
						if (r == 'next') io.next();
						else if (typeof r != 'undefined') {
							io.clear();
							return r;
						}
					}, total, immediate, null, null, complete, completeParams);					
				}
			}
			if (comp) complete(completeParams);
			return true;
		}
		function getTotal(max) {
			if (zot(start)) start = reverse?max:0;
			if (zot(end)) end = reverse?0:max;
			if ((reverse && end > start) || (!reverse && start > end)) return 0;
			if ((start < 0 && end) <0 || (start > max && end > max)) return 0;
			start = Math.max(0, Math.min(start, max));
			end = Math.max(0, Math.min(end, max));
			return Math.floor((reverse?(start-end):(end-start)) / step) + 1;
		}
		
	};//-45.3


// SUBSECTION GENERAL

/*--
obj.scaleTo = function(boundObj, percentX, percentY, type, boundsOnly, simple)

scaleTo
zim DisplayObject method

DESCRIPTION
Scales object to a percentage of another object's bounds and scale
Percentage is from 0 - 100 (not 0-1).
Also see sca(), fit() and Layout().

NOTE: currently supports rotated objects only for FIT mode and not for FILL or FULL. 
For rotated objects in FILL or FULL, put the rotated object in a Container
and then scaleTo() the container

WARNING: an error is happening when using scaleTo() in a resize event in FULL mode. 
Use the simple:true parameter to avoid errors - but may not work with rotated nested objects 

EXAMPLE
circle.scaleTo(stage, 50); // scale to half the W
circle.scaleTo(stage, 10, 20); // fit within these scalings of the stage
END EXAMPLE

PARAMETERS - supports DUO - parameters or single object with properties below
boundObj - the object that we are scaling to with percents below
percentX - (default no scaling) the scale in the x
percentY - (default no scaling) the scale in the y
	if both percentX and percentY are missing then assumes 100, 100 for each
	and type defaults to FILL rather than FIT
type - (default FIT or FILL if no percent is provided) the scaling to match bounds
	Note: as of ZIM Cat 04 the constant FIT or the string "fit", etc. can be used
	Note: as of ZIM NFT the default is FILL if no percent and FIT if a percent is provided
	FIT: to keep proportion (aspect ratio) and fit within bounds (formerly "smallest")
	FILL: to keep proportion (aspect ratio) and fill the bounds (formerly "biggest")
	FULL: match bounds dimensions - may stretch object (formerly "both" or "stretch")
boundsOnly - (default false) set to true to scale to the boundObj's bounds only - ignoring current boundObj scale
simple - (default false) set to true to avoid errors specifically in resize event

RETURNS obj for chaining
--*///+43
	zim.scaleTo = function(obj, boundObj, percentX, percentY, type, boundsOnly, simple) {
		var sig = "obj, boundObj, percentX, percentY, type, boundsOnly, simple";
		var duo; if (duo = zob(zim.scaleTo, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("scaleTo", arguments); return obj;}
		z_d("43");
		if (zot(boundObj)) boundObj = WW.zdf&&WW.zdf.stage?WW.zdf.stage:null;
		if (zot(obj) || !obj.getBounds || !obj.getBounds()) {zog ("zim methods - scaleTo(): please provide an object (with setBounds) to scale"); return obj;}
		if (zot(boundObj) || !boundObj.getBounds || !boundObj.getBounds()) {zog ("zim methods - scaleTo(): please provide a boundObject (with setBounds) to scale to"); return obj;}
		if (zot(percentX)) percentX = -1;
		if (zot(percentY)) percentY = -1;
		if (percentX == -1 && percentY == -1) {
			percentX = percentY = 100;
			if (zot(type)) type = "fill"; // added ZIM NFT
		}
		if (zot(type)) type = "fit";
		if (type=="smallest") type = "fit";
		else if (type=="biggest" || type=="outside" || type=="largest") type = "fill";
		else if (type=="both" || type=="stretch") type = "full";
		if (zot(boundsOnly)) boundsOnly = false;
		if (zot(simple)) simple = false;
				
		var w = boundObj.getBounds().width * percentX / 100 * (boundsOnly?1:boundObj.scaleX);
		var h = boundObj.getBounds().height * percentY / 100 * (boundsOnly?1:boundObj.scaleY);
		
		if (boundObj.type=="Stage" || boundObj.type=="StageGL") {
			w = boundObj.width * percentX / 100;
			h = boundObj.height * percentY / 100;
		}
				
		// project bounds as rectangle into boundObj 
		var hh,ww;
		if (!simple) {
			var bou = zim.boundsToGlobal(obj);		
			hh = bou.height/obj.scaleX;
			ww = bou.width/obj.scaleY;
			if (isNaN(hh) || isNaN(ww) || hh > 5000) {
				hh = obj.getBounds().height;
				ww = obj.getBounds().width;
			}	
		} else {
			hh = obj.getBounds().height;
			ww = obj.getBounds().width;
		}
						
		if ((percentX == -1 || percentY == -1) && type != "full") {
			if (percentX == -1) {
				zim.sca(obj, h/hh);
			} else {
				zim.sca(obj, w/ww);
			}
			return obj;
		}
		var scale;
		if (type == "full") {
			obj.scaleX = (percentX != -1) ? w/ww : obj.scaleX;
			obj.scaleY = (percentY != -1) ? h/hh : obj.scaleY;
			return obj;
		} else if (type == "fill") {
			scale = Math.max(w/ww, h/hh);
		} else { // fit 
			scale = Math.min(w/ww, h/hh);
		}
		zim.sca(obj, scale);
		return obj;
	};//-43

/*--
obj.fit = function(left, top, width, height, type)

fit
zim DisplayObject method

DESCRIPTION
Scale an object to rectangular dimensions and center it.
Actually scales and positions the object.
Object must have bounds set (setBounds()).

EXAMPLE
circle.fit(100, 100, 200, 300); // fits and centers in these dimensions
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
left, top, width, height - (default stage dimensions) the rectangle to fit
type - (default FIT) the scaling to match rectangle dimensions
	Note: as of ZIM Cat 04 the constant FIT or the string "fit", etc. can be used
	FIT: to keep proportion (aspect ratio) and fit within rectangle 
	FILL: to keep proportion (aspect ratio) and fill the rectangle 
	FULL: match rectange dimensions - may stretch object 

RETURNS an Object literal with the new and old details (bX is rectangle x, etc.):
{x:obj.x, y:obj.y, width:newW, height:newH, scale:scale, scaleX:scaleX, scaleY:scaleY, bX:left, bY:top, bWidth:width, bHeight:height}
--*///+46
	zim.fit = function(obj, left, top, width, height, type) {
		var sig = "obj, left, top, width, height, type";
		var duo; if (duo = zob(zim.fit, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("fit", arguments); return obj;}
		z_d("46");
		if (zot(obj) || !obj.getBounds) return;
		if (!obj.getBounds()) {
			zogy("zim methods - fit(): please setBounds() on object");
			return;
		}
		if (zot(left)) {
			if (!obj.stage) {
				zogy("zim methods - fit(): please add boundary dimensions or add obj to stage first");
				return;
			}
			if (!obj.stage.getBounds()) {
				zogy("zim methods - fit(): please add boundary dimensions or add obj with bounds to stage first");
				return;
			}
			var sW = obj.stage.getBounds().width;
			var sH = obj.stage.getBounds().height;
			left = 0; top = 0;
			width = sW; height = sH;
		}
		if (type===true) type = "fit";
		else if (type===false) type = "fill";
		if (zot(type)) type = "fit";
		
		obj.scaleX = obj.scaleY = 1;

		var w = width;
		var h = height;
		var objW = obj.getBounds().width;
		var objH = obj.getBounds().height;

		var newW;
		var newH;
		var scaleX;
		var scaleY;
		var scale;
		if (type=="full") {
			obj.scaleX = scaleX = w/objW;
			obj.scaleY = scaleY = h/objH;
			newW = w;
			newH = h;
		} else {
			if (type=="fit") { // fits dimensions inside rectangle
				if (w/h >= objW/objH) {
					scale = h / objH;
				} else {
					scale = w / objW;
				}				
			} else if (type=="fill") { // fills rectangle (outside)
				if (w/h >= objW/objH) {
					scale = w / objW;
				} else {
					scale = h / objH;
				}
			} 		
			scaleX = scaleY = scale;	
		}
		obj.scaleX = scaleX;
		obj.scaleY = scaleY;
		newW = objW * scaleX;
		newH = objH * scaleY;

		// horizontal center
		obj.x = (obj.regX-obj.getBounds().x)*scaleX + left + (w-newW)/2;

		// vertical center
		obj.y = (obj.regY-obj.getBounds().y)*scaleY + top + (h-newH)/2;

		return {x:obj.x, y:obj.y, width:newW, height:newH, scale:scale, scaleX:scaleX, scaleY:scaleY, bX:left, bY:top, bWidth:width, bHeight:height};

	};//-46

/*--
obj.boundsToGlobal = function(rect, flip, inside, globalObj)

boundsToGlobal
zim DisplayObject method

DESCRIPTION
Returns a createjs Rectangle of the bounds of object projected onto the stage.
Handles scaling and rotation.
If a createjs rectangle is passed in then it converts this rectangle
from within the frame of the obj to a global rectangle.
If flip (default false) is set to true it goes from global to local rect.
Used by drag() and hitTestBounds() above - probably you will not use this directly.

EXAMPLE
zog(circle.boundsToGlobal().x); // global x of circle
END EXAMPLE

PARAMETERS
rect - (default null) a rect inside an object which you would like mapped to global
flip - (default false) make a global rect ported to local values
inside - (default false) [NOT WORKING YET] make a rectangle from smallest projection rather than largest
globalObj - (default stage) project rectangle into a Container other than the stage 

RETURNS a createjs Rectangle of the bounds of object projected onto the stage
--*///+40
	zim.boundsCheck = false;
	zim.boundsToGlobal = function(obj, rect, flip, inside, globalObj) {
		if (!zim.boundsCheck) {z_d("40"); zim.boundsCheck = true;}
		if (zot(obj) || !obj.getBounds) return;
		if (zot(flip)) flip = false;
		if (globalObj && !obj.getBounds && !obj.getBounds()) return obj;
		var oB = obj.getBounds();
		if (!oB && zot(rect)) {
			zogy("zim methods - boundsToGlobal():\n please setBounds() on object (or a rectangle)");
			return;
		}
		if (rect) oB = rect;
		
		var pTL,pTR,pBR,pBL;
		if (globalObj && globalObj.type && !(globalObj.type=="Stage" ||  globalObj.type=="StageGL")) {
			pTL = obj.localToLocal(oB.x, oB.y, globalObj);
			pTR = obj.localToLocal(oB.x+oB.width, oB.y, globalObj);
			pBR = obj.localToLocal(oB.x+oB.width, oB.y+oB.height, globalObj);
			pBL = obj.localToLocal(oB.x, oB.y+oB.height, globalObj);			
		} else {
			if (flip) {
				pTL = obj.globalToLocal(oB.x, oB.y);
				pTR = obj.globalToLocal(oB.x+oB.width, oB.y);
				pBR = obj.globalToLocal(oB.x+oB.width, oB.y+oB.height);
				pBL = obj.globalToLocal(oB.x, oB.y+oB.height);
			} else {
				pTL = obj.localToGlobal(oB.x, oB.y);
				pTR = obj.localToGlobal(oB.x+oB.width, oB.y);
				pBR = obj.localToGlobal(oB.x+oB.width, oB.y+oB.height);
				pBL = obj.localToGlobal(oB.x, oB.y+oB.height);
			}
		}

		// handle rotation
		// if (inside) { // NOT WORKING 
		// 	var newTLX = Math.max(pTL.x,pTR.x,pBR.x,pBL.x);
		// 	var newTLY = Math.max(pTL.y,pTR.y,pBR.y,pBL.y);
		// 	var newBRX = Math.min(pTL.x,pTR.x,pBR.x,pBL.x);
		// 	var newBRY = Math.min(pTL.y,pTR.y,pBR.y,pBL.y);
		// } else {
			var newTLX = Math.min(pTL.x,pTR.x,pBR.x,pBL.x);
			var newTLY = Math.min(pTL.y,pTR.y,pBR.y,pBL.y);
			var newBRX = Math.max(pTL.x,pTR.x,pBR.x,pBL.x);
			var newBRY = Math.max(pTL.y,pTR.y,pBR.y,pBL.y);
		// }			

		return new createjs.Rectangle(
			newTLX,
			newTLY,
			newBRX-newTLX,
			newBRY-newTLY
		);
	};//-40

/*--
obj.resetBounds = function(width||boundsX, height||boundsY, null||width, null||height, margin)

resetBounds
zim DisplayObject method

DESCRIPTION
Pass in no parameters to reset the bounds to calculated bounds
Pass in width and height to set bounds to (0,0,width,height)
Pass in x, y, width and height to set bounds to (0,0,width,height)

NOTE: a container made with new Container() has auto calculated bounds
so the bounds (and width and height) adapt to surround any new children's bounds
A container set with bounds to start: new Container(100, 200) has static bounds
so the bounds (and width and height) will not change as new children are added
Calling container.resetBounds() with no parameter sets dynamic calculated bounds
Or you can reset the static bounds with parameters.

EXAMPLE
const container = new Container();
const rect = new Rectangle(500,300).addTo(container);
zog(container.width, container.height); // 500, 300 dynamic bounds

// OR

const container = new Container(100, 100);
const rect = new Rectangle(500,300).addTo(container);
zog(container.width, container.height); // 100, 100 static bounds

container.resetBounds();
zog(container.width, container.height); // 500, 300 dynamic bounds

container.resetBounds({margin:20}); 
zog(container.bounds); // -20, 20, 540, 340 static with margin

container.resetBounds(200, 200);
rect.removeFrom();
zog(container.width, container.height); // 200, 200 static bounds
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
width - (default null) null will set dynamic bounds and the object will take on bounds of children if a Container
	setting a number for the width will set static bounds that do not change as objects are added
height - (default width) the height of the bounds
	if there is a width supplied but no height then the height is set to the width
	setting these run obj.setBounds(boundsX,boundsY,width,height);
OR if four parameters are set:
boundsX - (default 0) the x of the bounds
boundsY - (default 0) the y of the bounds
width - (default null) the width of the bounds
height - (default width) the height of the bounds
	if there is a width supplied but no height then the height is set to the width
	setting these run obj.setBounds(boundsX,boundsY,width,height);
margin - (default 0) add margin to increase (or decrease if negative) bounds
	if used, this makes the bounds static rather than dynamic.

RETURNS object for chaining
--*///+40.5
	zim.resetBounds = function(obj, a, b, c, d, margin) {
		var sig = "obj, a, b, c, d, margin";
		var duo; if (duo = zob(zim.resetBounds, arguments, sig)) return duo;
		z_d("40.5");	
		var boundsX,width,boundsY,height;
		if (!zot(c)) {
			boundsX = a;
			width = c;
			boundsY = b;
			height = d;
		} else {
			boundsX = 0;
			width = a;
			boundsY = 0;
			height = b;
		}
		if (zot(height)) height = width;
		if (!zot(a)) obj.setBounds(boundsX,boundsY,width,height);
		else obj.setBounds(null);
		if (margin) {
			b = obj.getBounds();
			if (b) obj.setBounds(b.x-margin, b.y-margin, b.width+margin*2, b.height+margin*2);
		}
	return obj;
};//-40.5

/*--
obj.copyMatrix = function(source)

copyMatrix
zim DisplayObject method

DESCRIPTION
Copies the transformation properties from the source to the obj
(x, y, rotation, reg, scale and skew)

NOTE: used internally by animate() and setMask() for copying transform of shapes to mask
also used in addDisplayMembers for clone() method

EXAMPLE
circle.copyMatrix(circle2);
// circle will now match circle2 in x, y, rotation, scale and skew properties
END EXAMPLE

PARAMETERS
source - object from which the transform properties are being copied

RETURNS obj for chaining
--*///+45.5
	zim.copyMatrix = function(obj, source) {
		z_d("45.5");
		obj.x = source.x;
		obj.y = source.y;
		obj.scaleX = source.scaleX;
		obj.scaleY = source.scaleY;
		obj.regX = source.regX;
		obj.regY = source.regY;
		obj.rotation = source.rotation;
		obj.skewX = source.skewX;
		obj.skewY = source.skewY;
		return obj;
	};//-45.5

/*--
obj.duplicate = function(exact)

duplicate
zim DisplayObject method

DESCRIPTION
clones the object but also any custom properties

EXAMPLE
const circle = new Circle();
circle.custom = 345;
const circle2 = circle.duplicate();
zog(circle2.custom); // 345
END EXAMPLE

RETURNS cloned object with cloned custom properties
--*///+45.6
	zim.duplicate = function(obj, exact) {
		z_d("45.6");
		var d = obj.clone(exact);
		for (var prop in obj) {
			if (Object.prototype.hasOwnProperty.call(obj,prop) && d[prop]==null) {
				if (prop == "parent") continue;
				if (prop == "zimTouch") continue;
				d[prop] = obj[prop];
			}
		}
		// add in ZIM Cat 03 - perhaps with an events parameter
		// if so, watch shapes which get events copied automatically
		// if (obj._listeners) d._listeners = obj._listeners;
		return d;
	};//-45.6

/*--
obj.expand = function(padding, paddingV, paddingRight, paddingBottom)

expand
zim DisplayObject method

DESCRIPTION
Adds a createjs hitArea to an object with an extra padding of padding.
Good for making mobile interaction better on labels, buttons, etc.

Note: this will make the whole object a hitArea so objects inside will not dispatch mouse events.
If that is required then use "holder" container that holds the expanded object 
and put the other target object on top of the expanded object but inside the holder container.

EXAMPLE
const circle = new Circle(10, red)
	.center()
	.expand(); // makes hit area bigger
circle.on("click", ()=>{zog("yes");});
END EXAMPLE

PARAMETERS - accepts ZIM DUO - regular parameters or a single configuration object
** one parameter for all padding
** two parameters for left/right and top/bottom
** four parameters for left/top/right/bottom with any blank to receive default 20
padding - (default 20) how many pixels to expand bounds
paddingV - (default null) the vertical padding (making padding for horizontal)
paddingRight - (default null) the right padding - if set then padding parameter is the leftPadding
paddingBottom - (default null) the bottom padding - if set then paddingV parameter is the paddingTop

RETURNS obj for chaining
--*///+50
	zim.expand = function(obj, padding, paddingV, paddingRight, paddingBottom) {
		var sig = "obj, padding, paddingV, paddingRight, paddingBottom";
		var duo; if (duo = zob(zim.expand, arguments, sig)) return duo;
		z_d("50");
		if (zot(obj) || !obj.getBounds || !obj.getBounds()) {zogy("zim methods - expand(): please provide object with bounds set"); return obj;}
		if (zot(padding)) padding = 20;
		if (zot(paddingV)) paddingV = padding;
		var paddingLeft,paddingTop;
		if (!zot(paddingRight) || !zot(paddingBottom)) {
			if (zot(paddingRight)) paddingRight = padding;
			if (zot(paddingBottom)) paddingBottom = paddingV;
			paddingLeft = padding;
			paddingTop = paddingV;
		} else {
			paddingLeft = paddingRight = padding;
			paddingTop = paddingBottom = paddingV;
		}
		var oB = obj.getBounds();
		var rect = new zim.Shape({style:false});
		rect.graphics.f("rgba(0,0,0,.01)").r(oB.x-paddingLeft,oB.y-paddingTop,oB.width+paddingLeft+paddingRight,oB.height+paddingTop+paddingBottom);
		obj.hitArea = rect;

		return obj;
	};//-50

/*--
obj.setSwipe = function(swipe)

setSwipe
zim DisplayObject method

DESCRIPTION
Sets whether we want to swipe an object or not using ZIM Swipe.
Recursively sets children to same setting.

EXAMPLE
circle.setSwipe();
END EXAMPLE

PARAMETERS
swipe - (default true) set to false to not swipe object

RETURNS obj for chaining
--*///+34
	zim.setSwipe = function(obj, swipe) {
		z_d("34");
		if (zot(obj) || !obj.on) return;
		obj.zimNoSwipe = (swipe) ? null : true;
		if (obj instanceof createjs.Container) dig(obj);
		function dig(container) {
			var num = container.numChildren;
			var temp;
			for (var i=0; i<num; i++) {
				temp = container.getChildAt(i);
				temp.zimNoSwipe = obj.zimNoSwipe;
				if (temp instanceof createjs.Container) {
					dig(temp);
				}
			}
		}
		return obj;
	};//-34

/*--
obj.setMask = function(mask, dynamic)

setMask
zim DisplayObject method

DESCRIPTION
Specifies a mask for an object - the object can be any display object.
The mask can be a ZIM (or CreateJS) Shape or a ZIM Rectangle, Circle, Triangle or Blob.
Masking must be done with a Shape and the ZIM shapes are actually containers with Shape objects in them.
So setMask() takes care of all the arrangements and updates the mask when using the following ZIM features:
drag(), animate(), gesture(), transform() and using the Bezier curves, etc. with Blob.

NOTE: to skew and rotate a mask, put the mask in a Container - then skew the mask and rotate the container.
That works better with skew anyway as rotation of a skewed object changes the skew.

NOTE: a Bitmap can be used for masking using the ZIM AlphaEffect
See https://zimjs.com/docs.html?item=AlphaEffect

NOTE: the mask you pass in can still be seen but you can set its alpha to 0
just watch, if you want to interact with the mask it cannot have 0 alpha
unless you provide a hit area with expand() for instance (use 0 for padding)
You can also set the alpha to .01

NOTE: before ZIM 6.7.1, setMask could not be chained - but now it can

EXAMPLE
const rect = new Rectangle(200, 100, clear)
	.center();
var label = new Label("BIG", 200, null, white)
	.center()
	.setMask(rect);
END EXAMPLE

NOTE: to drag something, the alpha cannot be 0
so we can use expand(rect, 0) to assign a hit area
then we can drag even if the alpha is 0 (or set the alpha to .01)

EXAMPLE
const label = new Label("BIG", 200, null, white).center();
const rect = new Rectangle(200, 100, black)
	.expand(0)
	.center()
	.alp(0)
	.drag();
label.setMask(rect);
END EXAMPLE

NOTE: animate(), drag(), gesture() and transform() work specially with zim shapes to make this work
otherwise, if you want to reposition your mask then set the dynamic parameter to true
or use a zim.Shape() or createjs.Shape directly to avoid this issue

EXAMPLE
// masking with a Blob
const image = new Pic("pic.jpg").centerReg();
const blob = new Blob({color:faint}).center(); // this is draggable by default
image.setMask(blob);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
mask - the object whose shape will be the mask
dynamic - (default false) set to true if mask is being moved
	Blobs and shapes with drag(), transform(), gesture() and animate() will auto set dynamic to true if dynamic parameter is left empty
	Setting dynamic to false for these will remain with a setting of dynamic false and the mask will not move once set

NOTE: use obj.setMask(null) to clear the mask

RETURNS the object for chaining
Older versions returned the mask shape - the mask shape can now be accessed by obj.zimMask or mask.zimMask
--*///+50.1
	zim.setMask = function(obj, mask, dynamic) {
		z_d("50.1");
		if (zot(obj)) {zogy("zim methods - setMask(): please provide obj");}
		if (zot(mask)) {setMaskNull(); return obj;}
		var stage = obj.stage||(WW.zdf?WW.zdf.stage:null);
		function setMaskNull() {
			if (obj.zimMask && obj.zimMask.parent) obj.zimMask.parent.removeChild(obj.zimMask);
			obj.zimMask = null;
			if (obj.zimMaskTicker) zim.Ticker.remove(obj.zimMaskTicker);
			obj.mask = null;
		}
		if (obj.zimMaskOriginal && obj.zimMaskOriginal != mask) setMaskNull();
		if (zot(dynamic)) {
			// blob, drag, transform, gesture, animate
			dynamic = (mask.type=="Blob" || !zot(mask.zimDown) || !zot(mask.transformControls) || !zot(mask.zimTouch) || !zot(mask.zimTweens));
			mask.zimMaskDynamic = dynamic;
		}
		obj.zimMaskOriginal = mask;
		var m;
		function apply() {
			if (dynamic && (!stage || !mask.stage)) return obj;
			if (m) {				
				if (m.dispose) m.dispose(); // will remove
				else mask.removeChildAt(0);
			}
			m = null;			
			obj.zimMask = mask.zimMask = m = mask.shape.clone();
			zim.copyMatrix(m, mask);
			mask.addChildAt(m,0);
			m.alpha = 0;

			if (!obj.parent) {obj.mask = m; return;}

			var mm = mask.getConcatenatedMatrix().decompose();
			var om = obj.parent.getConcatenatedMatrix().decompose();
			m.scaleX = mm.scaleX/om.scaleX;
			m.scaleY = mm.scaleY/om.scaleY;
			m.rotation = (mm.rotation?mm.rotation:0)-(om.rotation?om.rotation:0);			
			var p = mask.localToLocal(mask.shape.x+mask.regX,mask.shape.y+mask.regY,obj.parent);
			m.x = p.x;
			m.y = p.y;

			obj.mask = m;
		}
		// called from Blob and zim functions that move zim shapes
		mask.zimMaskApply = function() {
			if (obj.zimMaskTicker) zim.Ticker.remove(obj.zimMaskTicker);
			obj.zimMaskTicker = zim.Ticker.add(apply);
		};
		if (mask && mask.shape) { // zim.Rectangle, Circle or Triangle, blob
			apply();
			if (dynamic) mask.zimMaskApply();
		} else {
			m = mask;
			obj.mask = m; // set the createjs mask
		}
		return obj;
	};//-50.1

/*--
obj.outline = function(color, size, boundsOnly)

outline
zim DisplayObject method

DESCRIPTION
For testing purposes.
Draws a rectangle around the bounds of obj (adds rectangle to the objects parent).
Draws a cross at the origin of the object (0,0) where content will be placed.
Draws a circle at the registration point of the object (where it will be placed in its container).
These three things could be in completely different places ;-)

NOTE: warning - the outline is added to the object's container so this can affect the container's numChildren, etc.

NOTE: will not subsequently be resized unless called again in Ticker, pressmove event, etc.
ZIM could update this outline automatically in drag and animate
but since the outline() is used for testing, it is not a good idea to waste processing

EXAMPLE
const circle = new Circle(50, red);
circle.center();
// show registration and origin at center and bounding box around outside
circle.outline();
END EXAMPLE

EXAMPLE
Dynamic Examples
const ball = new Circle().center().drag({removeTweens:false});
ball.on("mousedown", ()=>{
	ball.outline();
});
ball.on("pressmove", ()=>{
	ball.outline();
});
ball.animate({rotation:360}, 4);
Ticker.add(()=>{ball.outline();});
END EXAMPLE

EXAMPLE
// When applying outline() in a loop - loop in reverse
// as outlines are added to the object's container
const tile = new Tile(new Rectangle(), 5, 4, 10, 10).center();
tile.loop(item=>{
	item.outline();
}, true); // reverse loop
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
color - (default brown) the color of the outline
size - (default 2) the stroke size of the outline
boundsOnly - (default false) set to true to see only rectangle bounds

PROPERTIES
adds a ZIMoutlineShape and ZIMoutlineShapeC to object
adds an outlineToggled read only property that is true if showing and false if not showing outline

METHODS
adds an outlineToggle(state) method to the object that toggles the outline when called
	or can pass in true to show outline or false to not show outline
	note - method does not update the stage
	returns object for chaining

RETURNS the obj for chaining;
--*///+47
	zim.outline = function(obj, color, size, boundsOnly) {
		var sig = "obj, color, size, boundsOnly";
		var duo; if (duo = zob(zim.outline, arguments, sig)) return duo;
		if (obj.type=="AC"&&WW.zdf) {WW.zdf.ac("outline", arguments); return obj;}
		z_d("47");
		if (obj.type && obj.type == "zimOultineShape") {
			if (zon) zogy ("zim.outline() - warning, you are trying to outline an outline - do not outline in a loop");
			return obj;
		}
		if (zot(obj) || !obj.getBounds) {zogy("zim methods - outline(): please provide object with bounds set"); return obj;}
		if (!obj.getBounds()) {zogy("zim methods - outline(): please setBounds() on object");	return obj;}
		if (!obj.parent) {zogy("zim methods - outline(): object should be on stage first"); return obj;}
		if (zot(color)) color = "brown";
		if (zot(size)) size = 2;
		if (size <= 0) {
			if (obj.ZIMoutlineShape) obj.ZIMoutlineShape.parent.removeChild(obj.ZIMoutlineShape);
			if (obj.ZIMoutlineShapeC) obj.ZIMoutlineShapeC.parent.removeChild(obj.ZIMoutlineShapeC);
			obj.ZIMoutlineShape = obj.ZIMoutlineShapeC = null;
			return;
		}
		var oB = obj.getBounds();
		var shape = obj.ZIMoutlineShape = (obj.ZIMoutlineShape)?(obj.ZIMoutlineShape):new zim.Shape();
		shape.type = "zimOutlineShape";
		var shapeC = obj.ZIMoutlineShapeC = (obj.ZIMoutlineShapeC)?(obj.ZIMoutlineShapeC):new zim.Shape();
		shapeC.type = "zimOutlineShape";
		var p = obj.parent;
		obj.outlineToggled = true;
		obj.outlineToggle = function(type) {
			if (type === true) {
				obj.ZIMoutlineShape.visible = true;
				obj.ZIMoutlineShapeC.visible = true;
			} else if (type === false) {
				obj.ZIMoutlineShape.visible = false;
				obj.ZIMoutlineShapeC.visible = false;
			} else {
				obj.ZIMoutlineShape.visible = !obj.ZIMoutlineShape.visible;
				obj.ZIMoutlineShapeC.visible = !obj.ZIMoutlineShapeC.visible;
			}
			obj.outlineToggled = obj.ZIMoutlineShape.visible;
			return obj;
		};

		var pTL = obj.localToLocal(oB.x, oB.y, p);
		var pTR = obj.localToLocal(oB.x+oB.width, oB.y, p);
		var pBR = obj.localToLocal(oB.x+oB.width, oB.y+oB.height, p);
		var pBL = obj.localToLocal(oB.x, oB.y+oB.height, p);
		var pC = obj.localToLocal(0, 0, p);

		var g = shape.graphics.c();
		var gC = shapeC.graphics.c();
		g.s(color).ss(size)
			.mt(pTL.x, pTL.y)
			.lt(pTR.x, pTR.y)
			.lt(pBR.x, pBR.y)
			.lt(pBL.x, pBL.y)
			.lt(pTL.x, pTL.y)
			.cp();

		// subtract a scaled top left bounds from the top left point
		// zero = {x:pTL.x-oB.x*obj.scaleX, y:pTL.y-oB.y*obj.scaleY};

		if (!boundsOnly) {
			// cross at 0 0
			var s = 10;
			var ss = s+1;
			gC.s("white").ss(size+2);
			gC.mt(-ss, 0).lt(ss, 0);
			gC.mt(0, -ss).lt(0, ss);
			gC.s(color).ss(size);
			gC.mt(-s, 0).lt(s, 0);
			gC.mt(0, -s).lt(0, s);
			gC.cp();
			shapeC.x = pC.x;
			shapeC.y = pC.y;
			shapeC.rotation = obj.rotation;

			// circle at registration point
			g.s("white").ss(size+2).dc(obj.x,obj.y,s+6);
			g.s(color).ss(size).dc(obj.x,obj.y,s+6);
		}

		obj.parent.removeChild(shape);
		obj.parent.removeChild(shapeC);
		var index = obj.parent.getChildIndex(obj);
		obj.parent.addChildAt(shapeC, index+1);
		obj.parent.addChildAt(shape, index+1);


		shape.mouseEnabled = false;
		shapeC.mouseEnabled = false;
		// if (obj.stage) obj.stage.update();
		return obj;
	};//-47
	
// 
/*--
obj.blendmodes = function(time, basic)

blendmodes
zim DisplayObject method

DESCRIPTION
For testing purposes.
Cycles through blendmode (composite operation) settings.
Click the object to toggle the cycling.

SEE: ble() for modes and how to set the blendmode

EXAMPLE
new Rectangle(W, H, red).addTo();
new Circle(200, blue).blendmodes(); // will cycle through blend modes
END EXAMPLE

PARAMETERS 
time - (default 1) seconds to see each blendmode
basic - (default true) set to false to include extra compositions like source-over, destination-out, xor, etc.

RETURNS the obj for chaining;
--*///+47.05
	zim.blendmodes = function(obj, interval, basic) {
		z_d("47.05");

		if (zot(interval)) interval = 1;
		
		var types = ["normal", "multiply", "screen", "overlay", "darken", "lighten", "color-dodge", "color-burn",  "hard-light", "soft-light", "difference", "exclusion", "hue", "saturation", "color", "luminosity"];
		if (basic === false) types.push("source-over", "source-in", "source-out", "source-atop", "destination-over", "destination-in", "destination-out", "destination-atop", "copy", "xor");		
				
		var count = 0;
		var ti = zim.interval(interval, function(){
			var type = types[count%types.length];
			count++;
			obj.ble(type);
			zogb(type);
			if (obj.stage) obj.stage.update();
		});
		
		obj.on("mousedown", function() {
			ti.pause(!ti.paused);
		});	

		return obj;
	};//-47.05


////////////////  ZIM CONTROLS  //////////////

// Zim Controls (formerly Zim Pages) helps you layout and control flexive pages, click and swipe between pages and more
// classes in this module require createjs namespace to exist and in particular easel.js
// available at https://createjs.com

/*--
zim.STYLE and Style()

STYLE
zim constant and static Class

DESCRIPTION
STYLE can be used to set any parameter on a DisplayObject and many of the Controls.
For instance: Circle, Blob, Button, Pane, Bitmap, Sprite, Tile, Pen, Emitter, Scroller, etc.
These are applied at the time the objects are made.
They are cascading with each level overriding the previous level:

1. GENERAL: any style can be specified in general
	corner:30 will make all corners default to 30
2. TYPE: styles for object type can be set to override the general styles
	Button:{corner:0} will make all button corners default to 0
3. GROUP: styles for a group can be set to override the type styles
	homePage:{corner:20} will make all objects of that group default to 20
4. OBJECT: styles applied as parameters to the object override all other styles
	new Button({corner:40}) will make this button have a corner of 40

See: https://zimjs.com/style.html for an example
And: https://zimjs.com/test/styles.html for Control Styles

NOTE: As of ZIM Cat, a Style class has been added with the static methods to manage styles
STYLE is an object so all of these are just a couple lines to make it easier to update the object.
These include methods such as clear(), add(), remember(), addType(), addGroup(), etc.
See the Style entry down below for a complete listing and description.

NOTE: As of ZIM Cat 03, Direct Object styles are supported - adding DisplayObjects to a type {} is no longer required.
STYLE = {Button:{width:500}} // will be automatically converted to STYLE = {type:{Button:{width:500}}}

NOTE: As of ZIM ZIM 01, Direct Group styles are supported - adding a group to a group {} is no longer required.
The group must start with a lowercase letter.
STYLE = {big:{width:500}} // will be automatically converted to STYLE = {group:{big:{width:500}}}

NOTE: As of ZIM 016, group styles for an object will be used even if style for the object is set to false
this will ignore all styles except those made by a group

EXAMPLE
STYLE = {
	corner:20,
	backgroundColor:pink,
	type:{
		Button:{width:{min:100, max:500}, corner:0, centerReg:true, move:{y:series(-150, -50, 50, 150)}},
		Dial:{add:true, x:800, y:600, backgroundColor:red, scale:2, outline:true},
		Pane:{corner:ignore, color:white, draggable:true, width:300, label:"HI!"},
		ProgressBar:{add:true, x:200, y:600, barType:"rectangle", transform:true},
		Tabs:{add:true, x:100, y:100}
	},
	group:{
		homePage:{corner:30}
	}
}
new Button(); // will have a corner of 0 and be pink
new Button({group:"homePage"}); // will have a corner of 30 and be pink
new Button({corner:10, group:"homePage"}); // will have a corner of 10 and be pink
new Button({corner:"ignore"}) // will have a corner of its default 20 and be pink
new Button({style:false}).pos(700,100); // will have original default styles
new Dial(); // will be red and scaled twice as big and have an outline
new Tabs(); // will have a corner of 20 and selection will be pink
var p = new ProgressBar({corner:15}); // will be a bar with transform tools, corner 15
p.percent = 25;
new Pane().show(); // will ignore corner 30 and use its original 20 - it will say HI! in white and be draggable
END EXAMPLE

EXAMPLE 
// Lazy Objects - as of ZIM Cat 03
STYLE = {
	Circle:{color:red} // all circles made from now on are red
}
// This will be automatically converted by ZIM to:
STYLE = {
	type:{
		Circle:{color:red} 
	}    
}

Style.add({Circle:{color:red}}); // Lazy Objects with Style would do the same 
Style.addType("Circle",{color:red}); // the traditional Style way also works
new Circle(50).center();
END EXAMPLE

EXAMPLE 
// Lazy Groups - as of ZIM ZIM 01
// note: these must be lowercase so not confused with Lazy Objects
STYLE = {
	alert:{color:red} // all objects with group alert made from now on are red
}
// This will be automatically converted by ZIM to:
STYLE = {
	group:{
		alert:{color:red} 
	}    
}

Style.add({alert:{color:red}}); // Lazy Groups with Style would do the same 
Style.addGroup("alert",{color:red}); // the traditional Style way also works
new Circle({group:"alert"}).center();
END EXAMPLE

EXAMPLE 
// using once to run a STYLE on only the next object
STYLE = {color:red, once:true}
new Circle().center(); // this will be red
new Circle().center().mov(20); // this will be black
END EXAMPLE

EXAMPLE
STYLE = {
	borderColor:dark,
	borderWidth:5,
	Rectangle:{
		// color:red,
		color:[red, pink, purple], // pick a random color from here
		centerReg:true,
		animate:{props:{rotation:360}, time:.5, ease:"linear", loop:true},
		move:{x:series(-200, 0, 200)}
	}
}
// make three spinning rectangles
loop(3, ()=>{new Rectangle();});
END EXAMPLE

EXAMPLE 
// this makes all objects be cached at their width and height
STYLE = {cache:true}

// specify width and height for any Label
STYLE = {	
	Label:{
		cache:{width:20, height:20} // or also pass in x and y
	}
}
END EXAMPLE

EXAMPLE 
// have Circle ignore red but use percent - groupOnly
STYLE = {color:red, wonder:{percent:50}};
new Circle({style:false, group:"wonder"}).center();
END EXAMPLE

EXAMPLE
// Note: these commands are on the Style class not STYLE - but they operate on STYLE
// Also remember that ZIM STYLE only gets applied to new objects
// changing a STYLE will not change objects already created - this is different than CSS

// add a general color red style overwriting any previous color setting
Style.add({color:red});

// remove the general style for color
Style.remove("color");

// add styles for a Dial - overwriting all previous Dial styles
Style.addType("Dial", {useTicks:false, backgroundColor:yellow});

// remember current style using a "default" id
Style.remember();

// new Dials will use ticks and not be yellow
Style.addType("Dial", {useTicks:true});

// bring back the remembered styles so new Dials will have no ticks and be yellow
Style.recall();

// remember current STYLE to an id
Style.remember("myID");

// add styles for a group (existing objects are not changed - new ones will be)
Style.addGroup("big", {size:100});

the STYLE at the time myID was remembered will be active from now on
Style.recall("myID");
END EXAMPLE

TRANSFORM STYLES
Transformations can also be applied (all are numbers - visible is a Boolean):
x, y, rotation, alpha, scale, scaleX, scaleY, regX, regY, skewX, skewY, visible
a bounds style has a value of {x:Number, y:Number, width:Number, height:Number}
where x and y are optional

RANDOM, RANGES, AND SERIES STYLES
Any property value can be a ZIM VEE value to make use of ZIM Pick see https://zimjs.com/docs.html?item=Pick
color:[red, green, blue] will pick a random color for each object for which the style is applied
x:series(100,200,300) will place subsequent objects at these locations
width:{min:100, max:500} will make objects with a width within this range
corner:{noPick:[0,40,0,40]}; will set corners - note we have to noPick this otherwise it would pick a number from the array for the corner value
See Docs on ZIM Pick() and ZIM series() for more information
Use the delayPick:true style to pass a PICK object to a control
See: https://zimjs.com/explore/circleArcs.html
WARNING - if applying a ZIM VEE value for a property in the general style scope 
it will be activated for every object made even if that object does not have that property.
This will affect a series for instance. If three Sliders with useLabels turned on are made 
and the STYLE = {max:series(8,9,10)} this will not work as expected 
as the labels trigger the series steps as well.
So use STYLE = {Slider:{max:series(8,9,10)}} instead so the series triggers only for Slider objects.

ONCE
Set a once property to true to run the STYLE setting on only the next object made.
Once will delete the STYLE after the next object is made 
regardless of the whether the style is applied.
STYLE = {color:red, once:true}
new Circle().center(); // this will be red
new Circle().center().mov(20); // this will be black
Set a once property to a type such as "Label" and the STYLE will be cleared after a label has been made 
Note: some objects like an Arrow is made from a Button which has a label so this sometimes can be tricky. 
If it does not work, just turn the STYLE = {} or Style.clear() manually.

FUNCTION STYLES
The following functions have been added:
addTo, loc, pos, center, centerReg, reg, transform, drag, gesture,
tap, change, hold, outline, bounds, mov, animate, wiggle, expand and cache
Values of true will give default functionality for all but tap, change, mov, animate and wiggle
ZIM DUO configuration objects can be set as a value for any of these
example: drag:true;  or  drag:{onTop:false}
For animate and wiggle, [] can be put around multiple configuration objects
to wiggle in the x and y for instance or run multiple animate calls on the object
The tap, change and hold events are only what function to call - no extra parameters are available
They can be turned off with noTap, noChange and noHold styles.

CONVENIENCE STYLES
add:true - has been provided to add to the stage (use addTo for other containers)
move:{x:value, y:value} or move:x - mirrors the mov Function style (just adding the e)
pos: has corner convenience values: "left", "right", "top", "bottom", "rightbottom" or "bottomright", "center" and "centerReg"
blendMode:"difference", etc. see ble()
cursor:true for pointer or use any CSS cursor type.  Gets passed into cur() for the object
shadow:{color:value, offsetX:value, offsetY:value, blur:value} to apply a shadow
uppercase:true - to set text to uppercase if object has a label or a text property
mouse:false - set the object to noMouse() - no point in ever setting this to true as true is the default
visible:false - visible false
style:false - will turn off all styles for the selector

EXCLUSION
A value of ignore can be used to exclude any earlier styles and return to the original default.
ignore is a ZIM global variable - if zns is true then use zim.ignore or just "ignore".
Setting style:false will exclude the object from all styles
All DisplayObjects have a style parameter (default true). Set to false to ignore styles.

GROUPS
All DisplayObjects have a group parameter.
This parameter accepts a string or a comma delimited string of multiple groups.
The group of components can then be targeted in the Group section of STYLE
or as of ZIM ZIM 01, just the Lazy Group can be used to put just the group name (must start with lowercase letter)
A group can contain just one component and act like an ID in CSS.

INHERIT
Objects can inherit styles from their parent
Eg. setting a color font property on List will pass that to Tabs which pass it to Button which passes it to Label
This was initially set up manually but a new inherit parameter was created for a better system
If any styles are not being applied as expected or as desired, let us know at https://forum.zimjs.com and we can adjust!
The inherit property on the Components can be used to pass an object literal of styles to the component directly as well

STYLES FOR CUSTOM CLASSES
EXAMPLE
// 1. collect parameters: style, group, inherit
// 2. after calling super constructor add these:
	this.type = "Classname";
	this.group = group;
	var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
// 3. collect parameters like so:
	if (radius==null) radius = DS.radius!=null?DS.radius:100; // where 100 is default
// 4. call styleTransforms at bottom of class:
	if (style!==false) zim.styleTransforms(this, DS);
// 5. use styles in your app code:
	STYLE = {		
		Classname:{
			radius:200
		}		
	}
END EXAMPLE

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

Style() - ZIM class
Style provides static methods (on the class directly) to make changes to STYLE
These are very small - the techniques are provided as a comparison
Note: these affect only new objects - objects already created will not be changed

Style.clear() - clears the STYLE
	same as: STYLE = {};
Style.clearTypes() - clears the types
	same as: delete STYLE.types;
Style.clearGroups() - clears the groups
	same as: delete STYLE.groups
Style.remembered - property for holding remembered styles
	same as: remembered = {};
Style.remember(id) - stores a copy of the current style in memory at an id or "default"
	same as: remembered[id||"default"] = zim.copy(STYLE); // makes a copy and clones cloneable objects
Style.clearRemembered(id) - clears all remembered styles
	same as: delete remembered[id||"default"];
Style.recall(id) - sets the current style to a remembered STYLE
	same as: STYLE = remembered[id];
Style.add(obj) - adds general styles in form {newStile:val, newStyle2:value}
	same as: STYLE.newStyle = val; STYLE.newStyle2 = val;
	can also pass in Lazy Object style: Style.add({Object:{newStyle:value}});
	or use Style.addType() below
Style.addType(typeName, obj) - adds a type along with its styles - overwrites the same type
	same as: STYLE.type.typeName = obj;
Style.addGroup(groupName, obj) - adds a group along with its styles - overwrites the same group
	same as: STYLE.group.groupName = obj;
Style.remove(styleName) - removes a single general style specified as a string - same as delete STYLE.styleName
	same as: delete STYLE.styleName;
Style.removeType(typeName) - removes a type as string
	same as: delete STYLE.type.typeName
Style.removeGroup(groupName) - removes a group as a string
	same as: delete STYLE.group.groupName
--*///+50.34
	zim.STYLE = null;
	zim.ignore = "ignore";
	zim.getStyle = function(type, group, inherit, groupOnly) {
		if (!zim.STYLECHECK) {z_d("50.34"); zim.STYLECHECK=true;}

		var functionList = ["tap", "change", "hold", "noTap", "noChange", "noHold", "pos", "addTo", "center", "centerReg", "reg", "mov", "move", "drag", "transform", "gesture", "mouse", "expand", "outline", "bounds", "animate", "wiggle", "cache", "cursor","uppercase", "shadow"];

		// called by DisplayObjects
		// ZIM NFT MODULE ADJUST
		var STYLE = WW.STYLE || zim.STYLE;
		var DS = STYLE;		
		var val;

		// groupOnly - ZIM 015 
		var onlyCheck = false;
		if (!zot(groupOnly)) {
			type = null;
			group = groupOnly;
			onlyCheck = true;
		}

		// convert Lazy Object styles - ZIM Cat 03
		if (STYLE && STYLE.type && typeof STYLE.type == "string") {		
			STYLE.ttype = STYLE.type;			
			delete STYLE.type;
		}
		for (var prop in STYLE) {
			val = STYLE[prop]; 		
			if (prop.match(/^[(A-Z)]/)) {				
				if (!STYLE.type) STYLE.type = {};            
				if (STYLE.type[prop]) STYLE.type[prop] = zim.merge(STYLE.type[prop], val);
				else STYLE.type[prop] = val;   
				delete STYLE[prop];         
			} else if (val.constructor === {}.constructor && prop!="group" && prop!="type" && !zim.isPick(val) && functionList.indexOf(prop)==-1) {
				// Added Lazy Group in ZIM ZIM 01 post stable patch
				if (!STYLE.group) STYLE.group = {};            
				if (STYLE.group[prop]) STYLE.group[prop] = zim.merge(STYLE.group[prop], val);
				else STYLE.group[prop] = val;   
				delete STYLE[prop];
			}
		}
		// end Lazy
		
		// 016 - added !onlyCheck here for when a group is set and style is false but the group does not exist 
		// this was letting styles in as the next check gave empty group styles
		if (!zot(DS)) DS = zim.copy(DS); // can't copy with clone due to recursion
		else DS = {};

		// an object of styles from creator class that have already been ziked
		// for instance, List calls Window and Tabs and these can inherit styles applied to the List
		// Tabs call Buttons and Labels and these can inherit styles from the List and Tabs
		// List will overwrite Button styles - so originator overwrites subsequent styles

		var i;
		if (zot(inherit)) {
			inherit = {};
		} else {
			// remove any functions from inheritance
			for (i=0; i<functionList.length; i++) {
				delete inherit[functionList[i]];
			}
		}
		var IS = inherit;

		var TS = DS.type;
		if (TS) delete DS.type;
		if (!zot(group) && !zot(DS.group)) {
			var groups = group.split(","); // support comma delimited multiple groups
			var GS = {};
			for (i=0; i<groups.length; i++) {
				var g = groups[i].trim();
				if (!zot(DS.group[g])) GS = zim.merge(GS, DS.group[g]);
			}
			delete DS.group;
		}

		if (onlyCheck) {
			DS = {}; // watch if GS is null this would let styles leak through on onlyCheck unless reset DS
			if (!zot(group) && !zot(GS)) DS = GS;
		} else {
			if (!zot(type) && !zot(TS) && !zot(TS[type])) DS = zim.merge(DS, TS[type]);
			if (!zot(group) && !zot(GS)) DS = zim.merge(DS, GS);
		}

		for (var s in DS) {
			if (IS[s]) { // inherited value overrides
				delete DS[s];
				continue;
			}
			val = functionList.indexOf(s)==-1&&!DS.delayPick?zim.Pick.choose(DS[s]):DS[s]; // do not zik configuration objects of methods
			if (val=="ignore") {delete DS[s]; continue;}
			// not sure what the line below was for - maybe auto cloning a bitmap? but had to remove it ZIM 9.5.0 when debugging addTo STYLE issues
			// else if (val && val.clone && val.type != type && val.type != "Stage" && val.type != "StageGL") val = val.clone();
			// copy config objects with clone except for type container - do not center or centerReg on shape
			else if (val && val.constructor === {}.constructor) val = zim.copy(val, true, false);
			var zm; for (var z in DS) {
				if (zm=z.match(/^(.+)gColor$/)) {
					DS[zm[1]+"ackgroundColor"] = DS[z];
					delete DS[z];
				}
			}
			DS[s] = val;
		}
		DS = zim.merge(DS, IS);
		if (DS.ttype && !DS.type) {DS.type = DS.ttype; delete DS.ttype;}
		if (DS.style===false) return {};

		return DS;
	};

// sets x, y, alpha, rotation, scale, scaleX, scaleY, regX, regY, skewX, skewY, bounds, visible
// also sets tap, change, addTo, center, centerReg, transform, drag, gesture, animate, wiggle, expand, cache, and outline (used internally)
zim.styleTransforms = function(obj, styles) {
		
	var zimTransformList = ["visible","x","y","scale","scaleX","scaleY","rotation","alpha","skewX","skewY","blendMode"];
	
	var i;
	if (styles) {	
		if (styles.add) {
			obj.addTo();
		}		
		if (styles.cursor) {
			if (obj.cur) obj.cur(styles.cursor===true?"pointer":styles.cursor);
		}
		if (styles.shadow) {
			if (obj.sha) obj.sha(styles.shadow.color, styles.shadow.offsetX, styles.shadow.offsetY, styles.shadow.blur);
		}
		if (styles.addTo) {
			obj.addTo(styles.addTo===true?null:styles.addTo);
			// not sure what these were doing below but replaced them with above... ZIM 9.5.0
			//obj.addTo(styles.addTo.constructor==={}.constructor?styles.addTo:null);
		}		
		for (i=0; i<zimTransformList.length; i++) {
			if (styles[zimTransformList[i]]!=null) obj[zimTransformList[i]] = zim.Pick.choose(styles[zimTransformList[i]]);
		}
		if (styles.regX!=null || styles.regY!=null) { // ZIM ZIM 02 - moved regX and regY here
			obj.reg(zot(styles.regX)?DEFAULT:styles.regX, zot(styles.regY)?DEFAULT:styles.regY);
		}
		if (styles.bounds) {
			if (styles.bounds.constructor==={}.constructor) {
				obj.setBounds(styles.bounds.x?styles.bounds.x:0, styles.bounds.y?styles.bounds.y:0, styles.bounds.width?styles.bounds.width:100, styles.bounds.height?styles.bounds.height:100);
			}
		}
		if (styles.center) {
			obj.center(styles.center===true?null:styles.center);
			// obj.center(styles.center.constructor==={}.constructor?styles.center:null);
		}
		if (styles.centerReg) {
			obj.centerReg(styles.centerReg===true?null:styles.centerReg);
			//obj.centerReg(styles.centerReg.constructor==={}.constructor?styles.centerReg:null);
		}
		if (styles.reg!=null) {
			if (styles.reg.constructor==={}.constructor) {
				obj.reg(zim.Pick.choose(styles.reg.x), zim.Pick.choose(styles.reg.y), styles.reg.still);
			} else {
				obj.reg(styles.reg);
			}
		}
		if (styles.x!=null) {
			if (styles.loc) {
				if (styles.loc.x==null) styles.loc.x = styles.x;
			} else {
				styles.loc = {x:styles.x};
			}
		}
		if (styles.y!=null) {
			if (styles.loc) {
				if (styles.loc.y==null) styles.loc.y = styles.y;
			} else {
				styles.loc = {y:styles.y};
			}
		}
		if (styles.loc) {
			if (styles.loc.constructor==={}.constructor) {
				obj.loc(zim.Pick.choose(styles.loc.x), zim.Pick.choose(styles.loc.y));
			} else {
				obj.loc(zim.Pick.choose(styles.loc));
			}
		}
		if (styles.pos) {
			if (styles.pos.constructor==={}.constructor) {
				obj.pos(zim.Pick.choose(styles.pos.x), zim.Pick.choose(styles.pos.y), zim.Pick.choose(styles.pos.horizontal), zim.Pick.choose(styles.pos.vertical), zim.Pick.choose(styles.pos.container), zim.Pick.choose(styles.pos.index), styles.pos.add, zim.Pick.choose(styles.pos.reg), zim.Pick.choose(styles.pos.regX), zim.Pick.choose(styles.pos.regY));				
			} else {
				var sp = zim.Pick.choose(styles.pos);
				if (sp == "left" || sp == "top") obj.pos();
				if (sp == "right") obj.pos({horizontal:"right"});
				if (sp == "bottom") obj.pos({vertical:"bottom"});
				if (sp == "rightbottom" || sp == "bottomright") obj.pos({horizontal:"right", vertical:"bottom"});
				if (sp == "center") obj.center();
			}
		}
		if (styles.mov || styles.move) {
			if (styles.move) styles.mov = styles.move;
			if (styles.mov.constructor==={}.constructor) {
				obj.mov(zim.Pick.choose(styles.mov.x), zim.Pick.choose(styles.mov.y));
			} else {
				obj.mov(zim.Pick.choose(styles.mov));
			}
		}		
		if (styles.outline) {
			setTimeout(function(){
				obj.outline(styles.outline.constructor==={}.constructor?styles.outline:null);
				if (obj.stage) obj.stage.update();
			},20);
		}
		if (styles.drag) {
			obj.drag(styles.drag.constructor==={}.constructor?styles.drag:{currentTarget:true});
		}
		if (styles.gesture) {
			obj.gesture(styles.gesture.constructor==={}.constructor?styles.gesture:null);
		}
		if (styles.mouse===false) {
			obj.noMouse();
		}
		if (styles.transform) {
			setTimeout(function(){obj.transform(styles.transform.constructor==={}.constructor?styles.transform:null);},20);
		}
		if (styles.animate) {
			if (!Array.isArray(styles.animate)) styles.animate = [styles.animate];
			for (i=0; i<styles.animate.length; i++) {
				-function(){
					var sty = styles.animate[i];
					if (sty.constructor==={}.constructor) setTimeout(function(){obj.animate(sty);},20);
				}();
			}
		}
		if (styles.wiggle) {
			if (!Array.isArray(styles.wiggle)) styles.wiggle = [styles.wiggle];
			for (i=0; i<styles.wiggle.length; i++) {
				-function(){
					var sty = styles.wiggle[i];
					if (sty.constructor==={}.constructor) setTimeout(function(){obj.wiggle(sty);},20);
				}();
			}
		}
		if (styles.expand) {
			obj.expand(styles.expand===true?null:styles.expand);
		}
		if (styles.cache) {
			if (styles.cache.constructor==={}.constructor) {
				if (styles.cache.x) obj.cache(zim.Pick.choose(styles.cache.x), zim.Pick.choose(styles.cache.y), zim.Pick.choose(styles.cache.x), zim.Pick.choose(styles.cache.y));
				else obj.cache(zim.Pick.choose(styles.cache.width), zim.Pick.choose(styles.cache.height));
			} else {
				obj.cache();
			}
		}	
		if (styles.uppercase && (obj.text || obj.label)) {
			if (obj.text) obj.text = obj.text.toUpperCase();
			else obj.label.text = obj.label.text.toUpperCase();
		}

		if (styles.tap && obj.tap) obj.tap(styles.tap);
		if (styles.change && obj.change) obj.change(styles.change);
		if (styles.hold && obj.hold) obj.hold(styles.hold);
		if (styles.noChange && obj.noChange) obj.noChange();
		if (styles.noTap && obj.noTap) obj.noTap();
		if (styles.noHold && obj.noHold) obj.noHold();

		var STYLE = WW.STYLE || zim.STYLE;
		if (STYLE && (STYLE.once===true || STYLE.once==obj.type)) {			
			if (WW.STYLE) WW.STYLE = {}; else zim.STYLE = {};
		}		
	}
};

zim.Style = {
	remembered:{},
	clear:function() {if (WW.STYLE) WW.STYLE = {}; if (zim.STYLE) zim.STYLE = {}; return zim.Style;},
	clearTypes:function() {var STYLE = WW.STYLE || zim.STYLE; delete STYLE.types; return zim.Style;},
	clearGroups:function() {var STYLE = WW.STYLE || zim.STYLE; delete STYLE.groups; return zim.Style;},
	remember:function(id) {
		if (zot(id)) id = "default";
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		zim.Style.remembered[id]=zim.copy(STYLE, true);
		return zim.Style;
	},
	clearRemembered:function(id) {
		if (zot(id)) zim.Style.remembered = {};
		else delete zim.Style.remembered[id];
		return zim.Style;
	},
	recall:function(id) {
		if (zot(id)) id = "default";
		if (WW.STYLE) WW.STYLE = zim.Style.remembered[id]; 
		else zim.STYLE = zim.Style.remembered[id];
		return zim.Style;
	},
	add:function(obj) {
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		if (WW.STYLE) WW.STYLE = zim.merge(STYLE, obj);
		else zim.STYLE = zim.merge(STYLE, obj);
		return zim.Style;
	},
	addType:function(typeName, obj) {
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		if (!STYLE.type) STYLE.type = {};
		STYLE.type[typeName] = obj;
		return zim.Style;
	},
	addGroup:function(groupName, obj) {
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		if (!STYLE.group) STYLE.group = {};
		STYLE.group[groupName] = obj;
		return zim.Style;
	},
	remove:function(styleName) {
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		delete STYLE[styleName];
		return zim.Style;
	},
	removeType:function(typeName) {
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		if (!STYLE.type) return zim.Style;
		delete STYLE.type[typeName];
		return zim.Style;
	},
	removeGroup:function(groupName) {
		var STYLE = WW.STYLE || zim.STYLE; 
		if (!STYLE) {
			if (zns) STYLE = zim.STYLE = {};
			else STYLE = WW.STYLE = {};
		} 
		if (!STYLE.group) return zim.Style;
		delete STYLE.group[groupName];
		return zim.Style;
	}
};
//-50.34

/*--
zim.PATH

PATH
zim global variable

DESCRIPTION
PATH is used by lazy-loaded assets (not using Frame assets parameter or loadAssets() method).
This will be set by default to the latest path parameter in Frame or in loadAssets().

NOTE: if an lazy-loaded asset has a path in it (as in a /) then the PATH will be ignored.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// inside a ZIM Frame where no assets or path are provided:
new Pic("image.png").center(); // will look in local directory 
new Pic("images/image.png").center(); // will look in images/ directory 

PATH = "assets/";
new Pic("image.png").center(); // will look in assets/ directory
new Pic("sound.mp3").play(); // will look in assets/ directory
new Pic("test/image.png").center(); // will look in test/ directory
END EXAMPLE

EXAMPLE
// inside a ZIM Frame with assets parameter of "image.png" and path parameter of "assets/" 
new Pic("image.png").center(); // will look in the assets/ directory 
new Pic("other.png").center(); // will look in the assets/ directory

PATH = null;
new Pic("image.png").center(); // will look in assets/ directory
new Pic("other.png").center(); // will look in local directory

const load = F.loadAssets("test.png", "test/");
load.on("complete", ()=>{
	new Pic("test.png").center(); // will look in test/ directory
	S.update();
});

new Pic("new.png").center(); // will look in test/ directory
END EXAMPLE
--*///+29.35
zim.PATH = null;
//-29.35

/*--
zim.TIME

TIME
zim global variable

DESCRIPTION
Set to "seconds" or "s" (default) or to "milliseconds" or "ms" to adjust how time is used in ZIM
This will affect all time input in functions such as:
	animate()
	wiggle()
	timeout()
	interval()
	Sprite()
	Emitter()
and various minor settings in
Swiper(), Tip(), Pen(), Marquee(), Button(), ProgressBar(), Stepper(), Pages(), Accessibility(), Frame()

animate(), timeout() and interval()
also have a timeUnit parameter that will override the TIME setting

NOTE: before ZIM Cat, all time was in milliseconds.
As of ZIM Cat, time defaults to seconds.
This was primarily to make animation times a little simpler for coders, especially youth
It also matches the units of industry animate engines such as GreenSock
Once animate() was adjusted, it made sense to change globally
The one question was timeout and interval which is based on JS setTimeout and setInterval
The order of the parameters are already switched (and other features are added)
so a simpler time adds additional incentive to use ZIM timeout and interval

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// default time is in seconds
new Circle().center().animate({x:0}, 2); // in 2 seconds

TIME = "milliseconds"; // go back to ms as in pre ZIM Cat.
new Circle().center().animate({x:W}, 2000); // 2000 ms

new Circle().center().animate({
	props:{y:0},
	time:2, // back to 2 seconds because timeUnit override
	timeUnit:"seconds"
});
END EXAMPLE
--*///+29.4
zim.TIME = "seconds";
//-29.4

/*--
zim.TIMECHECK

TIMECHECK
zim global variable

DESCRIPTION
Check to see if time is in right units - default false (false as of ZIM Cat 04)
logs a warning if ((TIME=="seconds" && time>10) || (TIME=="milliseconds" && time<9))
Set TIMECHECK = true to turn on check if desired 
for instance when converting an old file to ZIM Cat and want to check for milliseconds

NOTE: as of ZIM Cat - time is in seconds rather than milliseconds
the TIMECHECK helps catch any conversion issues
See also the TIME constant if milliseconds is preferred

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// default time is in seconds
// setting TIMECHECK to true will test for any time over 10 as that may be ms 

TIMECHECK = true;
new Circle().center().wiggle("x", 100,200, 2000, 4000); // will give warning in console about time not being in ms
END EXAMPLE
--*///+29.45
zim.TIMECHECK = false;
//-29.45

/*--
zim.DIR

DIR
zim global variable

DESCRIPTION
Sets the direction to "ltr" or "rtl" (left-to-right or right-to-left)
This means the using START and END constants will affect certain positions and alignments as follows:
For pos():
	horizontal will be LEFT for START if DIR is "ltr" and RIGHT if DIR is "rtl"
	horizontal will be RIGHT for END if DIR is "ltr" and LEFT if DIR is "rtl"
For Label(), LabelLetters(), List()
	align will be LEFT for START if DIR is "ltr" and RIGHT if DIR is "rtl"
	align will be RIGHT for END if DIR is "ltr" and LEFT if DIR is "rtl"
	for LabelLetters, lineAlign is affected rather than align

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
DIR = "rtl";
new Circle().pos(100,0,START,TOP); // will pos 100 from the right
END EXAMPLE

EXAMPLE
DIR = "rtl";
new Label({
	text:"Will this wind be so mighty as to lay low the mountains of the earth?",
	labelWidth:200,
	align:START
}).center(); // will align the text to the right and then center label
END EXAMPLE
--*///+29.46
zim.DIR = "ltr";
//-29.46

/*--
zim.SEEDRAND

SEEDRAND
zim global variable

DESCRIPTION

WARNING - currently, this does not work - see seedRandom() in CODE module.

If set, the ZIM rand() function will be seeded with its value.
This means that rand() will repeat in order its random results.

See also the seed parameter of rand() to customize which rand() calls repeat.
See also SEEDRANDCOUNT to change the seed order - for instance set to 0 to start over.

This allows, for instance, a generative art piece to be the same for a certain user.
Or in conjunction with SEEDRANDCOUNT lets a player replay a same random game level.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
SEEDRAND = 20;
zog(rand(10,100)); // each time the app is run, this will be the same random number between 10 and 100
zog(rand(10,100)); // this will probably be a different random number than the first - but the same each time
zog(rand()); // and this will be the same random number between 0 and 1 not including 1.
END EXAMPLE

EXAMPLE 
// Remember the seed for a user with localStorage (like a cookie)
SEEDRAND = rand(100000000);
if (localStorage) {
	if (localStorage.seed) SEEDRAND = localStorage.seed;
	else localStorage.seed = SEEDRAND;
} 
new Circle(100, [red, green, blue]).center();

// the user will always have the same random color
// unless no localStorage or localStorage is cleared

SEEDRANDCOUNT = 0; // or SEEDRANDCOUNT--;
// below, will make another circle the same color as the first
new Circle(100, [red, green, blue]).center().mov(0,300);
END EXAMPLE
--*///+29.47
zim.SEEDRAND = null;
//-29.47

/*--
zim.SEEDRANDCOUNT

SEEDRANDCOUNT
zim global variable

DESCRIPTION

WARNING - currently, this does not work - see seedRandom() in CODE module.
but there is no equivilant to SEEDRANDOMCOUNT yet - we are working on it.

The current order number used for rand() if SEEDRAND is set or the rand() seedRand parameter is set
This starts at 0 and increases each time rand() is used internally or in the app.
 
See also SEEDRAND and the seed parameter of rand().

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE 
SEEDRAND = 10000;
zog(rand(100)); // a first random number 
zog(rand(100)); // a second random number 

SEEDRANDCOUNT = 0;
zog(rand(100)); // the first random number again 
zog(rand(100)); // the second random number again

SEEDRANDCOUNT--;
zog(rand(100)); // the second random number again

SEEDRAND = null;
zog(rand(100)); // an unseeded random number

SEEDRAND = 10000; // same seed as before 
zog(rand(100)); // a third random number (as SEEDRANDCOUNT was not changed)

SEEDRANDCOUNT = 1;
zog(rand(100)); // the second random number again (index 1)

SEEDRAND = 200;
zog(rand(100)); // a new random number but at index 2 as SEEDRANDCOUNT does NOT reset when SEEDRAND changes
END EXAMPLE
--*///+29.48
zim.SEEDRANDCOUNT = 0;
//-29.48

/*--
zim.ANIMATE

ANIMATE
zim global variable

DESCRIPTION
Set to false to stop animate() calls from working.
Handy for testing your app so you do not have to wait for animations every time!
To animate things in you can place everything in their final positions
and then set the "from" parameter to true to animate from starting positions
like x or y offstage, scale or alpha of 0, etc.
Then to avoid waiting for animations to complete, you can just set ANIMATE = false
and all your objects will be in their final locations and you don't wait for animations
When you are ready to run your animations for a final version, etc. just delete the line
or set ANIMATE to true.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
ANIMATE = false;
// without the line above, the circles will animate in
// we would have to wait for them every time we load the app
// sometimes animations are even longer and this can waste development time
// when we add the line above, the circles are on stage right away
// this is easier and safer than commenting out all your animations

const circle1 = new Circle(200, green);
circle1.center();
circle1.x -= 110;
circle1.animate({props:{alpha:0, scale:0}, time:.7, from:true});

const circle2 = new Circle(200, pink);
circle2.center();
circle2.x += 110;
circle2.animate({props:{alpha:0, scale:0}, time:.7, wait:.7, from:true});
END EXAMPLE
--*///+29.5
zim.ANIMATE = true;
//-29.5

/*--
zim.OPTIMIZE

OPTIMIZE
zim global variable

DESCRIPTION
A setting that relates to how S.update() is used by the components.
Default is false which means some components will update the stage automatically:
	the Slider will update the stage so that you can see the knob slide;
	the CheckBox and RadioButtons when checked will update the stage;
	the Tabs change button colors and then update the stage;
	closing of a Pane will update the stage
	the Stepper also updates as does changing color of a button, label, etc.
However, concurrent S.update() calls can slow down mobile performance.
So if you are making content for mobile you should set OPTIMIZE = true;
Then you will have to S.update() in the change event handlers
but you were probably doing things in these events and updating anyway!
Just be careful - you might be testing a checkbox and it won't check...
So it takes some getting used to running in optimized mode.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// add this to the top of your script
OPTIMIZE = true;
const slider = new Slider();
slider.center();
// will not see the slider operate (aside from rolling over button)
// unless you call S.update() in the change event
slider.on("change", ()=>{
	// do your code
	S.update(); // now will see the slider operate
});
END EXAMPLE

components affected by OPTIMIZE:
Label, Button, Checkbox, RadioButton, Pane, Stepper, Slider, Tabs

OPTIMIZE set to true also affects the ZIM Ticker
for functions like animate, drag, Scroller, Parallax
See zim.Ticker as you may have to set Ticker.update = true;
--*///+50.2
zim.OPTIMIZE = false;
//-50.2

/*--
zim.ACTIONEVENT

ACTIONEVENT
zim global variable

DESCRIPTION
a setting that specifies the event type to trigger many of the components
default is "mousedown" which is more responsive on mobile
setting the constant to anything else, will cause the components to use "click"

for instance, with the default settings, the following components will act on mousedown
CheckBox, RadioButtons, Pane, Stepper and Tabs

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// put this at the top of your code
ACTIONEVENT = "click";
new CheckBox().center();
// note it now operates on mouseup (click)
// the default ACTIONEVENT is mousedown
END EXAMPLE
--*///+50.3
zim.ACTIONEVENT = "mousedown";
//-50.3

/*--
zim.DEFAULTWIRE

DEFAULTWIRE
zim global variable

DESCRIPTION
The default setting for wire() and wired() source input type (the input parameter).
wire will usually be used to wire a component to a DisplayObject
and components usually have a currentValue or selectedIndex property that is changing in a change event, for instance

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// put this at the top of your code
DEFAULTWIRE = "selectedIndex";
const selector = new Selector(someTile).center();
new ColorPicker().center().wire(selector, "selectedIndex");

// the ColorPicker has a currentValue which would normally be the default for wire()
// but here we override this with the DEFAULTWIRE so the selectedIndex is used instead
// alternatively, the input parameter could be set to "selectedIndex"
// but perhaps there are many of these so the constant is provided for convenience
END EXAMPLE
--*///+50.32
zim.DEFAULTWIRE = "currentValue";
//-50.32

/*--
zim.KEYFOCUS

KEYFOCUS
zim global variable

DESCRIPTION
A global variable that stores the DisplayObjects that will receive keyboard focus.
This is a system for all DisplayObjects with keyboard controls (set to active).
Eligible DisplayObjects are:
 	Squiggle, Blob, Stepper, Slider, Dial, Tabs, ColorPicker, TextArea
The first eligible DisplayObject made will set KEYFOCUS to itself.
Anytime an eligible DisplayObject is used it sets KEYFOCUS to itself.
Eligable DisplayObjects have a keyFocus property that can be manually set.
There is only one DisplayObject with key focus
so setting removes key focus from the last key focused component.

NOTE: if tabbing from one component to the next is needed, consider using ZIM Accessibility()

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const slider = new Slider().center().mov(0, -100);
const stepper = new Stepper().center().mov(0, 100);
// arrows will control the slider as it is the first component made
// if the stepper is used then arrows will control the stepper
// if stepper.keyFocus = true is set to start then the stepper would have key control
// alternatively, KEYFOCUS = stepper; would give the stepper key control
// setting KEYFOCUS = null; would make no component have key control (until the component is pressed)
END EXAMPLE
--*///+50.33
zim.KEYFOCUS = null;
//-50.33

/*--
zim.POSREG

POSREG
zim global variable

DESCRIPTION
A global variable that stores the desired setting for the reg parameter of pos()
pos() had traditionally positioned based on registration point
Now it defaults to position to the sides or the top and bottom
Setting POSREG = true; will make pos() default to positioning at the registration

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
POSREG = false; // default
new Rectangle().pos({x:10, right:true}); // will position right side 10 pixels from right

POSREG = true;
new Rectangle().pos({x:10, right:true}); // will position registration point 10 pixels from right
END EXAMPLE
--*///+50.335
zim.POSREG = false;
//-50.335

/*--
zim.DRAGALL

DRAGALL
zim global variable

DESCRIPTION
A global variable that stores the desired setting for the all parameter of drag()
By default, drag() will drag individual items in a container (currentTarget = false)
This is handy to quickly drag a bunch of things.
But some developers are used to dragging the whole container by default.
Setting DRAGALL=true will change drag calls to default to the whole container (currentTarget = true)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
DRAGALL = false; // default
containerOfMonsters.drag(); // will drag individual monsters

DRAGALL = true;
containerOfMonsters.drag(); // will drag all the monsters at once
END EXAMPLE
--*///+50.337
zim.DRAGALL = false;
//-50.337

/*--
zim.MOBILE

MOBILE
zim global variable

NOTE: for making mobile apps - see https://zimjs.com/mobile.html
and the PWA entry in Docs https://zimjs.com/docs.html?item=PWA

NOTE: this is the MOBILE constant not the mobile() function. 
The mobile function detects if your app is on mobile
If searching for mobile press GO to go find mobile()

DESCRIPTION
A global variable that overrides ZIM mobile()
There are a half-dozen settings in ZIM that use ZIM mobile() to adjust default parameters
and various interactions - some examples are:

Squiggle() / Blob()
// handleSize = mobile?20:10;
// some interactions with controls

Button()
// toggleEvent = mobile?"mousedown":"click";

transform()
// customCursors = mobile?false:true;
// handleSize = mobile?20:10;

Accessibility()
// application = mobile?false:true;

Emitter()
// cache = mobile?false:true;

VR()
// swiper = mobile?false:true;

These settings will follow the value set by setting:
MOBILE = false;
or
MOBILE = true;

The default setting for MOBILE is "default";
If left as default, then ZIM uses the results from mobile();

WARNING: setting MOBILE will result in that value being returned from mobile();
To get an actual value from mobile() set MOBILE = "default" and run mobile();

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
MOBILE = false;
new Squiggle().center();
// will have smaller desktop Bezier handles even on mobile
// but will also set the Ticker framerate to 60, etc.
// unless MOBILE, at some point, is set back to default:
MOBILE = "default";

MOBILE = true;
new Blob().center();
// will have bigger mobile Bezier handles even on desktop
// but will also set the Ticker framerate to 30, etc.
// unless MOBILE, at some point, is set back to default:
MOBILE = "default";
END EXAMPLE
--*///+50.338
zim.MOBILE = "default";
//-50.338

/*--
zim.Ticker = {}

Ticker
zim static class

DESCRIPTION
A static class to let ZIM use a requestAnimationFrame with a single stage update.
Used by ZIM animate, drag, parallax, scrollers, etc. but any function can be added.
If a function has been added to the Ticker queue then it will run in the order added
along with a single stage update after all functions in queue have run.
There are settings that can adjust when the Ticker updates so see Usage notes below.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circle = new Circle(50, red).center();
Ticker.add(()=>{
	circle.x++;
}); // can also pass in a specific stage

// to be able to remove the function:
Ticker.add(tryMe);
function tryMe() {circle.x++;}
Ticker.remove(tryMe);

// OR with function literal, use the return value
var tickerFunction = Ticker.add(()=>{circle.x++;});
Ticker.remove(tickerFunction);

// Check to see if a function is in the Ticker for that stage:
zog(Ticker.has(tickerFunction)); // false at the moment until added again
END EXAMPLE

USAGE
if OPTIMIZE is true then the Ticker will not update the stage (it will still run functions)
however, OPTIMIZE can be overridden as follows (or with the always() method):

METHODS (static)
** As of ZIM 5.1.0, stage is optional and will default to the stage of first Frame object made
** WARNING - if you are in a second Frame you should pass stage as a parameter so it does not point to the first Frame's stage
** NOTE - if no stage is provided, the Ticker will update the stage of the zdf - ZIM default frame (usually the first Frame made)
Ticker.always(stage) - overrides OPTIMIZE and always runs an update for the stage even with no function in queue
Ticker.alwaysOff(stage) - stops an always Ticker for a stage
Ticker.add(function, stage) - adds the function to the Ticker queue for a given stage and returns the function that was added
	the function will receive a CreateJS tick object with delta, time, timeStamp, etc. properties
Ticker.remove(function) - removes the function from the Ticker queue
Ticker.removeAll([stage]) - removes all functions from the Ticker queue (optionally per stage)
Ticker.isUpdating(stage) - returns true if Ticker is updating for the stage or false if not 
Ticker.has(function, stage) - returns a Boolean true if function is currently added to the Ticker for the stage - or false if not currently added
Ticker.setFPS(60, 60) - (mobile, pc) default is set at natural requestAnimationFrame speed - this seems to be the smoothest
	Note: as of ZIM Cat 04, mobile default speed is 60fps - previous to ZIM Cat 04 mobile default speed was 30fps
Ticker.getFPS() - get the current frames per second - using createjs.Ticker.getMeasuredFPS();
Ticker.setTimingMode(mode) - (default "raf") RAF uses RequestAnimationFrame without framerate synching - gets screen synch (smooth) and background throttling
	set to "synched" for framerate synching - but will add some variance between updates
	set to "timeout" for setTimeout synching to framerate - no screen synch or background throttling (if RAF is not supported falls back to this mode)
	see CreateJS docs: https://www.createjs.com/docs/tweenjs/classes/Ticker.html
Ticker.raw(function) - a stand-alone direct call to RequestAnimationFrame for maximum speed
	Example: https://zimjs.com/raw/
 	Does not use Dictionary lookup that the add() uses so provides ultimate speed for generative art, etc.
	Returns function as id so can use Ticker.removeRaw(id)
	function will receive a single parameter that is a DOMHighResTimeStamp
	raw() does not automatically update the stage so put a S.update() in the function
	raw() is for when you want to run one function much like the draw() in Processing, the animate() renderer in ThreeJS, etc.
	add() is for when you want to run multiple functions with a single globally coordinated S.update()
Ticker.removeRaw(id) - remove the raw function based on the return value of the var id = Ticker.raw(function)
Ticker.dispose([stage]) - removes all functions from the queue removes and removes the list (optionally per stage)

PROPERTIES (static)
Ticker.update = true - overrides OPTIMIZE and forces an update if a function is in the queue
Ticker.update = false - forces no update regardless of OPTIMIZE
Ticker.update = null (default) - only updates if there is a function in queue and OPTIMIZE is false
Ticker.list - a ZIM Dictionary holding arrays with the functions in the Ticker queue for each stage
Ticker.list.objects - the array of stages in the Ticker
Ticker.list.values - the array holding an array of functions for each stage in the Ticker
Ticker.framerate - read only - use setFPS() to set

the Ticker is used internally by zim functions like animate(), drag(), wire(), Scroller(), Parallax()
you are welcome to add functions

USAGE
1. if you have your own ticker going, just set OPTIMIZE = true and don't worry about a thing
2. if you do not have your own ticker going but still want OPTIMIZE true to avoid components updating automatically,
then set OPTIMIZE = true and set Ticker.update = true
this will run a single update only when needed in zim Ticker for any zim functions
3. if you want a ticker with a single update going all the time (with OPTIMIZE true or false) then
run Ticker.always([stage]); // optionally per stage
4. if for some reason (can't think of any) you want no ticker updates for zim but want component updates
then set OPTIMIZE = false and then set Ticker.update = false
5. if you want maximum speed use Ticker.raw(function) which flows directly through to a RequestAnimationFrame
--*///+30
	zim.Ticker = {
		stages:null,
		myUpdate: null,
		alwaysList:new zim.Dictionary(),
		list:new zim.Dictionary(),
		wire:new zim.Dictionary(),
		setFPS: function(m, d) {
			if (zot(m) && zot(d)) {
				m = 60; d = 60;
			} else if (zot(m)) {
				m = 60;
			} else if (zot(d)) {
				d = m;
			}
			zim.Ticker.framerate = createjs.Ticker.framerate = (zim.mobile()) ? m : d;
		},
		setTimingMode: function(mode) {
			createjs.Ticker.timingMode = createjs.Ticker.RAF;
			if (mode == "synched") createjs.Ticker.timingMode = createjs.Ticker.RAF_SYNCHED;
			if (mode == "timeout") createjs.Ticker.timingMode = createjs.Ticker.TIMEOUT;
		},
		add: function(f, s) { // function, stage
			z_d("30");
			var t = zim.Ticker;
			if (t.has(f, s)) return f; // don't let the same function be added twice
			if (zot(s) || !s.update) s = WW.zdf.stage;
			if (zot(f) || typeof f !== 'function') {zogy("zim.Ticker.add() - only add functions"); return;}
			if (t.list.at(s)) {t.list.at(s).push(f);} else {t.list.add(s, [f]);}
			if (!t.ticker) t.ticker = createjs.Ticker.on("tick", t.call);
			if (!t.framerate) t.setFPS();
			return f;
		},
		addWire: function (obj, data) {
			z_d("30");
			if (zot(data[0])) return obj;
			var t = zim.Ticker;
			t.wire.add(obj, data);
			// data = [target-0, prop-1, twoWay-2, setSource-3, filter-4, call-5, input-6, lastValue-7]
			// if wanting to set the source equal to the target value to start...
			var current = data[0][data[1]];
			if (data[4]) current = data[4](current, "from");
			if (data[3]) obj[data[6]] = data[7] = current;

			if (!t.ticker) t.ticker = createjs.Ticker.on("tick", t.call);
			if (!t.framerate) t.setFPS();
			return obj;
		},
		rawID:{},
		raw: function(f) {
			z_d("30");
			var id = zim.makeID("letters", 7);
			-function raw(t) {f(t); zim.Ticker.rawID[id] = requestAnimationFrame(raw);}();
			return id;
		},
		removeRaw: function(id) {
			cancelAnimationFrame(zim.Ticker.rawID[id]);
			delete zim.Ticker.rawID[id];
		},
		call: function(e) {
			var t = zim.Ticker;
			var s, functions, i;
			var stages = []; // list of stages to update
			for (i=0; i<t.list.length; i++) {
				s = t.list.objects[i]; // stage
				functions = t.list.values[i]; // list of functions for the stage
				for (var j=0; j<functions.length; j++) {
					functions[j](e);
				}
				var u = false;
				if (t.alwaysList.at(s)) {
					u=true;
				} else if (functions.length > 0) {
					if (zot(t.update) && (!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE))) {
						u=true;
					} else if (t.update) {
						u=true;
					}
				}
				if (u && stages.indexOf(s) < 0) {
					stages.push(s);
				}
			}

			// check for wire
			// data = [target-0, prop-1, twoWay-2, setSource-3, filter-4, call-5, input-6, lastValue-7]
			for (i=t.wire.length-1; i>=0; i--) {
				var obj = t.wire.objects[i]; // object
				var data = t.wire.values[i]; // data
				if (data) {
					var current = obj[data[6]];
					if (current != data[7]) {
						if (data[4]) current = data[4](current, "to", data[7]);
						data[0][data[1]] = data[7] = current;
						if (data[5]) data[5](current);
						s = data[0].stage;
						if (s && stages.indexOf(s) < 0) stages.push(s);
					}
					if (data[2] && data[0]) { // twoWay
						current = data[0][data[1]];
						// zog(data[7], current)
						if (data[7] != current) {
							if (data[4]) current = data[4](current, "from", data[7]);
							obj[data[6]] = data[7] = current;
							if (data[5]) data[5](current);
							s = obj.stage;
							if (s && stages.indexOf(s) < 0) stages.push(s);
						}
					}
				}
			}

			// may have no functions to run but always is turned on
			if (t.list.length == 0) {
				for (i=0; i<t.alwaysList.length; i++) {
					s = t.alwaysList.objects[i]; // stage
					if (stages.indexOf(s) < 0) stages.push(s);
				}
			}
			var l = stages.length;
			for (i=0; i<l; i++) {
				stages[i].update();
			}
		},
		always: function(s) {
			z_d("30");
			var t = zim.Ticker;
			if (!t.framerate) t.setFPS();
			if (zot(s) || !s.update) s = WW.zdf.stage;
			t.alwaysList.add(s, true);

			if (!t.ticker) t.ticker = createjs.Ticker.on("tick", t.call);
		},
		alwaysOff: function(s) {
			var t = zim.Ticker;
			if (zot(s) || !s.update) s = WW.zdf.stage;
			t.alwaysList.remove(s);
		},
		remove: function(f) {
			var t = zim.Ticker;
			if (zot(f) || typeof f !== 'function') {zogy("zim.Ticker - only remove functions"); return;}
			for (var i=0; i<t.list.length; i++) {
				var index = t.list.values[i].indexOf(f);
				if (index > -1) {
					t.list.values[i].splice(index,1);
				}
			}
			if (t.alwaysList.length > 0 || t.list.length > 0 || t.wire.length > 0) return;
			createjs.Ticker.off("tick", t.ticker);
			t.ticker = null;
		},
		removeAll: function(s) { // functions only - not wire
			var t = zim.Ticker;
			var st;
			for (var i=0; i<t.list.length; i++) {
				st = t.list.objects[i]; // stage
				if (zot(s) || s === st) {
					t.list.values[i] = [];
				}
			}
			if (t.alwaysList.length > 0 || t.list.length > 0 || t.wire.length > 0) return;
			createjs.Ticker.off("tick", t.ticker);
			t.ticker = null;
		},
		removeWire: function(obj, target, prop, input) {
			var t = zim.Ticker;
			if (zot(obj) && zot(target) && zot(prop) && zot(input)) {
				t.wire.clear(); // remove all wires
			} else {
				for (var i=t.wire.length-1; i>=0; i--) {
					var o = t.wire.objects[i];
					var data = t.wire.values[i];
					if (!data) continue;
					if (obj && o!=obj) continue;
					if (target && data[0] != target) continue;
					if (prop && data[1] != prop) continue;
					if (input && data[6] != input) continue;
					t.wire.objects.splice(i,1);
					t.wire.values.splice(i,1);
				}
			}
			if (t.alwaysList.length > 0 || t.list.length > 0 || t.wire.length > 0) return;
			createjs.Ticker.off("tick", t.ticker);
			t.ticker = null;
		},
		isUpdating: function(s) {
			if (zot(s)) s = WW.zdf.stage;
			var u = false;
			var t = zim.Ticker;
			if (t.alwaysList.at(s)) {
				u=true;
			} else if (t.list && t.list.values.at(s) && t.list.values.at(s).length > 0) {
				if (zot(t.update) && (!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE))) {
					u=true;
				} else if (t.update) {
					u=true;
				}
			}
			return u;
		},
		has: function(f,s) { // swapped params in zim 5.3.1
			if (zot(s) || !s.update) s = WW.zdf.stage;
			return zim.Ticker.list && zim.Ticker.list.at(s) && zim.Ticker.list.at(s).indexOf(f) >= 0;
		},
		getFPS: function() {
			return createjs.Ticker.getMeasuredFPS();
		},
		dispose: function(s) {
			var t = zim.Ticker;
			var count = 0;
			var st;
			for (var i=t.list.length-1; i>=0; i--) { // countdown when removing
				st = t.list.objects[i]; // stage
				if (zot(s) || s === st) {
					t.list.remove(s);
					t.alwaysList.remove(s);
				} else {
					count+=t.list.values[i].length;
				}
			}
			if (t.alwaysList.length > 0) return;
			if (count == 0) {createjs.Ticker.off("tick", t.ticker); t.ticker = null;}
			return true;
		}
	};
	zim.Ticker.setFPS();

	Object.defineProperty(zim.Ticker, 'update', {
		get: function() {
			return zim.Ticker.myUpdate;
		},
		set: function(value) {
			var t =  zim.Ticker;
			if (typeof value != "boolean") value = null;
			t.myUpdate = value;
			if (t.myUpdate === false) {
				cancelAnimationFrame(t.ticker);
				// note, this overrides always()
				// but running always() will override update = false
				t.alwaysList = new zim.Dictionary();
			}
		}
	});//-30


// SUBSECTION PAGES, LAYOUT, ACCESSIBILITY

/*--
zim.Pages = function(pages, transition, speed, transitionTable, holder, arrowDisableColor, style, group, inherit)

Pages
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Pages handle going between pages.
Make a Pages object and add it to the stage.
All your pages from then on are added to and manipulated inside the Pages object.
Pages allows you to set the destination pages for swipe events.
Other events like buttons can call the go(page, direction) method.
Consider using HotSpots() to efficiently handle multiple buttons.

ZIM Cat introduces the ZIM Page() class that makes a Container with a background Rectangle.
This can be used as a page or any Container or other DisplayObject can be used as a page.
Transitions with ZIM Emitter were also added in ZIM Cat.
See https://zimjs.com/cat/page.html

ZIM Cat 03 intruduces the ZIM Arrow() class for an easy previous/next button system.
See https://zimjs.com/survey.html 

As of ZIM ZIM 02 a GlobalManager will be added to handle Pages resize for cached transitions.

NOTE: if you have a TextArea, Tag or Loader on a page, ZIM will automatically add and remove it.
but if the TextArea, Tag or Loader is in a Container on the page then it must be manually added and removed.
See https://zimjs.com/test/textareapages.html for an example

NOTE: if using a ZIM List in Pages then update the list after transitioning:
pages.on("pagetransitioned", ()=>{
	list.update();
});

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make pages (these can have content added to them)
const page1 = new Page(W, H, blue);
new Label("Swipe sideways").center(page1);
const page2 = new Page(W, H, green, pink); // makes a gradient
const page3 = new Page(W, H, yellow);

new Pages([page1, page2, page3], "slide").addTo();
END EXAMPLE

EXAMPLE
// PAGES WITH ARROWS
const page1 = new Page(W, H, green);
const page2 = new Page(W, H, purple, pink);
const page3 = new Page(W, H, yellow);

const pages = new Pages([page1, page2, page3], "bubbleZIM", 1).addTo();
new Arrow({pages:pages, direction:LEFT})
	.rot(180)
	.pos(50,50,LEFT,BOTTOM);
new Arrow({pages:pages}).pos(50,50,RIGHT,BOTTOM);
END EXAMPLE

EXAMPLE
// CUSTOM SWIPING
const home = new Page(W, H, blue);
new Label("Swipe up and down").center(home);
const hide = new Page(W, H, green, pink); 
const find = new Page(W, H, yellow);

// If swipe is not specified Pages will automatically swipe horizontally
// to the next page to the last page and backwards to the first page
// Here we override this with swipe arrays

const pages = new Pages({
	pages:[
		// imagine pages to the left, right, up and down
		// swipe:["to page on left", "to page on right", etc.s]
		{page:home, swipe:[null,"info",hide,find]},
		{page:hide, swipe:[null,null,null,home]},
		{page:find, swipe:[null,null,home,null]}
	],
	transition:"slide",
	speed:1 // slower than usual for demonstration
}).addTo();

// handle any events inserted into the swipe arrays
pages.on("info", ()=>{zog("info requested")});

// handle any custom requirements when arriving at a page
// the event gives you the page object
// so add a name properties just make it easier to manage
home.name = "home";
hide.name = "hide";
find.name = "find";
pages.on("page", ()=>{
	zog(pages.page.name); // now we know which page we are on
})

// you can manually go to pages as well
// we will make a little triangle to click:
const back = new Triangle({color:red});
back.center(find); // add triangle to find page
// not really supposed to add things to zim shapes
// they default to mouseChildren false
// we want to click on the back button
// so we have to set the mouseChildren of find to true
find.mouseChildren = true;
back.cur();
back.on("click", ()=>{pages.go(home, UP)});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
pages - (default null) an array of pages or page objects - for example:
	[home, hide] assuming home and hide Page or Container objects are made
	an optional swipe array holds mappings to swipe events [RIGHT, LEFT, DOWN, UP] or ["right", "left", "down", "up"]
	these could be pages to the left, right, top and bottom of the current page
	or they can be call commands as strings that will dispatch events with that name
	if no page has swipe data, then pages will swipe horizontally to each other by default with no wrap
	if swipe data is desired then use page object format:
	[{page:home, swipe:[null,"info",hide,find]},{page:hide, swipe:[null,null,null,home]}]
	set swipe:[] to not swipe the page
	just setting one page with swipe:[] and leaving the rest blank, will mean no swiping
transition - (default "none") the type of transition "none", "reveal", "slide", "fade", "clear", "black", "white", "fan"
	A ZIM Emitter() can also be passed in as a transition.
	If the emitter has vertical or horizontal set to true then the emitter will sit above a slide transition
	otherwise the emitter will sit above a fade transition.
	The following built in emitter transitions are provided:
		"pixelDark", "pixelLight", "pixelZIM",
		"bubbleDark", "bubbleLight", "bubbleZIM",
		"lineDark", "lineLight", "lineZIM"
		"explodeDark" "explodeLight" "explodeZIM"
	NOTE: if using pages that are smaller than the stage, use a Rectangle() as the holder 
		and the transition effects will be automatically masked by the rectangle. 
speed - (default .2) speed in seconds of the transition if set (see also ZIM TIME constant)
transitionTable - (default none) an array to override general transitions with following format:
	[[fromPage, toPage, "transition", seconds(optional)], etc.]
holder - (default the default stage) where are we putting the pages (used for setting transition properties)
	If using pages that are smaller than the stage 
	set the holder to a zim Rectangle with the desired dimensions and location 
	and the pages and transition effects will be masked by the shape of the rectangle.
	The rectangle will have a mouse() added so it is interactive inside. 
	Set the color of the rectangle to clear if desired.
arrowDisableColor - (default grey) the disabled backgroundColor of the ZIM Arrow buttons 
	when there is no next/prev page for that button 
	set to clear to hide the Arrow button completely
	false will not change the color but the button will not go anywhere when pressed
	
METHODS
addPage(page, swipeArray) - lets you alternatively add pages after you create the object
removePage(page) - lets you remove a page (if on this page, call a go() first and remove on the page event)
setSwipeArray(page, swipeArray) - lets you set the swipe array for a page
go(newPage, direction, trans, speed) - lets you go to a page for events other than swipe events
	newPage can be a reference to the page or an index matching the pages array order
	direction is which way the newPage is relative to the current page
	trans and speed are optional and will override any previously set transitions (speed in s)
resize() - call to resize transitions - not the pages themselves (use layouts)
pause() - pauses a transition before it starts (call from swipe event)
unpause() - unpauses a paused transition (unless another go() command is called)
puff(time) - adds all the pages behind the currentPage (adding time (s) will auto call settle)
settle() - removes all pages except the currentPage
setArrows(index) - disables or enables Arrow buttons held in arrows property - called automatically by Arrow buttons
disable() - stops swipe from activating and sets active = false
enable() - enables swipe action and sets active = true
dispose() - clears listeners and pages

PROPERTIES
type - holds the class name as a String
speed - of transitions in seconds (see also ZIM TIME constant)
transitionTable - [[fromPage, toPage, "transition", seconds(optional)], etc.] overrides default transition
page - the current page object (read)
index - the index of the current page in pages (read)
pages - the page array - in format: [{page:page1, swipe:[leftPage, rightPage, upPage, downPage]},{page:page2, swipe:[leftPage, rightPage, upPage, downPage]}]
	this may be adjusted if just an array of pages is passed which creates default swipe array
	and will be adjusted for pages added or removed with addPage or removePage methods	
lastPage - the last page before transition (read)
direction - direction of transition (read)
transitioning - read only Boolean as to whether the pages are transitioning
arrows - object with LEFT, RIGHT, DOWN, UP properties each holding an array of ZIM Arrow buttons if created
arrowDisableColor - the disable color of the Arrow buttons if created
active - default true, boolean to have swipes active (good for layered Pages objects)
swipe - the ZIM Swipe object used for pages (can tweak distance to percentage if rescaling)

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
Pages dispatches a "page" event when the page changes (to a page in the swipe array)
myPages.on("page",function(e){...})
with myPages.page being set to the new page (e.target.page)
and myPages.lastPage being set to the old page (e.target.lastPage)
myPages.direction gets the direction of the transition (e.target.direction)

if there is a string in the swipe array like "info"
then the Pages() object dispatches an event equivalent to the string
for the data example above, myPages.on("info",function(e){...});
would trigger when the home page is swiped to the left

Pages dispatches a "swipe" event before changing pages if swiped
you can then get pages.page, pages.nextPage and pages.direction
you can pause() if needed the transition to handle data, etc. and then unpause()
you do not need to handle going to another page when swiping - that is handled automatically
so you probably will not use the swipe event unless handling data between pages

Pages also dispatches a "pagetransitioned" event when a transition is complete
you will have the same properties available as with the page event

USAGE
the first page object is the start page
for the data above, swiping the home page down automatically goes to the hide page
if the home page is swiped up it automatically goes to the find page
you can add pages with the addPage() method
it will not show until you swipe or go to it - unless it was the first page added
1. if the holder is the stage then add the pages object to the stage
2. if the holder is another container then add pages object to the holder
and add the holder to the stage (read this twice to make sure you got it!)
in the second case, you will have to mask the holder so you do not see transitions
DO NOT add the pages to the stage or holder - let Pages do it for you
sometimes you need a page to be on the stage to operate on it
if this is the case, call puff() and make adjustments
call settle() when done - or pass in a time in ms to puff to auto settle after that time
you can define multiple pages objects add and remove pages objects as needed
--*///+71
	zim.Pages = function(pages, transition, speed, transitionTable, holder, arrowDisableColor, style, group, inherit) {
		var sig = "pages, transition, speed, transitionTable, holder, arrowDisableColor, style, group, inherit";
		var duo; if (duo = zob(zim.Pages, arguments, sig, this)) return duo;
		z_d("71");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Pages";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		var timeType = getTIME(speed);

		if (zot(pages)) pages = DS.pages!=null?DS.pages:[]; // can add pages with addPages
		this.pages = pages;
		if (zot(transition)) transition = DS.transition!=null?DS.transition:"none";
		if (zot(speed)) speed = DS.speed!=null?DS.speed:timeType=="s"?.2:200;
		if (zot(transitionTable)) transitionTable = DS.transitionTable!=null?DS.transitionTable:[];
		this.transitionTable = transitionTable;
		if (zot(arrowDisableColor)) arrowDisableColor = DS.arrowDisableColor!=null?DS.arrowDisableColor:zim.grey;
		this.arrowDisableColor = arrowDisableColor;

		if (zot(holder)) holder = DS.holder!=null?DS.holder:null;
		if (zot(holder) && WW.zdf) holder = WW.zdf.stage;
		if (!holder.getBounds || !holder.getBounds()) {zogy("zim controls - Pages():\nholder object must have bounds set"); return;}

		this.speed = speed;
		this.active = true;
		var that = this;
		that.transitioning = false;

		var hW = holder.getBounds().width;
		var hH = holder.getBounds().height;

		var black; var white;
		if (transition!="none" || transitionTable!=[]) makeTransitionAssets();

		function makeTransitionAssets() {
			black = new createjs.Shape();
			black.graphics.f("black").r(0,0,hW,hH+1);
			white = new createjs.Shape();
			white.graphics.f("white").r(0,0,hW,hH+1);
		}

		var directions = ["left","right","up","down"];

		var data; // holds the page data object
		var page; // holds a page

		var defaultSwipeCheck = true;
		var i;
		for (i=0; i<pages.length; i++) {
			data = pages[i];
			if (data.constructor != {}.constructor) data = pages[i] = {page:pages[i]};
			if (data.swipe) defaultSwipeCheck = false;
		}
		for (i=0; i<pages.length; i++) {
			data = pages[i];
			if (data.constructor !== {}.constructor) data = pages[i] = {page:pages[i]}; // accept an array of only pages
			if (defaultSwipeCheck) {
				var last = pages[i-1];
				var next = pages[i+1];
				data.swipe = [last?last.page:null, next?next.page:null];
			}
			preparePage(data.page, data.swipe);
		}

		var currentPage = this.page = pages[0] ? pages[0].page : null;
		if (!zot(this.page)) this.index = 0;
		this.addChild(currentPage);
		addHTML(currentPage);

		this.swipe = new zim.Swipe(holder);

		// handle giving swipe event time to trigger event and provide code intervention
		var pauseInfo;
		var paused = false;

		var swipeEvent = this.swipe.on("swipe", function(e) {
			if (!that.active) return;
			if (!that.parent) return;
			var direction = e.currentTarget.direction;
			if (direction == "none") return;
			// swap direction (swipe up means move down)
			var newDirection = "";
			if (direction=="left") newDirection="right";
			else if (direction=="right") newDirection="left";
			else if (direction=="up") newDirection="down";
			else if (direction=="down") newDirection="up";
			direction = newDirection;
			var dirIndex = directions.indexOf(direction);
			page = currentPage.zimSwipeArray[dirIndex];

			pauseInfo = [page, direction, null, null, true];
			that.page = currentPage;
			that.nextPage = page;
			that.direction = direction;
			that.dispatchEvent("swipe");

			setTimeout(function() {
				if (!paused) {
					that.go(page, direction, null, null, true); // true is from swipe
				}
			}, 50);
		});

		function preparePage(p, s) {
			if (zot(p)) return;
			// record any TextArea or Loader tags:
			p.zimHTMLList = new zim.Dictionary();
			removeHTML(p);

			p.zimSwipeArray = s ? s : [];
			p.zimOriginalAlpha = p.alpha;
			if (p.parent) p.parent.removeChild(data.page);
		}

		function addHTML(p) {			
			if (zot(p)) return;
			p.removedHTML = false;
			for (i=0; i<p.zimHTMLList.length; i++) {
				p.addChildAt(p.zimHTMLList.values[i].obj, p.zimHTMLList.values[i].depth);
			}
		}

		function removeHTML(p) {
			if (p.removedHTML) return;
			p.removedHTML = true;
			p.zimHTMLList.clear(); // re-add just in case depth changes or tag is removed
			var ch,i;
			for (i=0; i<p.numChildren; i++) { // record depths first
				ch = p.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					var obj = {obj:ch, depth:p.getChildIndex(ch)};
					p.zimHTMLList.add(ch, obj);
				}
			}
			for (i=p.numChildren-1; i>=0; i--) { // remove textareas and loaders second
				ch = p.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					p.removeChild(ch);
				}
			}
		}

		this.addPage = function(page, swipeArray) {
			preparePage(page, swipeArray);
			that.pages.push({page:page});
			if (!currentPage) {
				currentPage = that.page = page;
				that.addChild(currentPage);
			} else {
				if (page.parent) page.parent.removeChild(page);
			}
		};

		this.removePage = function(page) {
			// deal with textarea and loader
			removeHTML(page);
			if (that.currentPage == page) {
				that.removeChild(page);
				if (holder.stage) holder.stage.update(); // works even if holder is stage
			}
			zim.loop(that.pages, function (p, i) {
				if (p.page == page || p == page) that.pages.splice(i, 1);
			}, true);
			page.zimSwipeArray = null;
		};

		this.setSwipeArray = function(page, swipeArray) {
			if (zot(swipeArray)) swipeArray = [];
			var data = {page:page, swipe:swipeArray};
			data.page.zimSwipeArray = (data.swipe) ? data.swipe : [];
		};

		this.pause = function() {
			paused = true;
		};
		this.unpause = function() {
			if (paused) that.go(pauseInfo[0], pauseInfo[1], pauseInfo[2], pauseInfo[3], pauseInfo[4]);
		};

		var goCheck = true;
		this.go = function(newPage, direction, trans, speed, fromSwipe) {
			
			if (typeof newPage == "number") {
				var np = that.pages[newPage];
				if (zot(np)) return;
				newPage = np.page;
			}

			// newPage holds a page or a string command
			setTimeout(function() {paused = false;},200);
			var slides = [{x:hW},{x:-hW},{y:hH},{y:-hH}];
			var slides2 = [{x:0},{x:0},{y:0},{y:0}];
			var reveals = [{x:hW/2,alpha:0},{x:-hW/2,alpha:0},{y:hH/2,alpha:0},{y:-hH/2,alpha:0}];
		
			// check for default transition override in transitionTable
			var tempTransition = transition; // default transition
			var tempMs = that.speed; // default transition speed
			for (var i=0; i<that.transitionTable.length; i++) {
				if (that.transitionTable[i][0]==currentPage && that.transitionTable[i][1]==newPage) {
					tempTransition = that.transitionTable[i][2];
					if (!zot(that.transitionTable[i][3])) tempMs = that.transitionTable[i][3];
					break;
				}
			}
			// transition passed into go overrides all transitions
			// so if there is not a transition parameter set trans tempTransition
			// which is either the transition table transition or the default
			if (zot(trans)) trans = tempTransition; // use default
			if (zot(speed)) speed = tempMs; // use default
			that.speed = speed;
			
			function transEnd(pages) {
				pages[0].uncache();
				pages[1].uncache();
				that.transitioning = false;
				that.dispatchEvent("pagetransitioned");
				that.removeChild(that.lastPage);
				if (trans=="fan") {
					if (direction=="right"||direction=="down") {
						that.lastPage.rotation = 0;
						that.lastPage.regY = 0;
						that.lastPage.mov(0, -that.lastPage.height);
					} else {
						that.page.rotation = 0;
						that.page.regY = 0;
						that.page.mov(0, -that.lastPage.height);
					}
				}
				that.removeChild(black);
				that.removeChild(white);
				addHTML(currentPage);
				goCheck = true;
			}

			function transEndHalf(pages) {
				that.removeChild(that.lastPage);
				zim.animate(pages.shift(), {alpha:0}, that.speed/2, null, transEnd, pages);
			}

			that.direction = direction;
			if (newPage=="" || newPage==null) {
				that.page = currentPage;
				that.dispatchEvent("nothing");
			} else if (typeof newPage === 'string') {
				that.page = currentPage;
				that.dispatchEvent(newPage);
			} else {
				if (newPage == currentPage) return; // same page ;-)
				if (zot(direction)) direction="right";
				var dirIndex = directions.indexOf(direction);

				if (!goCheck) return;
				goCheck = false;

				newPage.x = 0;
				newPage.y = 0;
				newPage.alpha = newPage.zimOriginalAlpha;


				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// EMITTER EFFECTS PART 1
				var emitter;
				var slideEmitters = [
					"pixelDark",
					"pixelLight",
					"pixelZIM",
					"bubbleDark",
					"bubbleLight",
					"bubbleZIM",
					"lineDark",
					"lineLight",
					"lineZIM"
				];
				if (slideEmitters.indexOf(trans)>=0) {
					var slideTrans = trans;
					emitter = true;
					trans = "slide";
				}
				var fadeEmitters = [
					"explodeDark",
					"explodeLight",
					"explodeZIM",
				];
				if (fadeEmitters.indexOf(trans)>=0) {
					var fadeTrans = trans;
					emitter = true;
					trans = "fade";
				}
				if (trans.type=="Emitter") {
					emitter = trans;
					if (trans.horizontal || trans.vertical) {
						trans = "slide";
					} else {
						trans = "fade";
					}
				}
				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

				that.transitioning = true;
				if (trans == "slide") {
					newPage.x = -(slides[dirIndex].x | 0);
					newPage.y = -(slides[dirIndex].y | 0);
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					that.addChild(newPage);
					that.addChild(currentPage);
					zim.animate(currentPage, slides[dirIndex], that.speed, null, transEnd, [currentPage, newPage]);
					zim.animate(newPage, slides2[dirIndex], that.speed);
				} else if (trans == "reveal") {
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					that.addChild(newPage); // put destination under current page
					that.addChild(currentPage);
					zim.animate(currentPage, reveals[dirIndex], that.speed, null, transEnd, [currentPage, newPage]);
				} else if (trans == "fade") {
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					newPage.alpha = 1;
					that.addChild(newPage);
					that.addChild(currentPage);
					zim.animate(currentPage, {alpha:0}, that.speed, null, transEnd, [currentPage, newPage]);
				} else if (trans == "black") {
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					newPage.alpha = 1;
					that.addChild(newPage);
					that.addChild(currentPage);
					black.alpha = 0;
					that.addChild(black);
					zim.animate(black, {alpha:1}, that.speed/2, null, transEndHalf, [black, currentPage, newPage]);
				} else if (trans == "clear") {
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					newPage.alpha = 0;
					that.addChild(newPage);
					that.addChild(currentPage);
					zim.animate(currentPage, {alpha:0}, that.speed/2);
					zim.animate(newPage, {alpha:1}, that.speed/2, null, transEnd, [currentPage, newPage], that.speed/2);
				} else if (trans == "white") {
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					newPage.alpha = 1;
					that.addChild(newPage);
					that.addChild(currentPage);
					white.alpha = 0;
					that.addChild(white);
					zim.animate(white, {alpha:1}, that.speed/2, null, transEndHalf, [white, currentPage, newPage]);
				} else if (trans == "fan") {
					newPage.cache(0,0,(hW+1)/newPage.scaleX,(hH+1)/newPage.scaleY);
					currentPage.cache(0,0,(hW+1)/currentPage.scaleX,(hH+1)/currentPage.scaleY);
					newPage.alpha = 1;
					if (direction=="right"||direction=="down") {
						that.addChild(newPage);
						that.addChild(currentPage);
						currentPage.regY = currentPage.height;
						currentPage.mov(0, currentPage.height);
						zim.animate(currentPage, {rotation:-90}, that.speed, null, transEnd, [currentPage, newPage]);
					} else {
						that.addChild(currentPage);
						that.addChild(newPage);
						newPage.regY = currentPage.height;
						newPage.mov(0, currentPage.height);
						newPage.rotation = -90;
						zim.animate(newPage, {rotation:0}, that.speed, null, transEnd, [currentPage, newPage]);
					}
				} else {
					that.transitioning = false;
					that.addChild(newPage);
					that.removeChild(currentPage);
					goCheck = true;
					// that.dispatchEvent("pagetransitioned"); // hmmm... no
				}

				// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
				// EMITTER EFFECTS PART 2

				if (emitter) {

					var horiz = (dirIndex<2);
					var obj;
					var emi;

					if (slideTrans || trans=="slide") { // slide emitter
						
						if (slideTrans) { // built in
							
							// lines:
							if (slideTrans=="lineDark" || slideTrans=="lineLight") obj = new zim.Rectangle(horiz?30:hW+5, horiz?hH+5:30, (slideTrans=="lineDark"?zim.dark:zim.white)).alp(.2);
							else if (slideTrans=="lineZIM") obj = new zim.Rectangle(horiz?50:hW+5,horiz?hH+5:50,[zim.green,zim.yellow,zim.orange,zim.pink,zim.blue]).alp(.5);
							// pixels and bubbles:
							else if (slideTrans=="pixelDark" || slideTrans=="pixelLight") obj = new zim.Rectangle(40,40,zim.clear,(slideTrans=="pixelDark"?zim.dark:zim.white),2).alp(.7);
							else if (slideTrans=="pixelZIM") obj = new zim.Rectangle(40,40,[zim.green,zim.yellow,zim.orange,zim.pink,zim.blue]).alp(.7);
							else if (slideTrans=="bubbleDark" || slideTrans=="bubbleLight") obj = new zim.Circle(30,zim.clear,(slideTrans=="bubbleDark"?zim.dark:zim.white),2).alp(.7);
							else if (slideTrans=="bubbleZIM") obj = new zim.Circle(30,[zim.green,zim.yellow,zim.orange,zim.pink,zim.blue]).alp(.7);

							obj.centerReg({add:false});
							
							if (slideTrans=="lineDark" || slideTrans=="lineLight" || slideTrans=="lineZIM") {
								emi = new zim.Emitter({
									obj:obj,
									life:.5,
									decayTime:.5,
									shrink:false,
									force:0,
									gravity:0,
									width:0,
									startPaused:true
								});
							} else {								
								emi = new zim.Emitter({
									obj:obj,
									num:6,
									life:.5,
									decayTime:.5,
									width:horiz?0:hW,
									height:horiz?hH:0,
									vertical:horiz,
									horizontal:!horiz,
									startPaused:true
								});
							}

						} else { // custom slide emitter
							emi = emitter;
						}

						var emitters1 = [{x:0, y:hH/2},{x:hW, y:hH/2},{x:hW/2, y:0},{x:hW/2, y:hH}];
						var emitters2 = [{x:hW, y:hH/2},{x:0, y:hH/2},{x:hW/2, y:hH},{x:hW/2, y:0}];

						emi.centerReg(holder).spurt(null, that.speed);
						emi.x = emitters1[dirIndex].x;
						emi.y = emitters1[dirIndex].y;
						zim.animate(emi, emitters2[dirIndex], that.speed, null, function () {
							if (slideTrans) emi.dispose();
						});

					} else if (fadeTrans || trans=="fade") { // fade emitter

						if (fadeTrans) { // built in emitter
							if (fadeTrans=="explodeDark" || fadeTrans=="explodeLight") obj = new zim.Circle(150, (fadeTrans=="explodeDark"?zim.dark:zim.white)).alp(.5);
							else if (fadeTrans=="explodeZIM") obj = new zim.Circle(130, [zim.green,zim.yellow,zim.orange,zim.pink,zim.blue]).alp(.7);
							emi = new zim.Emitter({
								obj:obj,
								num:5,
								gravity:0,
								force:{min:20, max:40},
								life:.5,
								shrink:false,
								decayTime:.5,
								startPaused:true
							});
						} else { // custom emitter
							emi = emitter;
						}
						emi.centerReg(holder).spurt(null, that.speed*.35);
						emi.on("fizzed", function () {
							if (fadeTrans) emi.dispose();
						});
					}					
					if (holder && holder.type != "Stage" && holder.type != "StageGL") {	
						if (emi.particles && holder.shape) emi.particles.setMask(holder.shape);						
					}
					
				} // end emitter				
				
				if (holder && holder.shape) {
					if (emi && emi.particles) emi.particles.setMask(holder.shape);
				}

				removeHTML(currentPage);
				that.lastPage = currentPage;
				that.page = newPage;
				that.index = -1;
				for (i=0; i<that.pages.length; i++) {
					var p = that.pages[i].page;
					if (p == that.page) {
						that.index = i;
					}
				}
				if (trans == "none") addHTML(newPage);
				if (zot(fromSwipe)) fromSwipe = false;
				that.fromSwipe = fromSwipe;
				that.dispatchEvent("page");
				currentPage = newPage;
				that.setArrows(pages.index);
				if (holder.stage) holder.stage.update();
			}
		};
		
		if (holder && holder.shape) {			
			holder.mouseChildren = true;
			holder.mouseEnabled = true;			
			that.setMask(holder.shape);
		}

		this.resize = function() {
			hW = holder.getBounds().width;
			hH = holder.getBounds().height;
			if (transition!="none" || transitionTable!=[]) makeTransitionAssets();
		};

		this.puff = function(time) {
			// add all pages to the holder behind current page
			// if time then this is the time to settle automatically
			for (var i=0; i<pages.length; i++) {
				that.addChild(pages[i].page);
			}
			that.addChild(currentPage);
			if (time > 0) {
				setTimeout(function() {
					that.settle();
				}, time*(timeType=="s"?1000:1));
			}
		};

		this.settle = function() {
			that.removeAllChildren();
			that.addChild(currentPage);
			that.dispatchEvent("puffed");
		};

		this.disable = function() {
			that.active = false;
		};

		this.enable = function() {
			that.active = true;
		};
		
		this.arrows = {};
		this.setArrows = function() {
			if (zim.isEmpty(that.arrows)) return;
			var current = that.pages[that.index];			
			if (!current || !current.swipe) return;
			var swipe = current.swipe;
			var directions = [zim.LEFT, zim.RIGHT, zim.UP, zim.DOWN];
			zim.loop(directions, function (d, i) {
				if (!swipe[i]) {
					zim.loop(that.arrows[d], function(b) {
						if (b.setDisabled===false) {b.activate(true, b.arrowBackgroundColor); b.setDisabled=null; return;}
						if (!b.enabled) return; // already disabled
						b.activate(false, that.arrowDisableColor);
					});
				} else {
					zim.loop(that.arrows[d], function(b) {
						if (b.setDisabled===true) {b.activate(false, that.arrowDisableColor); b.setDisabled=null; return;}
						if (b.enabled) return; // already enabled
						b.activate(true, b.arrowBackgroundColor);
					});
				}
			});
			if (that.stage) that.stage.update();
		}
		// function arrowsOn(b) {
		// 	b.enabled = true;
		// 	if (that.arrowDisableColor === zim.clear) b.visible = true;
		// 	else if (that.arrowDisableColor !== false) b.icon.color = b.arrowBackgroundColor;
		// }
		// function arrowsOff(b) {
		// 	b.enabled = false;
		// 	if (that.arrowDisableColor === zim.clear) b.visible = false;
		// 	else if (that.arrowDisableColor !== false) b.icon.color = that.arrowDisableColor;
		// }
		
		that.added(function (stage) {
			if (stage.frame && stage.frame.scaling == "full") {
				if (!zim.globalManager) {
					var gm = zim.globalManager = new zim.Manager();
					gm.frame = stage.frame;
					gm.event = stage.frame.on("resize", function() {
						gm.resize();
					});
				}
				zim.globalManager.add(that);
			}
		});

		if (style!==false) zim.styleTransforms(this, DS);

		this.dispose = function(a,b,disposing) {
			if (zim.globalManager) {
				var gm = zim.globalManager;				
				gm.remove(that);
				if (zim.globalManager.items.length==0) {
					gm.frame.off("resize", gm.event);
					gm.dispose();
					zim.globalManager = null;
				}				
			}
			that.swipe.off("swipe", swipeEvent);
			that.swipe.dispose();
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};

	};
	zim.extend(zim.Pages, zim.Container, ["clone", "dispose"], "zimContainer", false);
	//-71

/*--
zim.Arrow = function(backgroundColor, rollBackgroundColor, pages, direction, type, newPage, trans, speed, style, group, inherit)

Arrow
zim class - extends a zim.Button which extends a zim.Container which extends a createjs.Container

DESCRIPTION
Makes an Button with an arrow backing of different designs - see types parameter - default is a Triangle.
By default it faces right - you can use .rot(180) to make it face left and .rot(-90) or .rot(90) for up and down.

WITH ZIM PAGES
If you pass in a ZIM Pages object then the Arrow is set to automatically go from page to page.
You must pass in a pages object to use and which direction you want to go.
The button will call the Pages go() method for whatever page listed in the pages array at the current page and direction 
In other words, if page is page1 and the pages array says page1 swipes right to page2 
then passing in RIGHT would make pressing the Arrow button to to page2.
The order of the pages in the pages pages array may be different than their swipe targets 
although if just an array of pages is passed into Pages then the order will match.

If a page has no page listed for the direction then the Arrow will automatically remove itself.
This means that PageArrow for a direction will be registered with the Pages object 
So that the button can be added back again if a new page needs it.

These can be embedded on the pages themselves or used in interface outside the pages.

SEE https://zimjs.com/survey for an example.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// a fat arrow with a stick - also "thin", "angle" (no stick) and "triangle" (default)
new Arrow({type:"thick"}).pos(30,30,RIGHT,BOTTOM).tap(next);
END EXAMPLE

EXAMPLE
// Assuming a pages variable that points to a ZIM Pages object
// These will go through the pages in order 
// and default to remove themselves if not needed at start or end

new Arrow(blue, green, pages, RIGHT).pos(30,30,RIGHT,BOTTOM);
new Arrow(blue, green, pages, LEFT).pos(30,30,LEFT,BOTTOM);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
backgroundColor - (default blue) the background color of the arrow (can STYLE anything Button style)
rollBackgroundColor - (default blue.lighten(.2)) the rollBackground color of the arrow
pages - (default null) a ZIM Pages object - if null then this is just an arrow button 
	if set to Pages object then will atomatically work to change pages - see also direction
direction - (default RIGHT) a direction RIGHT, LEFT, UP, DOWN to the page the button will lead to
type - (default "triangle") the type of the arrow as follows:
	"triangle" is a triangle (default)
	"thick" is a fat arrow 
	"thin" is a thin arrow 
	"angle" is an angle bracket 
	These are icons and rollIcons added to a ZIM Button with clear backgroundColor 
	Can also set backing and rollBacking properties, etc. with STYLE
newPage - (default null) specify a new page
	by default the page will go to the next page if direction is RIGHT or DOWN
	by default the page will go to the prev page if direction is LEFT or UP
trans - (default Pages default transition) the type of transition "none", "reveal", "slide", "fade", "clear", "black", "white", "fan"
	A ZIM Emitter() can also be passed in as a transition.
	If the emitter has vertical or horizontal set to true then the emitter will sit above a slide transition
	otherwise the emitter will sit above a fade transition.
	The following built in emitter transitions are provided:
		"pixelDark", "pixelLight", "pixelZIM",
		"bubbleDark", "bubbleLight", "bubbleZIM",
		"lineDark", "lineLight", "lineZIM"
		"explodeDark" "explodeLight" "explodeZIM"
speed - (default Pages default speed) speed in seconds of the transition if set 
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
activate(state, offColor) - turn on or off the Arrow button with state true or false and a color for offColor
	returns object for chaining
All ZIM Button methods

PROPERTIES
setDisabled - set to true or false in ZIM Pages "page" event function to override Arrow button setting 
	or just manually adjust the Pages pages swipe array - which is better as disables or enables swipe and Arrow button setting
All ZIM Button properties - including icon and rollIcon which access the ZIM Triangle for the arrow

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS 
Arrow automatically adds a "mousedown" or "click" event to go to the desired page 
The event will call the go() method of ZIM Pages
Additional "mousedown", "click" or other button events can be added if desired
--*///+71.2
	zim.Arrow = function(backgroundColor, rollBackgroundColor, pages, direction, type, newPage, trans, speed, style, group, inherit) {
		var sig = "backgroundColor, rollBackgroundColor, pages, direction, type, newPage, trans, speed, style, group, inherit";
		var duo; if (duo = zob(zim.Arrow, arguments, sig, this)) return duo;
		z_d("71.2");
		
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Arrow", this.group, inherit);
							
		if (zot(direction)) direction = DS.direction!=null?DS.direction:"right";
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.blue;
		this.arrowBackgroundColor = backgroundColor;
		if (zot(rollBackgroundColor)) rollBackgroundColor = DS.rollBackgroundColor!=null?DS.rollBackgroundColor:zim.blue.lighten(.2);
		this.arrowRollBackgroundColor = rollBackgroundColor;
		if (zot(type)) type = DS.type!=null?DS.type:"triangle";
		if (zot(newPage)) newPage = DS.newPage!=null?DS.newPage:null;
		if (zot(trans)) trans = DS.trans!=null?DS.trans:null;
		if (zot(speed)) speed = DS.speed!=null?DS.speed:null;
				
		var icon,rollIcon,iconColor,rollIconColor,ps;
		if (type=="triangle") {
			icon = new zim.Triangle(45,45,45,backgroundColor,null,null,null, null,-7).rot(90);
			rollIcon = new zim.Triangle(45,45,45,rollBackgroundColor,null,null,null, null,-7).rot(90);
		} else if (type=="thick") {
			icon = new zim.Shape();
			iconColor = icon.graphics.f(backgroundColor).command; // need to be able to change this color
			ps = "AhFBdIiWAAIAAi4ICWAAIAAh7IEhDWIkhDXg";
			icon.p(ps).reg(-4);
			rollIcon = new zim.Shape();
			rollIconColor = rollIcon.graphics.f(rollBackgroundColor).command; // need to be able to change this color			
			rollIcon.p(ps).reg(-4);
		} else if (type=="thin") {
			icon = new zim.Shape();
			iconColor = icon.graphics.f(backgroundColor).command; // need to be able to change this color
			ps = "AhBCIIBZhbIjWAAIAAhVIDaAAIhdhfIA9g+IDDDFIAAAAIAAAAIjDDGg";
			icon.p(ps).reg(-4);
			rollIcon = new zim.Shape();
			rollIconColor = rollIcon.graphics.f(rollBackgroundColor).command; // need to be able to change this color			
			rollIcon.p(ps).reg(-4);
		} else if (type=="angle") {
			icon = new zim.Shape();
			iconColor = icon.graphics.f(backgroundColor).command; // need to be able to change this color
			ps = "AiNC5IC4i5Ii4i5IAxgxIDqDqIjqDrg";
			icon.p(ps).reg(-3);
			rollIcon = new zim.Shape();
			rollIconColor = rollIcon.graphics.f(rollBackgroundColor).command; // need to be able to change this color			
			rollIcon.p(ps).reg(-3);
		}
		
		this.zimButton_constructor(50, 50, "", zim.clear, zim.clear, null, null, null, null, null, null, null, null, null, null, null, icon, rollIcon);
		this.type = "Arrow";
		
		var that = this;		
		this.activate = function(state, offColor) {
			if (zot(state)) state = true;
			if (zot(offColor)) offColor = zim.grey;
			if (offColor===false) return that;
			if (state) {
				that.enabled = true;
				if (offColor !== false) {
					if (type=="triangle") {
						that.icon.color = that.arrowBackgroundColor;
						that.rollIcon.color = that.arrowRollBackgroundColor;
					} else {
						iconColor.style = that.arrowBackgroundColor;
						rollIconColor.style = that.arrowRollBackgroundColor;
					}
				}			
			} else {
				that.enabled = false;
				if (offColor !== false) {
					if (type=="triangle") {
						that.icon.color = offColor;	
						that.rollIcon.color = offColor;	
					} else {
						iconColor.style = offColor;
						rollIconColor.style = offColor;
					}
				}
			}
			return that;			
		}	

		if (!zot(pages) && pages.type=="Pages") {
		
			var eventType = (!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click";
			
			// register button with Pages
			// could be multiple buttons in same direction (if buttons on multiple pages)
			if (zot(pages.arrows)) pages.arrows = {};
			if (zot(pages.arrows[direction])) pages.arrows[direction] = [];
			pages.arrows[direction].push(this);

			
			var next = getNext();
			if (!next) {
				this.activate(false, pages.arrowDisableColor);
			}			

			function getNext() {
				var current = pages.pages[pages.index];			
				if (!current || !current.page || !current.page.zimSwipeArray) return;
				var swipe = current.page.zimSwipeArray;
				if (direction == "left") return swipe[0];
				else if (direction == "right") return swipe[1];
				else if (direction == "up") return swipe[2];
				else if (direction == "down") return swipe[3];
			}

			this.expand();
			this.on(eventType, function () {
				if (pages.transitioning) return;
				var next = getNext();
				if (!next) return;
				pages.go(next, direction, trans, speed);			
			});

		}
		
		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Arrow(backgroundColor, rollBackgroundColor, pages, direction, type, newPage, trans, speed, style, this.group, inherit));
		};

	};
	zim.extend(zim.Arrow, zim.Button, "clone", "zimButton", false);
	//-71.2
		

/*--
zim.HotSpot = function(obj, x, y, width, height, call, callOver, callOut, local, talk)

HotSpot
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
HotSpot adds an invisible button to a container object (often think of this as the page).
If you want multiple spots it is more efficient to use the HotSpots class above
which manages multiple HotSpot objects (otherwise you end up with multiple event functions).
The spot is a pixel rect with an alpha of .01 and then uses a hitArea of a backing shape.
The spot will get a cursor of "pointer".

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const hs = new HotSpot(S, 100, 100, 50, 50, myFunction);
function myFunction() {
	zog("activation!");
}
// hs.show(); // uncomment this to see rectangle hotSpot
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
holder - container object in which to place the hotspot (stage for instance)
x, y, width and height - of the rectangle for the hotspot
call - the function to call when the spot is pressed
local - (default true) hotSpot rect is based on local coordinates of the container
	use when the element scale independently from the stage
	if set to false then you pass in global coordinates and hotSpot will convert them
talk - (default "hotspot") text for ZIM Accessibility screen reader

METHODS
show() - helps when creating the spot to see where it is
hide() - hides the hotspot
dispose() - removes the listener and the spot

PROPERTIES
type - holds the class name as a String
spot - the actual hotSpot object that gets added to the container can be accessed with the spot property
eg. hs.spot

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)
--*///+73
zim.HotSpot = function(obj, x, y, width, height, call, callOver, callOut, local, talk) {
	var sig = "obj, x, y, width, height, call, callOver, callOut, local, talk";
	var duo; if (duo = zob(zim.HotSpot, arguments, sig, this)) return duo;
	z_d("73");
	this.zimContainer_constructor(null,null,null,null,false);
	this.type = "HotSpot";

	if (zot(obj) || !obj.addChild) {zogy("zim controls - HotSpot():\nPlease pass in container object for obj"); return;}
	if (obj instanceof createjs.Container == false) {zogy("zim controls - HotSpot():\nObjects passed in should be Containers"); return;}
	if (zot(x) || zot(y) || zot(width) || zot(height)) {zogy("zim controls - HotSpot():\nPlease pass in x, y, width, height"); return;}
	if (zot(local)) local = true;
	var eventType = (!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click";

	var w = width; var h = height;
	var point,newW,newH;
	if (!local) {
		point = obj.globalToLocal(x,y);
		var point2 = obj.globalToLocal(x+w,y+h);
		newW = point2.x-point.x;
		newH = point2.y-point.y;
	} else {
		point = new zim.Point(x,y);
		newW = width;
		newH = height;
	}
	var but = new zim.Shape(width, height);
	but.talk = zot(talk)?"HotSpot":talk;
	but.alpha = 0;
	but.graphics.f("black").dr(0,0,newW,newH);
	but.x = point.x;
	but.y = point.y;
	but.cur("pointer");
	but.expand(0);
	this.spot = but;

	if (typeof(call) == "function") {
		var butEvent = but.on(eventType,function(e) {
			call(e);
		});
	}
	if (typeof(callOver) == "function") {
		var butOverEvent = but.on("mouseover",function(e) {
			callOver(e);
		});
	}
	if (typeof(callOut) == "function") {
		var butOutEvent = but.on("mouseout",function(e) {
			callOut(e);
		});
	}
	obj.addChild(but);

	this.show = function() {
		but.alpha = .5;
		if (obj.stage) obj.stage.update();
	};
	this.hide = function() {
		but.alpha = 0;
		if (obj.stage) obj.stage.update();
	};
	this.dispose = function() {
		if (butEvent) but.off(eventType, butOverEvent);
		if (butOverEvent) but.off("mouseover", butOverEvent);
		if (butOutEvent) but.off("mouseout", butOutEvent);
		obj.removeChild(but);
		but = null;
		return true;
	};
};
zim.extend(zim.HotSpot, zim.Container, "dispose", "zimContainer", false);
//-73

/*--
zim.HotSpots = function(spots, local, mouseDowns)

HotSpots
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
HotSpots allow you to create multiple hotSpot objects on multiple pages.
A hotSpot is an invisible click area (like an image map in HTML).
You can alternatively specify an object and it will turn that into a hotSpot.
HotSpots lets you control many or all of your interactions in one place.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// our first hotSpot will be a 50 pixel square at 100, 100

// then we will add hotSpots to these items as well
const circle = new Circle(60, red).center();
const button = new Button().pos(100,100,RIGHT,BOTTOM);

// make the hotSpots object
// these are all on the same page
// gets really handy when you have multiple pages with Pages
const hs = new HotSpots([
	{page:S, rect:[100,100,50,50], call:()=>{zog("hot!");}},
	{page:S, rect:circle, call:()=>{zog("circle!");}},
	{page:S, rect:button, call:()=>{zog("button!");}},
]);
// hs.show(); // uncomment this to see rectangle hotSpots
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
spots (default null) - an array of hotspot data objects with the following format:
	[{page:home, rect:[190,50,260,260], talk:"screen reader content", call:someFunction, callOver:optionalFunction, callOut:optionalFunction},
	 {page:home, rect:[70,405,500,150], talk:"screen reader content", call:someOtherFunction, callOver:optionalFunction, callOut:optionalFunction}]
	the page should be a Container
	the rect is the [left, right, width, height] of a rectangle relative to the stage
	talk (optional) will provide text for screen reader if ZIM Accessibility() is turned on
	call is the callback function to call when a hotSpot is clicked
	callOver and callOut will add mouseover and mouseout event functions to the hotSpot
	instead of a rect array you can pass an object that must have setBounds() set
	[{page:home, rect:submitButton, call:function(){//code}}]
	the hotSpot will then use the button position and bounds as the rectangle
	note - in this case, HotSpots will actually add a mousedown or click event to the button
	null can be left here and then hotSpots added with add()
local (default true) hotSpot rect is based on local coordinates of the container
	use when the element scale independently from the stage
	if set to false then you pass in global coordinates and hotSpot will convert them
mouseDowns (default false) stops mousedown events on a button that is used as a hotSpot
	prevents users from activating a swipe on a button (when using ZIM Swipe)

METHODS
show() - shows the hotspots for testing during authoring time
hide() - hides the hotspots
add(page,rect,call) - can dynamically add hotSpots
remove(page,rect) - rect is optional - so can remove all spots on a page or by the rect
dispose() - removes listeners

PROPERTIES
type - holds the class name as a String
hotSpots - an array of HotSpot objects

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

NOTE: the class does actually add rectangle shapes to your page
the spot is a pixel rect with an alpha of .01 and then uses a hitArea of a backing shape
this could have been done with "math" alone but rollover cursor would be a pain
the class creates HotSpot objects - see the class underneath this one
--*///+72
	zim.HotSpots = function(spots, local, mouseDowns) {
		var sig = "spots, local, mouseDowns";
		var duo; if (duo = zob(zim.HotSpots, arguments, sig, this)) return duo;
		z_d("72");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "HotSpots";

		if (zot(local)) local = true;
		if (zot(mouseDowns)) mouseDowns = false;
		var eventType = (!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click";

		var that = this;

		var data; // spot data object
		var hs; // hotSpot object
		var hotSpots = that.hotSpots = []; // array of hotSpot objects

		// loop through data and add hotSpot objects
		if (zot(spots)) spots = [];
		for (var i=0; i<spots.length; i++) {
			addSpot(spots[i]);
		}

		function addSpot(data) {
			var button = null;
			if (!Array.isArray(data.rect)) {
				button = data.rect; // data includes a button rather than rect
				if (!button) {
					zogy("zim controls - HotSpots(): HotSpot "+ data.page + " " + data.rect +" button does not exist");
					return;
				}
				data.rect = [button.x, button.y, button.width||1, button.height||1];	// bounds are not used for button
			}

			hs = new zim.HotSpot(data.page,data.rect[0],data.rect[1],data.rect[2],data.rect[3],data.call,data.callOver,data.callOut,local,data.talk);
			hs.zimHSpage = data.page;
			hs.button = button;
			hotSpots.push(hs);
			hs.on(eventType, hsEvent);
			if (button && zot(data.callOver) && zot(data.callOut)) {

				// stop hotSpot from taking away rollovers on button
				hs.spot.mouseEnabled = false;
				hs.spot.mouseChildren = false;
				// but now need to add click to button as hotSpot will not work
				button.zimHScall = data.call;
				button.zimHSEvent = button.on(eventType, hsEvent, true);
				if (!mouseDowns) {
					button.zimHSMDEvent = button.on("mousedown",function(e) {
						e.stopImmediatePropagation();
					});
				}
				if (button.cur) button.cur("pointer");
			}
		}

		function hsEvent(e) {
			if (e.stopImmediatePropagation) e.stopImmediatePropagation();
			if (WW.event) WW.event.cancelBubble=true;
			if (typeof(e.currentTarget.zimHScall) == "function") {
				e.currentTarget.zimHScall(e);
			}
		}

		this.add = this.addHotSpot =function(page,rect,call,callOver,callOut,talk) {
			data = {page:page, rect:rect, call:call, callOver:callOver, callOut:callOut, talk:talk};
			spots.push(data);
			addSpot(data);
		};

		this.show = function() {
			for (var i=0; i<hotSpots.length; i++) {
				hs = hotSpots[i];
				if (!hs.button) hs.spot.alpha = .2;
			}
		};
		this.hide = function() {
			for (var i=0; i<hotSpots.length; i++) {
				hs = hotSpots[i];
				hs.spot.alpha = 0;
			}
		};

		this.remove = this.removeHotSpots = function(page, rect) {
			for (var i=spots.length-1; i>=0; i--) {
				data = spots[i];
				hs = hotSpots[i];
				if (rect && !Array.isArray(rect)) { // button
					rect = [rect.x, rect.y, rect.getBounds().width, rect.getBounds().height];
				}
				if (
					(zot(page) && zot(rect)) ||
					(zot(rect) && page==data.page) ||
					(zot(page) && zim.arraysEqual(rect,data.rect)) ||
					(page==data.page && zim.arraysEqual(rect,data.rect))
				) {
					// remove hotSpot from data and hotSpots list
					spots.splice(i,1);
					if (hs.button) {
						hs.button.off(eventType, hs.button.zimHSEvent);
						hs.button.zimHSEvent = null;
						if (!mouseDowns) {
							hs.button.off("mousedown", hs.button.zimHSMDEvent);
							hs.button.zimHSMDEvent = null;
						}
					}
					hs.off(eventType, hsEvent);
					hs.dispose();
					hotSpots.splice(i,1);
				}
			}
		};

		this.dispose = function() {
			for (var i=0; i<hotSpots.length; i++) {
				hs = hotSpots[i];
				if (hs.button) {
					hs.button.off(eventType, hs.button.zimHSEvent);
					hs.button.zimHSCall = null;
					hs.button.zimHSEvent = null;
					if (!mouseDowns) {
						hs.button.off("mousedown", hs.button.zimHSMDEvent);
						hs.button.zimHSMDEvent = null;
					}
				}
				hs.off(eventType, hsEvent);
				hs.dispose();
			}
			return true;
		};
	};
	zim.extend(zim.HotSpots, zim.Container, "dispose", "zimContainer", false);
	//-72


/*--
zim.Guide = function(obj, vertical, pixels, hideKey, pixelKey, style, group, inherit)

Guide Class
extends a zim.Container which extends a createjs.Container

DESCRIPTION
Guide shows a guideline to help layout assets with code.
Cursor x and y in pixels or percentage are shown along edges
as a distance from the guide.
You only need one guide per axis because you measure from the guide to your cursor.
Use the G key to toggle guide visibility.
Use the P key to toggle pixels and percent.
Make sure you remove the guide for your final version (dispose).

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// simple form for a vertical guide
// use the distance from the guide to your cursor to measure
// so you only need one vertical guide for horizontal measurement
const guide = new Guide();

// better to add guides to a GuideManager
const manager = new GuideManager();
manager.add(new Guide(stage));
manager.add(new Guide(stage, false));

// or with percent
// manager.add(new Guide(stage, true, false));
// manager.add(new Guide(stage, false, false));

// then you can remove all guides with
// manager.dispose();
// handy with guides on multiple Pages
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
obj - (default the default stage) object to add guide to for example a Container
vertical - (default true) set to false for horizontal guide
pixels - (default true unless Frame is in FULL mode) set to false to show percent
hideKey - (default G) key to press to hide guide
pixelKey - (default P) key to press to swap pixels and percent

METHODS
resize() - resizes the guide if the container size changes - not needed now with global manager
toggle(state - default null) - toggle() will show controls if they are hidden or hide controls if they are showing
	alternatively, pass in true to show controls or false to hide controls
	note - method does not update the stage
dispose() - removes keyboard event listeners and guide

PROPERTIES
type - holds the class name as a String
toggled - boolean - read only true if controls are showing or false if controls are hidden
pixels - boolean - set to true to change to pixels, false to go to percent
--*///+76
	zim.Guide = function(obj, vertical, pixels, hideKey, pixelKey, style, group, inherit) {
		var sig = "obj, vertical, pixels, hideKey, pixelKey, style, group, inherit";
		var duo; if (duo = zob(zim.Guide, arguments, sig, this)) return duo;
		z_d("76");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Guide";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(obj)) {
			if (WW.zdf) {
				obj = WW.zdf.stage;
			} else {
				obj = "stage";
			}
		}
		if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:true;
		if (obj != "stage" && (!obj.addChild || !obj.getBounds || !obj.getBounds())) {zog ("zim controls - Guide(): Please provide container with bounds for the obj (setBounds())"); return;}
		if (zot(pixels)) pixels = DS.pixels!=null?DS.pixels:!(zdf&&zdf.scaling=="full");
		if (zot(hideKey)) hideKey = DS.hideKey!=null?DS.hideKey:"G";
		if (zot(pixelKey)) pixelKey = DS.pixelKey!=null?DS.pixelKey:"P";

		var that = this;
		var stageEvent;

		// make text boxes that show x and y
		var boxW = 80;
		var boxH = 26;
		var minX = boxW/6+boxW/2;
		var minY = boxH*2;
		var maxX; // set max values once we get a stage
		var maxY;

		var box;
		if (vertical) {
			box = makeBox("#00c5af", "white", "white");
			box.shape.regX = boxW+boxW/6; box.shape.regY = boxH/2;
			box.label.x = -boxW/2-boxW/6;
		} else {
			box = makeBox("#d61fa0", "white", "white");
			box.shape.regX = boxW/2; box.shape.regY = boxH + boxH/4;
			box.label.y = -boxH*3/4;
		}

		function makeBox(fill, stroke, color) {
			var box = new zim.Container({style:false});
			box.shape = new zim.Shape();
			box.shape.graphics.s(stroke).ss(1).f(fill).r(0,0,boxW,boxH);
			box.shape.alpha = .9;
			box.addChild(box.shape);
			box.label = new createjs.Text("10", "16px arial", color);
			box.label.textAlign = "center";
			box.label.textBaseline = "middle";
			box.addChild(box.label);
			box.mouseChildren = false;
			box.mouseEnabled = false;
			return box;
		}

		var stage;
		if (obj != "stage") obj.addChild(that);
		var addedInterval = zim.added(that, added);

		var guideCheck = false;
		var objW;
		var objH;
		var line;
		var dragBounds;
		function added() {
			if (obj == "stage") {
				stage =	that.stage;
				obj = stage;
			} else {
				stage =	obj.stage;
			}
			if (stage.frame && stage.frame.scaling == "full") {
				if (!zim.globalManager) {
					var gm = zim.globalManager = new zim.Manager();
					gm.frame = stage.frame;
					gm.event = stage.frame.on("resize", function() {
						gm.resize();
					});
				}
				zim.globalManager.add(that);
			}
			obj.addChild(that);
			objW = obj.getBounds().width;
			objH = obj.getBounds().height;
			if (vertical) {
				box.y = objH/2;
				box.label.text = "x:" + ((that.pixels) ? Math.round(objW*70/100) : "70%");
			} else {
				box.x = objW/2;
				box.label.text = "y:" + ((that.pixels) ? Math.round(objH*70/100) : "70%");
			}
			line = new zim.Shape();
			that.addChild(line);
			(vertical) ? line.x = objW*.7 : line.y = objH*.7;

			if (!guideCheck) {
				obj.addChild(that);
				drawGuide();
			}
			stage.off("stagemousemove", stageEvent);
			stageEvent = stage.on("stagemousemove", where);
			stage.update();
		}

		var lastPoint = {x:0,y:0};
		function where(e) {
			// convert mouse location to local point
			var point; var diff;
			if (e) {
				point = obj.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
				lastPoint = point;
			} else {
				point = {x:lastPoint.x, y:lastPoint.y};
			}
			if (pixels) {	
				if (vertical) {
					diff = Math.round(Math.abs(point.x-line.x));
					box.label.text = "x:" + Math.max(0, Math.min(diff, Math.round(objW)));
					box.y = Math.max(minY, Math.min(point.y, maxY));
				} else {
					diff = Math.round(Math.abs(point.y-line.y));
					box.label.text = "y:" + Math.max(0, Math.min(diff, Math.round(objH)));
					box.x = Math.max(minX, Math.min(point.x, maxX));
				}
			} else {
				if (vertical) {
					diff = Math.round(Math.abs(point.x-line.x)/objW*100);
					box.label.text = "x:" + Math.max(0, Math.min(diff, 100)) + "%";
					box.y = Math.max(minY, Math.min(point.y, maxY));
				} else {
					diff = Math.round(Math.abs(point.y-line.y)/objH*100);
					box.label.text = "y:" + Math.max(0, Math.min(diff, 100)) + "%";
					box.x = Math.max(minX, Math.min(point.x, maxX));
				}
			}
			if (stage) stage.update();
		}

		// make the guide once we have the stage
		// and any time resize is called
		function drawGuide() {
			guideCheck = true;
			objW = obj.getBounds().width;
			objH = obj.getBounds().height;
			var pointer;
			if (vertical) {
				pointer = "ew-resize";
				dragBounds = new createjs.Rectangle(0,0,objW,0);
			} else {
				pointer = "ns-resize";
				dragBounds = new createjs.Rectangle(0,0,0,objH);
			}
			zim.noDrag(line);
			setTimeout(function() {
				// give time for content to settle
				zim.drag(line, dragBounds, null, pointer, pointer, null, null, true);
			}, 500);
			stage.mouseMoveOutside = true;
			stage.enableMouseOver(10);

			maxX = objW-boxW*2/3;
			maxY = objH-boxH - boxH;
			line.uncache();
			var g = line.graphics;
			if (vertical) {
				g.c().s("rgba(0,255,255,.1)").ss(20).mt(0,0).lt(0,objH);
				g.f().s("white").ss(2).mt(0,0).lt(0,objH);
				g.s("#00c5af").sd([20,20]).mt(0,0).lt(0,objH).sd();
				line.cache(-10,0,20,objH);
			} else {
				g.c().s("rgba(255,0,255,.1)").ss(20).mt(0,0).lt(objW,0);
				g.f().s("white").ss(2).mt(0,0).lt(objW, 0);
				g.s("#d61fa0").sd([20,20]).mt(0,0).lt(objW, 0).sd();

				line.cache(0,-10,objW,20);
			}

			(vertical) ?  box.x = objW : box.y = objH;
			that.addChild(box);

		}

		Object.defineProperty(this, 'pixels', {
			get: function() {
				return pixels;
			},
			set: function(value) {
				pixels = value;
				that.resize();
			}
		});

		// add key listener to hide and show the guide
		WW.addEventListener("keydown", keyEvent);

		function keyEvent(e) {
			if (!e) e=event;
			if (!stage) return;
			if (String.fromCharCode(e.keyCode) == hideKey.toUpperCase()) { // G
				that.toggle();
			}
			if (String.fromCharCode(e.keyCode) == pixelKey.toUpperCase()) { // P
				that.pixels = !that.pixels;
			}
		}

		this.toggled = true;
		this.toggle = function(type) {
			if (type === true) {
				that.visible = that.toggled = true;
			} else if (type === false) {
				that.visible = that.toggled = false;
			} else {
				that.visible = !that.visible;
				that.toggled = that.visible;
			}
			if (stage) {
				stage.off("stagemousemove", stageEvent);
				if (that.visible) {
					stageEvent = stage.on("stagemousemove", where, that);
				}
				stage.update();
			}
			return that;
		};

		this.resize = function() {
			if (!that) return false;
			if (stage) {
				drawGuide();
				where();
			}
			return true;
		};

		if (style!==false) zim.styleTransforms(this, DS);

		this.dispose = function() {
			if (!that) return false;
			if (zim.globalManager) {
				var gm = zim.globalManager;				
				gm.remove(that);
				if (zim.globalManager.items.length==0) {
					gm.frame.off("resize", gm.event);
					gm.dispose();
					zim.globalManager = null;
				}				
			}
			zim.noDrag(line);
			clearInterval(addedInterval);
			that.removeAllChildren();
			WW.removeEventListener("keydown", keyEvent);
			if (that.parent) that.parent.removeChild(that);
			that = null;
			return true;
		};
	};
	zim.extend(zim.Guide, zim.Container, "clone", "zimContainer", false);
	//-76

/*--
zim.Grid = function(obj, color, pixels, hideKey, pixelKey, allowToggle, cache, numbers, style, group, inherit)

Grid
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A Grid shows gridlines to help layout assets with code (pixels is default).
Cursor x and y percentage or pixels are shown along edges.
Use the G key to toggle grid visibility.
Use the P key to toggle pixels and percent.
Make sure you remove the grid for your final version (dispose).

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const grid = new Grid();

// better to add grids to a GridManager
const manager = new GridManager();
manager.add(new Grid());

// or with percent
// manager.add(new Grid(null, null, false));

// then you can remove all grids with
// grid.dispose();
// handy with guides on multiple Pages
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
obj - (default the default stage) the object to add grid to (for example a Container)
color - (default black) the color of the grid
pixels - (default true unless Frame is in FULL mode) set to false to show percent
hideKey - (default G) key to press to hide grid
pixelKey - (default P) key to press to swap percent and pixels
allowToggle - (default true) set to false to not allow grid to toggle between percent and pixels with key
cache - (default true) cache the grid
numbers - (default true) show numbers on grid

METHODS
resize() - resize the grid if the container changes size - not needed now with global manager
toggle(state - default null) - toggle() will show controls if they are hidden or hide controls if they are showing
	alternatively, pass in true to show controls or false to hide controls
	note - method does not update the stage
	returns object for chaining
dispose() - clears keyboard events and grid

PROPERTIES
type - holds the class name as a String
grid - access to grid Container
numbersX - access to horizontal numbers 
numbersY - access to vertical numbers
toggled - boolean - read only true if controls are showing or false if controls are hidden
pixels - boolean - set to true to change to pixels, false to go to percent
--*///+78
	zim.Grid = function(obj, color, pixels, hideKey, pixelKey, allowToggle, cache, numbers, style, group, inherit) {
		var sig = "obj, color, pixels, hideKey, pixelKey, allowToggle, cache, numbers, style, group, inherit";
		var duo; if (duo = zob(zim.Grid, arguments, sig, this)) return duo;
		z_d("78");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Grid";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(obj)) {
			if (WW.zdf) {
				obj = WW.zdf.stage;
			} else {
				obj = "stage";
			}
		}
		if (zot(color)) color = DS.color!=null?DS.color:zim.black;
		if (obj != "stage" && (!obj.addChild || !obj.getBounds || !obj.getBounds())) {zog ("zim controls - Grid(): Please provide container with bounds for the obj (setBounds())"); return;}
		if (zot(pixels)) pixels = DS.pixels!=null?DS.pixels:!(zdf&&zdf.scaling=="full");
		if (zot(hideKey)) hideKey = DS.hideKey!=null?DS.hideKey:"G";
		if (zot(pixelKey)) pixelKey = DS.pixelKey!=null?DS.pixelKey:"P";
		if (zot(allowToggle)) allowToggle = DS.allowToggle!=null?DS.allowToggle:true;
		if (zot(cache)) cache = DS.cache!=null?DS.cache:true;
		if (zot(numbers)) numbers = DS.numbers!=null?DS.numbers:true;

		var that = this;
		var pix = 10; // for grid
		var stageEvent;

		this.mouseChildren = false;
		this.mouseEnabled = false;

		// make text boxes that show x and y
		var boxW = 80;
		var boxH = 26;

		var top = that.numbersX = makeBox("#dddddd", color, "#333333");
		top.shape.regX = boxW/2; top.shape.regY = -boxH/4;
		top.label.y = boxH*3/4;
		
		var left = that.numbersY = makeBox("#dddddd", color, "#333333");
		left.shape.regX = -boxW/6; left.shape.regY = boxH/2;
		left.label.x = boxW/2 + boxW/6;

		if (!numbers) {
			top.visible = false;
			left.visible = false;
		}

		function makeBox(fill, stroke, color) {
			var box = new zim.Container({style:false});
			box.shape = new createjs.Shape();
			box.shape.graphics.s(stroke).ss(1).f(fill).r(0,0,boxW,boxH);
			box.shape.alpha = .9;
			box.addChild(box.shape);
			box.label = new createjs.Text("10", "16px arial", color);
			box.label.textAlign = "center";
			box.label.textBaseline = "middle";
			box.addChild(box.label);
			box.mouseChildren = false;
			box.mouseEnabled = false;
			return box;
		}

		var minX = boxW/6+boxW/2;
		var minY = boxH*2;
		var maxX; // set max values once we get a stage
		var maxY;

		top.x = minX;
		left.y = minY;
		top.label.text = "x:0";
		left.label.text = "y:0";

		var stage;
		if (obj != "stage") obj.addChild(that);
		var addedInterval = zim.added(that, added);

		var gridCheck = false;
		function added() {
			if (obj == "stage") {
				stage =	that.stage;
				obj = stage;
			} else {
				stage =	obj.stage;
			}
			if (stage.frame && stage.frame.scaling == "full") {
				if (!zim.globalManager) {
					var gm = zim.globalManager = new zim.Manager();
					gm.frame = stage.frame;
					gm.event = stage.frame.on("resize", function() {
						gm.resize();
					});
				}
				zim.globalManager.add(that);
			}
			if (!gridCheck) {
				drawGrid();
				obj.addChild(that);
			}
			stage.off("stagemousemove", stageEvent);
			stageEvent = stage.on("stagemousemove", where);
			stage.update();
		}
		var lastPoint = {x:0,y:0};
		function where(e) {
			// convert mouse location to local point
			var point;
			if (e) {
				point = obj.globalToLocal(e.rawX/zim.scaX, e.rawY/zim.scaY);
				lastPoint = point;
			} else {
				point = {x:lastPoint.x, y:lastPoint.y};
			}
			if (pixels) {	// pixels
				top.label.text = "x:" + Math.max(0, Math.min(Math.round(point.x), Math.round(objW)));
				top.x = Math.max(minX, Math.min(point.x, maxX));
				left.label.text = "y:" + Math.max(0, Math.min(Math.round(point.y), Math.round(objH)));
				left.y = Math.max(minY, Math.min(point.y, maxY));
			} else {
				top.label.text = "x:" + Math.max(0, Math.min(Math.round(point.x/objW*100), 100)) + "%";
				top.x = Math.max(minX, Math.min(point.x, maxX));
				left.label.text = "y:" + Math.max(0, Math.min(Math.round(point.y/objH*100), 100)) + "%";
				left.y = Math.max(minY, Math.min(point.y, maxY));
			}
			if (stage) stage.update();
		}

		// make the grid once we have the stage
		var objW;
		var objH;
		var cached;
		function drawGrid() {
			gridCheck = true;
			if (obj && obj.getBounds) {
				objW = obj.getBounds().width;
				objH = obj.getBounds().height;
			}
			if (stage) {
				stage.mouseMoveOutside = true;
				stage.enableMouseOver(10);
			}
			maxX = objW-boxW*2/3;
			maxY = objH-boxH - boxH;
			cached = that.grid = new zim.Container({style:false});
			that.addChild(cached);
			var grid = new createjs.Shape();
			cached.addChild(grid);
			var g = grid.graphics;
			g.s(color).ss(1);

			var grid2 = new createjs.Shape();
			cached.addChild(grid2);
			
			var i;
			if (pixels) {

				for (i=0; i<objW/pix; i++) {
					g.mt(i*pix, 0).lt(i*pix, objH);
				}
				for (i=0; i<objH/pix; i++) {
					g.mt(0, i*pix).lt(objW, i*pix);
				}
				grid.alpha = .3;

				g = grid2.graphics;
				g.s(color).ss(1);

				for (i=0; i<objW/(pix*10); i++) {
					g.mt(i*(pix*10), 0).lt(i*(pix*10), objH);
				}
				for (i=0; i<objH/(pix*10); i++) {
					g.mt(0, i*(pix*10)).lt(objW, i*(pix*10));
				}

			} else { // percent - every 5 percent

				for (i=1; i<20+1; i++) {
					g.mt(i*objW/20, 0).lt(i*objW/20, objH);
				}
				for (i=1; i<20; i++) {
					g.mt(0, i*objH/20).lt(objW, i*objH/20);
				}
				grid.alpha = .3;

				g = grid2.graphics;
				g.s(color).ss(1);

				for (i=1; i<10; i++) {
					g.mt(i*objW/10, 0).lt(i*objW/10, objH);
				}
				for (i=1; i<10; i++) {
					g.mt(0, i*objH/10).lt(objW, i*objH/10);
				}
			}

			var crossSize = 80;
			g.s("#FFFFFF").ss(8);
			g.mt(objW/2, objH/2-crossSize/2).lt(objW/2, objH/2+crossSize/2);
			g.mt(objW/2-crossSize/2, objH/2).lt(objW/2+crossSize/2, objH/2);

			g.s("#000000").ss(4);
			g.mt(objW/2, objH/2-crossSize/2).lt(objW/2, objH/2+crossSize/2);
			g.mt(objW/2-crossSize/2, objH/2).lt(objW/2+crossSize/2, objH/2);

			// draw a border
			g.s(color).ss(cache?3:2);
			g.dr(0,0,objW,objH);

			grid2.alpha = .5;
			if (cache) cached.cache(0,0,objW,objH);

			that.addChild(top);
			that.addChild(left);

			if (stage) stage.update();
		}

		Object.defineProperty(this, 'pixels', {
			get: function() {
				return pixels;
			},
			set: function(value) {
				pixels = value;
				that.resize();
			}
		});

		// add key listener to hide and show the grid
		WW.addEventListener("keydown", keyEvent);

		function keyEvent(e) {
			if (!e) e=event;
			if (!stage || !allowToggle) return;
			if (String.fromCharCode(e.keyCode) == hideKey.toUpperCase()) { // G
				that.toggle();
			}
			if (String.fromCharCode(e.keyCode) == pixelKey.toUpperCase()) { // P
				that.removeChild(cached);
				cached = null;
				that.pixels = !that.pixels;
			}
		}


		this.toggled = true;
		this.toggle = function(type) {
			if (type === true) {
				that.visible = that.toggled = true;
			} else if (type === false) {
				that.visible = that.toggled = false;
			} else {
				that.visible = !that.visible;
				that.toggled = that.visible;
			}
			stage.off("stagemousemove", stageEvent);
			if (that.visible) {
				stageEvent = stage.on("stagemousemove", where, that);
			}
			if (stage) stage.update();
			return that;
		};

		this.resize = function() {
			if (!that) return false;
			that.removeChild(cached);
			cached = null;
			if (stage) {
				drawGrid();
				where();
				setTimeout(function(){ // solve ipod bug
					if (that) that.removeChild(cached);
					cached = null;
					drawGrid();
				},200);
			}
			return true;
		};

		if (style!==false) zim.styleTransforms(this, DS);

		this.dispose = function() {
			if (zim.globalManager) {
				var gm = zim.globalManager;				
				gm.remove(that);
				if (zim.globalManager.items.length==0) {
					gm.frame.off("resize", gm.event);
					gm.dispose();
					zim.globalManager = null;
				}				
			}
			clearInterval(addedInterval);
			that.removeAllChildren();
			WW.removeEventListener("keydown", keyEvent);
			if (that.parent) that.parent.removeChild(that);
			that = null;
			return true;
		};

	};
	zim.extend(zim.Grid, zim.Container, "clone", "zimContainer", false);
	//-78

/*--
zim.Wrapper = function(items, width, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit)

Wrapper
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A Wrapper wraps its content to the next row at a given width
The Wrapper is similar to the CSS Flexbox with the following:

ALIGNMENTS:
	It has left, center/middle right then top, center/middle bottom alignments
	for whole rows and columns and then for inside the rows and columns.
	These may or may not be active depending on the wrapper type below
WRAPPER TYPES:
	The types are spacing (default), spread, stretch, or column
	A colSize is available for the column type
	A rowSize is available that works with any of the above types
SETTINGS:
	There are also flip, reverse, bottomFull and col/row void settings.
MARGINS:
	ZIM display objects can have margins left, top, right, bottom
	that will shift objects relatively inside the Wrapper
	without affecting other objects in the wrapper.

WRAPPER WITH WINDOW AND LAYOUT
The Wrapper is resized automatically when added to a ZIM Window.
Set the Window resizeHandle parameter to true to let the user resize.
The Wrapper resizes and scales as a region in the ZIM Layout class.
The Window also resizes - so a Wrapper can go in a Window in a Layout object.

WRAPPER VS TILE
The Tile is locked in to rows and columns and does not wrap content
The Tile also has many responsive settings to squeeze, stretch, align, etc.
Consider the Wrapper like FlexBox perhaps Grid with ColSize set - and the Tile like a Table

WRAPPER VS LABEL
The Label can wrap text using the labelWidth/lineWidth parameters (they are the same).
The Wrapper is used to wrap objects - perhaps including a Label object.

See https://zimjs.com/ten/wrapper.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circles = [];
loop(40, ()=>{
	circles.push(new Circle(20, [orange, green, blue]));
});
const wrapper = new Wrapper(circles, 400, 20, 20).center();

interval(.5, ()=>{
	wrapper.resize(rand(300,500)).outline();
	S.update();
});
END EXAMPLE

EXAMPLE
const win = new Window({
	width:500,
	height:400,
	titleBar:"Wrapper",
	titleBarBackgroundColor:yellow,
	scrollBarDrag:true,
	fullSize:true,
	resizeHandle:true,
	backgroundColor:lighter,
	padding:10
})
	.center()
	.add(new Wrapper({
		items:[
			new Circle(), new Rectangle(), new Triangle(),
			new Circle(), new Rectangle(), new Triangle(),
			new Circle(), new Rectangle(), new Triangle(),
			new Circle(), new Rectangle(), new Triangle(),
			new Circle(), new Rectangle(), new Triangle(),
			new Circle(), new Rectangle(), new Triangle()
		],
		spacingH:10,
		spacingV:10,
		wrapperType:"spread"
	}));
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
items - (default null) - an Array of items (or a single item) to add to the wrapper - also see add() addAt() and remove() methods
	the wrapper is a ZIM Container so any ZIM add and remove methods can be used and then a resize() method called
width - |ZIM VEE| (default 300) set to a width to wrap items at this width (see resize(w,h) method to change width)
spacingH - (default 0) a spacing between items - ignored if colSize is set
	spacingH does not get ZIM VEE - the results are jiggly when wrapping
spacingV - |ZIM VEE| (default 0) a spacing between rows - ignored if rowSize is set
wrapperType - (default "spacing") changes how the wrapper lays out the items as follows:
	"spacing" - places each item spaced at the spacingH from the next item
	"spread" - places equal spacing around edges and items horizontally (min the spacingH)
	"stretch" - places equal spacing between objects horizontally with no spacing at edges (min the spacingH)
	"column" - uses colSize parameter to determine spacing (spacingH is ignored)
align - |ZIM VEE| (default LEFT) set to CENTER, MIDDLE, RIGHT
	this aligns the whole row - see also alignInner for aligning inside columns
	align:series(LEFT, RIGHT) will toggle rows aligning left and right
valign - |ZIM VEE| (default TOP) set to CENTER, MIDDLE, BOTTOM
	this aligns the rows at the top, middle or bottom only when a height is provided (rare)
	see also valignInner for vertical aligning within rows (common)
alignInner - |ZIM VEE| (default LEFT) set to CENTER, MIDDLE, RIGHT
	aligns the items when colSize is set only - see also align for aligning whole rows horizontally
valignInner - |ZIM VEE| (default BOTTOM) set to TOP, CENTER, MIDDLE
	aligns the items in vertically in their row (common) - see also valign for aligning whole rows vertically (rare)
flip - |ZIM VEE| (default false) set to true to flip the order of the rows
	flip:series(false, true) would read left to right then right to left then left to right, etc.
reverse - |ZIM VEE| (default false) set to true to reverse all the items so the first is (probably) at the bottom right
bottomFull - |ZIM VEE| (default false) set to true to fill the Wrapper at the bottom
	does not reverse but rather leaves potentially fewer items at the top
colSize - |ZIM VEE| (default null) set to number to hard code column width
	this is ignored if the wrapperType is not set to "column"
	use colSize:series(100, 200, 100, 400) to set specific sizes
	this will also the only setting for which alignInner works
rowSize - |ZIM VEE| (default null) set to number to hard code row height
	this ignores spacingV but can be used with any wrapperType
	use a series(100, 200, 100, 400) to set specific sizes
height - (default null) does not really set the height of the wrapper
	the height is always determined by the width and the items as they wrap
	(both the width and height cannot be used together without scaling and the wrapper does not scale items)
	the height will have no effect when the valign parameter is set to TOP (default)
	The height will place the bottom of the wrapper at the height when the valign is BOTTOM
	The height will place the wrapper in the middle of the height when the valign is CENTER/MIDDLE
	Note: in the all cases the bounds will still be the bounds around the wrapper
	just the positioning of the wrapper is changed.
	This allows the wrapper to be placed at the bottom and grow to the top
	or placed in the middle and grow from the middle
	which would not be possible otherwise aside from repositioning after each resize
minSpreadNum - (default 2) spread would always center a single item on a row
	and can look weird spreading two or even three final items
	a wrapper with wrapperType:"spread" will spread items if there are at least minSpreadNum items
	if there is less than minSpreadItems then it will align the items according to align
minStretchNum - (default 3) stretch would always center a single item on a row
	and can look weird stretching two or even three final items
	a wrapper with wrapperType:"stretch" will stretch items if there are at least minStretchNum items
	if there is less than minStretchItems then it will align the items according to align
	this will not stop the first line from stretching unless minStretchFirst parameter is set to false
percentVoidH - |ZIM VEE| (default 0) set a percent horizontal space between items default in center
offsetVoidH - |ZIM VEE| (default 0) set a percent (or negative percent) to offset the void from the center horizontally
percentVoidV - |ZIM VEE| (default 0) set a percent vertical space between rows default in center
offsetVoidV - |ZIM VEE| (default 0) set a percent (or negative percent) to offset the void from the center vertically
minStretchFirst - (default true) set to false to avoid stretching the first line if less than minStretchNum is set and met
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(items) - add an item or an array of items to the wrapper - will call a resize() - returns the wrapper for chaining
addAt(items, index) - insert an item or an array of items at an index - will call a resize() - returns the wrapper for chaining
remove(items) - removes an item or items (pass in an array) - will call a resize() - returns the wrapper for chaining
setProps(properties) - sets provided properties (as {prop:val, prop:val}) for each item
	the values accept ZIM VEE - dynamic parameters - see ZIM Pick()
	returns object for chaining
resize(width, height) - resize the wrapper passing an optional width and height - returns wrapper for chaining
	most of the properties below resize the wrapper automatically
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy of the Wrapper
dispose() - removes listeners and deletes object

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
items - an array of the wrapper items 
items2D - read only array of rows each containing an array of colums of items
** see the parameter for descriptions of the following
** setting each will resize the wrapper at the current width and height
** all these properties accept ZIM VEE (except spacingH) for instance: flip:series(false,true)
spacingH
spacingV
wrapperType
align
valign
alignInner
valignInner
flip
reverse
bottomFull
colSize
rowSize
percentVoidH
offsetVoidH
percentVoidV
offsetVoidV

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

--*///+78.5

	zim.Wrapper = function(items, width, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit) {
		var sig = "items, width, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, style, group, inherit";
		var duo=null; if (duo = zob(zim.Wrapper, arguments, sig, this)) return duo;

		z_d("78.5");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Wrapper", this.group, inherit);

		if (zot(width)) width = DS.width!=null?DS.width:300;
		if (zot(height)) height = DS.height!=null?DS.height:null;
		if (zot(spacingH)) spacingH = DS.spacingH!=null?DS.spacingH:null;
		if (zot(spacingV)) spacingV = DS.spacingV!=null?DS.spacingV:null;
		if (zot(wrapperType)) wrapperType = DS.wrapperType!=null?DS.wrapperType:"spacing";
		if (zot(align)) align = DS.align!=null?DS.align:"left";
		if (zot(valign)) valign = DS.valign!=null?DS.valign:"top";
		if (zot(alignInner)) alignInner = DS.alignInner!=null?DS.alignInner:"left";
		if (zot(valignInner)) valignInner = DS.valignInner!=null?DS.valignInner:"bottom";
		if (zot(flip)) flip = DS.flip!=null?DS.flip:false;
		if (zot(reverse)) reverse = DS.reverse!=null?DS.reverse:false;
		if (zot(bottomFull)) bottomFull = DS.bottomFull!=null?DS.bottomFull:false;
		if (zot(colSize)) colSize = DS.colSize!=null?DS.colSize:100;
		if (zot(rowSize)) rowSize = DS.rowSize!=null?DS.rowSize:null;
		if (zot(spacingH)) spacingH = 0; // sizes override spacing
		if (zot(spacingV)) spacingV = 0;
		if (zot(minSpreadNum)) minSpreadNum = DS.minSpreadNum!=null?DS.minSpreadNum:2;
		if (zot(minStretchNum)) minStretchNum = DS.minStretchNum!=null?DS.minStretchNum:3;
		if (zot(percentVoidH)) percentVoidH = DS.percentVoidH!=null?DS.percentVoidH:0;
		if (zot(offsetVoidH)) offsetVoidH = DS.offsetVoidH!=null?DS.offsetVoidH:0;
		if (zot(percentVoidV)) percentVoidV = DS.percentVoidV!=null?DS.percentVoidV:0;
		if (zot(offsetVoidV)) offsetVoidV = DS.offsetVoidV!=null?DS.offsetVoidV:0;
		if (zot(minStretchFirst)) minStretchFirst = DS.minStretchFirst!=null?DS.minStretchFirst:true;		

		var buildHeight = 200;
		var totalSpacing = 0;
		var averageSpacing = 0;
		var lastSpacing = 0;
		var widthVoid = width;
		this.items = [];

		var spread; var stretch;
		if (wrapperType == "spread") spread = true;
		else if (wrapperType == "stretch") stretch = true;

		this.zimContainer_constructor(width,buildHeight);
		this.type = "Wrapper";

		if (align == "middle") align = "center";
		if (valign == "middle") valign = "center";
		if (alignInner == "middle") alignInner = "center";
		if (valignInner == "middle") valignInner = "center";

		var that = this;
		this.add = function(obj) {
			this.addAt(obj, this.numChildren-1);
			return that;
		};
		this.addAt = function(obj, index) {
			if (zot(obj)) return that;
			if (zot(index) || index < 0) index = 0;
			if (!Array.isArray(obj)) obj = [obj];
			zim.loop(obj, function (o, i) {
				that.addChildAt(o, index+i);
			});
			that.resize();
			return that;
		};
		this.remove = function(obj) {
			if (!Array.isArray(obj)) obj = [obj];
			zim.loop(obj, function(o) {
				if (o && o.removeFrom) o.removeFrom();
			}, true);
			that.resize();
			return that;
		};
		this.convert = function(container, cache) {
			var all = [];
			container.loop(function (child) {
				all.push(child);
				if (cache) child.cache();
			});
			that.add(all);
			container.removeFrom();
			return that;
		};

		var fl;


		this.resize = function(w, h) {

			if (that.preventResize) return;

			if (!zot(w)) width = w;
			if (!zot(h)) height = h;

			this.items2D = [];
			this.items = [];
			totalSpacing = 0; // for last spread
			averageSpacing = 0;
			lastSpacing = 0;

			if (zot(percentVoidH)) percentVoidH = 0;
			if (zot(offsetVoidH)) offsetVoidH = 0;
			var pv = zim.Pick.choose(percentVoidH);
			var ov = zim.Pick.choose(offsetVoidH);
			widthVoid = width*(100-pv)/100;

			this.setBounds(widthVoid, buildHeight);
			var totalX = 0;
			var totalY = 0;
			var maxY = 0;
			that.cols = 0;
			that.rows = 0;
			var currentCols = [];
			var heights = [0];
			var lastPoint = null;
			var lineObjectWidths = 0;
			var b = null;
			var co = zim.Pick.choose(colSize);
			if (wrapperType!="column") co = null;
			var ro = zim.Pick.choose(rowSize);
			var colCount = 0;
			var point,newX;

			if (flip.type == "series") flip.index = 0;
			fl = zim.Pick.choose(flip);

			zim.loop(this, function(o, i) {
				if (bottomFull || fl) {
					o.pos(totalX+(o.marginRight?o.marginRight:0), totalY+(o.marginTop?o.marginTop:0), zim.RIGHT, fl?zim.TOP:zim.BOTTOM);
				} else {
					o.pos(totalX+(o.marginLeft?o.marginLeft:0), totalY+(o.marginTop?o.marginTop:0));
				}
				colCount++;
				b = o.boundsToGlobal();
				var pointTL = that.globalToLocal(b.x, b.y);
				var pointBR = that.globalToLocal(b.x+b.width, b.y+b.height);
				if (bottomFull || fl) {
					point = that.globalToLocal(b.x, b.y);
					// o.wrapHeight = buildHeight-totalY-point.y;
				} else {
					point = that.globalToLocal(b.x+b.width, b.y+b.height);
					// o.wrapHeight = point.y-totalY;
				}
				o.wrapHeight = pointBR.y-pointTL.y;
				o.wrapWidth = pointBR.x-pointTL.x;

				if (pv) {
					// get center - used for void
					var point2 = that.globalToLocal(b.x+o.wrapWidth/2, b.y+o.wrapHeight/2);
					o.centerX = point2.x;
					o.centerY = point2.y;
					point2 = null;
				}

				if (co) {
					newX = co*colCount;
				} else {
					if (bottomFull || fl) {
						newX = widthVoid - point.x + (o.marginLeft?o.marginLeft:0) + spacingH;
					} else {
						newX = point.x + (o.marginRight?o.marginRight:0) + spacingH;
					}
				}

				// WRAPPING
				if (Math.round(newX)-spacingH > widthVoid) {
					alignObjects(currentCols, lastPoint, maxY, lineObjectWidths, co, pv, ov, false);
					lineObjectWidths = 0;
					if (that.cols == 0) that.cols = i;
					totalX = 0;
					totalY += maxY+(ro?0:zim.Pick.choose(spacingV));
					maxY = 0;
					ro = zim.Pick.choose(rowSize);
					pv = zim.Pick.choose(percentVoidH);
					ov = zim.Pick.choose(offsetVoidH);
					
					colCount = 0;
					//if (i<t-1) {
						that.items2D.push(zim.copy(currentCols));
						that.rows++; // might not be another to add
						heights.push(totalY);
					//}
					currentCols = [];
					
					if (bottomFull || fl) {
						o.pos(totalX+(o.marginRight?o.marginRight:0), totalY+(o.marginTop?o.marginTop:0), zim.RIGHT, fl?zim.TOP:zim.BOTTOM);
					} else {
						o.pos(totalX+(o.marginLeft?o.marginLeft:0), totalY+(o.marginTop?o.marginTop:0));
					}

					if (pv) {
						b = o.boundsToGlobal();
						point2 = that.globalToLocal(b.x+o.wrapWidth/2, b.y+o.wrapHeight/2);
						o.centerX = point2.x;
						o.centerY = point2.y;
						point2 = null;
					}

					colCount++;
					if (co) {
						newX = 0;
					} else {
						newX = (o.marginLeft?o.marginLeft:0) + o.wrapWidth + (o.marginRight?o.marginRight:0) + zim.Pick.choose(spacingH);
						if (bottomFull || fl) {
							point.x = widthVoid - ((o.marginRight?o.marginRight:0) + o.wrapWidth);
						} else {
							point.x = (o.marginLeft?o.marginLeft:0) + o.wrapWidth;
						}
					}
				}
				currentCols.push(o);
				lineObjectWidths += o.wrapWidth;
				totalX = newX;
				if (ro) {
					maxY = ro;
				} else {
					maxY = Math.max(maxY, o.wrapHeight+(o.marginTop?o.marginTop:0)+(o.marginBottom?o.marginBottom:0));
				}
				lastPoint = new zim.Point(point.x, totalY+maxY);
			}, (reverse&&bottomFull?false:reverse||bottomFull));
			// end loop

			if (that.numChildren>0) {
				if (that.cols == 0) that.cols = that.numChildren;
				that.items2D.push(zim.copy(currentCols));
				heights.push(totalY);
				alignObjects(currentCols, lastPoint, maxY, lineObjectWidths, co, pv, ov, true); // true for data end
				that.rows+=1; // row changes after making all cols - but not last one
			}

			var va = zim.Pick.choose(valign);
			var diff;
			if (zot(va)) va = "top";

			if (bottomFull) {
				diff = (totalY+maxY)-buildHeight;
				zim.loop(this, function (obj) {
					obj.mov(0,diff);
				});
				that.items2D.reverse();
				zim.loop(that.items2D, function (rr) {
					rr.reverse();
				});
			}

			var perV = zim.Pick.choose(percentVoidV);
			var offV = zim.Pick.choose(offsetVoidV);
			if (!zot(perV)) {
				if (zot(offV)) offV = 0;
				var totalHeight = totalY+maxY;
				var splitRowSize = totalHeight*perV/100;
				var splitRowStart = totalHeight/2+offV/100*totalHeight;
				zim.loop(heights, function (hh, i) {
					if (hh >= splitRowStart) {
						zim.loop(that.items2D, function (rr) {
							zim.loop(rr, function (obj) {
								obj.mov(0, splitRowSize);
							});
						}, null, 1, i);
						return "break";
					}
				});
			}
			if (!zot(height)) {
				if (valign=="bottom") {
					diff = height-(totalY+maxY);
					zim.loop(this, function (obj) {
						obj.mov(0,diff);
					});
				} else if (valign == "center" || valign == "middle") {
					diff = (height-(totalY+maxY))/2;
					zim.loop(this, function (obj) {
						obj.mov(0,diff);
					});
				}
			}
			
			that.setBounds(null);
			b = that.getBounds();
			if (b) that.setBounds(0,b.y,width,b.height);
	
			zim.loop(that.items2D, function (item) {
				zim.loop(item, function (i) {
					that.items.push(i);
				});
			});

			if (this.stage) this.stage.update();
			return that;

		}; // end resize()


		function alignObjects(objects, lastPoint, maxY, lineObjectWidths, co, pv, ov, dataEnd) {

			var al = zim.Pick.choose(align);
			var sp = zim.Pick.choose(spread);
			var st = zim.Pick.choose(stretch);
			var ai = zim.Pick.choose(alignInner);
			var vi = zim.Pick.choose(valignInner);

			if (zot(al)) al = "left";
			if (zot(vi)) vi = "top";
			if (zot(ai)) ai = "left";

			if (fl) objects.reverse();

			var voidThresh = ((100-pv)/100/2+ov/100)*width;
			var voidMove = width*pv/100;
			var am=0; // amount that obj was moved relative to its centered x during resize calculations
			var alignCheck = false;
			var lastX,diffX;

			if (co) { // columns		
				if (bottomFull || fl) objects.reverse();
				var gap = widthVoid%co;
				var voidLoc = widthVoid/2+ov/100*widthVoid;
				var added = 0;
				var posit = 0;
				var firstObjectsLength = Math.floor(widthVoid/co);
				if (that.rows != 0 && dataEnd) alignCheck = true;
				zim.loop(objects, function (obj, i) {
					// alignment within cols
					am = 0;
					if (ai=="right") posit = co*i+added+co-obj.wrapWidth;
					else if (ai=="center" || ai=="middle") posit = co*i+added+(co-obj.wrapWidth)/2;
					else posit = co*i+added;

					lastX = obj.x;
					obj.pos(posit);
					diffX = obj.x-lastX;
					obj.centerX+=diffX;

					if (obj.marginLeft) am+=obj.marginLeft;
					if (obj.marginRight) am-=obj.marginRight;

					// overall alignment
					var missing;
					if (al=="center" || al=="middle") {
						// obj.mov(gap/2);
						missing = Math.floor(widthVoid/co)-objects.length;
						am += (gap+(missing?missing*co:0))/2;
					} else if (al=="right") {
						missing = Math.floor(widthVoid/co)-objects.length;
						am += gap+(missing?missing*co:0);
					}
					obj.mov(am);
					obj.centerX+=am;
				});

				if (al=="center") {
					// only if end row is not even or odd like the other rows
					if (alignCheck && (objects.length+firstObjectsLength)%2!=0) {
						am = (voidLoc<=widthVoid/2?-1:1)*co/2; // void is center or left - move left
						zim.loop(objects, function (obj) {
							obj.mov(am);
							obj.centerX+=am;
						});
					}
				}

			} else if (sp || st) { // spread or stretch				
				// equal space between
				var spacing, extra;
				if (sp) spacing = objects.length?((widthVoid-lineObjectWidths)/(objects.length+1)):0;
				else if (st) spacing = objects.length-1>0?((widthVoid-lineObjectWidths)/(objects.length-1)):0;

				// if (objects.length<minStretchNum && that.rows != 0 && dataEnd) {
				if (objects.length<minStretchNum && dataEnd) {
					if (minStretchFirst || that.rows > 0) {
						spacing = that.rows==0?spacingH:lastSpacing;
						alignCheck = true;
					}					
				}
				lastSpacing = spacing;

				var widthTotal = 0;				
				if (bottomFull || fl) objects.reverse();
				zim.loop(objects, function (obj, i) {
					am = 0;
					lastX = obj.x;
					obj.pos(spacing*(i+(sp?1:0))+widthTotal);
					diffX = obj.x-lastX;
					obj.centerX+=diffX;
					if (!alignCheck) {
						if (obj.marginLeft) am+=obj.marginLeft;
						if (obj.marginRight) am-=obj.marginRight;
						obj.mov(am);
						obj.centerX+=am;
					}
					widthTotal+=obj.wrapWidth;
				});
				if (alignCheck) {
					am=0;
					// new zim.Circle(4,purple).loc(lastPoint.x, 0, that)
					var totalShift = (sp?spacing:0); // ### change
					diffX = 0;
						zim.loop(objects, function (obj) { // looping in reverse
						if (al=="right") {
							lastX = obj.x;
							obj.pos(totalShift,null,zim.RIGHT);
							diffX = obj.x-lastX;
							totalShift+=obj.wrapWidth+spacing;
						} else if (al=="center") {
							var centerShift = (widthVoid-(widthTotal + (objects.length-1)*spacing))/2-(sp?spacing:0); // ### change
							lastX = obj.x;
							obj.pos(totalShift+centerShift,null,zim.RIGHT);
							diffX = obj.x-lastX;
							totalShift+=obj.wrapWidth+spacing;
						}
						if (obj.marginLeft) am+=obj.marginLeft;
						if (obj.marginRight) am-=obj.marginRight;
						obj.mov(am);
						obj.centerX+=diffX+am;
					}, true);
				}
			} else {
				// shifts for normal wrapping
				if (al=="center") {
					zim.loop(objects, function (obj) {						
						am = ((bottomFull||fl?0:width)-lastPoint.x)/2;
						if (sp || st) {
							if (obj.marginLeft) am+=obj.marginLeft;
							if (obj.marginRight)  am-=obj.marginRight;
						}
						obj.mov(am);
						obj.centerX+=am;
					});
				} else if ((bottomFull||fl) && al=="left") {
					extra = objects[objects.length-1].marginLeft;
					zim.loop(objects, function (obj) {
						am = -lastPoint.x+(extra?extra:0);
						if (sp) {
							am+=averageSpacing;
						}
						obj.mov(am);
						obj.centerX+=am;
					});
				} else if (!(bottomFull||fl) && al=="right") {
					extra = objects[objects.length-1].marginRight;
					zim.loop(objects, function (obj) {
						am = width-lastPoint.x-(extra?extra:0);
						if (sp) {
							am-=averageSpacing;
						}
						obj.mov(am);
						obj.centerX+=am;
					});
				} else if (sp) {
					if (sp) {
						zim.loop(objects, function (obj) {
							am = averageSpacing*(al=="right"?-1:1);
							obj.mov(am);
							obj.centerX+=am;
						});
					}
				}
			}

			// change to pvH ovH
			if (pv) {
				voidThresh = (1/2+ov/100)*widthVoid;
				voidMove = width*pv/100;
				zim.loop(objects, function (obj) {
					// new zim.Circle(2).loc(obj.centerX, obj.centerY, that);
					// new zim.Circle(5, red).loc(widthVoid/2+ov/100*widthVoid, 200, that);
					if (co || st || sp) {
						if (al=="right") {
							if (obj.centerX > widthVoid-voidThresh) obj.mov(voidMove);
						} else if (al=="center") {
							if (Math.round(obj.centerX) == Math.round(widthVoid/2+ov/100*widthVoid)) obj.mov(voidMove/2);
							else if (Math.round(obj.centerX) > Math.round(widthVoid/2+ov/100*widthVoid)) obj.mov(voidMove);
						} else {
							if (obj.centerX > voidThresh) obj.mov(voidMove);
						}
					} else if (!(bottomFull||fl) && al=="right") {
						if (obj.centerX < width-voidThresh) obj.mov(-voidMove);
					} else if (!(bottomFull||fl) && al=="center") {
						// might want to center each side on their side...
						if (obj.centerX > width/2+ov/100*widthVoid) obj.mov(voidMove/2);
						else obj.mov(-voidMove/2);
					} else if ((bottomFull||fl) && al=="right") {
						if (obj.centerX > widthVoid-voidThresh) obj.mov(voidMove);
					} else if ((bottomFull||fl) && al=="center") {
						if (obj.centerX > widthVoid/2+ov/100*widthVoid) obj.mov(voidMove);
					} else { // lefts
						if (obj.centerX > voidThresh) obj.mov(voidMove);
					}
				});
			}

			if (sp) {
				totalSpacing += spacing;
				averageSpacing = totalSpacing/(that.rows+1);
			}

			// VERTICAL
			if (vi=="center") {
				zim.loop(objects, function (obj) {
					obj.mov(0, (maxY-obj.wrapHeight)/2*(bottomFull?-1:1));
				});
			} else if (!bottomFull && vi=="bottom") {
				zim.loop(objects, function (obj) {
					obj.mov(0, (maxY-obj.wrapHeight)-(obj.marginBottom?obj.marginBottom:0));
				});
			} else if (bottomFull && vi=="top") {
				zim.loop(objects, function (obj) {
					obj.mov(0, -(maxY-obj.wrapHeight)+(obj.marginTop?obj.marginTop:0));
				});
			}

			fl = zim.Pick.choose(flip);

		} // end alignObjects

		
		this.setProps = function(props) {
			zim.setProps(this.items, props);
			return this;
		}
	

		Object.defineProperty(that, 'spacingH', {
			get: function() {
				return spacingH;
			},
			set: function(value) {
				spacingH = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'spacingV', {
			get: function() {
				return spacingV;
			},
			set: function(value) {
				spacingV = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'wrapperType', {
			get: function() {
				return wrapperType;
			},
			set: function(value) {
				if (value == "spread") spread = true;
				else spread = false;
				if (value == "stretch") stretch = true;
				else stretch = false;
				wrapperType = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'align', {
			get: function() {
				return align;
			},
			set: function(value) {
				align = value;
				if (align == "middle") align = "center";
				this.resize();
			}
		});
		Object.defineProperty(that, 'valign', {
			get: function() {
				return valign;
			},
			set: function(value) {
				valign = value;
				if (valign == "middle") valign = "center";
				this.resize();
			}
		});
		Object.defineProperty(that, 'alignInner', {
			get: function() {
				return alignInner;
			},
			set: function(value) {
				alignInner = value;
				if (alignInner == "middle") alignInner = "center";
				this.resize();
			}
		});
		Object.defineProperty(that, 'valignInner', {
			get: function() {
				return valignInner;
			},
			set: function(value) {
				valignInner = value;
				if (valignInner == "middle") valignInner = "center";
				this.resize();
			}
		});
		Object.defineProperty(that, 'colSize', {
			get: function() {
				return colSize;
			},
			set: function(value) {
				colSize = value;
				if (wrapperType == "column") this.resize();
			}
		});
		Object.defineProperty(that, 'rowSize', {
			get: function() {
				return rowSize;
			},
			set: function(value) {
				rowSize = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'flip', {
			get: function() {
				return flip;
			},
			set: function(value) {
				flip = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'reverse', {
			get: function() {
				return reverse;
			},
			set: function(value) {
				reverse = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'bottomFull', {
			get: function() {
				return bottomFull;
			},
			set: function(value) {
				bottomFull = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'percentVoidH', {
			get: function() {
				return percentVoidH;
			},
			set: function(value) {
				percentVoidH = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'offsetVoidH', {
			get: function() {
				return offsetVoidH;
			},
			set: function(value) {
				offsetVoidH = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'percentVoidV', {
			get: function() {
				return percentVoidV;
			},
			set: function(value) {
				percentVoidV = value;
				this.resize();
			}
		});
		Object.defineProperty(that, 'offsetVoidV', {
			get: function() {
				return offsetVoidV;
			},
			set: function(value) {
				offsetVoidV = value;
				this.resize();
			}
		});


		if (!zot(items)) that.add(items);

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.clone = function() {
			var r = that.cloneProps(new zim.Wrapper(items, width, spacingH, spacingV, wrapperType, align, valign, alignInner, valignInner, flip, reverse, bottomFull, colSize, rowSize, height, minSpreadNum, minStretchNum, percentVoidH, offsetVoidH, percentVoidV, offsetVoidV, minStretchFirst, this.style, this.group));
			return r;
		};
	};

	zim.extend(zim.Wrapper, zim.Container, "clone", "zimContainer", false);

    // LabelWords is declared above but needs the Wrapper to extend so move extend to here
    if (zim.LabelWords) zim.extend(zim.LabelWords, zim.Wrapper, "clone", "zimWrapper", false);

	//-78.5

/*--
zim.Tile = function(obj, cols, rows, spacingH, spacingV, unique, width, height, squeezeH, squeezeV, colSize, rowSize, align, valign, count, mirrorH, mirrorV, snapToPixel, clone, events, exact, scaleToH, scaleToV, scaleToType, backgroundColor, backgroundPadding, backgroundPaddingH, backgroundPaddingV, backing, backdropColor, backdropPadding, backdropPaddingH, backdropPaddingV, mat, style, group, inherit)

Tile
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Tile has two main uses:

1. ART
Creates a tile with an object for the columns and rows specified - a mirror effect is available too.
By default the object is cloned.
A ZIM VEE value can be passed to tile multiple types of objects

2. LAYOUT
Set the unique parameter to true to pass in an array of unique objects
** Pre ZIM Cat, a series() would be used with the count set if required and clone set to false to keep object events
Now this is handled by ZIM with the unique parameter, simplifying the process.
The array could be thumbnail pictures, interface bars, content sections on a page, etc.
Horizontal and vertical spacings can be set
Setting colSize and rowSize will override spacings and force grid dimensions
align and valign parameters can be used - or set with STYLE
setting a width or height will spread the items - and override the colSize and rowSize
In both dimensioned and non dimensioned modes,
the rows and columns can be squeezed together and aligned as a group
So a variety of layouts can be accommodated.

See: three videos on laying out with Tile 
https://www.youtube.com/watch?v=J1dwD_wd_-U - components - using unique parameter
https://www.youtube.com/watch?v=pjWxhqSSdww - custom widths - series
https://www.youtube.com/watch?v=-eSVkCOshE8 - leader board example

See: https://zimjs.com/tile.html for a dynamic example

NOTE: ZIM Layout() is also available to layout content that is scaled into regions

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circle = new Circle();
const tile = new Tile(circle, 20, 10).center();
END EXAMPLE

EXAMPLE
// tile 10 rectangles spaced out across the stage
const tile = new Tile({obj:new Rectangle(), cols:10, spacingH:30, width:W*.9}).center();
END EXAMPLE

EXAMPLE
// tile two rows with a Dial and a Slider in each
const tile = new Tile({
	obj:[new Dial(), new Slider(), new Dial(), new Slider()],
	unique:true, // as of ZIM Cat
	cols:2, rows:2,
	spacingH:30, spacingV:30,
	valign:CENTER
}).center();
// use tile.getChildAt(0) to access first Dial - or:
tile.items[0].on("change", ()=>{zog("changing dial 1")});
// See next example if events are already on items
END EXAMPLE 

EXAMPLE
// Like the previous example but with events specified before Tile is made
// Using the change() method which is chainable because it returns the object
// (Do not chain an on() method for the event as it does not return the object)
const d1 = new Dial().change(()=>{zog("changing dial 1")});
const d2 = new Dial();
const s1 = new Slider();
const s2 = new Slider();
const tile = new Tile({
	obj:[d1, s1, d2, s2],
	// with unique true, it uses objects in order 
	// without picking randomly and without cloning
	unique:true, 
	cols:2, rows:2,
	spacingH:30, spacingV:30,
	valign:CENTER
}).center();
// or after
s2.change(()=>{zog("changing slider 2")});
END EXAMPLE

EXAMPLE
STYLE = {
	background:{corner:20, borderColor:white},
	backdrop:{corner:{noPick:[20,20,0,0]}},
	Dial:{backgroundColor:white},
	Slider:{barColor:white, button:"pill"}
}
const d1 = new Dial().change(()=>{zog("changing dial 1")});
const d2 = new Dial();
const s1 = new Slider();
const s2 = new Slider();
const tile = new Tile({
	obj:[d1,s1,d2,s2],
	unique:true,
	scaleToH:80,
	scaleToV:60,
	cols:2, rows:2,
	spacingH:10, 
	spacingV:10,
	align:CENTER,
	valign:CENTER,
	backgroundColor:new GradientColor([pink,purple],45),
	backdropColor:interstellar,
	backdropPaddingH:30,
	backdropPaddingV:-20
}).center();
END EXAMPLE

EXAMPLE 
// set the regX and regY for every tile item be the center of the tile
const tile = new Tile(new Rectangle(10, 10, red), 20, 20, 5, 5).normalize("reg", CENTER).center();
// make the central tile items be bigger than the edges (by 1.5 times in center)
tile.loop(t=>{t.sca(1+t.ratio*.5);});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
	Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
obj - |ZIM VEE| (default new Circle()) the display object to tile
	note: put rotated objects in a container (unless rotated 180 degrees) and tile the container
	If obj is a String then the object will be turned into an asset(obj).centerReg({add:false}).clone() so a clone of the asset with id of obj.
	If the unique parameter is set then an array of objects can be used here (ZIM VEE will be turned off)
	If the obj is a ZIM VEE function (not array, object literal or series) then the Tile clone parameter will default to false
cols - (default 1 - if no cols and rows then 3) the columns to tile
rows - (default 1 - if no cols and rows then 3) the rows to tile
spacingH - (default 0 - if no cols and rows then 3) a spacing between columns - ignored if colSize is set
spacingV - (default 0 - if no cols and rows then 3) a spacing between rows - ignored if rowSize is set
unique - (default false) - set to true if tiling unique items like components with events set or objects with custom properties
	1. this will turn off ZIM VEE for the obj parameter which will accept an array of unique objects
	2. the count parameter will be set to the length of the array
	3. and the clone parameter will be set to false	
width - (default null) set to a width to spread items in rows evenly out to width (see resize() method)
	colSize and mirrorH are ignored if width is set
height - (default null) set to a height to spread items in columns evenly out to height (see resize() method)
	rowSize and mirrorV are ignored if height is set
squeezeH - (default false) how to handle positioning within rows
	when width is not set:
		false - will not compress tiles beyond max calculated width for column including spacingH
		true - will treat all rows independently and fill spaces - align will align rows to widest row
	when width is set:
		false - will not compress past longest row including spacingH
		true - will compress all rows - align will then align rows to widest row
		"full" - will continue to compress always keeping each row to the width (may cause overlap)
squeezeV - (default "none") how to handle positioning within columns
	when height is not set:
		false - will not compress tiles beyond max calculated height for column including spacingV
		true - will treat all columns independently and fill spaces - valign will align columns to highest row
	when height is set:
		false - will not compress past longest column including spacingV
		true - will compress all columns - valign will then align columns to longest column
		"full" - will continue to compress always keeping each column to the height
colSize - |ZIM VEE| (default item size) set to number to hard code column width (ignores spacing)
	ignored if width is set
	use a series(100, 200, 100, 400) to set specific sizes
	if using in STYLE then set delayPick:true as well
rowSize - |ZIM VEE| (default item size) set to number to hard code row height (ignores spacing)
	ignored if height is set
	use a series(100, 200, 100, 400) to set specific sizes
	if using in STYLE then set delayPick:true as well
align - |ZIM VEE (non-squeezed only)| (default LEFT) set to CENTER, MIDDLE, RIGHT
	this is a basic align and may not work with rotated objects
	add these to a container perhaps for best results
valign - |ZIM VEE (non-squeezed only)| (default TOP) set to CENTER, MIDDLE, "bottom"
count - (default cols*rows - obj array length if unique is true) optional total number of items to tile
	if count is set to 0 then count is ignored and a warning message is provided in console
mirrorH - (default false) flip alternating objects horizontally (works with top left registration point)
mirrorV - (default false) flip alternating objects vertically (works with top left registration point)
snapToPixel - (default true) sets the stage to snapToPixelEnabled and snaps to pixels to avoid small gaps when Tile is repositioned
clone - (default true - or false if unique is true or false if obj is ZIM VEE function) set to false to prevent Tile from cloning objects
	also see unique parameter
events - (default false) Boolean - set to true to receive change events from elements of Tile
	this allows using one change event (or change() method) for a set of components in the Tile
exact - (default false) Boolean - set to true to exactly clone the obj rather than let ZIM VEE Pick values activate
scaleToH - |ZIM VEE| (default null) set to scale item in percentX - see ZIM scaleTo() - also see scaleToType
scaleToV - |ZIM VEE| (default null) |ZIM VEE| set to scale item in percentY - see ZIM scaleTo() - also see scaleToType
scaleToType - |ZIM VEE| (default FIT if scaleToH or scaleToV) |ZIM VEE| type of scaleTo() used when scaleToH or scaleToV is provided
	this is applied once after Tile is made in a natural way - either making cols and row sizes based on items or colSize and rowSize
backgroundColor - |ZIM VEE| (default null) set this to add a background color (Rectangle) behind each item 
	the background rectangles are added first below all items then the items on top
	the backgrounds property will be an array of the background rectangles 
	the items property will hold the actual items - but watch when looping the tile itself it will be any backdropColorRect, backdropRect, backgrounds, backings then items
	** the background rectangles have their style turned off but styles can be applied to the group "background" 
	STYLE = {background:{corner:20, borderWidth:2, borderColor:purple}} will add only these styles to the backgrounds
backgroundPadding - (default 0) set the padding of the backgroundColor Rectangles - this will adjust the bounds of the Tile accordingly
backgroundPaddingH - (default backgroundPadding) set the horizontal padding of the backgroundColor Rectangles
backgroundPaddingV - (default backgroundPadding) set the vertical padding of the backgroundColor Rectangles
backing - |ZIM VEE| (default null) set this to clone a backing DisplayObject beneath all items
	backing objects are not scaled and are placed based on align and valign
	the backing objects are added as a set above the backgrounds (if there are backgrounds) and below the items
	the backing objects have style turned off during cloning so style the backing ahead of time if desired
	the backings property will be an array of backing objects 
	the items property will hold the actual items - but watch when looping the tile itself it will be any backdropColorRect, backdropRect, backgrounds, backings then items
backdropColor - (default null) will add a backdrop colored backdropColor underneath all tile objects
	the backdrop will affect the bounds of the tile
	** the backdrop will have its style turned off but style can be applied to the group "backdrop" 
	STYLE = {background:{corner:20, borderWidth:2, borderColor:purple}} will add only these styles to the backdrop
backdropPadding - (default spacingH) set the padding of the backdropColorRect - this will adjust the bounds of the Tile accordingly
backdropPaddingH - (default backdropPadding) set the horizontal padding of the backdropColorRect
backdropPaddingV - (default backdropPadding) set the vertical padding of the backdropColorRect
mat - (default null) a ZIM DisplayObject to be added above a backdrop and below any backgrounds, backings and items
	the alignment of this will always be centered - it can have scaleTo() applied and be moved afterwards
	the mat will not affect the bounds of the tile even if it is bigger than the tile
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
itemUnderPoint(x, y, ignoreSpacing) - gets the item under a global point - (within item's col and row dimensions)
	** will not work properly with squeeze and gets original items - so not items that are moved
	x and y are F.mouseX, F.mouseY for example.
	ignoreSpacing defaults to true and is a bigger selection space if there is spacing (can also be set to HORIZONTAL or VERTICAL to ignore only one direction)
setProps(properties) - sets provided properties (as {prop:val, prop:val}) for each item
	the values accept ZIM VEE - dynamic parameters - see ZIM Pick()
	returns object for chaining
remake(items) - pass in an array of items to tile - see items property for editing current list - returns tile for chaining
	can also change rows and cols and remake()
resize(width, height) - resize the tile with new width and/or height if the width and/or height parameters were set - returns tile for chaining
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy with properties such as x, y, etc. also copied
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if a Tile is made with new Circle(20,[blue,green])
	then its clone will have random blue or green circles that will differ from the original
	If exact is set to true then the clone will the same colors as the original
dispose() - removes listeners and deletes object

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
items - read only array of the original tile items - or use tile.getChildAt() or tile.loop(function (item) {})
items2D - read only array of rows each containing an array of colums of items
items2DCols - read only array of columns each containing array of rows of items
** the current properties work for equal column size and equal row size
** although the row and column size can be different
current ** - a read only array of the current order of tile items - if items have been scrambled
current2D ** - read only array the current order of rows each containing an array of colums of items
current2DCols ** - read only array the current order of columns each containing array of rows of items
tileNum - this property is added to each object in the tile to give its number in the tile
tileCol - this property is added to each object in the tile to give its column number in the tile
tileRow - this property is added to each object in the tile to give its row number in the tile
backgrounds - an array of ZIM Rectangle objects set by the backdroundColor parameter
backings - an array of DisplayObjects set by the backing parameter
backdrop - a ZIM Rectangle set by the backdropColor parameter 
mat - a DisplayObject set by the mat parameter
These properties can be changed by calling remake()
	items - an array of items the tile uses
		modify this and pass in to remake(items) to update the Tile with new items
		cannot modify count - count will become the length of the array passed to remake()
	cols - number of columns - can modify - need to call remake() to see changes
	rows - number of rows - can modify - need to call remake() to see changes
These properties can be changed by calling resize(width, height) - set width or height to 0 for no spreading
	spacingH - horizontal spacing - can modify - need to call resize() to see changes
	spacingV - vertical spacing - can modify - need to call resize() to see changes
	squeezeH - horizontal compression - can modify - need to call resize() to see changes
	squeezeV - vertical compression - can modify - need to call resize() to see changes
	align - (not with ZIM VEE) horizontal alignment - can modify - need to call resize() to see changes
	valign - (not with ZIM VEE) vertical alignment - can modify - need to call resize() to see changes
	mirrorH - horizontal mirroring - can modify - need to call resize() to see changes
	mirrorV - vertical mirroring - can modify - need to call resize() to see changes

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a change event if items inside tile dispatch a change event
the change event object has an item property (e.item)
that refers to the item that caused the change event - for instance a Slider, Dial, etc.
note: the item is not the event object target - as that is the tile

--*///+66.5
	zim.Tile = function(obj, cols, rows, spacingH, spacingV, unique, width, height, squeezeH, squeezeV, colSize, rowSize, align, valign, count, mirrorH, mirrorV, snapToPixel, clone, events, exact, scaleToH, scaleToV, scaleToType, backgroundColor, backgroundPadding, backgroundPaddingH, backgroundPaddingV, backing, backdropColor, backdropPadding, backdropPaddingH, backdropPaddingV, mat, style, group, inherit) {
		var sig = "obj, cols, rows, spacingH, spacingV, unique, width, height, squeezeH, squeezeV, colSize, rowSize, align, valign, count, mirrorH, mirrorV, snapToPixel, clone, events, exact, scaleToH, scaleToV, scaleToType, backgroundColor, backgroundPadding, backgroundPaddingH, backgroundPaddingV, backing, backdropColor, backdropPadding, backdropPaddingH, backdropPaddingV, mat, style, group, inherit";
		var duo; if (duo = zob(zim.Tile, arguments, sig, this)) return duo;
		z_d("66.5");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Tile";
	
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		if (zot(obj)) obj = DS.obj!=null?DS.obj:new zim.Circle();
		if (zot(cols)) cols = DS.cols!=null?DS.cols:1121;
		if (zot(rows)) rows = DS.rows!=null?DS.rows:1121;
		var defaultFlag;
		if (cols==1121 && rows==1121) cols = rows = defaultFlag = 3;
		else if (cols==1121) cols = 1;
		else if (rows==1121) rows = 1;
		if (zot(unique)) unique = DS.unique!=null?DS.unique:false;
		if (zot(width)) width = DS.width!=null?DS.width:null;
		if (zot(height)) height = DS.height!=null?DS.height:null;
		if (zot(colSize)) colSize = DS.colSize!=null?DS.colSize:null;
		if (zot(rowSize)) rowSize = DS.rowSize!=null?DS.rowSize:null;
		if (!zot(width)) colSize = null; // width and height override sizes
		if (!zot(height)) rowSize = null;

		if (zot(spacingH)) spacingH = DS.spacingH!=null?DS.spacingH:defaultFlag?3:null;
		if (zot(spacingV)) spacingV = DS.spacingV!=null?DS.spacingV:defaultFlag?3:null;
		var spacingHO = spacingH;
		var spacingVO = spacingV;
		if (zot(spacingH) || !zot(colSize) || !zot(width)) spacingH = 0; // sizes override spacing
		if (zot(spacingV) || !zot(rowSize) || !zot(height)) spacingV = 0;		
		if (zot(squeezeH)) squeezeH = DS.squeezeH!=null?DS.squeezeH:false;
		if (zot(squeezeV)) squeezeV = DS.squeezeV!=null?DS.squeezeV:false;
		if (zot(align)) align = DS.align!=null?DS.align:"left";
		if (zot(valign)) valign = DS.valign!=null?DS.valign:"top";
		if (zot(count)) count = DS.count!=null?DS.count:(unique&&Array.isArray(obj))?obj.length:null;
		if (count === 0) {count = null; if (zon) {zogy("ZIM Tile() - count parameter of 0 is ignored - see docs");}}
		if (zot(mirrorH)) mirrorH = DS.mirrorH!=null?DS.mirrorH:false;
		if (zot(mirrorV)) mirrorV = DS.mirrorV!=null?DS.mirrorV:false;
		if (zot(snapToPixel)) snapToPixel = DS.snapToPixel!=null?DS.snapToPixel:true;
		if (snapToPixel) {
			if (obj && obj.stage) obj.stage.snapToPixelEnabled = true;
			else if (typeof(elem) !== 'undefined' && WW.zdf) WW.zdf.stage.snapToPixelEnabled = true;
		}
		if (zot(clone)) clone = DS.clone!=null?DS.clone:unique?false:null;
		if (clone==null) clone = typeof(obj) === 'function' && obj.type != "series"?false:true; 
		if (zot(events)) events = DS.events!=null?DS.events:true;

		if (zot(scaleToH)) scaleToH = DS.scaleToH!=null?DS.scaleToH:null;
		if (zot(scaleToV)) scaleToV = DS.scaleToV!=null?DS.scaleToV:null;
		if (zot(scaleToType)) scaleToType = DS.scaleToType!=null?DS.scaleToType:null;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:null;
        if (zot(backgroundPadding)) backgroundPadding = DS.backgroundPadding!=null?DS.backgroundPadding:0;
		if (zot(backgroundPaddingH)) backgroundPaddingH = DS.backgroundPaddingH!=null?DS.backgroundPaddingH:!zot(backgroundColor)?backgroundPadding:0;
		if (zot(backgroundPaddingV)) backgroundPaddingV = DS.backgroundPaddingV!=null?DS.backgroundPaddingV:!zot(backgroundColor)?backgroundPadding:0;
		if (zot(backing)) backing = DS.backing!=null?DS.backing:null;
		if (zot(backdropColor)) backdropColor = DS.backdropColor!=null?DS.backdropColor:null;		
		if (zot(backdropPadding)) backdropPadding = DS.backdropPadding!=null?DS.backdropPadding:0;
		if (zot(backdropPaddingH)) backdropPaddingH = DS.backdropPaddingH!=null?DS.backdropPaddingH:!zot(backdropColor)?backdropPadding:0;
		if (zot(backdropPaddingV)) backdropPaddingV = DS.backdropPaddingV!=null?DS.backdropPaddingV:!zot(backdropColor)?backdropPadding:0;
		if (backdropPaddingV || backdropPaddingH) backdropPadding = true; // numbers only used from H and V values
		if (zot(mat)) mat = DS.mat!=null?DS.mat:false;

		var that = this;
		that.cols = cols = Math.round(cols);
		that.rows = rows = Math.round(rows);
		that.spacingH = spacingH;
		that.spacingV = spacingV;
		that.squeezeH = squeezeH;
		that.squeezeV = squeezeV;
		var VEEAlign = (typeof align=="function");
		var VEEVAlign = (typeof valign=="function");
		// these two are used only for not ZIM VEE - as there are VEE with Squeeze is not supported
		that.align = VEEAlign?"left":align;
		that.valign = VEEVAlign?"top":valign;
		that.mirrorH = mirrorH;
		that.mirrorV = mirrorV;

		// ~~~~~~~~~~~~~~~~~~~  GET ARRAY OF ITEMS  ~~~~~~~~~~~~~~~
		// this list could be edited later and passed back into remake()
		// so need to separate this part from the rest
		// also, need to record what was made with zik so resize does not change items
		that.items = [];
		var tile;
		var currentCount = 0;
		var ACCheck = false;
		outer:
		for (var j=0; j<rows; j++) {
			for (var i=0; i<cols; i++) {
				currentCount++;
				if (!zot(count) && currentCount > count) break outer;
				tile = unique?obj[currentCount-1]:zim.Pick.choose(obj);
				if (typeof tile == "string") tile = WW.asset(tile).centerReg({add:false}).clone();
				if (zot(tile)) {
					tile = new zim.Container(0,0,0,0);
				}
				// if (clone && !(j==0 && i==0)) tile = tile.clone();
				if (clone) {
					if ((j!=0 || i!=0)) tile = tile.clone(exact);
				}
				if (events) {
					tile.on("change", function (e) {
						var evt = new createjs.Event("change");
						evt.item = e.currentTarget;
						that.dispatchEvent(evt);
					});
				}
				that.items.push(tile);
				if (tile.type == "AC") ACCheck = true;
				tile.tileNum = currentCount-1;
				tile.tileCol = i;
				tile.tileRow = j;
			}			
		}
		if (ACCheck && zon) zogy("ZIM Tile - assets must have dimensions for Tile");

		// ~~~~~~~~~~~~~~~~~~~  ORIGINAL CALCULATIONS ~~~~~~~~~~~~~~~
		// collect col and row tile total sizes
		// with resize, we need to do this separately so zik is only run once

		var objects; // nested array of objects - recreated from linear items array
		var widthTotals; // for each row
		var heightTotals; // for each column
		var widthMax; // for each column
		var heightMax; // for each row
		var widthTotalMax; // for all columns
		var heightTotalMax; // for all rows
		var widthUncompressedMax; // for all columns uncompressed
		var heightUncompressedMax; // for all rows uncompressed
		var scalesX; // used for resizing mirror
		var scalesY;
		var rowCounts; // number of rows across columns
		var finalAlign; // so any zik col align is rememebered

		// remember any set widths and heights in case
		// zik is used for colSize and rowSize
		var widthHeights;

		function makeTile() {

			that.removeAllChildren();

			objects = []; // row arrays of picked objects in column
			widthTotals = []; // for each row
			heightTotals = []; // for each column
			widthMax = []; // for each column
			heightMax = []; // for each row
			widthTotalMax = 0; // for all columns
			heightTotalMax = 0; // for all rows
			widthUncompressedMax = 0; // for all columns uncompressed
			heightUncompressedMax = 0; // for all rows uncompressed
			scalesX = []; // used for resizing mirror
			scalesY = [];
			rowCounts = []; // number of rows across columns
			widthHeights = []; // width and heights per row per col [w,h]
			finalAlign = []; // remember horizontal aligns - vertical aligns are made in final loop

			if (!that.items || !that.items.length) that.items = [];
			count = that.items.length;
			var currentCount = 0;
			var tile;
			var i; var j=0; var k=0;
			var h; var w;
			for (i=0; i<count; i++) {
				j=Math.floor(i/that.cols);
				k=i%that.cols;
				if (zot(objects[j])) objects[j] = [];
				if (zot(that.items[i])) that.items[i] = new zim.Container(0,0,0,0);
				objects[j][k] = that.items[i];
			}
			that.rows = Math.max(1, objects.length);
			that.cols = Math.max(1, !zot(objects[0])?objects[0].length:0);

			outer2:
			for (j=0; j<that.rows; j++) {
				scalesX.push([]);
				scalesY.push([]);
				widthHeights.push([]);
				if (rowSize&&zot(height)) h = zim.Pick.choose(rowSize);
				for (i=0; i<that.cols; i++) {
					currentCount++;
					if (!zot(count) && currentCount > count) break outer2;
					tile = objects[j][i];
					tile.snapToPixel = snapToPixel;
					that.addChild(tile);

					scalesX[j].push(tile.scaleX);
					scalesY[j].push(tile.scaleY);
					if (colSize&&zot(width)) w = zim.Pick.choose(colSize);
					if (j==0) finalAlign.push(zim.Pick.choose(align));

					// needs projected width and height on the tile 
					var tB = tile.boundsToGlobal(null, null, null, that);
					if (!colSize||!zot(width)) w = Math.abs(tB.width);
					if (!rowSize||!zot(height)) h = Math.abs(tB.height);
					// if (!colSize||!zot(width)) w = Math.abs(tile.width);
					// if (!rowSize||!zot(height)) h = Math.abs(tile.height);

					widthHeights[j][i] = [w,h];
					if (zot(widthMax[i])) widthMax[i] = 0;
					if (zot(heightMax[j])) heightMax[j] = 0;
					if (w > widthMax[i]) widthMax[i] = w;
					if (h > heightMax[j]) heightMax[j] = h;
					if (zot(widthTotals[j])) widthTotals[j] = 0;
					if (zot(heightTotals[i])) heightTotals[i] = 0;
					widthTotals[j] += w;
					heightTotals[i] += h;
					if (widthTotals[j] > widthTotalMax) widthTotalMax = widthTotals[j];
					if (heightTotals[i] > heightTotalMax) heightTotalMax = heightTotals[i];
					if (zot(rowCounts[i])) rowCounts[i] = 0;
					rowCounts[i]++;
				}
			}
			var val;
			if (that.squeezeH === false) {
				for (i=0; i<widthMax.length; i++) {
					val = widthMax[i];
					widthUncompressedMax+=val;
				}
			}
			if (that.squeezeV === false) {
				for (i=0; i<heightMax.length; i++) {
					val = heightMax[i];
					heightUncompressedMax+=val;
				}
			}

		}
		makeTile();
		var widthO = widthUncompressedMax;
		var heightO = heightUncompressedMax;

		var overallWidth;
		var overallHeight;
		var rowTotals;
		var rowSpacings;
		var widthScaling = 1;
		var heightScaling = 1;		
		
		function resize(width, height) {

			if (that.normalized) that.resetOriginalReg();

			if (!zot(backdropColor) && backdropPadding) {
				width -= Math.max(backdropPaddingH*2, 0);
				height -= Math.max(backdropPaddingV*2, 0);
			}
			
			// ~~~~~~~~~~~~~~~~~~~  GET WIDTHS ~~~~~~~~~~~~~~~

			if (width <= 0) width = null;
			if (height <= 0) height = null;

			if (!zot(width)&&that.squeezeH=="full") {
				overallWidth = width;
			} else if (!zot(width)) {
				if (scaleToH) overallWidth = width;
				else overallWidth = Math.max(widthTotalMax+(that.cols-1)*that.spacingH, width);
			} else {
				if (widthUncompressedMax > 0) overallWidth = widthUncompressedMax+(that.cols-1)*that.spacingH;
				else overallWidth = widthTotalMax+(that.cols-1)*that.spacingH;
			}

			if (!zot(height)&&that.squeezeV=="full") {
				overallHeight = height;
			} else if (!zot(height)) {				
				if (scaleToV) overallHeight = height;
				else overallHeight = Math.max(heightTotalMax+(that.rows-1)*that.spacingV, height);
			} else {
				if (heightUncompressedMax > 0) overallHeight = heightUncompressedMax+(that.rows-1)*that.spacingV;
				else overallHeight = heightTotalMax+(that.rows-1)*that.spacingV;
			}

			that.setBounds(0,0,overallWidth,overallHeight);
			widthScaling = (overallWidth-(that.cols-1)*spacingHO)/(widthO);
			heightScaling = (overallHeight-(that.rows-1)*spacingVO)/(heightO);

			// ~~~~~~~~~~~~~~~~~~~  PLACEMENTS ~~~~~~~~~~~~~~~

			var rowObjects;
			var colTotal; // keep track of current x positions
			// loop order means we need to keep array data for y
			rowTotals = []; // keep track of current y positions
			rowSpacings = [];
			var rowTops = [];
			for (j=0; j<objects.length; j++) {
				rowObjects = objects[j];
				colTotal = 0;
				for (i=0; i<rowObjects.length; i++) {
					tile = rowObjects[i];
					var left;
					var spreadXspacing;
					if (j==0) {
						rowTotals[i] = 0;

						// ~~~~~~~~~~~~~~~~~~~  VERTICAL ALIGN ~~~~~~~~~~~~~~~

						if (!zot(height)) {
							if (that.squeezeV=="full") {
								rowSpacings[i] = rowCounts[i]>1?((height - heightTotals[i]) / (rowCounts[i]-1)):0;
							} else if (that.squeezeV) {
								rowSpacings[i] = rowCounts[i]>1?Math.max(that.spacingV, (height - heightTotals[i]) / (rowCounts[i]-1)):0;
							} else {
								rowSpacings[i] = rowCounts[i]>1?Math.max(that.spacingV, (overallHeight - heightTotals[i]) / (rowCounts[i]-1)):0;
							}
						}
						if (that.squeezeV) {
							// check for center or bottom valign of whole row
							if (that.valign=="center" || that.valign=="middle") {
								rowTops[i] = (overallHeight-(heightTotals[i]+(rowCounts[i]-1)*(!zot(height)?rowSpacings[i]:that.spacingV)))/2;
							} else if (that.valign=="bottom") {
								rowTops[i] = overallHeight-(heightTotals[i]+(rowCounts[i]-1)*(!zot(height)?rowSpacings[i]:that.spacingV));
							} else {
								rowTops[i] = 0;
							}
						} else {
							rowTops[i] = 0;
						}
					}

					if (i==0) {

						// ~~~~~~~~~~~~~~~~~~~  HORIZONTAL ALIGN ~~~~~~~~~~~~~~~

						if (!zot(width)) {
							if (that.squeezeH=="full") {
								spreadXspacing = rowObjects.length>1?((width - widthTotals[j]) / (rowObjects.length-1)):0;
							} else if (that.squeezeH) {
								spreadXspacing = rowObjects.length>1?Math.max(that.spacingH, (width - widthTotals[j]) / (rowObjects.length-1)):0;
							} else {
								spreadXspacing = rowObjects.length>1?Math.max(that.spacingH, (overallWidth - widthTotals[j]) / (rowObjects.length-1)):0;
							}
						}
						if (that.squeezeH) {
							// check for center or right align of whole row
							if (that.align=="center" || that.align=="middle") {
								left = (overallWidth-(widthTotals[j]+(rowObjects.length-1)*(!zot(width)?spreadXspacing:that.spacingH)))/2;
							} else if (that.align=="right") {
								left = overallWidth-(widthTotals[j]+(rowObjects.length-1)*(!zot(width)?spreadXspacing:that.spacingH));
							} else {
								left = 0;
							}
						} else {
							left = 0;
						}

						// squeeze does not work with ZIK - so this is for non-squeezed
						var finalVAlign = zim.Pick.choose(valign); // start of each row pick a valign
					}
					// squeeze does not work with ZIK - here is the recorded align for the current column
					align = finalAlign[i];

					var w = widthHeights[j][i][0];
					var h = widthHeights[j][i][1];

					if (that.mirrorH && i%2==1) {
						tile.scaleX = -scalesX[j][i];
						// tile.x = colTotal+w-b.x*2*tile.scaleX;
					} else {
						// tile.x = colTotal + (tile.regX-b.x);
					}
					tile.pos(colTotal, null);

					if (!that.squeezeH && VEEAlign) {
						if (zot(width) && (align=="center" || align=="middle")) {
							tile.x += (widthMax[i]-tile.width)/2;
						} else if (zot(width) && align=="right") {
							tile.x += widthMax[i]-tile.width;
						}
					} else if (!that.squeezeH) { // this allows for dynamic setting of align (for non-VEE, non squeezeH)
						if (zot(width) && (that.align=="center" || that.align=="middle")) {
							tile.x += (widthMax[i]-tile.width)/2;
						} else if (zot(width) && that.align=="right") {
							tile.x += widthMax[i]-tile.width;
						}
					} else {
						if (zot(width) && (that.align=="center" || that.align=="middle")) {
							tile.x += (w-tile.width)/2;
						} else if (zot(width) && that.align=="right") {
							tile.x += w-tile.width;
						}
					}
					if (that.mirrorV && j%2==1) {
						tile.scaleY = -scalesY[j][i];
						// tile.y = rowTotals[i]+h-b.y*2;
					} else {
						// tile.y = rowTotals[i] + tile.regY-b.y;
					}
					tile.pos(null,rowTotals[i]);
					if (!that.squeezeV && VEEVAlign) {
						if (zot(height) && (finalVAlign=="center" || finalVAlign=="middle")) {
							tile.y += (heightMax[j]-tile.height)/2;
						} else if (zot(height) && finalVAlign=="bottom") {
							tile.y += heightMax[j]-tile.height;
						}
					} else if (!that.squeezeV) { // this allows for dynamic setting of valign (for non-VEE, non squeezeV)
						if (zot(height) && (that.valign=="center" || that.valign=="middle")) {
							tile.y += (heightMax[j]-tile.height)/2;
						} else if (zot(height) && that.valign=="bottom") {
							tile.y += heightMax[j]-tile.height;
						}
					} else {
						if (zot(height) && (that.valign=="center" || that.valign=="middle")) {
							tile.y += (h-tile.height)/2;
						} else if (zot(height) && that.valign=="bottom") {
							tile.y += h-tile.height;
						}
					}

					if (that.squeezeH === true || !zot(width)) {
						colTotal += w+(!zot(width)?spreadXspacing:that.spacingH);
					} else {
						colTotal += widthMax[i]+(!zot(width)?spreadXspacing:that.spacingH);
					}

					tile.x += left;
					tile.y += rowTops[i];

					if (that.squeezeV === true || !zot(height)) {
						rowTotals[i] += h+(!zot(height)?rowSpacings[i]:that.spacingV);
					} else {
						rowTotals[i] += heightMax[j]+(!zot(height)?rowSpacings[i]:that.spacingV);
					}
				}
			}
			
			if (that.normalized) that.normalize();

		} // end resize

		resize(width, height);	

		this.setProps = function(props) {
			zim.setProps(this.items, props);
			return this;
		}
		
		this.itemUnderPoint = function(x, y, ignoreSpacing) {
			if (zot(ignoreSpacing)) ignoreSpacing = true;
			if (zot(x) || zot(y)) return;
			var point = that.globalToLocal(x, y);
			x = point.x;
			y = point.y;

			var wT = 0;
			var co = zim.loop(widthMax, function (w, i) {
				wT+=w+that.spacingH;
				if (!ignoreSpacing || ignoreSpacing == "vertical") {
					// test for in cracks
					if (x > wT-that.spacingH  && x < wT) return false;
				}
				if (x < wT-that.spacingH/2) return i;
			});
			if (co === false) return; // in crack
			if (co === true) co = cols-1;

			if (x < 0 || x > overallWidth || y < 0 || y > overallHeight) return;
			var hT = 0;
			var ro = zim.loop(heightMax, function (h, j) {
				var ss = !zot(height)?rowSpacings[i]:that.spacingV;
				if (!ignoreSpacing || ignoreSpacing == "horizontal") {
					// test for in cracks
					if (y > hT-ss  && y < hT) return false;
				}
				hT+=h+ss;
				if (y < hT-ss/2) return j;
			});
			if (ro === false) return; // in crack
			if (ro === true) ro = rows-1;

			return that.items2D[ro][co];
		};

		this.remake = function(items) {
			if (!zot(items)) that.items = items;
			makeTile();
			resize(width, height);
			makeAdditions(true);
			return that;
		};

		this.resize = function(w, h) {
			if (zot(w)) w = width;
			if (zot(h)) h = height;
			width = w;
			height = h;
			resize(w, h);
			makeAdditions(true);
			return that;
		};

		function get2D(array) {
			var nested = [];
			var inner;
			for (var i=0; i<array.length; i++) {
				if (i%that.cols==0) {
					inner = [];
					nested.push(inner);
				}
				inner.push(array[i]);
			}
			return nested;
		}

		function get2DCols(array) {
			var nested = [];
			var i;
			for (i=0; i<that.cols; i++) {
				nested.push([]);
			}
			for (i=0; i<array.length; i++) {
				nested[i%that.cols][Math.floor(i/that.cols)] = array[i];
			}
			return nested;
		}

		Object.defineProperty(this, "items2D", {
			get:function(){
				return get2D(that.items);
			},
			set:function() {
				if (zon) zogy("Tile() - items2D is read only");
			}
		});

		Object.defineProperty(this, "items2DCols", {
			get:function(){
				return get2DCols(that.items);
			},
			set:function() {
				if (zon) zogy("Tile() - items2DCols is read only");
			}
		});

		Object.defineProperty(this, "current", {
			get:function(){
				var items = [];
				// var tileWidth = (that.width - (that.cols-1)*that.spacingH) / that.cols;
				// var tileHeight = (that.height - (that.rows-1)*that.spacingV) / that.rows;

				// loop through tile locations and compile array of objects under point
				zim.loop(that.items, function (t) {
					// get index of middle of bounding box of item
					var b = t.getBounds();
					var x = t.x - t.regX + b.x + b.width / 2;
					var y = t.y - t.regY + b.y + b.height / 2;
					var index = that.hitTestGrid(that.width, that.height, that.cols, that.rows, x, y, null, null, that.spacingH, that.spacingV, true, "open");
					if (index != null) items[index[0]] = t;
				});
				// // slow with hundreds
				// for (var j=0; j<that.rows; j++) {
				// 	for (var i=0; i<that.cols; i++) {
				// 		var x = i*(that.spacingH + tileWidth)+tileWidth/2;
				// 		var y = j*(that.spacingV + tileHeight)+tileHeight/2;
				// 		var item = that.getObjectUnderPoint(x, y, 1);
				// 		items.push(item);
				// 	}
				// }
				return items;
			},
			set:function() {
				if (zon) zogy("Tile() - current is read only");
			}
		});

		Object.defineProperty(this, "current2D", {
			get:function(){
				return get2D(that.current);
			},
			set:function() {
				if (zon) zogy("Tile() - current2D is read only");
			}
		});

		Object.defineProperty(this, "current2DCols", {
			get:function(){
				return get2DCols(that.current);
			},
			set:function() {
				if (zon) zogy("Tile() - current2DCols is read only");
			}
		});

		// ZIM 015 CHANGES 
		// scaleToH, scaleToV, scaleToType, 
		// backgroundColor, backing, 
		// backdropColor, backdropPadding, backdropPaddingH, backdropPaddingV, 
		// mat	
		
		var backgrounds;
		var backings;
		var backgroundColors;
		var backdrop;
		var backgroundScaleX;
		var backgroundScaleY;

		function makeAdditions(resize) {

			// if resize is true it keeps the existing backgrounds, backings, backdrop and mat 
			// it uses the values from the first zik so they do not change as being resized

			if (resize) {
				// probably okay if leaving these but just in case...
				if (backdrop) backdrop.removeFrom();
				if (mat) mat.removeFrom();
				// should be okay with keeping backings and backgrounds 
				// they will have levels recycled
			}

			if (!zot(backgroundColor) || backing || scaleToH || scaleToV) {
				if (!resize && (scaleToH || scaleToV)) {
					backgroundScaleX = [];
					backgroundScaleY = [];
				}
				if (!resize || zot(backgroundColor)) backgrounds = []; // used regardless
				if (!resize && !zot(backgroundColor)) backgroundColors = [];
				if (!resize && backing) backings = [];

				var lastX = (colSize?spacingHO:0)/2;
				var lastY = (rowSize?spacingVO:0)/2;
				var rect;
				var cou = 0;
				zim.loop(that.items2D, function(c, j) {
					zim.loop(c, function(item, i){	
						var color = black;
						if (!zot(backgroundColor)) {
							if (resize && !zot(backgroundColor)) {
								color = backgroundColors[cou];                               
								rect = backgrounds[cou]
									.siz(widthMax[i]*widthScaling-(colSize?spacingHO:0)+backgroundPaddingH*2, heightMax[j]*heightScaling-(rowSize?spacingVO:0)+backgroundPaddingV*2)
									.loc(lastX, lastY, that, 0);
							} else {
								color = zik(backgroundColor);
								backgroundColors.push(backgroundColor);	
								rect = new zim.Rectangle({
									width:widthMax[i]*widthScaling-(colSize?spacingHO:0)+backgroundPaddingH*2, 
									height:heightMax[j]*heightScaling-(rowSize?spacingVO:0)+backgroundPaddingV*2, 
									color:color,
									style:false,
									scaleDimensions:false,
									strokeObj:{ignoreScale:true},
									group:"background"
								})
									.loc(lastX, lastY, that, 0)
								backgrounds.push(rect);
							}
							item.pos(0,0,align,valign,rect).addTo(that);
						}			
						
						lastX = rect.x + rect.width + spacingHO;					
						if (scaleToH || scaleToV) {	
							var sX;
							var sY;
							if (resize) {
								sX = backgroundScaleX[cou];
								sY = backgroundScaleY[cou];
							} else {	
								var sX = zik(scaleToH)||100;
								var sY = zik(scaleToV)||100;
								backgroundScaleX.push(sX);	
								backgroundScaleY.push(sY);	
							}
							item.scaleTo(rect, sX, sY, scaleToType).pos(0,0,align,valign,rect).addTo(that);						
						}
						if (backing) {
							var ba;
							if (resize) ba = backings[cou];
							else ba = zik(backing).clone(null, false);
							backings.push(ba);
							ba.pos(0,0,align,valign,rect).addTo(that);
						}
						cou++;
					});
					lastX = (colSize?spacingHO:0)/2;
					lastY += rect.height + spacingVO;
				});
				if (backing && !zot(backgroundColor)) {
					zim.loop(backings, function(bbb) {
						bbb.addTo(that, backgrounds.length) // add after backgrounds
					}, true); // backwards
				}
				if (zot(backgroundColor)) {
					zim.loop(backgrounds, function(background) {
						background.dispose();
					}, true); // backwards
					backgrounds = null;
					backgroundColors = null;
				} else {
					that.backgrounds = backgrounds;
					that.backgroundColors = backgroundColors;
				}

				if (!zot(backgroundColor) && (colSize || rowSize)) {
					that.loop(function(item) {
						item.mov(colSize?-spacingHO/2:0, rowSize?-spacingVO/2:0);					
					});
					var bb = that.getBounds();
					that.setBounds(bb.x, bb.y, bb.width-(colSize?spacingHO:0)*cols, bb.height-(rowSize?spacingVO:0)*rows)
					bb = that.getBounds();
				}
				if (backing) that.backings = backings;
				
			}
			
			// add backdrop

			if (mat) {
				that.mat = mat;
				mat.center(that,0);
			}

			// add backdropColor 
			if (backdropColor) {
				var bb = that.getBounds();
				backdrop = that.backdrop = new zim.Rectangle({
					width:bb.width+backdropPaddingH*2, 
					height:bb.height+backdropPaddingV*2, 
					color:backdropColor,
					style:false,
					group:"backdrop"
				});
				backdrop.center(that,0);
				that.loop(function(item) {
					item.mov(Math.max(0,backdropPaddingH), Math.max(backdropPaddingV,0));					
				});	
				that.setBounds(0,0,bb.width+Math.max(0,backdropPaddingH)*2,bb.height+Math.max(backdropPaddingV,0)*2);
			}

		}
		makeAdditions();



		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.clone = function(exact) {
			if (zot(exact) && unique) exact = true; // added ZIM 016
			if (exact) {
				var exactItems = [];
				if (backgroundColor) var exactBackgroundColors = [];
				if (backing) var exactBackings = [];
				for (var i=0; i<that.items.length; i++) {
					exactItems.push(that.items[i].clone(true));
					if (backgroundColor) exactBackgroundColors.push(backgroundColors[i]);
					if (backing) exactBackings.push(backings[i].clone(true));
				}
			}			
			return that.cloneProps(new zim.Tile(exact&&exactItems?zim.series(exactItems):(obj.clone?obj.clone():obj), that.cols, that.rows, that.spacingH, that.spacingV, exact?false:unique, width, height, that.squeezeH, that.squeezeV, colSize, rowSize, align, valign, that.items.length, that.mirrorH, that.mirrorV, snapToPixel, exact?false:clone, events, exact, scaleToH, scaleToV, scaleToType, exact&&exactBackgroundColors?zim.series(exactBackgroundColors):backgroundColor, backgroundPadding, backgroundPaddingH, backgroundPaddingV, exact&&exactBackings?zim.series(exactBackings):(backing&&backing.clone)?backing.clone():backing, backdropColor, backdropPadding, backdropPaddingH, backdropPaddingV, (mat&&mat.clone)?mat.clone():mat, this.style, this.group));
		};
	};
	zim.extend(zim.Tile, zim.Container, "clone", "zimContainer", false);
	//-66.5

/*--
zim.Pack = function(width, height, items, spacingH, spacingV, flatten, direction, lock, backgroundColor, align, valign, lastAlign, paddingH, paddingV, dragOrder, dragColor, dragThickness, dragDashed, reverse, funnel, showPacking, order, container, style, group, inherit)

Pack
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Pack scales objects so they are packed within a width and height.
This means that some objects will scale more than others.
Pack works with the rectangular bounds of the objects.
The Pack will most likely not fit exactly in the dimensions provided
but it can be aligned or valigned within the dimensions and padding and backgroundColor set.
The dragOrder parameter can be set to true to allow objects to be sorted.
And the pack can be added to a TransformManager to remember the order on refresh.
There are lots of subtle options with the main ones described below:

FLATTEN 
If flatten is true (default) then Pack will integrate any trailing items so the Pack is completely rectangular.
It may integrate at the start (default) or at the end - and it does so in two rows (or columns) to minify the effect.
The effect will be that these two rows or columns will have somewhat bigger items. 
If flatten is false then the left over items can be aligned with lastAlign.
Note that align and valign is for the placements of the whole pack in the dimensions provided.

DIRECTION 
Direction HORIZONTAL (default) will order the items horizontally to fill a row then go to the next row (like a Tile).
This will leave horizontal seams but will not necessarily fill the horizontal space - see LOCK below.
Direction VERTICAL will order the items vertically along rows and when the column is done then go to the next column.
This will leave vertical seams but will not necessarily fill the vertical space - see LOCK below.
There is also a reverse parameter that will order these in the opposite direction (right to left or bottom to top).  

LOCK 
Lock HORIZONTAL will make the pack fit to the side edges - probably leaving a gap in the vertical.
Lock VERTICAL will make the pack fit to the vertical top and bottom - probably leaving a gap in the horizontal.
Lock can be set to AUTO to pick the best fit between these based on the largest area of the pack.

ORDER 
There is a dragOrder parameter (default false) that can be set to true to let users drag items to change the order.
This will repack each time.  There are also getOrder() and setOrder() methods to record the order 
and pass it back in to the order parameter of Pack.
This allows the app/content creators to try out different views and choose one.
The pack can also be passed into a ZIM TransformManager() along with a persist ID to let users save their order.

See: https://zimjs.com/zim/pack.html - pictures and saving
See: https://zimjs.com/zim/pack2.html - in a resizeable window

NOTE: ZIM Tile() has squeeze which can squeeze the items in horizontally or vertically.
ZIM Wrapper() will wrap items to fit best in rows or columns 
but both of these will not scale its items and the results will be ragged edges.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Pack(rand(200,600), rand(200,600)).center(); // packs three default rectangles
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default 500) the outer width of the pack object which will define the backgroundColor and enclose the content
	use the outerWidth property to change once the pack is made as the width property will just scale the pack.
height - (default 500) the outer height of the pack object which will define the backgroundColor and enclose the content
	use the outerHeight property to change once the pack is made as the width property will just scale the pack.
items - (default three colored Rectangles) set to an array of items to pack - can be pictures or any DisplayObject - even interactive
	the items property will reference this array as originally ordered (plus any items added or removed with addAt() or removeAt()) 
	there is also a currentItems property that has the same items but in the latest order based on dragOrder or the order property
spacingH - (default 10) set the horizontal spacing between the items - this is almost exact but may be a little less if direction horizontal and lock is vertical
spacingV - (default 10) set the vertical spacing between the items - this is amost exact but may be a little less if direction vertical and lock horizontal
flatten - (default true) merge any left-over items into the previous two rows to make the end flat 
direction - (default HORIZONTAL) order the items horizontally or vertically - this will create seams in the chosen direction
lock - (default AUTO) set to VERTICAL to fit content from top to bottom (less padding) or HORIZONTAL to fit content to sides (less padding)
	set to AUTO to pick the direction that gives the largest content area.
	note: that this setting is independent of the direction
	the pack may not fit perfectly in the dimensions provided (probably not) so this setting specifies which side to lock to 
	the align and valign parameters then can be used to align the content in the provided width and height
backgroundColor - (default clear) set this to show a background rectangle behind the content dimensioned to the width and height
align - (default CENTER) horizontal alignment of the content in the provided dimensions - if lock is vertical (also LEFT and RIGHT)
valign - (default CENTER) vertical alignment of the content in the provided dimensions - if lock is horizontal (also TOP and BOTTOM)
lastAlign - (default LEFT/TOP) if flatten is false the the alignment of the left over items
	use LEFT, CENTER, RIGHT for direction HORIZONTAL or TOP, CENTER, BOTTOM for direction VERTICAL
paddingH - (default 0) the horizontal space between the outer dimension and the content
paddingV - (default 0) the vertical space between the outer dimension and the content
dragOrder - (default false) set to true to let users (or authors) drag the items to new positions
	this will re-pack the pack and possibly shift items to new columns or rows or even shift lock orientation if lock is AUTO
dragColor - (default white) the color of the ghost rectangle and beacon diamond - also see ghost and beacon properties
dragThickness - (default 2) the thickness of the ghost and beacon
dragDashed - (default true) the dashed of the ghost
reverse - (default false) set to true to reverse the pack order
funnel - (default false) set to true to add fewer items to the edges causing a larger to smaller look when flatten is true
showPacking - (default false) set to true to show packing steps at an interval of 1 second - for interest only
order - (default null) set to an array of order data - see getOrder() get the array after dragging and setOrder() to dynamically set an order 
	the format is [index, index, index, etc.] for each item where index is the new desired index for each original item
	also see TransformManager(pack, "id") to automatically save the current order and remake the pack in the last order on refresh
container - (default stage) a container that holds the Pack - just used to place the beacon in the container
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
getOrder(popup) - get the current order of the pack if dragOrder is set to true - pass in true to see order in a ZIM Pane 
	this can then be copied and pasted into the Pack() order parameter to start the pack at the desired order 
setOrder(order) - pass in an array of desired order - see the Pack() order parameter for more info - returns the object for chaining
addAt(items, index) - pass a single or an array of items to add to the pack at the provided index (or at the end if no index) - returns the object for chaining
removeAt(number, index) - remove the specified number of items at the provided index (or at the end if no index) - returns the object for chaining
clone() - make a copy of the pack 
dispose() - removes listeners and deletes object

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
items - get the original items array passed to the pack (including addAt() and removeFrom() changes)
currentItems - get the array of items in the current order (this may be different if dragOrder is true)
cols - get the current number of columns 
rows - get the current number of rows
iterations - get the number of times the pack was made to optimize its size
flatten - get or set the flatten - see the Pack() flatten parameter
direction - get or set the direction - see the Pack() direction parameter
lock - get or set the lock - see the Pack() lock parameter
order - get or set the current order of the pack - also see getOrder() and setOrder()
dragOrder - get or set whether the items can be dragged to new positions 
outerWidth - remake the pack at this width - note: width just scales the pack like any DisplayObject
outerHeight - remake the pack at this height - note: width just scales the pack like any DisplayObject
spacing - get or set the spacing - will do both horizontal and vertical 
backing - a reference to the ZIM Rectangle used for the backgroundColor
ghost - a reference to the ZIM Rectangle if dragOrder is true that is used to show dragging
beacon - a reference to the ZIM Rectangle (at 45 rotation) if dragOrder is true that is used to show the inser point
ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a change event if items are re-ordered

--*///+66.55
zim.Pack = function(width, height, items, spacingH, spacingV, flatten, direction, lock, backgroundColor, align, valign, lastAlign, paddingH, paddingV, dragOrder, dragColor, dragThickness, dragDashed, reverse, funnel, showPacking, order, container, style, group, inherit) {
	var sig = "width, height, items, spacingH, spacingV, flatten, direction, lock, backgroundColor, align, valign, lastAlign, paddingH, paddingV, dragOrder, dragColor, dragThickness, dragDashed, reverse, funnel, showPacking, order, container, style, group, inherit";
	var duo; if (duo = zob(zim.Pack, arguments, sig, this)) return duo;
	z_d("66.52");	
		
	this.group = group;
	var DS = style===false?{}:zim.getStyle("Pack", this.group, inherit);
	if (zot(width)) width = DS.width!=null?DS.width:500;
	if (zot(height)) height = DS.height!=null?DS.height:500;

	this.zimContainer_constructor(width, height);
	this.type = "Pack";

	if (zot(items)) items = DS.items!=null?DS.items:[new zim.Rectangle(400,300, zim.orange), new zim.Rectangle(400,200, zim.purple), new zim.Rectangle(500,300, zim.blue)];
	if (zot(spacingH)) spacingH = DS.spacingH!=null?DS.spacingH:10;
	if (zot(spacingV)) spacingV = DS.spacingV!=null?DS.spacingV:10;
	if (zot(flatten)) flatten = DS.flatten!=null?DS.flatten:"top";
	if (zot(direction)) direction = DS.direction!=null?DS.direction:"horizontal";
	if (zot(lock)) lock = DS.lock!=null?DS.lock:"auto";
	if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.clear;
	if (zot(align)) align = DS.align!=null?DS.align:"center";
	if (zot(valign)) valign = DS.valign!=null?DS.valign:"center";
	if (zot(lastAlign)) lastAlign = DS.lastAlign!=null?DS.lastAlign:direction=="horizontal"?"left":"top";
	if (zot(paddingH)) paddingH = DS.paddingH!=null?DS.paddingH:0;
	if (zot(paddingV)) paddingV = DS.paddingV!=null?DS.paddingV:0;
	if (zot(dragOrder)) dragOrder = DS.dragOrder!=null?DS.dragOrder:false;
	if (zot(dragColor)) dragColor = DS.dragColor!=null?DS.dragColor:zim.white;
	if (zot(dragThickness)) dragThickness = DS.dragThickness!=null?DS.dragThickness:2;
	if (zot(dragDashed)) dragDashed = DS.dragDashed!=null?DS.dragDashed:true;
	if (zot(reverse)) reverse = DS.reverse!=null?DS.reverse:false;
	if (zot(funnel)) funnel = DS.funnel!=null?DS.funnel:false;
	if (zot(showPacking)) showPacking = DS.showPacking!=null?DS.showPacking:false; 
	if (zot(order)) order = DS.order!=null?DS.order:null; 
	
	var that = this;
	that.funnel = funnel;

	var num = items.length;
	var desiredW = width-paddingH*2;
	var desiredH = height-paddingV*2;
	var sampleSize = 50;
	if (flatten===false) flatten = NONE;

	var backing = this.backing = new Rectangle({width:width, height:height, color:backgroundColor, scaleDimensions:false}).addTo(this);
	
	that.items = zim.copy(items); // shallow copy - so just the order, not a clone

	// handle small packs 0 and 1 items
	if (items.length <= 0) return this;
	if (items.length == 1) {            
		scalePack(items[0]);
		placePack(items[0]);
		return this;
	}        
			
	var sortFunction = function(obj1, obj2, options) {            
		if (obj1.width > obj2.width) {return 1;}
		if (obj1.width < obj2.width) {return -1;}
		return 0;
	}
	function scalePack(obj) {
		obj.scaleTo(backing,100-paddingH/desiredW*100*2,100-paddingV/desiredH*100*2);
		obj.scale*=that.scale;
		if (obj.scale < 0) obj.scale=.05;
	}
	function placePack(obj) {
		obj.pos(align!=CENTER&&align!=MIDDLE?paddingH:0,valign!=CENTER&&valign!=MIDDLE?paddingV:0,align,valign,backing).addTo(that);
	}
	function applyOrder(order) {
		var newOrder = [];
		zim.loop(order, function(index, i) {
			newOrder[i] = that.items[index];                
		});        
		// when coming from a TransformManager persist... some items may be undefined   
		items = [];
		zim.loop(newOrder, function(item){
			if (item) items.push(item);
		});
	}

	var pack = that.content = new zim.Container();
	var cols;
	var rows;
	var cols2;
	var rows2;
	var lastNum;
	var lastLastNum;        
	var totalCount; 
	var lastArea;
	var prevLastArea;
	var lastC;
	var prevLastC;
	var lastR;
	var prevLastR;
	var timeID;

	zim.loop(items, function(item, i) {
		item.zpRotation = item.rotation;
		item.zpIndex = i;
	});

	if (order) applyOrder(order);

	if (direction==VERTICAL) swapDirection(true);

	// rather than do the algorithm twice on direction horizontal or vertical 
	// we rotate each item put it in a container and tile it as if it is horizontal 
	// then after we rotate the whole pack and pull the items out of their containers 
	function swapDirection(toVertical) {

		pack.rotation = 0;
				
		var widthT = height; // could use ES6
		height = width;
		width = widthT;

		var desiredWT = desiredH; 
		desiredH = desiredW;
		desiredW = desiredWT;

		var spacingHT = spacingV; 
		spacingV = spacingH;
		spacingH = spacingHT;

		var paddingHT = paddingV;
		paddingV = paddingH;
		paddingH = paddingHT;
		
		if (flatten==RIGHT) flatten = BOTTOM;
		else if (flatten!=CENTER && flatten!=NONE) flatten = TOP;
		
		if (lastAlign==BOTTOM) lastAlign = LEFT; // will be bottom
		else if (lastAlign != CENTER && lastAlign != MIDDLE) lastAlign = RIGHT; // will be top

		backing.dispose(); 
		backing = new Rectangle(width, height, backgroundColor).center(that); // already switched width and height

		if (toVertical) { // flipping to right   
			if (lock==HORIZONTAL) lock=VERTICAL;
			else if (lock==VERTICAL) lock=HORIZONTAL;
			zim.loop(items, function(item,i) {
				var holder = new zim.Container(item.height, item.width);
				item.rotation+=90;
				item.pos(0,0,TOP,LEFT,holder);
				items[i] = holder;
			});
		} else { // flipping back to left  
			if (lock==HORIZONTAL) lock=VERTICAL;
			else if (lock==VERTICAL) lock=HORIZONTAL;
			pack.rotation-=90;
			zim.loop(items, function(item, i) {
				var holder = item;
				var it = item.getChildAt(0).addTo(pack).sca(holder.scale);
				holder.dispose();
				items[i] = it;
			});
		}
	}

	var originalLock = lock;        
	function doPack(items) {
		if (lock==AUTO) lock = HORIZONTAL;
		cols = Math.ceil(Math.sqrt(num));
		rows = Math.ceil(num/cols);
		lastNum = null;
		lastLastNum = null;        
		totalCount = 0; 
		timeID = null;
		lastArea = 0;
		prevLastArea = 0;
		lastC = null;
		prevLastC = null;
		lastR = null;
		prevLastR = null;
		process(items, cols, rows);
		doIteration(pack, cols, rows);
	}

	doPack(items);        
	finalPlacement();
	
	function finalPlacement() {

		scalePack(pack);
		placePack(pack);  

		if (flatten==NONE) {            
			zim.loop(items, function(item) {
				if (item.surrogate) {
					items.splice(items.indexOf(item),1);
					item.dispose();
				} else {
					item.bot(); // manage levels
				}
			}, true);

			// HANDLE LEFTOVER
			var leftover = rows*cols-num;
			if (flatten == NONE && leftover > 0) {
				var pa = pack.getChildAt(pack.numChildren-1);
				// horizontal are not in ready made containers so their registration can be off
				if (direction == HORIZONTAL && !reverse && lastAlign != LEFT) {                    
					var dist = pack.getBounds().width-(pa.x+(pa.getBounds().x-pa.regX)*pa.scaleX + pa.width); 
					zim.loop(cols-leftover, function(i) {
						pack.getChildAt(pack.numChildren-i-1).mov(lastAlign==RIGHT?dist:dist/2);       
					});           
				} else if (direction == HORIZONTAL && reverse && lastAlign != RIGHT) {
					var dist = pa.x+(pa.getBounds().x-pa.regX)*pa.scaleX;
					zim.loop(cols-leftover, function(i) {
						pack.getChildAt(pack.numChildren-i-1).mov(lastAlign==LEFT?-dist:-dist/2);       
					});                    
				// verticals are in containers with known registration
				} else if (direction == VERTICAL && !reverse && lastAlign != RIGHT) {   
					var dist = pa.x;
					zim.loop(cols-leftover, function(i) {
						pack.getChildAt(pack.numChildren-i-1).mov(lastAlign==LEFT?-dist:-dist/2);       
					});                             
				} else if (direction == VERTICAL && reverse && lastAlign != LEFT) {
					var dist = pack.getBounds().width-pa.x;
					zim.loop(cols-leftover, function(i) {
						pack.getChildAt(pack.numChildren-i-1).mov(lastAlign==RIGHT?dist:dist/2);       
					});  
				}
			}
		} 

		// handle rotations back for vertical
		if (direction==VERTICAL) {
			swapDirection(false);
			scalePack(pack); 
			placePack(pack);
		}

		that.cols = cols;
		that.rows = rows;
		that.iterations = totalCount-2; // as it goes too far then back
		that.currentItems = items;

		that.dispatchEvent("change");
	} // end finalPlacement

	// DRAG ORDER
	var beacon;
	var ghost;
	var bw;
	if (dragOrder) that.added(dragOrderOn);        
	function dragOrderOn() {
		dragOrderOff();
		bw = Math.min(30, (direction==HORIZONTAL?pack.height/rows/3*that.scale*pack.scale:pack.width/cols/3*that.scale*pack.scale));
		if (!beacon) {
			beacon = that.beacon = new zim.Rectangle({
				width:bw,
				height:bw,
				borderColor:dragColor,
				borderWidth:dragThickness,
				scaleDimensions:false
			}).reg(CENTER).rot(45); 
		} else {
			beacon.siz(bw,bw).reg(CENTER);
		}
		if (!ghost) ghost = that.ghost = new zim.Rectangle({
			width:100, 
			height:100, 
			borderColor:dragColor, 
			borderWidth:dragThickness, 
			dashed:dragDashed,
			scaleDimensions:false
		}).reg(CENTER);
		var targetIndex;
		var downIndex;
		var downItem;
		var pb;      
	
		that.mdEvent = that.on("mousedown", function(e) {
			downItem = e.target;
			beacon.top();
			targetIndex = null;
			if (items.indexOf(downItem) < 0) return; // spacing or background selected
			pb = that.localToGlobal(that.getBounds().x, that.getBounds().y);
			var b = downItem.boundsToGlobal();
			that.ghost.siz(b.width, b.height).reg(CENTER).loc(b.x+ghost.width/2, b.y+ghost.height/2, container||that.stage);
			ghost.diffX = that.stage.frame.mouseX-ghost.x;
			ghost.diffY = that.stage.frame.mouseY-ghost.y;
			downIndex = pack.getChildIndex(downItem);
			that.stage.update();
		});
	
		that.pmEvent = that.on("pressmove", function() {
			if (!ghost.parent) return;
			var f = that.stage.frame;
			ghost.loc(f.mouseX-ghost.diffX, f.mouseY-ghost.diffY, container||that.stage);
			var target = that.getObjectUnderPoint((ghost.x-pb.x)/that.scaleX, (ghost.y-pb.y)/that.scaleY, 1);
			if (items.indexOf(target) >= 0) {
				var b = target.boundsToGlobal();
				// new Rectangle(b.width,b.height,red).loc(b)
				if (direction==HORIZONTAL) {
					// horizontal spacing may be off as estimated width is set to actual width when calculating 
					if (ghost.x >= b.x+b.width/2) {
						beacon.loc(b.x+b.width+spacingH/2*that.scaleX*pack.scaleX, b.y+b.height/2, container||that.stage);
						targetIndex = pack.getChildIndex(target)+(reverse?0:1);
					} else {   
						beacon.loc(b.x-spacingH/2*that.scaleX*pack.scaleX, b.y+b.height/2, container||that.stage);   
						targetIndex = pack.getChildIndex(target)+(reverse?1:0);    
					}                              
				} else {
					// vertical spacing is not affected and then it gets rotated to horizontal so no adjustment
					if (ghost.y >= b.y+b.height/2) {
						beacon.loc(b.x+b.width/2, b.y+b.height+spacingV/2, container||that.stage);
						targetIndex = pack.getChildIndex(target)+(reverse?0:1);
					} else {
						beacon.loc(b.x+b.width/2, b.y-spacingV/2, container||that.stage);
						targetIndex = pack.getChildIndex(target)+(reverse?1:0);    
					}
				}                 
			}                 
			that.stage.update();          
		});

		that.puEvent = that.on("pressup", function() {
			if (!ghost.parent) return;
			if (targetIndex != null) {
				if (targetIndex>downIndex) targetIndex--;
				if (targetIndex!=downIndex) {
					downItem.level = targetIndex;
					items = [];
					pack.loop(function(item,i){
						items.push(item.rot(item.zpRotation||0).sca(1));
					});
					lock = originalLock;
					if (direction==VERTICAL) swapDirection(true);
					doPack(items);
					finalPlacement();                    
				}
			}
			ghost.removeFrom();
			beacon.removeFrom();
			that.stage.update();
		});
	}
	function dragOrderOff() {
		if (that.mdEvent) that.off("mousedown", that.mdEvent);  
		if (that.pmEvent) that.off("pressmove", that.pmEvent);
		if (that.puEvent) that.off("pressup", that.puEvent);
		if (beacon) beacon.removeFrom();
		if (ghost) ghost.removeFrom();
	}

	// SEARCH TO GET SIZE THAT FITS
	// starts in middle tests fit and changes columns towards better direction
	function doIteration(pack, c, r) {
		pack.scale = 1;
		if (totalCount++ > 20) {
			if (timeID) timeID.clear();
			return;
		}
		var end = false;
		if (pack.height > desiredH) {
			cols2 = c+1;
			rows2 = Math.ceil(num/cols2);  
			if (c == lastLastNum && lock == VERTICAL) {
				if (prevLastArea > lastArea) {
					cols2 = prevLastC;
					rows2 = prevLastR;
					end = true;
				} else {
					return pack;
				} 
			}
		} else if (pack.height <= desiredH) {
			cols2 = Math.max(c-1, 1);
			rows2 = Math.ceil(num/cols2);
			if (c == lastLastNum && lock == HORIZONTAL) {
				if (prevLastArea > lastArea) {
					cols2 = prevLastC;
					rows2 = prevLastR;
					end = true;
				} else {
					return pack;
				} 
			}
		}         
		
		lastLastNum = lastNum;
		lastNum = cols; 
		cols = cols2;
		rows = rows2;               

		zim.loop(items, function(block) {
			if (flatten==NONE && block.surrogate) {
				items.splice(items.indexOf(block),1);
				block.dispose();
			} else block.siz(null,desiredH);
		}, true);

		process(items, cols, rows);  

		prevLastArea = lastArea;
		prevLastC = lastC;
		prevLastR = lastR;

		if (
			originalLock==AUTO 
			|| (lock==HORIZONTAL&&Math.round(pack.width)==desiredW) 
			|| (lock==VERTICAL&&Math.round(pack.height)==desiredH)
		) {
			lastArea = pack.width*pack.height;
		} else {
			lastArea = 0; // otherwise last is not valid so don't pick it
		}           

		lastC = cols;
		lastR = rows;            
		if (end) {
			if (timeID) timeID.clear();
			placePack(pack);
			if (that.stage) that.stage.update();
			return;
		}  
		
		if (showPacking) {
			timeID = timeout(1, function() {                    
				doIteration(pack, cols, rows);                    
			});
			placePack(pack);
			if (that.stage) that.stage.update();
			pack.sca(1);
		} else {  
			pack.sca(1);              
			doIteration(pack, cols, rows);                
		}   
		
	} // end doIteration


	function process(items, cols, rows) {  
	
		var totalSize = 0;
		zim.loop(items, function(item, i) {
			item.siz(null,sampleSize); // sampleSize does not matter just make same height
			totalSize+=item.width;
		});  
		var aveWidth = totalSize / num;
		var finalItems = items;
	
		if (num%cols!=0) {
			if (flatten==NONE) {
				// if flatten is NONE then add surrogates if num does not fit in cols and rows 
				zim.loop(cols-num%cols, function() {
					var sur =  new zim.Rectangle(aveWidth, sampleSize, grey);
					sur.surrogate = true;
					finalItems.push(sur);
				});
			} 
		}
	
		var tile = new Tile(finalItems, cols, rows, 0, 0, true);
		var sections = []; // array of row tiles

		// we have possibly an odd number at the bottom. 
		// we could distribute this on a single line or average the last two lines 
		// this would make these items bigger. 
		// It would be better probably to make the first two lines bigger. 
		// To do this we will shift the number of items down from the top through to the bottom 
		// items2D is read only and will keep on being overwritten by getter setter  
		// so we will create new sets of rows 

		var working = zim.copy(tile.items2D);
		
		if (flatten!=NONE && cols*rows!=num && working.length>1) {    
			var fnum;
			if (flatten==BOTTOM) {    
				fnum = that.funnel?Math.floor((cols*rows-num)/2):Math.ceil((cols*rows-num)/2);
				zim.loop(fnum, function(i) {
					working[rows-1].unshift(working[rows-2].pop()); // off the end of the second last row to start of last row              
				});
			} else {               
				var n = cols*rows-num;
				zim.loop(working, function(row,i,t) {
					if (i!=t-1) {
						zim.loop(row.splice(-n,n), function(item) { // would use rest .. but ES5
							working[i+1].unshift(item);
						},true);                       
					}
				});
				fnum = that.funnel?Math.floor((cols*rows-num)/2):Math.ceil((cols*rows-num)/2);
				zim.loop(fnum, function(i) {
					working[0].push(working[1].shift()); // off the end of the start of the second row to end of first row              
				});
			}        
		} 

		zim.loop(working, function(row, j, t) {           
			var wT = 0
			zim.loop(row, function(c) {wT+=c.width;});
			var sc = (desiredW-spacingH*(row.length-1)) / wT;
			zim.loop(row, function(c) {c.scale*=sc;});
			var r = zim.copy(row);
			if ((reverse && direction==HORIZONTAL) || (!reverse && direction==VERTICAL)) r.reverse();
			var tttt = new Tile(r, row.length, 1, spacingH, 0, true)
			if (reverse) tttt.loop(function(item){item.bot();}); // tricky... reverses stacking
			sections.push(tttt);
		});
		tile.dispose();
		

		var lastHeight = 0;
		pack.loc(backing, null, that);
		pack.removeAllChildren();
		zim.loop(sections, function(section) {
			section.loc(0,lastHeight,pack);            
			lastHeight += section.height+spacingV;
			section.loop(function(c,i,t) {c.addTo(pack).ord(-(t-i))}, true);
		})
		zim.loop(sections, function(section) {
			section.dispose();
		}, true);

		scalePack(pack);                    
		return pack;

	} // end process

	// PROPERTIES AND METHODS 

	that.getOrder = function(popup) {				
		if (zot(popup)) popup = false;
		if (popup) {
			if (!pane) {
				var pane = that.pane = new zim.Pane({
					displayClose:false,
					container:that.stage,
					width:Math.min(500, that.stage.width-20),
					height:Math.min(500, that.stage.height-20),
					draggable:true,
				});
				var textArea = that.textArea = new zim.TextArea(Math.min(400, that.stage.width-70), Math.min(400, that.stage.height-70));
				textArea.centerReg(pane);
			} 
			pane.show();		
			textArea.text = JSON.stringify(that.order);
		}            
		return that.order;
	};

	this.setOrder = function(order) {
		applyOrder(order);            
		doPack(items);        
		finalPlacement();
		return that;
	}
	this.addAt = function(items, index) {
		if (zot(items)) return that;
		if (zot(index)) index = that.items.length;
		if (!Array.isArray(items)) items = [items];
		zim.loop(items, function(item, i) {
			that.items.push(item); // new items just get added to the end of original items
			item.zpIndex = that.items.length-1;
			that.currentItems.splice(index+i,0,item); // but spliced in to desired location in currentItems            
		});
		doPack(that.currentItems);        
		finalPlacement();
		return that;
	}
	this.removeAt = function(number, index) {
		if (zot(number)) number = 1;
		if (zot(index)) index = that.items.length;
		var items = that.currentItems.splice(index,number);
		zim.loop(items, function(item) {
			var i = that.items.indexOf(item);
			that.items.splice(i,1);
		});            
		doPack(that.currentItems);          
		finalPlacement();
		return that;
	}

	Object.defineProperty(that, 'order', {
		get: function() {
			var order = [];
			pack.loop(function(item) {order.push(item.zpIndex);});
			return order;
		},
		set: function(value) {
			that.setOrder(value);
		}
	});

	Object.defineProperty(that, 'lock', {
		get: function() {
			return originalLock;
		},
		set: function(value) {
			if (value==originalLock) return;
			lock = value;
			doPack(items);        
			finalPlacement();
			if (dragOrder) dragOrderOn();
		}
	});

	Object.defineProperty(that, 'direction', {
		get: function() {
			return direction;
		},
		set: function(value) {
			if (value==direction) return;
			direction = value;
			pack.rotation = 0;
			items = [];
			pack.loop(function(item,i){
				items.push(item.rot(item.zpRotation||0).sca(1));
			});
			if (direction==VERTICAL) swapDirection(true);
			doPack(items);        
			finalPlacement();
			if (dragOrder) dragOrderOn();
		}
	});

	Object.defineProperty(that, 'spacing', {
		get: function() {
			return direction==VERTICAL?spacingV:spacingH;
		},
		set: function(value) {
			spacingH = spacingV = value;
			doPack(items);        
			finalPlacement();
		}
	});

	Object.defineProperty(that, 'outerWidth', {
		get: function() {
			return width;
		},
		set: function(value) {
			if (width==value) return;
			width = value;
			desiredW = width-paddingH*2;  
			if (backing) {
				backing.widthOnly = width;
				backing.center(that);
			}
			doPack(items);        
			finalPlacement();
			if (dragOrder) dragOrderOn();
		}
	});

	Object.defineProperty(that, 'outerHeight', {
		get: function() {
			return height;
		},
		set: function(value) {
			if (height==value) return;
			height = value;
			desiredH = height-paddingV*2;  
			if (backing) {
				backing.heightOnly = height;
				backing.center(that);
			}
			doPack(items);        
			finalPlacement();
			if (dragOrder) dragOrderOn();
		}
	});

	Object.defineProperty(that, 'flatten', {
		get: function() {
			return flatten;
		},
		set: function(value) {
			if (flatten==value) return;
			flatten = value;
			doPack(items);        
			finalPlacement();
		}
	});

	Object.defineProperty(that, 'dragOrder', {
		get: function() {
			return dragOrder;
		},
		set: function(value) {
			if (value) dragOrderOn();
			else {
				dragOrderOff();
				if (that.stage) that.stage.update();
			}
		}
	});

	if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

	this.dispose = function(disposing) {	
		if (dragOrder) dragOrderOff();		
		that.items = null;
		that.currentItems = null;
		if (!disposing) this.zimContainer_dispose(true);
		return true;
	}

	this.clone = function() {		
		return that.cloneProps(new zim.Pack(width, height, zim.copy(items, true), spacingH, spacingV, flatten, direction, lock, backgroundColor, align, valign, lastAlign, paddingH, paddingV, dragOrder, dragColor, dragThickness, dragDashed, reverse, funnel, showPacking, zim.copy(that.order), container, this.style, this.group));
	};

} 
zim.extend(zim.Pack, zim.Container, ["dispose", "clone"], "zimContainer", false);
//-66.55

/*--
zim.Beads = function(path, obj, count, angle, startPercent, endPercent, percents, onTop, showControls, visible, interactive, clone, group, style, inherit)

Beads
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION

Beads adds objects around a Squiggle or Blob path.
Different objects can be specified with ZIM VEE (Pick) values
to put random or sequenced objects around path.
The objects should have center registration for the most part.
Although animating, wiggling or customizing the registration can be cool.
The count of the object and the start and end percents can be specified

Beads can be used to make dotted borders or bead-like art.
The path can be any Squiggle or Blob - see https://zimjs.com/paths/ for example
The beads property holds the beads and can be animated in sequence

See https://zimjs.com/ten/beads.html for a mini-site of examples

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Beads({
	path:new Blob({points:"rectangle"}),
	obj:new Circle(5, series(red, blue)),
	visible:false,
	count:52
}).center();
END EXAMPLE

EXAMPLE
const sun = new Beads({
	path:new Blob({color:yellow}), //.radialGradient([yellow,orange],[.2,.8],0,0,0, 0,0,100),
	obj:new Triangle(60, 60, 60, series(orange,yellow,red)).reg(null, 60),
	interactive:false,
	count:9
}).center().drag({all:true});

// here we animate the beads property of Beads - which holds only the beads (not the path)
// sequence is automatically set to 0 to animate each bead individually
// to animate all the beads, animate on the main beads object
// You can still set a sequence to a value to run a sequence
sun.beads.animate({
	props:{scaleY:1.7},
	time:{min:1.5, max:2},
	rewind:true,
	loop:true,
	// sequence:200
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
path - (default new Blob({borderColor:blue})) a ZIM Squiggle or Blob on which to place the objects
obj - |ZIM VEE| the display object to place along the path - or use [] or series() for alternatives - also, see clone()
count - (default 10) the number of objects to place
angle - (default null) set to a specific angle such as 0 to keep all objects upright
	the default of null will align the objects normal (out from) the curve (at 90 degrees from the tangent at its placement point)
startPercent - (default 0) a start percent around the path starting from the first point of the Blob or Squiggle
endPercent - (default 100 or 100-spacing for Blob) an end percent for the last object
	can be smaller than startPercent to wrap around past 100
percents - (default null) an array of percent spacings to override default evenly spaced percents (also see percents property)
onTop - (default false) set to true to let the blob or squiggle come to the top of the bead object when manipulated
showControls - (default false) set to true to start off with the controls showing (also see interactive)
visible - (default true) set to false to not see the Blob or Squiggle path
interactive - (default true) set to false to not interact with the Blob or Squiggle path
clone - (default true) set to false to prevent Beads from cloning objects - good for series if events or custom properties are placed on each object
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
resize() - call resize if programatically changing the Squiggle or Blob path
	this will be done automatically when using path controls
hasProp(property as String) - returns true if property exists on object else returns false
clone(exact) - makes a copy with properties such as x, y, etc. also copied
	exact (default false) ZIM VEE (Pick) values are active in clones unless exact is set to true
	For instance, if Beads is made with new Circle(20,[blue,green])
	then its clone will have random blue or green circles that will differ from the original
	If exact is set to true then the clone will the same colors as the original
dispose() - removes listeners and deletes object

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
path - the Squiggle or Blob path on which the bead objects are placed
beads - a ZIM Container holding all the bead objects - this has a type of "BeadContainer"
	this can be looped through for hitTests, etc
	or can be animated and will automatically have a sequence of 0ms set
	other sequence values can be set to animate beads in sequence
	Each bead has the following properties added:
		beadNum - the index number of the bead when created
items - an array of the bead items for convenience - also see the beads property
count - get the number of beads
percents - get the array of percent spacings - see also percents parameter

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

--*///+66.7
	zim.Beads = function(path, obj, count, angle, startPercent, endPercent, percents, onTop, showControls, visible, interactive, clone, group, style, inherit) {
		var sig = "path, obj, count, angle, startPercent, endPercent, percents, onTop, showControls, visible, interactive, clone, group, style, inherit";
		var duo; if (duo = zob(zim.Beads, arguments, sig, this)) return duo;
		z_d("66.7");
		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Beads";

		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:false;
		if (zot(showControls)) showControls = DS.showControls!=null?DS.showControls:false;
		if (zot(visible)) visible = DS.visible!=null?DS.visible:true;
		if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:true;
		if (zot(path)) path = DS.path!=null?DS.path:new zim.Blob({
			color:null,
			borderWidth:3,
			borderColor:zim.blue
		});
		path.visible = visible;
		path.interactive = interactive;
		path.toggle(showControls);
		path.onTop = onTop;

		if (zot(obj)) obj = DS.obj!=null?DS.obj:new zim.Circle(10);
		if (zot(count)) count = DS.count!=null?DS.count:10;
		if (zot(angle)) angle = DS.angle!=null?DS.angle:null;
		if (zot(startPercent)) startPercent = DS.startPercent!=null?DS.startPercent:0;
		if (zot(endPercent)) endPercent = DS.endPercent!=null?DS.endPercent:100;
		if (zot(percents)) percents = DS.percents!=null?DS.percents:null;
		var projectedEndPercent = endPercent;
		if (endPercent < startPercent) projectedEndPercent = 100+endPercent;

		var i;
		if (zot(percents)) {
			var percent;
			if (path.type == "Squiggle") {
				percent = (projectedEndPercent-startPercent) / (count-1);
			} else {
				percent = (projectedEndPercent-startPercent) / (count-(startPercent!=projectedEndPercent%100?1:0));
			}
			percents = [];
			var lastPercent = startPercent-percent;
			for (i=0; i<count; i++) {
				percents.push(lastPercent+percent);
				lastPercent += percent;
				if (lastPercent > 100) lastPercent -= 100;
			}
		}
		if (zot(clone)) clone = DS.clone!=null?DS.clone:true;
		var that = this;
		that.count = count;
		that.percents = percents;

		// ~~~~~~~~~~~~~~~~~~~  GET ARRAY OF ITEMS  ~~~~~~~~~~~~~~~
		// this list could be edited later and passed back into remake()
		// so need to separate this part from the rest
		// also, need to record what was made with zik so resize does not change items
		that.items = [];
		var item;
		for (i=0; i<count; i++) {
			item = zim.Pick.choose(obj);
			if (clone) {
				if (i!=0) item = item.clone();
			}
			item.beadNum = i;
			item.startPercent = percents[i];
			that.items.push(item);
		}

		that.path = path.addTo(that);
		that.beads = new zim.Container().addTo(that, onTop?0:null);
		that.beads.type = "BeadsContainer";

		this.resize = function() {
			var segmentRatios = path.segmentRatios;
			var segmentPoints = path.segmentPoints;
			for (var i=0; i<that.count; i++) {
				var point = path.getCurvePoint(Math.max(0, Math.min(.9999, percents[i]/100)), segmentRatios, segmentPoints, true);

				if (!point) continue;
				var locPoint = that.beads.globalToLocal(point.x, point.y);
				if (!locPoint) continue;
				// zog(point.angle)
				that.items[i]
					.loc(locPoint, null, that.beads)
					.rot((zot(angle)?(point.angle>180?(point.angle-360+path.rotation):point.angle+path.rotation):angle));
			}
			return this;
		};
		that.resize();
		if (interactive) {
			path.on("pressmove", that.resize);
			path.on("update", that.resize);
		}

		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it

		this.dispose = function(disposing) {			
			if (!disposing) this.zimContainer_dispose(true);
			that.items = [];	
			return true;
		}

		this.clone = function(exact) {
			if (exact) {
				var exactItems = [];
				for (var i=0; i<that.items.length; i++) {
					exactItems.push(that.items[i].clone(true));
				}
			}
			return that.cloneProps(new zim.Beads(path.clone(), exact?zim.series(exactItems):(obj.clone?obj.clone():obj), that.count, angle, startPercent, endPercent, percents, onTop, showControls, visible, interactive, clone, this.style, this.group));
		};
	};
	zim.extend(zim.Beads, zim.Container, ["clone","dispose"], "zimContainer", false);
	//-66.7

/*--
zim.Layout = function(holder, regions, lastMargin, lastMarginMin, backgroundColor, vertical, showRegions, scalingObject, hideKey, style, group, inherit)

Layout
zim class - extends a createjs.EventDispatcher

DESCRIPTION
Layout arranges objects on the page by fitting (scaling) them in regions.
Make a layout object for each page if desired
and even nest layout objects inside regions.
Fixed aspect ratio content is fit into regions.
Layout is good for flexive design where you anchor titles and navigation.
Layout handles any number of regions vertically or horizontally.
It is useful for full scale mode for different devices or browser window scale.

NOTE: As of ZIM ZIM 02, a GlobalManager will be used to resize any Layout objects.

SPECIAL:
** If the object in a region is a Wrapper, the wrapper will be scaled 
to fit the region width of a vertical Layout and the height of a horizontal Layout 
See: https://zimjs.com/ten/wrapper.html
** If the object in a region is a Window, the window will be scaled to the region.
** If the object is given a type="Region" then it will have its bounds set to the region size.
This allows for another Layout to be nested within a region and scale to the inner region.
For example:
	var content = new Container(500,500);  
	content.type = "Region"; // this now will have its bounds set to the region size
If the object is a Container (usual choice) then it must be given a starting width and height
which will be reset to the region size and resized to continue to match the region size.
SEE: https://zimjs.com/explore/layouts.html
SEE: https://zimjs.com/cat/layout.html

SEE: https://zimjs.com/pages
SEE: https://codepen.io/zimjs/pen/oMRprj

NOTE: ZIM Tile is available to lay out non-scaled content

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// these would be containers with your content
// make sure that bounds are set on containers
// you may want to hard code bounds for clarity
const header = new Rectangle(500, 200, blue);
const content = new Rectangle(600, 500, green);
const footer = new Rectangle(500, 200, blue);
S.addChild(header, content, footer);

// make a vertical Layout - more useful for FULL scale mode
const layout = new Layout({
	holder:S,
	regions:[
		{obj:header, marginTop:10, maxWidth:80, minHeight:10, valign:TOP},
		{obj:content, marginTop:5, maxWidth:90}, // note, middle gets no minHeight
		{obj:footer, marginTop:5, maxWidth:80, height:10}
	],
	lastMargin:5
});

// As of ZIM ZIM 02, A GlobalManager will automatically be added 
// to resize any Layout objects
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
holder - object to hold layout (stage, container, etc) that must have bounds set
regions - an array of region DisplayObjects with specific properties for each region 
	(or array of DisplayObjects for defaults)
	Example VERTICAL region objects - all dimensions are percents
		[{obj:title, marginTop:10, maxWidth:80, minHeight:20, align:LEFT, valign:TOP},
		{obj:content, marginTop:5, maxWidth:90}, // note, middle gets no minHeight
		{obj:nav, marginTop:5, maxWidth:80, height:20, backgroundColor:red}]
	note: no minHeight for middle regions - but heights on any region
	align defaults to middle for the regions
	valign defaults to top and bottom for the top and bottom region and middle for the others
	backgroundColor applies a backing color to the region
	only vertical GradientColor and centered RadialColor are supported at this time
	so use new GradientColor([blue,green]) or new GradientColor([orange, yellow])
	Example HORIZONTAL region objects
		[{obj:col1, marginLeft:10, maxHeight:80, width:20, valign:"bottom"},
		{obj:col2, marginLeft:5, maxHeight:90, align:MIDDLE}, // note, middle gets no minWidth
		{obj:col3, marginLeft:5, maxHeight:80, minWidth:20, align:LEFT, valign:TOP}]
	align defaults to left and right for the outer regions and middle for the inside regions
	valign defaults to top for all the regions
	** See the SPECIAL section above in the description for Wrapper, Window and Region objects
lastMargin - (default 0) the margin at the bottom (vertical) or at the right (horizontal)
lastMarginMin - (default 0) the minimum margin at the bottom (vertical) or at the right (horizontal)
backgroundColor - (default null) background color for the whole holder
	only vertical GradientColor and centered RadialColor are supported at this time
	so use new GradientColor([blue,green]) or new GradientColor([orange, yellow])
vertical - (default true) set to false for horizontal layout
showRegions - (default null) show boundaries of regions (formerly regionShape)
	can toggle on and off with B key if this is set to true
scalingObject - (default holder) an object used as the bounds of the region scaling
	setting a scalingObject will also set the bounds of the holder to the scalingObject bounds
	it does not scale the holder - only scales the region objects inside
hideKey - (default B) is the hot key for hiding and showing the bounds

METHODS
resize() - resize based on new bounds of the holder (or scalingObject)
toggle(state - default null) - toggle() will show controls if they are hidden or hide controls if they are showing
	alternatively, pass in true to show controls or false to hide controls
	note - method does not update the stage
addShape(shape) - adds a bounding shape dynamically
removeShape() - permanently removes the bounding shape
disable() - disables all the layout (shape and sizing)
enable() - enables all the layout (shape and sizing)
dispose() - removes backgroundColors and bounds key event
	to get rid of the objects in the layout call dispose on those objects in the app

PROPERTIES
type - holds the class name as a String
regions - the regions object - if changed will have to call resize() manually
backing - the Shape that holds all the background colors
toggled - read-only Boolean as to whether the controls are showing or hidden

DESCRIPTION OF FLEXIVE DESIGN
here described with vertical layout - horizontal is similar but rotated 90
the content in the middle will try and expand against the top and bottom
until it forces the top and bottom to their minimum percents
if the content hits its maximum width percent first then the top and bottom
will fill up the rest of the height until they reach their maximum widths
--*///+80
	zim.Layout = function(holder, regions, lastMargin, lastMarginMin, backgroundColor, vertical, showRegions, scalingObject, hideKey, style, group, inherit) {
		var sig = "holder, regions, lastMargin, lastMarginMin, backgroundColor, vertical, showRegions, scalingObject, hideKey, style, group, inherit";
		var duo; if (duo = zob(zim.Layout, arguments, sig, this)) return duo;
		z_d("80");
		this.cjsEventDispatcher_constructor();
		this.type = "Layout";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(holder)) holder = DS.holder!=null?DS.holder:null;
		if (zot(scalingObject)) scalingObject = DS.scalingObject!=null?DS.scalingObject:null;

		if (zot(holder) || !holder.getBounds) {zog ("zim controls - Layout(): please provide an object with bounds set that holds the objects being laid out"); return;}
		scalingObject = (zot(scalingObject)) ? holder : scalingObject;
		if (!scalingObject.getBounds || !scalingObject.getBounds()) {zog ("zim controls - Layout(): holder must have bounds set or provide a scalingObject with bounds"); return;}
		
		var bounds = scalingObject.getBounds();
		holder.setBounds(0,0,bounds.width,bounds.height);
		// note, Layout sets bounds of holder but does not scale the holder - only the objects in regions
		// it may be that the holder is scaled by some external process
		// but probably not if a scalingObject is used

		if (zot(lastMargin)) lastMargin = DS.lastMargin!=null?DS.lastMargin:0;
		if (zot(lastMarginMin)) lastMarginMin = DS.lastMarginMin!=null?DS.lastMarginMin:0;
		if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:true;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:"";
		if (zot(hideKey)) hideKey = DS.hideKey!=null?DS.hideKey:"B";
		if (zot(showRegions)) showRegions = DS.showRegions!=null?DS.showRegions:null;
		var regionShape;
		if (showRegions) regionShape = new zim.Shape(); 
		var backing = this.backing = new zim.Shape(); // holds any backing colors
		var that = this;
		this.active = true;

		// loop through region objects and assign defaults
		// also check that regions can fit with values given
		// we basically do the same thing with horizontal and vertical layouts
		// but obviously one uses widths and the other heights, etc.
		// so adapted generic phrases of PRIMARY and SECONDARY
		// primary for vertical is in the Y direction and uses height and top
		// primary for horizontal is in the X direction and uses width and left
		// secondary for vertical is X and for horizontal is Y
		// min, absolute and margin values are only available in the primary
		// max values are only available in the secondary
		// align, valign and backgroundcolor is available for primary and secondary
		// absolute values (height, width) are to be used if given
		// if not given we try to maximize size and to adhere to min values
		// as calculations progress we calculate given, maxGiven and marginGiven values
		// these are temporary depending on the resizing and are always in the primary direction
		// secondary direction is quite simple
		// primary direction is quite complex involving a number of steps and even some recursion

		if (zot(regions)) regions = DS.regions!=null?zim.copy(DS.regions):null;
		if (zot(regions)) return;
		zim.loop(regions, function (r, i) {
			if (r instanceof createjs.DisplayObject) regions[i] = {obj:r};
			if (regions[i].object) {
				regions[i].obj = regions[i].object;
				delete regions[i].object;
			}
		});
		this.regions = regions; // expose the regions object for dynamic adjustments then manual resize

		var r; // used to hold a region in a loop
		var totalAbsolute = 0;
		var minPrimary = "minWidth";
		var primary = "width";
		var secondary = "height";
		var marginPrimary = "marginLeft";
		var marginMinPrimary = "marginMinLeft";
		var maxSecondary = "maxHeight";
		if (vertical) {
			minPrimary = "minHeight";
			primary = "height";
			secondary = "width";
			marginPrimary = "marginTop";
			marginMinPrimary = "marginMinTop";
			maxSecondary = "maxWidth";
		}
		
		// Margin Manifesto

		// margins and marginMins are always respected as a minimum number 
		// if the the region sizes + margins are more than 100% an error is given and Layout is not drawn.
		// end margins anchor and middle margins grow evenly with extra space 
		// auto can be set on any margin and will push as much as it can 

		// specifically:

		// end margins will anchor 
		// end margins with auto will push 
		// end marginMins will be respected if auto is pushing 
		// end marginMins have little effect without auto - they only overwrite an end margin that is smaller

		// inside margins will be respected as a minimum 
		// inside margins grow evenly with extra space 
		// inside margins with auto push as much as they can 
		// inside marginMins are respected 

		var autoMargins = [];
		var autoCount = 0;
		for (var i=0; i<regions.length; i++) {
			r = regions[i];
			if (!r.obj || !r.obj.getBounds()) {zogy("Layout(): each region object must have an object with setBounds() set"); return;}
			if (!r[minPrimary]) r[minPrimary] = 0;
			if (!r[primary]) r[primary] = 0;
			if (!r.backgroundColor) r.backgroundColor = "";
			r.given = 0;
			r.maxGiven = 0;
			if (r[marginPrimary] == "auto") {
				autoMargins[i] = true;
				autoCount++;
				if (r[marginMinPrimary]) r[marginPrimary] = r[marginMinPrimary];
				else delete r[marginPrimary];
			} else if (r[marginPrimary] && r[marginMinPrimary] && r[marginPrimary] < r[marginMinPrimary]) {
				r[marginPrimary] = r[marginMinPrimary];
			}
			if (zot(r[marginPrimary])) r[marginPrimary] = .0001;
			if (!r[maxSecondary]) r[maxSecondary] = 100;
			if (vertical) {
				// default alignment differs for orientation
				if (!r.align) r.align = "middle";
				if (!r.valign) {
					if (i==0) {r.valign = "top";}
					else if (i==regions.length-1) {r.valign = "bottom";}
					else {r.valign = "middle";}
					if (regions.length == 1) {r.valign = "middle";}
				}
			} else {
				if (!r.valign) r.valign = "top";
				if (!r.align) {
					if (i==0) {r.align = "left";}
					else if (i==regions.length-1) {r.align = "right";}
					else {r.align = "middle";}
					if (regions.length == 1) {r.align = "middle";}
				}
			}
			if (r[primary]) r[minPrimary] = 0; // primary overrides minPrimary
			totalAbsolute += r[primary] + r[marginPrimary];
		}
		
		if (lastMargin == "auto") {
			autoMargins[regions.length] = true; 
			lastMargin = lastMarginMin?lastMarginMin:0
		} else {
			if (lastMargin && lastMarginMin && lastMargin < lastMarginMin) lastMargin = lastMarginMin;
		}
		
		// primaries (not minPrimaries) are absolute percentage and are kept no matter what
		// margins are absolute percentage and are kept no matter what
		// check if primaries and margins are more than 100%
		totalAbsolute += lastMargin;
		if (totalAbsolute > 100) {zogy("Layout(): cannot fit regions into 100% bounds"); return;}
		var leftOverPrimary = 100-totalAbsolute;

		distribute(); // also called from within resize function
		function distribute() {
			// distribute leftOverPrimary to any regions without a primary or a given (primary)
			// proportion based on primary dimension of objects in regions
			// apply this primary to given (primary)
			var totalPrimaries = 0;
			var i;
			for (i=0; i<regions.length; i++) {
				r = regions[i];
				r.given = 0;
				if (r[primary] == 0) totalPrimaries += r.obj.getBounds()[primary];
			}
			// now we know total raw heights of objects needing height applied
			// loop back through and give these objects their proportion of what is left
			for (i=0; i<regions.length; i++) {
				r = regions[i];
				if (r[primary] == 0) r.given = r.obj.getBounds()[primary] / totalPrimaries * leftOverPrimary;
			}
		}

		this.resize = function() {
			var i;
			if (!that.active) return;
			bounds = scalingObject.getBounds();
			holder.setBounds(0,0,bounds.width,bounds.height);
			backing.graphics.clear();
			if (backgroundColor!="") {
				processColor(backing, backgroundColor, 0, 0, bounds.width, bounds.height);				
				backing.graphics.r(0,0,bounds.width,bounds.height);
			}
			for (i=0; i<regions.length; i++) {
				r = regions[i];
				r.maxGiven = 0;
				r.marginGiven = 0;
			}
			// all the primaries are applied
			// but some objects might not need the primary because they have maxed out on maxSecondary
			// we need to give this extra primary back to the pool
			// and keep doing it until there are no more maxed objects

			var keepGoing = true; var allCheck; 
			// var giveBack;
			var p; var s; var boundsP; var boundsS; var maxGiven;
			var leftOverPrimary2 = leftOverPrimary;
			while (keepGoing) {
				// check for objects maxed in width
				// giveBack = 0;
				keepGoing = false; allCheck = true;
				// we want to keep going unless all objects are maxed
				// or none of the objects are maxed
				for (i=0; i<regions.length; i++) {
					r = regions[i];					
					if (r.given > 0 && r.maxGiven == 0) {
						p = r.obj.getBounds()[primary];
						s = r.obj.getBounds()[secondary];
						boundsP =  r.given * bounds[primary]/100;
						boundsS =  r[maxSecondary] * bounds[secondary]/100; // convert to pixels
						maxGiven = s/p*boundsP;
						if (maxGiven > boundsS && r.obj.type != "Window") {
							// maxed out so give back height
							// keepGoing=true;
							// store this as maxGiven property
							// might have to take it away if later minHeights are not met
							r.maxGiven = p/s*boundsS * 100/bounds[primary]; // convert back to percentage
							// giveBack += r.given - r.maxGiven;
							leftOverPrimary2 -= r.maxGiven;
						} else {
							allCheck = false;
						}
					}
				}

				if (allCheck) break;	
					
				// redistribute the extra stuff to all that are not maxed out and not with primary values
				// proportion based on primary dimension of objects in regions
				// apply this primary to given (primary)
				var totalPrimaries = 0;
				for (i=0; i<regions.length; i++) {
					r = regions[i];
					if (r[primary] == 0 && r.maxGiven == 0) totalPrimaries += r.obj.getBounds()[primary];
				}
				// now we know total raw heights of objects needing height applied
				// loop back through and give these objects their proportion of what is left
				for (i=0; i<regions.length; i++) {
					r = regions[i];
					if (r[primary] == 0 && r.maxGiven == 0) r.given = r.obj.getBounds()[primary] / totalPrimaries * leftOverPrimary2;
				}
				
			} // end while loop ~~~~~~~~~~~~
			
			// if end regions have not met their minPrimaries
			// set those minPrimaries to primaries and resize again
			// divide leftover primary to regions with no set primary
			// maximize middle regions as this is usually content
			// if the edge regions have minPrimaries set them to minPrimary
			// if they do not have minPrimaries then proportion them equally with the rest

			var scaleCheck = true;
			r = regions[0];
			if (r.maxGiven > 0) {
				if (r.maxGiven < r[minPrimary]) {r[primary] = r[minPrimary]; scaleCheck = false;}
			} else if (r.given > 0) {
				if (r.given < r[minPrimary]) {r[primary] = r[minPrimary]; scaleCheck = false;}
			}
			r = regions[regions.length-1];
			if (r.maxGiven > 0) {
				if (r.maxGiven < r[minPrimary]) {r[primary] = r[minPrimary]; scaleCheck = false;}
			} else if (r.given > 0) {
				if (r.given < r[minPrimary]) {r[primary] = r[minPrimary]; scaleCheck = false;}
			}

			if (!scaleCheck) {
				// recalculate leftOverPrimary
				totalAbsolute = 0;
				for (i=0; i<regions.length; i++) {
					r = regions[i];
					totalAbsolute += r[primary] + r[marginPrimary];
				}
				totalAbsolute += lastMargin;
				if (totalAbsolute > 100) {zogy("zim display - Layout(): cannot fit regions into 100% bounds"); return;}

				leftOverPrimary = 100-totalAbsolute;
				distribute();
				that.resize();
				return;
			}

			// if specified all primaries or all maxed in secondary
			// then distribute based on inner margins
			// watch out - may need to revert to original margins if page is resized
			// so introduce a new marginGiven property

			var allHeights = true; var marginTotal = 0; var primaryTotal = 0;
			for (i=0; i<regions.length; i++) {
				r = regions[i];
				marginTotal += r[marginPrimary];
				if (r[primary] > 0) primaryTotal += r[primary];
				else if (r.maxGiven > 0) primaryTotal += r.maxGiven;
				else if (r.given > 0) primaryTotal += r.given;
				if (r[primary] == 0) {
					allHeights = false;
				}
			}
			if (allHeights || allCheck) {
				marginTotal += lastMargin;
				var extra = 100-primaryTotal-marginTotal;
				// remove two outer margins
								
				marginTotal -= (lastMargin + regions[0][marginPrimary]);
				if (extra != 0 && marginTotal != 0) { // divide up extra margin space
					for (i=0; i<regions.length; i++) {
						if (i==0) continue;
						r = regions[i];
						r.marginGiven = r[marginPrimary]/marginTotal*(marginTotal+extra);
					}
				}
			}
			
			// AUTO ~~~~~~~~~~~~~~
			// handle auto setting in margin
			
			if (autoCount > 0) {				
				var totP = 0;
				var tot = 0;
				for (i=0; i<regions.length; i++) {
					r = regions[i];
					if (r.marginGiven > 0) tot += r.marginGiven; // convert to pixels
					else tot += r[marginPrimary];
					r.marginGiven = 0;
					totP += r[marginPrimary]>.05?r[marginPrimary]:0
				}
				var diff = (tot-totP)/autoCount;				
				for (i=0; i<autoMargins.length; i++) {
					if (autoMargins[i] && regions[i]) {
						r = regions[i];
						r.marginGiven = (r[marginMinPrimary]?r[marginMinPrimary]:0) + diff;
					}
				}
			}
		

			// ready to fit objects into regions, align and draw any bounds and background colors
			var pPos=0; // primary position (x for horizontal, y for vertical)
			var sPos=0; // secondary position
			// var p;  	// primary dimension (width for horizontal, height for vertical)
			// var s;	// secondary dimension
			var f; 		// fit variable will receive a handy object with new data and original region bounds data
						// {x:obj.x, y:obj.y, width:newW, height:newH, scale:scale, bX:left, bY:top, bWidth:width, bHeight:height}

			var addedW; var addedH;	// just a little offscreen coloring to help page transitions
			if (regionShape && regionShape.graphics) {
				var g = regionShape.graphics;
				g.c();
			}
			for (i=0; i<regions.length; i++) {
				r = regions[i];

				// calculate primary data
				if (r.marginGiven > 0) pPos += r.marginGiven * bounds[primary]/100; // convert to pixels
				else pPos += r[marginPrimary] * bounds[primary]/100;
				
				
				if (r[primary] > 0) {p = r[primary];}
				else if (r.maxGiven > 0) {p = r.maxGiven;}
				else if (r.given > 0) {p = r.given;}
				else {p = 0;}
				p = p * bounds[primary]/100;

				// calculate secondary data
				s = r[maxSecondary] * bounds[secondary]/100;
				sPos = (bounds[secondary]-s)/2;

				// fit the objects into the region, align and draw any regionShape
				// this is slightly different for different orientations
				if (vertical) {
					if (r.obj.type == "Wrapper") r.obj.resize(s);
					if (r.obj.type == "Window") r.obj.resize(s,p);
					if (r.obj.type == "Region") r.obj.setBounds(s,p);
					f = zim.fit(r.obj,sPos,pPos,s,p);
				} else {
					if (r.obj.type == "Wrapper") r.obj.resize(p);
					if (r.obj.type == "Window") r.obj.resize(p,s);
					if (r.obj.type == "Region") r.obj.setBounds(p,s);					
					f = zim.fit(r.obj,pPos,sPos,p,s);
				}

				// handle alignment
				if (r.valign == "top") r.obj.y = f.bY;
				else if (r.valign == "bottom") r.obj.y = f.bY+f.bHeight-f.height;
				if (r.align == "left") r.obj.x = f.bX;
				else if (r.align == "right") r.obj.x = f.bX+f.bWidth-f.width;
				if (regionShape && regionShape.graphics) {
					g.s("white").ss(2).r(f.bX,f.bY,f.bWidth,f.bHeight);
					g.s("#ff8203").sd([20,20]).r(f.bX,f.bY,f.bWidth,f.bHeight).sd();
				}

				// draw any backing colors for region
				// transitions in ZIM Pages need a little extra overlap on page edges
				addedH = addedW = 0;
				if (pPos == 0 || (pPos+p) == bounds[primary]) if (vertical) {addedH=1;} else {addedW=1;}
				if (s == bounds[secondary]) if (vertical) {addedW=1;} else {addedH=1;}
				if (r.backgroundColor != "") {
					processColor(backing, r.backgroundColor, f.bX, f.bY, f.bWidth+addedW, f.bHeight+addedH);
					backing.graphics.r(f.bX, f.bY, f.bWidth+addedW, f.bHeight+addedH);
				}
				// increase our primary position
				pPos += p;
				if (r.obj.ZIMoutlineShape) r.obj.outline();
			}	
			
		}; // end resize 
		
		function processColor(shape, co, x, y, w, h) {	
			// if (co.type == "GradientColor") shape.graphics.lf(co.colors, co.ratios, co.x0, co.y0, co.x1, co.y1);
			if (co.type == "GradientColor") shape.graphics.lf(co.colors, co.ratios, x, y, x, y+h);
			// else if (co.type == "RadialColor") shape.graphics.rf(co.colors, co.ratios, co.x0, co.y0, co.r0, co.x1, co.y1, co.r1);
			else if (co.type == "RadialColor") shape.graphics.rf(co.colors, co.ratios, x+w/2, y+h/2, 0, x+w/2, y+h/2, Math.max(w/2,h/2));
			else if (co.type == "BitmapColor") shape.graphics.bf(co.image, co.repetition, co.matrix);	
			else shape.graphics.f(r.backgroundColor);
		}

		this.resize();

		// add regionShape if there is one and backing shape
		if (regionShape) holder.addChild(regionShape);
		holder.addChildAt(backing,0);

		// key listener and other methods:

		// add key listener to hide and show the bounds
		WW.addEventListener("keydown", keyEvent);
		function keyEvent(e) {
			if (!e) e=event;
			if (regionShape) {
				if (String.fromCharCode(e.keyCode) == hideKey.toUpperCase()) { // B
					that.toggle();
					if (regionShape.stage) regionShape.stage.update();
				}
			}
		}

		this.disable = function() {
			that.active = false;
			WW.removeEventListener("keydown", keyEvent);
			if (regionShape) regionShape.alpha = 0;
		};

		this.enable = function() {
			that.active = true;
			WW.addEventListener("keydown", keyEvent);
			that.resize();
			if (regionShape) regionShape.alpha = 1;
		};

		this.removeShape = function() { // use for final app
			if (regionShape) {
				regionShape.graphics.clear();
				regionShape.dispose();
				regionShape = null;
				regionShape = false;
			}
			WW.removeEventListener("keydown", keyEvent);
		};

		this.toggled = true;
		this.toggle = function(type) {
			if (type === true) {
				regionShape.visible = true;
			} else if (type === false) {
				regionShape.visible = false;
			} else {
				regionShape.visible = !regionShape.visible;
			}
			that.toggled = regionShape.visible;
			return that;
		};

		this.addShape = function(shape) {
			that.removeShape();
			regionShape = shape;
			WW.addEventListener("keydown", keyEvent);
			holder.addChild(regionShape);
			that.resize();
		};

		if (style!==false) zim.styleTransforms(this, DS);

		if (scalingObject.added) scalingObject.added(doAdd);
		else doAdd(scalingObject);
		function doAdd(stage) {
			if (stage && stage.frame && stage.frame.scaling == "full") {
				if (!zim.globalManager) {
					var gm = zim.globalManager = new zim.Manager();
					gm.frame = stage.frame;
					gm.event = stage.frame.on("resize", function() {
						gm.resize();
					});
				}
				zim.globalManager.add(that);
			}
		}		

		this.dispose = function() {	
			that.resize = null; // used by managers to detect disposed layout
			if (zim.globalManager) {
				var gm = zim.globalManager;				
				gm.remove(that);
				if (zim.globalManager.items.length==0) {
					gm.frame.off("resize", gm.event);
					gm.dispose();
					zim.globalManager = null;
				}				
			}
			if (that.backing) that.backing.dispose();
			that.backing = null;		
			that.removeShape(); // also removes listener
			return true;
		};
	};
	zim.extend(zim.Layout, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-80

/*--
zim.Accessibility = function(appName, tabOrder, tabIndex, cycle, decimals, frame, application, alwaysHighlight, AHTime, AHColor, AHBorderWidth, AHBorderPadding, AHAlpha, AHObject, AHObjectScale)

Accessibility
zim class - extends a createjs.EventDispatcher

DESCRIPTION
Adds Screen Reader accessibility to the canvas for TAB key or Swipe (mobile) highlighting of ZIM objects
Some objects can be activated using the ENTER key and adjusted using the ARROW keys
Default or custom titles can be set to be read by the Screen Reader
The objects and the order in which the objects recieve focus can be set with a tabOrder array
A text message can be passed to the talk() method and it will be read by a Screen Reader

NOTE: Instructions to activate a screen reader on desktop or laptop computers
On Windows, you can type Narrator into Cortana and run it - it is really easy
On Mac, under Accessibility choose Voice Over
On Android, under Accesibility choose Voice and turn on TalkBack
Windows worked at ZIM 6, Apple worked at 6.1.0, Android worked at 6.1.0 aside from Slider, Dial, Stepper and ColorPicker
Custom readers were not tested

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const button = new Button().center()
button.on("mousedown", ()=>{
	zgo("https://zimjs.com");
});
const dial = new Dial().center().mov(200);

const accessibility = new Accessibility();
// this will automatically read in all objects on the stage and give default messages for the Screen Reader
// ENTER key events will be added to objects that will translate to mousedown and click events on the object
// Tab (swipe on mobile) to focus on the Button and press enter (double tap on mobile) to go to the ZIM site
// The Dial can use arrows to increase and decrease its value (up and right increase, down and left decrease)
// On mobile, double tapping the Dial brings up a select box with options (as does Slider, Stepper, and ColorPicker)

// OR

const accessibility = new Accessibility("Second Example");
accessibility.tabOrder = [
	dial,
	{obj:button, title:"Press ENTER to go to ZIM site"}
];
// this will start and end the app with "Second Example" being read (rather than default, "application")
// the dial will be the first item to tab to
// the button has a tabOrder object so it will have the title read rather than the default button message
// You could also provide a tabOrder object for the dial as well
END EXAMPLE

NOTE: Please see https://zimjs.com/screenreader for a detailed example
NOTE: Please see https://zimjs.com/accessibility for a more examples

PARAMETERS supports DUO - parameters or single object with properties below
appName - (default "application") read in screen reader when application receives or loses focus
tabOrder - (default an array of all ZIM Display Objects on stage) an array of zim Display Objects
 	These will be given TAB key control (and ENTER and ARROWS) and will work with Screen Readers
	Or given swipe left/right and double tap on mobile
	*** Alternatively, an array of tabOrder objects with an obj property and a title property can be used
	The obj is the Dispay Object and the title is what is read by the Screen Reader
	eg. {obj:button, title:"Press Enter Key to start game"}
	Can also specify tabOrder as a property of Accessibility
	*** The tabOrder may change compared to the array that is initially provided
	*** as RadioButtons, Picker, Tabs, and Pad components are split into separate items
	*** For objects not on the stage including a Pane, Waiter, etc. do not rely on the auto adding, use the parameter specified array instead.
tabIndex - (default -1) - a starting index for focus - or can set tabIndex property after object is made
cycle - (default false) set to true to keep tab order inside application rather than leaving application when an end is reached
decimals - (default 2) number of decimals max to read for screen reader
frame - (default currentFrame) the frame
application - (default true - false on mobile) set to false to set role of buttons as buttons rather than application - may cause problems with NVDA unless set to forms mode
alwaysHighlight - (default false) screen readers will add their own highlights - but this will set highlight to true even if there is no screen reader
	Set to true to place a rectangle around the object being put into focus by pressing the tab key or swipe on mobile
	This will replace screen reader highlights (eg. for Windows Narrator) except for when aria is true (eg. Apple Voice Over)
	The rest of the parameters relate to the alwaysHighlight - meaning highlight even if there is no screen reader
AHTime - (default .7) seconds to show the alwaysHighlight (also see ZIM TIME constant)
AHColor - (default brown) - the color of the alwaysHighlight rectangle
AHBorderWidth - (default 3) thickness of border
AHBorderPadding - (default 5) distance from object bounds outward towards border
AHAlpha - (default .8) alpha of the alwaysHighlight
AHObject - (default null) set to a display object - including animated objects - to override the rectangle as a alwaysHighlight object
AHObjectScale - (default .8) scale the AHObject relative to the object with tab focus

METHODS
tab(dir) - set dir to 1 (default) to emulate tab forward or -1 to emulate shift tab
changeTitle(target, title, activate) - change a title for the Screen Reader
	target - the tabObject (eg. button) or the tabIndex of the item in the tabOrder to change
		*** The tabOrder may change compared to the array that is initially provided
		*** as RadioButtons, Picker, Tabs, and Pad components are split into separate items
	title - the new title that will be read to the screen reader
		If no title is provided any component passed will just update to its currentValue or selectedIndex
	activate (default false) - set to true to set focus of item at index and send to Screen Reader
talk(words) - tell the Screen Reader to read the words provided (does not affect focus)
resize(target) - target is the object or index of the object to update - or do not pass a target to update all
	This needs to be done if the object is moved, scaled, or removed from / re-added to the stage
	Accessibility works by placing HTML tags behind the canvas where the ZIM objects exist - so resize() handles this
	Use the Frame resize event and optionally, the ResizeManager()
dispose() - removes listeners and sets tabOrder to []

PROPERTIES
type - holds the class name as a String
tabOrder - get or set an array with the order in which display objects will receive focus with tab and shift tab (swipe on mobile)
tabIndex - get or set the index of the tabOrder (also see currentObject)
	Setting works only if object at the index is on the stage
	Returns -1 if no tabOrder object has the focus
currentObject - get or set the object in the tabOrder that has focus
	Objects have the following Accessibility properties added:
		zimAccessibility - the accessibility object
		zimTabIndex - the index in the tabOrder
		zimTabTag - the HTML tag that is used to represent the object to the screen reader
		zimTabParent - the parent of an object for RadioButtons, Tabs, and Pads (for others, the zimTabParent is the object)
		tabIndex - the index of the tag in tabParent (if there is a parent)
		type - the type of object. If there is a zimTabParent (that is not itself), the type is RadioButton, TabsButton or PadButton
activatedObject - get the object in the tabOrder that was last clicked or had the ENTER key pressed on
startAppTag - get the HTML tag that announces application start
endAppTag - get the HTML tag that announces application end
cycle - (default false) set to true to keep tab order inside application rather than leaving application when an end is reached
decimals - (default 2) number of decimals max to read for screen reader
frame - (default currentFrame) the frame
alwaysHighlight - Boolean to use a alwaysHighlight rectangle
AHTime - seconds to show the hightlight (also see ZIM TIME constant)
AHColor - the color of the alwaysHighlight rectangle
AHBorderWidth - thickness of border
AHBorderPadding - (default 5)distance from object bounds outward towards border
AHAlpha - alpha of the alwaysHighlight
AHObject - set to a display object - including animated objects - to override the rectangle as a alwaysHighlight object
AHObjectScale - scale the AHObject relative to the object with tab focus
enabled - default is true - set to false to disable

EVENTS
Dispatches a "change" event when the screen reader is about to talk
	This is when the talk() method runs or the tabIndex is changed (from click, swipe, tab, changeTitle - with activate true)
	The event object has a title property that holds the words the screen reader will say
 	Several change events can happen at the same time so what is said is usually the last
	but the talk() method takes priority as it runs in alert mode so focus is not lost
 The Enter key dispatches mousedown and click events from object with focus
	The event object has a fromEnter property which is true if from an enter key on the object
	This could trigger a button press for instance

--*///+30.5
	zim.Accessibility = function(appName, tabOrder, tabIndex, cycle, decimals, frame, application, alwaysHighlight, AHTime, AHColor, AHBorderWidth, AHBorderPadding, AHAlpha, AHObject, AHObjectScale) {
		var sig = "appName, tabOrder, tabIndex, cycle, decimals, frame, application, alwaysHighlight, AHTime, AHColor, AHBorderWidth, AHBorderPadding, AHAlpha, AHObject, AHObjectScale";
		var duo; if (duo = zob(zim.Accessibility, arguments, sig, this)) return duo;
		z_d("30.5");
		this.cjsEventDispatcher_constructor();
		this.type = "Accessibility";

		if (zot(appName)) appName = "application";
		if (zot(cycle)) cycle = false;
		if (zot(decimals)) decimals = 2;
		if (zot(frame)) frame = WW.zdf;
		if (zot(application)) application = zim.mobile()?false:true;
		if (zot(alwaysHighlight)) alwaysHighlight = false;
		var timeType = getTIME(AHTime);
		if (zot(AHTime)) AHTime = timeType=="s"?.7:700;
		if (zot(AHColor)) AHColor = "brown";
		if (zot(AHBorderWidth)) AHBorderWidth = 3;
		if (zot(AHBorderPadding)) AHBorderPadding = 5;
		if (zot(AHAlpha)) AHAlpha = .8;
		if (zot(AHObjectScale)) AHObjectScale = .8;
		if (zot(AHObject)) {
			var alwaysHighlightShape = new zim.Shape({style:false});
			alwaysHighlightShape.mouseEnabled = false;
		} else {
			if (AHObject.mouseEnabled) AHObject.mouseEnabled = false;
		}

		if (typeof frame == "undefined") var frame = WW.zdf;
		if (zot(frame)) {
			if (zon) zogy("Accessibility - needs a Frame");
			return;
		}
		var pRatio = frame.retina?(WW.devicePixelRatio || 1):1;

		var that = this;
		that.cycle = cycle;
		that.decimals = decimals;
		that.alwaysHighlight = alwaysHighlight; // will want to set as getter setter
		that.AHTime = AHTime;
		that.AHColor = AHColor;
		that.AHBorderWidth = AHBorderWidth;
		that.AHBorderPadding = AHBorderPadding;
		that.AHAlpha = AHAlpha;
		that.AHObjectScale = AHObjectScale;

		// ZIM Accessibility
		// If there is a tabOrder then make HTML tags (tabTags) that match tab objects
		// Put these outside viewable document area and give them titles that match the text property
		// ALSO - add:
		// 1. a tabPrefixTag before the canvas
		// 2. a tabBufferTag before and after the last tabTag
		// 3. a tabSuffixTag before and after the buffer
		// These are used when exiting or entering canvas tab system
		// When entering, the tab system forwards the focus to the first or last tab on stage
		// When exiting, the prefix or suffix is left active, the title is read
		// This allows the next tab to go to the normal tab order on the HTML page
		// The buffer tag lets us enter the canvas if the user goes back after exiting to the suffix tag
		// there is no need for a buffer tag for the prefix as we use the canvas tag itself
		// 4. We also add a talk tag with a role of alert
		// We change the innerHTML of this tag and it will be read without losing focus

		// item is used for an object from the tabOrder - with obj and title properties
		// obj is used when referencing the obj property of the item

		var _tabOrder = -1; // will be an array, but need to handle purposeful empty array
		var _tabIndex = -1;
		var tabTags = [];
		var tabEvents = [];
		var phrases = {RadioButtons:"option", Tabs:"tab", Pad:"key"};
		var currentHighlight;
		var canvasID = frame.canvas.id;
		var mobile = zim.mobile();
		var ariaCheck = false; // keeps track of whether we have checked aria
		var _aria = null; // keeps track of aria setting
		var ariaEvents = []; // [obj, event] - uses on
		var prefixTab;
		var suffixTab;
		var talkTag;
		var noAriaTabPrefix;
		var noAriaTabSuffix;
		var noAriaTabPrefix2;
		var noAriaTabSuffix2;
		var firstDelay = 150;
		var lastMadeTag;

		Object.defineProperty(this, 'tabOrder', {
			get: function() {
				return _tabOrder;
			},
			set: function(array) {
				var i;
				// remove any previous tabTags and prefix/suffix and events
				if (prefixTab) prefixTab.removeEventListener("focus", clearAlert);
				if (suffixTab) suffixTab.removeEventListener("focus", clearAlert);
				for (i=0; i<tabTags.length; i++) {
					if (tabTags[i].parentElement) tabTags[i].outerHTML = "";
				}
				tabTags = [];

				// remove any previous mousedown events added to capture focus
				var item;
				var obj;
				for (i=0; i<tabEvents.length; i++) {
					item = _tabOrder[i];
					if (item) tabEvents[i][0].off("mousedown", tabEvents[i][1]);
				}
				tabEvents = [];
				_tabOrder = [];
				var finalTabs = [];
				lastMadeTag = frame.shim?document.body:frame.canvas;
				talkCheck = false;

				var subtotal = 0;
				for (i=0; i<array.length; i++) {
					item = array[i];
					if (item.type == "HotSpots") {
						// for (var j=0; j<item.hotSpots.length; j++) {
						// 	addSpots.push(item.hotSpots[j].spot);
						// }
						array.splice.apply(array, [i, 1].concat(item.hotSpots));
						item = item.hotSpots[0];
					}
					if (item.type == "HotSpot") item = item.spot;
					if (item.constructor == {}.constructor) {
						obj = item.obj;
						if (!obj || !obj.getStage) continue; // must provide display object
						if (!item.title) item.title = getText(obj, i+subtotal);
					} else {
						obj = item;
						item = {obj:item, title:getText(item, i+subtotal)};
					}

					// these components we will split into individual tab items
					// we use the RadioButtons labels and the Tabs and Pad buttons
					// and there is a slight difference in phrasing - otherwise, they work the same
					if (obj.type == "RadioButtons" || obj.type == "Tabs" || obj.type == "Pad") {
						var splitAdd = [];
						subtotal--; // subtract 1 for the obj in array we replace
						for (var j=0; j<obj.buttons.length; j++) {
							subtotal++;
							var but = obj.buttons[j];
							var splitItem = {obj:but, title:item.title + " - " + phrases[obj.type] + ": " + ((but.text=="a" || but.text=="A") ? "eh" : but.text)};
							splitAdd.push(splitItem);
							but.zimTabParent = obj;
							but.zimTabParent.zimAccessibility = that;
							but.zimTabIndex = i+subtotal; // for click event
							but.tabIndex = j; // for seeing if pressed
							but.zimAccessibility = that;
							addExtraTitle(splitItem);
							lastMadeTag	= makeTabTag(canvasID+"Tab"+(i+subtotal), splitItem.title, lastMadeTag, splitItem);
							tabEvents.push([but, but.on("mousedown", setTabFocus)]);
							if (!ariaCheck) ariaEvents.push([but, but.on("mousedown", ariaCheckEvent)]);
						}
						finalTabs = finalTabs.concat(splitAdd);
					} else {
						obj.zimTabIndex = i+subtotal;
						obj.zimTabParent = obj; // just so always can ask for zimTabParent
						addExtraTitle(item);
						obj.zimAccessibility = that;
						tabEvents.push([obj, obj.on("mousedown", setTabFocus)]);
						if (!ariaCheck) ariaEvents.push([obj, obj.on("mousedown", ariaCheckEvent)]);
						finalTabs.push(item);
						lastMadeTag	= makeTabTag(canvasID+"Tab"+(i+subtotal), item.title, lastMadeTag, item);
					}
				}

				// ARIA
				// need to check for aria which is used by Apple Voice Over for instance...
				// so start assuming aria is true
				// then make a noAria tag before the prefix and a noAria tag after the suffix
				// these will have aria-hidden = true attributes
				// they also have a focus event and if the focus is triggered, _aria gets set to false
				// also, the noAria tags are removed and focus given to the prefix or suffix
				// So... the check does not work right away, but just as focus

				// 10.9.0 - In Adobe Animate a scaled wrapper is put around the canvas - so put tags outside this
				// just defaulting to the body - if Animate was ever embedded in other HTML code this might not be optimal
				// that is why ZIM wraps the canvas directly to let other tags use the ScreenReader

				prefixTab = that.startAppTag = makeTabTag(canvasID+"PrefixTab", appName + " start", frame.shim?document.body:frame.canvas, null, "before"); // resting tag when exiting backwards
				prefixTab.addEventListener("focus", clearAlert);
				if (!ariaCheck) {
					prefixTab.addEventListener("focus", removeAriaEvent);
					// make tags surrounding prefix that set aria to false if seen by non-aria
					noAriaTabPrefix = makeTabTag(canvasID+"noAriaTab", "", prefixTab, null, "before");
					noAriaTabPrefix.setAttribute("aria-hidden", true);
					noAriaTabPrefix.focusTab = prefixTab;
					noAriaTabPrefix.addEventListener("focus", ariaFalseEvent);
					// if click inside on TextArea or Loader it will not determine aria
					// and so, we may arrive at the prefix going backwards from the inside - sigh
					noAriaTabPrefix2 = makeTabTag(canvasID+"noAriaTab", "", prefixTab);
					noAriaTabPrefix2.setAttribute("aria-hidden", true);
					noAriaTabPrefix2.focusTab = prefixTab;
					noAriaTabPrefix2.addEventListener("focus", ariaFalseEvent);
				}

				lastMadeTag = makeTabTag(canvasID+"BufferTab", "", lastMadeTag); // catch tag if sent to suffix then shift tabs back in to canvas
				// not sure if we need this on mobile
				if (mobile) lastMadeTag.setAttribute("aria-hidden", true);

				lastMadeTag = suffixTab = that.endAppTag = makeTabTag(canvasID+"SuffixTab", appName + " end", lastMadeTag); // resting tag when exiting forward
				suffixTab.addEventListener("focus", clearAlert);
				if (!ariaCheck) {
					suffixTab.addEventListener("focus", removeAriaEvent);
					lastMadeTag = noAriaTabSuffix = makeTabTag(canvasID+"noAriaTab", "", suffixTab); // resting tag when exiting backwards
					noAriaTabSuffix.setAttribute("aria-hidden", true);
					noAriaTabSuffix.focusTab = suffixTab;
					noAriaTabSuffix.addEventListener("focus", ariaFalseEvent);

					noAriaTabSuffix2 = makeTabTag(canvasID+"noAriaTab", "", suffixTab, null, "before"); // resting tag when exiting backwards
					noAriaTabSuffix2.setAttribute("aria-hidden", true);
					noAriaTabSuffix2.focusTab = suffixTab;
					noAriaTabSuffix2.addEventListener("focus", ariaFalseEvent);
				}

				_tabOrder = finalTabs;
			}
		});

		function removeOuterTags() {
			if (prefixTab) {
				prefixTab.removeEventListener("focus", clearAlert);
				prefixTab.removeEventListener("focus", removeAriaEvent);
				if (prefixTab.parentNode) prefixTab.outerHTML = "";
			}
			if (noAriaTabPrefix) {
				noAriaTabPrefix.removeEventListener("focus", ariaFalseEvent);
				if (noAriaTabPrefix.parentNode) noAriaTabPrefix.outerHTML = "";
			}
			if (noAriaTabPrefix2) {
				noAriaTabPrefix2.removeEventListener("focus", ariaFalseEvent);
				if (noAriaTabPrefix2.parentNode) noAriaTabPrefix2.outerHTML = "";
			}
			if (lastMadeTag) {
				if (lastMadeTag.parentNode) lastMadeTag.outerHTML = "";
			}
			if (suffixTab) {
				suffixTab.removeEventListener("focus", clearAlert);
				suffixTab.removeEventListener("focus", removeAriaEvent);
				if (suffixTab.parentNode) suffixTab.outerHTML = "";
			}
			if (noAriaTabSuffix) {
				noAriaTabSuffix.removeEventListener("focus", ariaFalseEvent);
				if (noAriaTabSuffix.parentNode) noAriaTabSuffix.outerHTML = "";
			}
			if (noAriaTabSuffix2) {
				noAriaTabSuffix2.removeEventListener("focus", ariaFalseEvent);
				if (noAriaTabSuffix2.parentNode) noAriaTabSuffix2.outerHTML = "";
			}
		}


		Object.defineProperty(this, 'tabIndex', {
			get: function() {
				return _tabIndex;
			},
			set: function(num) {
				if (!_state) return;
				if (num < 0 || num >= _tabOrder.length) {
					clearTab();
				} else {
					if (num != _tabIndex) clearOld();
					var obj = _tabOrder[num].obj;
					if (obj.stage) {
						_tabIndex = num;
						obj.focus = true;
						tabFocus = true;
						tabFirstCheck = false;

						that.changeTitle(obj);
						obj.zimTabTag.focus();

						setTimeout(function() {
							obj.zimTabTag.focus();
							var readerEvent = new createjs.Event("change");
							readerEvent.title = obj.zimTabTag.getAttribute("aria-label");
							that.dispatchEvent(readerEvent);
						}, firstDelay);

						// if (num == _tabIndex) return;

						// custom hightlights
						if (that.alwaysHighlight && (!_aria || !mobile)) {
							if (!that.AHObject) {
								currentHighlight = alwaysHighlightShape;
								var oB = obj.getBounds();
								var pTL = obj.localToGlobal(oB.x-5, oB.y-5);
								var pTR = obj.localToGlobal(oB.x+oB.width+5, oB.y-5);
								var pBR = obj.localToGlobal(oB.x+oB.width+5, oB.y+oB.height+5);
								var pBL = obj.localToGlobal(oB.x-5, oB.y+oB.height+5);

								var g = alwaysHighlightShape.graphics;
								g.clear();
								g.s(that.AHColor).ss(that.AHBorderWidth)
									.mt(pTL.x-that.AHBorderPadding, pTL.y-that.AHBorderPadding)
									.lt(pTR.x+that.AHBorderPadding, pTR.y-that.AHBorderPadding)
									.lt(pBR.x+that.AHBorderPadding, pBR.y+that.AHBorderPadding)
									.lt(pBL.x-that.AHBorderPadding, pBL.y+that.AHBorderPadding)
									.lt(pTL.x-that.AHBorderPadding, pTL.y-that.AHBorderPadding)
									.cp();
								alwaysHighlightShape.alpha = that.AHAlpha;
								if (that.AHTime > 0) tabTimeout = setTimeout(function(){frame.stage.removeChild(alwaysHighlightShape); frame.stage.update();}, that.AHTime*(timeType=="s"?1000:1));

							} else {
								currentHighlight = that.AHObject;
								var b = zim.boundsToGlobal(obj);
								that.AHObject.alp(that.AHAlpha).addTo(frame.stage, null, false);
								that.AHObject.fit(b.x, b.y, b.width, b.height);
								that.AHObject.sca(that.AHObject.scaleX*that.AHObjectScale);
								if (that.AHTime > 0) tabTimeout = setTimeout(function(){frame.stage.removeChild(that.AHObject); frame.stage.update();}, that.AHTime*(timeType=="s"?1000:1));
							}
							frame.stage.addChild(currentHighlight);
							frame.stage.update();
						}
					} else {
						clearTab();
					}
				}
				function clearOld() {
					if (_tabIndex && _tabIndex > -1) {
						if (_tabOrder && _tabOrder[_tabIndex]) _tabOrder[_tabIndex].obj.focus = false;
					} else {
						for (var i=0; i<_tabOrder.length; i++) {
							_tabOrder[i].obj.focus = false;
						}
					}
				}
				function clearTab() {
					clearOld();
					tabFocus = false;
					if (that.AHObject) frame.stage.removeChild(that.AHObject);
					if (that.alwaysHighlightShape) frame.stage.removeChild(that.alwaysHighlightShape);
					frame.stage.update();
					_tabIndex = -1;
				}
			}
		});

		Object.defineProperty(this, 'aria', {
			get: function() {
				return _aria;
			},
			set: function(val) {
				_aria = val;
				if (_aria) setAriaTrue();
				// and more
			}
		});

		// AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAA
		// Aria
		// function called from mousedown on any object to see if entering app through mousedown rather than tab
		// ONLY HAPPENS ONCE! function gets removed after checking
		// if (mobile == "android") setAriaTrue();

		function ariaCheckEvent(e) {
			var obj = e.currentTarget;
			var bounds = obj.boundsToGlobal();
			var cX = bounds.x + bounds.width/2;
			var cY = bounds.y + bounds.height/2;
			var delta = 5;
			// aira sends event through with mouseX and mouseY at the center of the object
			if (e.stageX/zim.scaX < cX-delta || e.stageX/zim.scaX > cX+delta || e.stageY/zim.scaY < cY-delta || e.stageY/zim.scaY > cY+delta) {
				setAriaFalse();
			} else {
				setAriaTrue();
			}
		}

		function clearAlert() {
			if (talkTag) talkTag.innerHTML = "";
		}

		if (mobile == "android") {
			zim.ACTIONEVENT = "click";
			if (!zns) WW.ACTIONEVENT = "click";
		}

		// function to set aria true
		function setAriaTrue() {
			_aria = true;
			removeAriaCheck();
			if (talkTag) talkTag.setAttribute("aria-hidden", false);

			zim.ACTIONEVENT = "click";
			if (!zns) WW.ACTIONEVENT = "click";
			// can't tell if aria until first click which might place a highlight
			// aria uses its own highlight so do not want two highlights
			// for windows narrator, if we use a custom highlight then we move the tags off the stage
			// but with mobile, they don't get moved off the stage but rather to the edge of the screen - arrg
			frame.stage.removeChild(currentHighlight);
			if (mobile) that.alwaysHighlight = false;
			frame.stage.update();
			var item;
			var obj;
			var tag;
			for (var i=0; i<_tabOrder.length; i++) {
				item = _tabOrder[i];
				obj = item.obj;
				tag = obj.zimTabTag;
				tag.disabled = false;
				item.title = item.title.replace(/\s\(use arrow keys\)/, "");
				tag.setAttribute("aria-label", item.title);
				tag.addEventListener("focus", ariaTagFocusEvent);
			}
		}
		// function to set aria false
		function setAriaFalse() {
			_aria = false;
			var item;
			var obj;
			var tag;
			for (var i=0; i<_tabOrder.length; i++) {
				item = _tabOrder[i];
				obj = item.obj;
				tag = obj.zimTabTag;
				tag.disabled = false;
			}
			removeAriaCheck();
			if (alwaysHighlight) moveTagsOffstage();
		}

		// function to go to new tag via aria swipe
		// note, the aria-label is read as soon as focus is received
		// so can't do any testing of selected, or values
		// so the label must be set before coming in to focus
		function ariaTagFocusEvent(e) {
			var tag = e.currentTarget;
			var obj = tag.zimObject;
			// that.tabIndex = obj.zimTabIndex;
			_tabIndex = obj.zimTabIndex;
			obj.focus = true;
			var readerEvent = new createjs.Event("change");
			readerEvent.title = tag.getAttribute("aria-label");
			that.dispatchEvent(readerEvent);
		}

		// function to send focus to prefix or suffix if no aria present
		function ariaFalseEvent(e) {
			_aria = false;
			e.target.focusTab.focus();
		}
		// function to set aria when arriving at prefix or suffix
		function removeAriaEvent() {
			if (zot(_aria) || _aria) setAriaTrue(); // was not set to false or was set to true
			else setAriaFalse(); // was set to false
		}

		// function to remove ariaChecking objects and events
		function removeAriaCheck() {
			ariaCheck = true;

			prefixTab.removeEventListener("focus", removeAriaEvent);
			suffixTab.removeEventListener("focus", removeAriaEvent);

			noAriaTabPrefix.removeEventListener("focus", ariaFalseEvent);
			noAriaTabSuffix.removeEventListener("focus", ariaFalseEvent);
			if (noAriaTabPrefix.parentNode) {
				noAriaTabPrefix.parentNode.removeChild(noAriaTabPrefix);
				noAriaTabSuffix.parentNode.removeChild(noAriaTabSuffix);
			}

			noAriaTabPrefix2.removeEventListener("focus", ariaFalseEvent);
			noAriaTabSuffix2.removeEventListener("focus", ariaFalseEvent);
			if (noAriaTabPrefix2.parentNode) {
				noAriaTabPrefix2.parentNode.removeChild(noAriaTabPrefix2);
				noAriaTabSuffix2.parentNode.removeChild(noAriaTabSuffix2);
			}

			for (var i=0; i<ariaEvents.length; i++) {
				ariaEvents[i][0].off("mousedown", ariaEvents[i][1]);
			}
		}

		// function to move tags offstage if there is no aria
		function moveTagsOffstage() {
			for (var i=0; i<tabTags.length; i++) {
				var t = tabTags[i];
				if (t.zimObject && (t.zimObject.type == "Loader" || t.zimObject.type == "TextArea" || t.zimObject.type == "Tag")) continue;
				tabTags[i].style.left = "-2000px";
			}
		}


		// ZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZZ

		// function to handle tabOrder parameter versus tabOrder property being set at start
		if (!zot(tabOrder)) {
			_tabOrder = [];
			that.tabOrder = tabOrder;

			if (!zot(tabIndex)) that.tabIndex = tabIndex;
		} else {
			// wait a sec to see if the tabOrder property is set
			// and if not, set a default tabOrder to all objects on the stage
			setTimeout(function() {
				if (_tabOrder == -1) {
					_tabOrder = [];
					var tabTemp = [];
					zim.loop(frame.stage, function(obj){if (obj.type) tabTemp.push(obj);});
					that.tabOrder = tabTemp;
					if (!zot(tabIndex)) that.tabIndex = tabIndex;
				}
			}, 50);
		}

		// CLICK
		// function called from mousedown on any tabOrder objects to handle setting tabIndex
		function setTabFocus(e) {
			var obj = e.currentTarget;
			if (obj.type == "RadioButton" || obj.type == "TabsButton" || obj.type == "PadButton") {
				for (var j=0; j<obj.zimTabParent.buttons.length; j++) {
					var but = obj.zimTabParent.buttons[j];
					but.zimTabTag.setAttribute("aria-label", but.zimTabTag.getAttribute("aria-label").split(" - currently")[0] + (obj.zimTabParent.selectedIndex == but.tabIndex ? " - currently selected." : " - currently not selected."));
				}
			}
			that.tabIndex = e.currentTarget.zimTabIndex;
			that.activatedObject = obj;
		}

		// function to create text for screen reader prepending object type
		// and in some cases if tabParent then preparing prefix for future items like radio buttons
		function getText(obj) {
			if (obj.talk) return obj.talk;
			if (obj.type == "TextArea" || obj.type == "RadioButtons" || obj.type == "Tabs" || obj.type == "Pad") return obj.type; // first part of title naming for radio button if no title provided
			if (obj.type == "Waiter") return "Waiter active - please wait";
			return obj.text ? obj.type + " - " + ((obj.text=="a" || obj.text=="A") ? "eh" : obj.text) : obj.type + ((obj.type == "Dial" || obj.type == "Slider" || obj.type == "ColorPicker" || obj.type == "Stepper") ? " (use arrow keys)" : "") + ((obj.type == "TextArea") ? " (press ENTER to edit)" : "");
		}

		// function to add extra information to title
		// 7.6.2022 - Pettis added TextInput to obj.type based off of TextArea
		function addExtraTitle(item) {
			var obj = item.obj;
			item.title = item.title.replace(/\.$/, "");
			if (obj.type == "RadioButton" || obj.type == "TabsButton" || obj.type == "PadButton") item.title = item.title + (obj.tabIndex == obj.zimTabParent.selectedIndex ? " - currently selected" : " - currently not selected");
			else if (obj.type == "CheckBox") item.title = item.title + (obj.checked ? " - currently checked" : " - currently not checked");
			else if (obj.type == "Stepper") item.title = item.title + " - currently displaying " + obj.currentValue;
			else if (obj.type == "Slider" || obj.type == "Dial") item.title = item.title + " - currently at " + zim.decimals(obj.currentValue, that.decimals);
			else if (obj.type == "ColorPicker") item.title = item.title + " - currently at " + obj.selectedColor;
			else if (obj.type == "TextArea") item.title = item.title + (obj.tag.value != "" ? "" : " - placeholder: " + obj.tag.placeholder); // text areas get read automatically (except placeholder)
			else if (obj.type == "Indicator") item.title = item.title + " - currently " + (obj.selectedIndex>=0 ? "at " + (obj.selectedIndex+1) + " of " + obj.num :  "not indicating");
			else if (obj.type == "TextInput") item.title = item.title + (obj.htmlTag.value != "" ? "" : " - placeholder: " + obj.htmlTag.placeholder); // text areas get read automatically (except placeholder)
			// else if (obj.type == "Button" && application) item.title = item.title + " button";
			item.title += ".";
		}



		// function to make HTML tags off screen to feed titles to screen reader using focus()
		function makeTabTag(id, title, targetTag, item, place) {
			var obj;
			var tabTag;
			if (item) obj = item.obj;
			// if (item && (!obj.getBounds || obj.getBounds()==null)) return;
			if (item && (obj.type == "TextArea" || obj.type == "Loader")) {
				tabTag = obj.tag;
				tabTag.setAttribute("aria-label", title);
				if (obj) tabTag.setAttribute("aria-hidden", !obj.stage);
				if (place == "before") {
					targetTag.parentNode.insertBefore(tabTag, targetTag);
				} else {
					targetTag.parentNode.insertBefore(tabTag, targetTag.nextSibling);
				}
				
    		    // 7.6.2022 - Pettis added this "if" to check for TextArea and keep z-index 3 while focused.
                if (obj.type == "TextArea") tabTag.style.zIndex = 3;
                else tabTag.style.zIndex = -5;
				
				tabTag.zimObject = obj;
				item.obj.zimTabTag = tabTag;
				tabTags.push(tabTag);
				return tabTag;
	
		    // 7.6.2022 - Pettis added this "if" to check for TextInput and grab the htmlTag
			} else if (item && (obj.type == "TextInput")) {
				tabTag = obj.htmlTag;
				tabTag.setAttribute("aria-label", title);
				if (obj) tabTag.setAttribute("aria-hidden", !obj.stage);
				if (place == "before") {
					targetTag.parentNode.insertBefore(tabTag, targetTag);
				} else {
					targetTag.parentNode.insertBefore(tabTag, targetTag.nextSibling);
				}
				tabTag.style.zIndex = -5;
				tabTag.zimObject = obj;
				item.obj.zimTabTag = tabTag;
				tabTags.push(tabTag);
				return tabTag;
			}
			
			var i;
			if (item && (obj.type == "Dial" || obj.type == "Slider" || obj.type == "Stepper" || obj.type == "ColorPicker")) {
				var stepArray = [];
				if (obj.type == "Dial" || obj.type == "Slider") {
					var step = (obj.step <= 0 ? (obj.max-obj.min)/20 : obj.step);
					for (i=obj.min; i<obj.max; i=i+step) {
						stepArray.push(obj.min + i);
					}
				} else if (obj.type == "Stepper") {
					stepArray = obj.stepperArray;
				} else if (obj.type == "ColorPicker") {
					stepArray = obj.colors;
				}
				tabTag = document.createElement("select");
				tabTag.disabled = true;
				tabTag.zimObject = obj;
				tabTag.addEventListener("change", function(e) {
					if (!_aria && !mobile=="android") return;
					e.currentTarget.zimObject.zimTabParent.currentValueEvent = e.target.value;
					frame.stage.update();
				});
				tabTag.size = 1;
				var el;
				var op;
				for (i=0; i<stepArray.length; i++) {
					el = stepArray[i];
					op = document.createElement("option");
					op.setAttribute("aria-label", el);
					op.innerHTML = el;
					tabTag.add(op);
					if (el == obj.zimTabParent.currentValue) op.setAttribute("selected", "selected");
				}
				tabTag.setAttribute("role", "button");
			} else {
				tabTag = document.createElement("div");
				if (obj) tabTag.zimObject = obj;
				tabTag.innerHTML = "tag"; // needs to have text for ipad to read it
				// tabTag.setAttribute("role", (obj&&obj.type=="Button"&&application)?"application":"button");
				tabTag.setAttribute("role", application?"application":"button");
				if (mobile=="android") {
					tabTag.addEventListener("click", function() {
						obj.dispatchEvent("click");
					});
				}
			}
			tabTag.setAttribute("id", id);
			tabTag.setAttribute("tabindex", 0);
			tabTag.setAttribute("aria-label", title);
			if (obj) tabTag.setAttribute("aria-hidden", !obj.stage);

			if (place == "before") {
				targetTag.parentNode.insertBefore(tabTag, targetTag);
			} else {
				targetTag.parentNode.insertBefore(tabTag, targetTag.nextSibling);
			}
			tabTag.style.position = "absolute";
			if (item) {
				obj = item.obj;
				var bounds = obj.boundsToGlobal();
				if (frame.retina) {
					tabTag.style.left = (frame.x + bounds.x*frame.scale/pRatio)+"px";
					tabTag.style.top = (frame.y + bounds.y*frame.scale/pRatio)+"px";
					tabTag.style.width = (bounds.width*frame.scale/pRatio)+"px";
					tabTag.style.height = (bounds.height*frame.scale/pRatio)+"px";
				} else {
					tabTag.style.left = (frame.x + bounds.x * frame.scale)+"px";
					tabTag.style.top = (frame.y + bounds.y * frame.scale)+"px";
					tabTag.style.width = (bounds.width * frame.scale)+"px";
					tabTag.style.height = (bounds.height * frame.scale)+"px";
				}
				item.obj.zimTabTag = tabTag;
			} else {
				tabTag.style.left = -1000+"px";
				tabTag.style.top = frame.y+"px";
			}
			tabTag.style.overflow = "hidden";
			tabTag.style.zIndex = -5;
			tabTag.style.fontSize = "20px";
			tabTag.style.color = "rgba(0,0,0,.01)";

			tabTags.push(tabTag);
			return tabTag;
		}

		// keydown event to handle tab, enter and arrows for various objects
		var tabFocus = false;
		var tabFirstCheck = true;
		var tabFrameEvent = frame.on("keydown", function(e) {
			if (e.keyCode==9) {
				if (!checkTabs()) { // check focus has not been given outside frame canvas
					tabFocus = false;
					if (that.tabIndex != -1) that.tabIndex = -1;
				}
				if (tabFocus) {
					goTabs(e);
				} else {
					setTabs(e);
				}
			}

			// area for special keys ENTER, ARROWS if frame has tabFocus, etc.
			if (tabFocus && _tabOrder.length > 0 && that.tabIndex >= 0) {

				// ENTER key
				if (e.keyCode==13) {
					var item = _tabOrder[that.tabIndex];
					var obj = item.obj;
					if (item && obj.stage) {
						var downEvent = new createjs.Event("mousedown");
						var clickEvent = new createjs.Event("click");
						downEvent.fromEnter = clickEvent.fromEnter = true;
						if (obj.type == "Pane") {
							obj.backdrop.dispatchEvent(downEvent); // on backdrop
							obj.backdrop.dispatchEvent(clickEvent);
						} else {
							obj.dispatchEvent(downEvent);
							obj.dispatchEvent(clickEvent);
						}
					}
				}

			} // end special keys (not tab)

		}); // keydown event


		// function to check if any other HTML tag or other Frame currently has taken focus
		// this is not called immediately when focus is lost but rather on next keydown event with tab key pressed
		function checkTabs() {
			var frameTagFocus = false;
			for (var i=0; i<tabTags.length; i++) {
				if (document.activeElement == tabTags[i]) {
					frameTagFocus = true;
					break;
				}
			}
			if (document.activeElement == frame.canvas || frameTagFocus) return true;
			return false;
		}

		// function to test for tab key event when currently on PrefixTab or SuffixTab for frame
		// will then set up tabFocus and send focus to right object with goTabs()
		function setTabs(e) {
			if (!frame.shiftKey && (zid(canvasID+"PrefixTab") == document.activeElement || frame.canvas == document.activeElement)) {
				// this means tabbing forward and arriving at canvas
				// set tab to last tabTag on canvas so next goes to first tabTag
				if (_tabOrder.length > 0) _tabOrder[_tabOrder.length-1].obj.focus = true;
				tabFirstCheck = true;
				tabFocus = true;
				goTabs(e);
			} else if (frame.shiftKey && (zid(canvasID+"SuffixTab") == document.activeElement || zid(canvasID+"BufferTab") == document.activeElement)) {
				// this means tabbing with shift and arriving at SuffixTab
				// so set to first tabTag so goTabs loops backwards around to last tabTag
				// as long as tabFirstCheck is true
				// we have entered the canvas so set the tabFocus to true
				if (_tabOrder.length > 0) _tabOrder[0].obj.focus = true;
				tabFirstCheck = true;
				tabFocus = true;
				goTabs(e);
			}
		}

		// function to call tab() used by setTabs and keydown when tabs are already set
		function goTabs(e) {
			if (e.ctrlKey) {
				focusToDoc(e.shiftKey?-1:1);
				return;
			}
			if (e.shiftKey) that.tab(-1);
			else that.tab(1);
			e.preventDefault();
		}

		// method to move to next or previous tab - called from goTabs() or by user
		var tabTimeout;
		this.tab = function(dir) {
			clearTimeout(tabTimeout);
			if (currentHighlight) frame.stage.removeChild(currentHighlight);
			if (zot(dir)) dir = 1;
			if (_tabOrder.length == 0) {
				focusToDoc(dir);
				return;
			}
			for (var i=0; i<_tabOrder.length; i++) {
				var obj = _tabOrder[i].obj;
				if (obj.focus) {
					obj.focus = false;
					var index = i + dir;
					var normalizedIndex = (index+_tabOrder.length*10000)%_tabOrder.length;
					var tabData = _tabOrder[normalizedIndex];
					obj = tabData.obj;

					// make sure on stage
					var attempts = 0;
					var badTabs = false;
					// keep looking if the object t is not on the stage or is not enabled (or parent is not enabled if it has one)
					while(!(obj.stage && ((!obj.zimTabParent && (zot(obj.enabled) || obj.enabled)) || (obj.zimTabParent && (zot(obj.zimTabParent.enabled) || obj.zimTabParent.enabled))))) {
						attempts++;
						index = index + dir;
						normalizedIndex = (index+_tabOrder.length*100)%_tabOrder.length;
						tabData = _tabOrder[normalizedIndex];
						obj = tabData.obj;
						if (attempts == _tabOrder.length) { // none on stage
							badTabs = true;
							break;
						}
					}
					if (badTabs || (!that.cycle && index != normalizedIndex && !tabFirstCheck)) {
						focusToDoc(dir);
						return;
					}
					tabFirstCheck = false;
					that.tabIndex = normalizedIndex;
					break;
				}
			}
		};

		// function to give focus to html doc when no more frame tabs left in direction we are tabbing
		function focusToDoc(dir) {
			tabFocus = false;
			zid(canvasID + (dir==1 ? "SuffixTab" : "PrefixTab") ).focus();
			frame.stage.removeChild(AHObject);
			frame.stage.update();
			that.tabIndex = -1;
		}

		// target is tabIndex or obj
		this.changeTitle = function(target, title, activate) {
			if (typeof target != "number") target = target.zimTabIndex;
			if (zot(target)) return;
			if (activate && zot(title)) {that.tabIndex = target; return;} // changeTitle is called from within tabIndex setter function (without the activate part...)
			var item = _tabOrder[target];
			var obj = item.obj;
			// when passing no title will be coming from component for title update due to change in component
			// if you want no title, then pass "" as title
			if (zot(title)) title = obj.zimTabTag.getAttribute("aria-label").split(" - currently")[0];
			item.title = title;
			addExtraTitle(item);
			obj.zimTabTag.setAttribute("aria-label", item.title);
			if (activate) that.tabIndex = target;
		};
		var talkCheck = false;
		this.talk = function(words) {
			// talk tag
			// this prevents talk tag from being read at the start - activate it once we need to talk
			// then we set the innerHTML to "" when we swipe focus to start or end app on the way out
			// we may still get the tag read on mobile if they exit the app through some other tag
			// and then swipe focus towards end of app - as it is just after the end of app
			// this will then re-read the message... but it is unlikely, and did not see a way around it
			if (!talkCheck) {
				talkTag = makeTabTag(canvasID+"TalkTab", "", suffixTab);
				talkTag.setAttribute("role", "alert");
				talkCheck = true;
			}

			// talk tag is role alert which allows it to talk without removing focus
			// the tag is aria-hidden for aria == false

			// Nathan fix
			talkTag.removeAttribute("role");
			talkTag.setAttribute("aria-label", words);
			talkTag.setAttribute("role", "alert");

			var readerEvent = new createjs.Event("change");
			// TODO - remove talk in front of event
			readerEvent.title = words;
			that.dispatchEvent(readerEvent);
		};

		this.resize = function(target) {
			if (!zot(target)) {
				if (typeof target != "number") target = target.zimTabIndex;
				if (target < 0) return;
				var item = _tabOrder[target];
				var obj = item.obj;
				if (!obj.stage && currentHighlight && obj==that.currentObject) {
					frame.stage.removeChild(currentHighlight);
					frame.stage.update();
				}
				// if (that.alwaysHighlight && !zot(_aria)) return; // commented in 10.9.0
				resizeObj(obj);
			} else {
				// commented in 10.9.0 - we may have just been saving work
				// but notice on occassion that tags are being seen next to frame - so always resize
				// if (that.alwaysHighlight && !zot(_aria)) return;
				for (var i=0; i<_tabOrder.length; i++) {
					resizeObj(_tabOrder[i].obj);
				}
			}
			function resizeObj(obj) {
				if (obj.type == "TextArea" || obj.type == "Loader") {
					obj.resize();
					return;
				} else {
					var bounds = obj.boundsToGlobal();
					var tabTag = obj.zimTabTag;
					if (frame.retina) {
						tabTag.style.left = (frame.x + bounds.x*frame.scale/pRatio)+"px";
						tabTag.style.top = (frame.y + bounds.y*frame.scale/pRatio)+"px";
						tabTag.style.width = (bounds.width*frame.scale/pRatio)+"px";
						tabTag.style.height = (bounds.height*frame.scale/pRatio)+"px";
					} else {
						tabTag.style.left = (frame.x + bounds.x * frame.scale/pRatio/pRatio)+"px";
						tabTag.style.top = (frame.y + bounds.y * frame.scale/pRatio/pRatio)+"px";
						tabTag.style.width = (bounds.width * frame.scale/pRatio/pRatio)+"px";
						tabTag.style.height = (bounds.height * frame.scale/pRatio/pRatio)+"px";
					}
				}
				tabTag.setAttribute("aria-hidden", !obj.stage);
				tabTag.hidden = !obj.stage;
			}
		};

		Object.defineProperty(this, 'currentObject', {
			get: function() {
				if (_tabOrder[_tabIndex] && _tabOrder[_tabIndex].obj) return _tabOrder[_tabIndex].obj;
				else return null;
			},
			set: function(obj) {
				for (var i=0; i<_tabOrder.length; i++) {
					if (_tabOrder[i].obj == obj) {that.tabIndex = i; break;}
				}
			}
		});

		var _state = true;
		Object.defineProperty(this, 'enabled', {
			get: function() {
				return _state;
			},
			set: function(state) {
				_state = state;
			}
		});

		this.dispose = function() {
			if (alwaysHighlightShape) alwaysHighlightShape.graphics.clear();
			that.tabOrder = [];
			for (var i=0; i<tabTags.length; i++) if (tabTags[i].parentElement) tabTags[i].outerHTML = "";
			// remove the invisible tags...
			removeOuterTags();
			that.removeAllEventListeners();
			frame.off("keydown", tabFrameEvent);
		};
	};
	zim.extend(zim.Accessibility, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-30.5

// SUBSECTION 3D

/*--
zim.TextureActive = function(width, height, color, color2, angle, borderColor, borderWidth, corner, interactive, animated, backingOrbit, pattern, scalePattern, style, group, inherit)

TextureActive
zim class extends a zim Page which extends a ZIM Container which extends a createjs Container

DESCRIPTION
A TextureActive object is a Container that can be used as a CanvasMaterial in three.js.
This allows ZIM to be mapped onto any material and mesh in three.js.
For instance, ZIM can be used as interface panels in virtual reality.
Any material can be made interactive so games and puzzles could be on walls, or any models.
This has world-wide wonderful applications!

NOTE: used with three.js

WORKINGS
The TextureActive object can be passed into a ZIM TextureActives() object to be made interactive.
The TextureActives object uses raycasting on the three.js material to provide CreateJS x and y coordinates.
The three.js mesh must be passed to the TextureActives addMesh() method.
The ZIM CreateJS 1.4.0 and later must be used as there are two settings:
createjs.remotePointers and createjs.remoteQueue 
These prepare CreateJS to receive x and y from three.js and update TextureActive cache and material needsUpdate flag.

SEE:
https://zimjs.com/015/textureactive.html - panel with various components
https://zimjs.com/015/textureactive_raw.html - same but without ZIM Three
https://zimjs.com/015/textureactive2.html - first person interactive cylinders
https://zimjs.com/015/textureactive3.html - model with scrambler
https://zimjs.com/015/textureactive4.html - HUD, Noise, Synth
https://zimjs.com/015/textureactive5.html - Physics
https://zimjs.com/015/textureactive_hud.html - HUD affecting three object
https://zimjs.com/015/textureactive_hud_raw.html - same but without ZIM Three 

XR
TextureActive will detect if XR (AR/VR) is being used and will use the suitable Raycaster
Additional classes are provided with the ZIM Three helper library for controllers, movement and teleport 

SEE: 
https://zimjs.com/015/vr.html - for example with Three and controllers (trigger), movement (sticks and squeeze) and teleport (B and Y buttons)


EXAMPLE 
import zim from "https://zimjs.org/cdn/015/zim_three";

new Frame(FIT, 1024, 768, darker, purple, ready);
function ready() {

	// PANEL
	const panel = new TextureActive({
		width:W,
		height:H,
		color:white.toAlpha(.8),
		corner:20
	});
	const circle = new Circle(100,red).center(panel).drag(); 

	// BACK OF PANEL
    const backing = new TextureActive({
        width:panel.width,
        height:panel.height,
        color:black,
        corner:20,
        animated:false,
        interactive:false
    });
    TextureActive.makeBacking(backing.width, backing.height).addTo(backing); // CANVAS WINDOW

	const three = new Three({
        width:window.innerWidth, 
        height:window.innerHeight, 
        cameraPosition:new THREE.Vector3(0,0,500),
        textureActive:true
    });

    const renderer = three.renderer;
    const scene = three.scene;
    const camera = three.camera;

    const controls = new OrbitControls(camera, three.canvas);

    const textureActives = new TextureActives([panel, backing], THREE, three, renderer, scene, camera, controls, 1, 0, 1500);

    // can capture raydown, raymove, rayup, rayover and rayout
    textureActives.on("raymove", e=>{
        // zog(e.intersect.distance);
    });

    const canvasWindow = three.makePanel(panel, textureActives);
    scene.add(canvasWindow);

    // BACK OF PANEL
    const canvasWindowBacking = three.makePanel(backing, textureActives, true, .5) // transparent and alpha  
    scene.add(canvasWindowBacking);
    canvasWindowBacking.rotation.y = 180*RAD; // flip it around the other way
    
    // // IGNORE LIST
    // // The ignoreList is handy if you want to interact with TextureActives through objects on the same layer
    // // uncomment below to see an example of ignoring the red plane mesh so raycast will go right through to menu 
    // // note, this would be simpler to test if we did not apply the layer of 1 to the TextureActives
    // // because if we did not set the mesh on layer 1 then it would already be ignored ;-) 
    // // keep the ignoreList commented to see that the red plane does not let the raycast past 
    // // and therefore activates the orbit controls.
   
    // const geometry = new THREE.PlaneGeometry(100, 100, 1, 1); 
    // const material = new THREE.MeshBasicMaterial({
    //     color:0xcc0000
    // });
    // const way = new THREE.Mesh(geometry, material);           
    // scene.add(way);  
    // camera.layers.enable(1);
    // way.layers.set(1);
    // way.position.z = 50;
    // textureActives.ignoreList = [way];

} // end ready
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
width - (default zimDefaultFrame.width) the width of the TextureActive
	but backing is sized to screen.width if no width is provided
height - (default zimDefaultFrame.height) the height of the Page
	but backing is sized to screen.height if no height is provided
color - (default zim.light) the color of the TextureActive
color2 - (default null) a second color which would form a zim.GradientColor() as the color
angle - (default 90) the angle for the gradient if there is a gradient
borderColor - (default null) the stroke color
borderWidth - (default 1 if stroke is set) the size of the stroke in pixels
corner - (default 0) the round of corner
   can also be an array of [topLeft, topRight, bottomRight, bottomLeft]
   inside this array can be arrays of [horizontal, vertical] which skews each corner
   can also be a combination array of values and skew arrays
   [topLeft, [horizontal, vertical], bottomRight, [horizontal, vertical]]
interactive - (default true) set to false to not be interactive 
	interactive will use raycasting in the TextureActives object 
	to provide x and y to CreateJS which is then used by ZIM
animated - (default true) set to false if no animation is necessary 
	note that the animation will be true if interactive is true 
	this tells ZIM to update the cache of the TextureActive every stage update
backingOrbit - (default true) set to false to not allow oribitControls to rotate when pressed on backing
pattern - (default null) a DisplayObject that will be added to the TextureActive above the backing
	For instance, import zim_pizzazz and use:
	makePattern("slants", series(grey,dark), 20, 52, 40).alp(.2)
scalePattern - (default "fill") scale the pattern so it fills the window (formerly "bigger" or "outside")
	set to false for no scaling or:
	FIT or "fit" fits inside the TextureActive keeping proportion (formerly "smallest")
   	FILL or "fill" fills the TextureActive keeping proportion (formerly "biggest" or "outside")
   	FULL or "full" keeps both x and y scales - may stretch object (formerly "both")
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone() - makes a copy with properties such as x, y, etc. also copied - note, contents are not cloned
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

STATIC METHODS 
makeLogo(shade, mouse) - make the ZIM TextureActive logo 
	shade is "light" (default) or "dark" and mouse is true or false (default) to receive interactivity
	used on the class like so: TextureActive.makeLogo().pos(0,50,CENTER,TOP,textureActive)
	See the top of the https://zimjs.com/015/textureactives.html panel
makeBacking(width, height, text, color) - make a ZIM icon for the backing of a panel 
	width and height default to 800 x 600 
	the text defaults to "CANVAS WINDOW" 
	and the color defaults to light.
	See the back of the https://zimjs.com/015/textureactives.html panel

PROPERTIES
type - holds the class name as a String
interactive - get whether the TextureActive is interactive
animated- get whether the TextureActive is animated
backingOrbit - get and set whether the TextureActive backing is controlled by orbit controls

ALSO: See ZIM Page for properties such as:
backing, pattern, color 

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+35.2

zim.TextureActive = function(width, height, color, color2, angle, borderColor, borderWidth, corner, interactive, animated, backingOrbit, pattern, scalePattern, style, group, inherit) {
	var sig = "width, height, color, color2, angle, borderColor, borderWidth, corner, interactive, animated, backingOrbit, pattern, scalePattern, style, group, inherit";
	var duo; if (duo = zob(zim.TextureActive, arguments, sig, this)) return duo;   
	z_d("35.2");

	this.group = group;
	var DS = style===false?{}:zim.getStyle("TextureActive", this.group, inherit);

	if (zot(width)) width=DS.width!=null?DS.width:WW.zdf.width;
	if (zot(height)) height=DS.height!=null?DS.height:WW.zdf.height;
	if (zot(interactive)) interactive=DS.interactive!=null?DS.interactive:true;
	if (zot(animated)) animated=DS.animated!=null?DS.animated:true;
	if (zot(color)) color=DS.color!=null?DS.color:null;
	if (zot(color2)) color2=DS.color2!=null?DS.color2:null;
	if (zot(angle)) angle=DS.angle!=null?DS.angle:null;
	if (zot(borderColor)) borderColor=DS.borderColor!=null?DS.borderColor:null;
	if (zot(borderWidth)) borderWidth=DS.borderWidth!=null?DS.borderWidth:null;
	if (borderColor < 0 || borderWidth < 0) borderColor = borderWidth = null;
	else if (borderColor!=null && borderWidth==null) borderWidth = 1;
	if (zot(corner)) corner=DS.corner!=null?DS.corner:10;
	if (zot(backingOrbit)) backingOrbit=DS.backingOrbit!=null?DS.backingOrbit:true;
	if (zot(pattern)) pattern=DS.pattern!=null?DS.pattern:null;
	if (zot(scalePattern)) scalePattern=DS.scalePattern!=null?DS.scalePattern:null;

	this.zimPage_constructor(width, height, color, color2, angle, pattern, scalePattern, null, style, group, inherit);
	this.type = "TextureActive";

	if (corner) this.backing.corner = corner;
	if (!zot(borderWidth)) this.backing.borderWidth = borderWidth;
	if (!zot(borderColor)) this.backing.borderColor = borderColor;   
	if (borderWidth || !zot(borderColor)) {
		this.backing.siz(this.width-borderWidth, this.height-borderWidth);
		this.backing.center();
	}        

	this.backing.mouseChildren = false;
	this.interactive = interactive;
	this.animated = animated;
	this.backingOrbit = backingOrbit;

	if (style!==false) zim.styleTransforms(this, DS);

	this.dispose = function(a,b,disposing) {
		if (this.textureActives) this.textureActives.remove(this);
		if (!disposing) this.zimPage_dispose(true);
	}

	this.clone = function() {
		return this.cloneProps(new zim.TextureActive(width, height, color, color2, angle, borderColor, borderWidth, corner, interactive, animated, backingOrbit, pattern, scalePattern, style, this.group, inherit));
	};
}
zim.extend(zim.TextureActive, zim.Page, ["clone","dispose"], "zimPage", false);
zim.TextureActive.makeLogo = function(shade, mouse) {
	if (zot(shade)) shade = "light";
	var onLight = shade != "dark";
	var c1 = onLight?zim.light:zim.dark;
	var c2 = onLight?zim.dark:zim.light;
	var c3 = onLight?zim.white:zim.black;
	var c4 = onLight?zim.black:zim.white;
	var logo = new zim.Container(400,100);   
	var icon = WW.zdf.makeIcon(c1,c2,[c1,c1,c1,c1,c1]).ske(0,30).scaleTo(logo,100,100).center(logo);
	var b1 = new zim.Rectangle((400-icon.width)/2+4, 80-10, new zim.GradientColor([onLight?c1:c3,onLight?c3:c1,onLight?c1:c3],-70), c4, .5).addTo(logo);
	var b2 = b1.clone().pos(0,0,"right","bottom",logo);
	new zim.Label({text:"Texture", size:50, color:c2, variant:true}).scaleTo(b1,75,75).center(b1);
	new zim.Label({text:"Active", size:50, color:c2, variant:true}).scaleTo(b1,72,72).center(b2);
	if (!mouse) return logo.noMouse();
	return logo;
}
zim.TextureActive.makeBacking = function(width, height, text, color) {
	if (zot(width)) width = 800;
	if (zot(height)) height = 600;
	if (zot(text)) text = "CANVAS WINDOW";
	if (zot(color)) color = zim.light;
	var backing = new zim.Container(width, height);
	backing.icon = WW.zdf.makeIcon({box:black}).sca(2);
	backing.label = new zim.Label({text:text, size:25, color:color, align:"center"}).reg("center");
	backing.tile = new zim.Tile({
		obj:[backing.icon, backing.label], 
		rows:2, 
		spacingV:24, 
		unique:true,
		align:CENTER
	}).scaleTo(backing, 50, 70).center(backing);
	backing.tile.items[1].mov(0,10);
	return backing;
}
//-35.2

/*--
zim.TextureActives = function(actives, threejs, zimThree, renderer, scene, camera, controls, layers, near, far, ignoreList, toggleKey, color, outerColor, damp, style, group, inherit)

TextureActives
zim class extends a createjs EventDispatcher

DESCRIPTION
The ZIM TextureActive system allows ZIM to be used within three.js 
as a CanvasTexture for any material in any mesh.
This can be animated and interacted with.
For instance, ZIM can be used as interface panels in virtual reality.
Any material can be made interactive so games and puzzles could be on walls, or any models.
This has world-wide wonderful applications!

TextureActives applies the interactivity to TextureActive objects
and has an addMesh() method to register three.js meshes with their TextureActive 
A TextureActives object must be made after the TextureActive objects are made 
and after a three.js renderer, scene, camera and constrols are made.
But it can be made before the meshes that use the TextureActive objects are made.
Then either a Three.makePanel() or a textureActives.addMesh() method can be used to add TextureActive objects.

NOTE: used with three.js

WORKINGS
The TextureActive object can be passed into a ZIM TextureActives() object to be made interactive.
The TextureActives object uses raycasting on the three.js material to provide CreateJS x and y coordinates.
The three.js mesh must be passed to the TextureActives addMesh() method.
The ZIM CreateJS 1.4.0 and later must be used as there are two settings:
createjs.remotePointers and createjs.remoteQueue 
These prepare CreateJS to receive x and y from three.js and update TextureActive cache and material needsUpdate flag.

SEE:
https://zimjs.com/015/textureactive.html - panel with various components
https://zimjs.com/015/textureactive_raw.html - same but without ZIM Three
https://zimjs.com/015/textureactive2.html - first person interactive cylinders
https://zimjs.com/015/textureactive3.html - model with scrambler
https://zimjs.com/015/textureactive4.html - HUD, Noise, Synth
https://zimjs.com/015/textureactive5.html - Physics
https://zimjs.com/015/textureactive_hud.html - HUD affecting three object
https://zimjs.com/015/textureactive_hud_raw.html - same but without ZIM Three 

XR
TextureActive will detect if XR (AR/VR) is being used and will use the suitable Raycaster
Additional classes are provided with the ZIM Three helper library for controllers, movement and teleport 

NOTE: for XR, a layer must be set so the controllers do not get in the way of interactivity
so in the TextureActives() set layer:1 and when adding meshes use addMesh(mesh, 1)

SEE: 
https://zimjs.com/015/vr.html - for example with Three and controllers (trigger), movement (sticks and squeeze) and teleport (B and Y buttons)


EXAMPLE (not XR)
import zim from "https://zimjs.org/cdn/015/zim_three";

new Frame(FIT, 1024, 768, darker, purple, ready);
function ready() {

// PANEL
const panel = new TextureActive({
	width:W,
	height:H,
	color:white.toAlpha(.8),
	corner:20
});
const circle = new Circle(100,red).center(panel).drag(); 

// BACK OF PANEL
const backing = new TextureActive({
	width:panel.width,
	height:panel.height,
	color:black,
	corner:20,
	animated:false,
	interactive:false
});
TextureActive.makeBacking(backing.width, backing.height).addTo(backing); // CANVAS WINDOW

const three = new Three({
	width:window.innerWidth, 
	height:window.innerHeight, 
	cameraPosition:new THREE.Vector3(0,0,500),
	textureActive:true
});

const renderer = three.renderer;
const scene = three.scene;
const camera = three.camera;

const controls = new OrbitControls(camera, three.canvas);

const textureActives = new TextureActives([panel, backing], THREE, three, renderer, scene, camera, controls, 1, 0, 1500);

// can capture raydown, raymove, rayup, rayover and rayout
textureActives.on("raymove", e=>{
	// zog(e.intersect.distance);
});

const canvasWindow = three.makePanel(panel, textureActives);
scene.add(canvasWindow);

// BACK OF PANEL
const canvasWindowBacking = three.makePanel(backing, textureActives, true, .5) // transparent and alpha  
scene.add(canvasWindowBacking);
canvasWindowBacking.rotation.y = 180*RAD; // flip it around the other way

// // IGNORE LIST
// // The ignoreList is handy if you want to interact with TextureActives through objects on the same layer
// // uncomment below to see an example of ignoring the red plane mesh so raycast will go right through to menu 
// // note, this would be simpler to test if we did not apply the layer of 1 to the TextureActives
// // because if we did not set the mesh on layer 1 then it would already be ignored ;-) 
// // keep the ignoreList commented to see that the red plane does not let the raycast past 
// // and therefore activates the orbit controls.

// const geometry = new THREE.PlaneGeometry(100, 100, 1, 1); 
// const material = new THREE.MeshBasicMaterial({
//     color:0xcc0000
// });
// const way = new THREE.Mesh(geometry, material);           
// scene.add(way);  
// camera.layers.enable(1);
// way.layers.set(1);
// way.position.z = 50;
// textureActives.ignoreList = [way];

} // end ready
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
actives - a ZIM TextureActive object or an array of ZIM TextureActive objects
	also see the add() method 
	these will be tiled in ZIM and used to be mapped as a CanvasTexture onto three.js materials for meshes
	see https://zimjs.com/docs.html?item=TextureActive
threejs - reference to the three.js namespace
zimThree - (default null) reference to the ZIM Three object if the Three helper module is used (saves lots of lines!)
renderer - reference to the three.js renderer (if using Three, then three.renderer)
scene - reference to the three.js scene (if using Three, then three.scene)
	if using more than one scene then make more than one TexureActives object
camera - reference to the three.js camera (if using Three, then three.camera)
	if using more than one camera then make more than one TexureActives object
controls - (default null) a three.js OrbitControls or FirstPersonControls 
	other controls may work but are not directly accomodated
layers - (default 0) a layer number from 0 to 31 or an array of layers 
	this will instruct the raycaster to look at only the provided layers
	it is a good idea to specify 1 for instance and add TexureActive meshes to layer 1 
	the addMesh() method has a layer parameter that should match the layer number used here 
	the Three makePanel() method will automatically add the panel mesh to the layer specified for the TextureActives object
	NOTE: for XR, layers must be set so the controls do not get in the way of interactivity
near - (default undefined) - the start of the distance-from-camera range for the object to be interactive
far - (default undefined) - the end of the distance-from-camera range for the object to be interactive
ignoreList - (default null) - a mesh or array of meshes to ignore if between the camera and the TextureActive mesh 
	by default, meshes on the same layer will prevent interactivity if between the camera and the TextureActive mesh
	if the mesh is not on the same layer then it will be ignored by default
toggleKey - (default t) the key to toggle to or from the ZIM canvas and the three.js canvas
	this can be used to directly interact with the ZIM objects - good for testing 
	the ZIM objects are tiled horizontally with a slider or swiping to pan across them 
	the toggle can be deactivated by setting it to -1 
	or any time by setting the textureActives.manager.toggleKey to -1
	the ZIM canvas and toggling is handled by the ZIM TextureActivesManager
	which is automatically made as soon as one TextureActives object is made
color - (default darker) the color for the ZIM stage (when the toggle key is pressed)
outerColor - (default black) the color of off the ZIM stage (when the toggle key is pressed)
damp - (default .2) the damping of the TextureActivesManager - set to false for no damping
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
add(actives) - add a ZIM TextureActive object or an array of ZIM TextureActive objects
	or see the actives parameter of TextureActives
remove(actives) - remove a ZIM TextureActive object or an array of ZIM TextureActive objects
addMesh(mesh, layer) - add a three.js mesh to TextureActives at the optional layer - see the layer parameter of TextureActives 
	also see the ZIM Three helper module makePanel() method to easily make a three.js Plane mesh with a TextureActive
dispose() - removes event listeners - must still set outside references to null for garbage collection

PROPERTIES
type - holds the class name as a String
interactive - get whether there are interactive TextureActive objects
animated - get whether there are animated TextureActive objects
manager - the ZIM TexureActivesManager object that handles toggling between the three.js canvas and the ZIM canvas 
	this is used to interact directly with ZIM for testing, etc.
	and can be used to toggle between states and change or remove the key for toggling 
ignoreList - get or set the array of three.js meshes to ignore - see the ignoreList parameter of TextureActives
raycaster - a reference to the three.Raycaster object if the TextureActives is interactive
	this is responsible for geting x and y coordinates on TextureActive materials and sending them to CreateJS
	where they replace the regular DOM mouse or pointer events
raycast - get or set whether the raycaster is operational
renderer - the three.js renderer
layers - get an array of layers used by the raycaster
actives - get an array of ZIM TextureActive objects currently being used - see add() and remove()
threeMeshes - get an array of three.js meshes currently being used - see addMesh() and add() and remove()

EVENTS
raydown - dispatched when mouse is down on a ZIM TextureActive material
raymove - dispatched when mouse is moving on a ZIM TextureActive material
rayup - dispatched when mouse is up on a ZIM TextureActive material
rayover - dispatched when mouse is moves over a ZIM TextureActive material
rayout - dispatched when mouse is moves out from a ZIM TextureActive material
--*///+35.4

zim.TextureActives = function(actives, threejs, zimThree, renderer, scene, camera, controls, layers, near, far, ignoreList, toggleKey, color, outerColor, damp, style, group, inherit) {
var sig = "actives, threejs, zimThree, renderer, scene, camera, controls, layers, near, far, ignoreList, toggleKey, color, outerColor, damp, style, group, inherit";
var duo; if (duo = zob(zim.TextureActives, arguments, sig, this)) return duo;   
z_d("35.4");

this.group = group;
var DS = style===false?{}:zim.getStyle("TextureActives", this.group, inherit);

var stage, frame;
var message = "ZIM TextureActives - need a ZIM Frame";
if (zot(actives) && zot(actives[0])) {
	if (WW.zdf) {
		frame = WW.zdf;
		stage = WW.zdf.stage;
	} else {
		zogy(message);
		return;
	}
} else if (zot(actives) || zot(actives[0]) || zot(actives[0].stage)) {
	if (WW.zdf) {
		frame = WW.zdf;
		stage = WW.zdf.stage;
	} else {
		zogy(message);
		return;
	}
} else {
	stage = actives[0].stage;
	frame = stage.frame;
}	

if (zot(actives)) actives=DS.actives!=null?DS.actives:null;   
if (zot(threejs)) threejs=DS.threejs!=null?DS.threejs:null;   
if (zot(zimThree)) zimThree=DS.zimThree!=null?DS.zimThree:null;   
if (zot(renderer)) renderer=DS.renderer!=null?DS.renderer:null;   
if (zot(scene)) scene=DS.scene!=null?DS.scene:null;   
if (zot(camera)) camera=DS.camera!=null?DS.camera:null;   
if (zot(controls)) controls=DS.controls!=null?DS.controls:null;   
if (zot(layers)) layers=DS.layers!=null?DS.layers:[];  
if (!Array.isArray(layers)) layers = [layers]; 
if (zot(near)) near=DS.near!=null?DS.near:undefined;   
if (zot(far)) far=DS.far!=null?DS.far:undefined;   
if (zot(ignoreList)) ignoreList=DS.ignoreList!=null?DS.ignoreList:[];  
if (!Array.isArray(ignoreList)) ignoreList = [ignoreList];
if (zot(toggleKey)) toggleKey=DS.toggleKey!=null?DS.toggleKey:"t";  
if (zot(color)) color=DS.color!=null?DS.color:zim.darker;  
if (zot(outerColor)) outerColor=DS.outerColor!=null?DS.outerColor:"black";  
if (zot(damp)) damp=DS.damp!=null?DS.damp:null; 

var that = this;

if (!zim.TAM) {
	zim.TAM = new zim.TextureActivesManager(stage, toggleKey, damp);
	// seems to be needed to let certain interactions happen like ZIM TextInput
	if (renderer && renderer.domElement) renderer.domElement.addEventListener("mousedown", function(e) {
		e.preventDefault();
	});
}
that.manager = zim.TAM; 

this.ignoreList = ignoreList;
this.raycast = true;
this.renderer = renderer;
this.layers = layers;

this.animated = false;
this.interactive = false;
this.actives = [];
this.threeMeshes = []; 
var applied = false;

// also used by add() method
function addActives(actives) {
	if (zot(actives)) actives = [];
	if (!Array.isArray(actives)) actives = [actives];
	var count = 0;
	var interactive;
	var animated;
	zim.loop(actives, function(active) {
		if (that.actives.indexOf(active) < 0) {
			that.actives.push(active);                    
			active.cache();        
			active.textureActives = that;    
			active.canvas.content = active;    
			if (active.interactive) {
				interactive = true;
				active.canvas.isTextureActive = true;
			}
			if (active.animated) animated = true;                        
			count++;
		}
	});
	if (interactive && !that.interactive) {
		that.interactive = true;
		if (count > 0) apply();
	}
	if (animated && !that.animated) that.animated = true;
	return count;
} 
addActives(actives);

zim.TAM.updateTile(that, that.actives);
zim.TAM.color = color;
zim.TAM.outerColor = outerColor;

frame.canvas.style.display = "none";		


function apply () {

	if (applied) return; // apply only once
	applied = true;
	
	// activate raycasts mapping to createjs pointers
	// renderer.domElement is needed to add css cursors 
	// stage is needed to disable dom events on stage
	if (!that.pointerCheck) that.pointerCheck = zim.TAM.addPointer(that);            

	that.pointerData = {x:frame.mouseX, y:frame.mouseY, mousedown:false};

	var startW = window.innerWidth;
	var startH = window.innerHeight;
	var lastMesh=-1;
	var overMesh=-2;
	var lastMaterial=-1;
	var overMaterial=-2;
	that.overInterval = zim.interval(.05, function() {
		if ((overMesh && overMesh != lastMesh) || (overMaterial && overMaterial != lastMaterial)) {
			var e = new createjs.Event("rayover");
			e.mesh = that.mesh = overMesh;
			e.material = that.material = overMaterial;
			if (overMaterial.userData) e.textureActive = that.textureActive = overMaterial.userData.ta_content;
			e.intersect = that.intersect;
			that.dispatchEvent(e);
			if (controls && !controls.screenSpacePanning) controls.activeLook = false;  // firstPersonControls only  
		} else if ((!overMesh && lastMesh) || (!overMaterial && lastMaterial)) {
			var e = new createjs.Event("rayout");
			e.mesh = lastMesh;
			e.material = lastMaterial;
			if (lastMaterial.userData) e.textureActive = lastMaterial.userData.ta_content;
			e.intersect = that.intersect;
			that.dispatchEvent(e);
			if (controls && !controls.screenSpacePanning) controls.activeLook = true;  // firstPersonControls only  
		}
		lastMesh = overMesh;
		lastMaterial = overMaterial;
	});

	var raycaster = that.raycaster = new threejs.Raycaster(undefined, undefined, near, far);   
	if (layers.length > 0) {
		zim.loop(layers, function(layer) {
			raycaster.layers.set(layer);  
		});
	}			
	
	var currentDown;
	var XR;
	that.XR = WW.XR = false;
	var tempMatrix = new threejs.Matrix4();

	that.doLcDown = function (e) {
		// possibly need to set pointerID
		XR = true;
		doDown(e);
	}
	that.doLcUp = function (e) {
		XR = true;
		doUp(e);
	}
	that.doLcMove = function (e) {
		XR = true;
		doMove(e, "left"); // move does not come with data
	}
	that.doRcDown = function (e) {
		XR = true;
		doDown(e);
	}
	that.doRcUp = function (e) {
		XR = true;
		doUp(e);
	}
	that.doRcMove = function (e) {
		XR = true;
		doMove(e, "right");
	}

	var controller1 = that.controllerLeft = renderer.xr.getController(0);
	controller1.addEventListener('selectstart', that.doLcDown); // ignoring select
	controller1.addEventListener('selectend', that.doLcUp);
	controller1.addEventListener('move', that.doLcMove);

	var controller2 = that.controllerRight = renderer.xr.getController(1);
	controller2.addEventListener('selectstart', that.doRcDown); // ignoring select
	controller2.addEventListener('selectend', that.doRcUp);
	controller2.addEventListener('move', that.doRcMove);


	that.doPointerDown = function(e) {
		XR = false;
		doDown(e);
	}	
	window.addEventListener("pointerdown", that.doPointerDown);			
	function doDown(e) {

		if (!that.raycast) return;

		if (XR) {
			var controller = e.target;
			tempMatrix.identity().extractRotation(controller.matrixWorld);
			raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
			raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
			if (e.data && e.data.handedness == "left") e.pointerId = 2;
			else e.pointerId = 1;
		} else {
			var point;
			if (!zimThree || zimThree.resizeEvent) {
				point = {
					x: (e.clientX/window.innerWidth*2-1),
					y: (1-e.clientY/window.innerHeight*2)
				}
			} else {
				point = {
					x: (e.clientX/startW*2-1),
					y: (1-e.clientY/startH*2)
				}
			}
			raycaster.setFromCamera(point, camera);					
		}
		var intersects = raycaster.intersectObjects(scene.children);
		
		currentDown = null;  
		var obj, i, material;
		for (i=0; i<intersects.length; i++) {					
			obj = intersects[i].object;
			if (that.ignoreList.indexOf(obj) > -1) continue;
			if (that.threeMeshes.indexOf(obj) > -1) {
				if (obj.material && Array.isArray(obj.material)) {
					material = obj.material[intersects[i].face.materialIndex];
				} else if (obj.material) {
					material = obj.material;
				} else {
					break;
				}
			}
			if (material 
				&& material.map 
				&& material.map.source 
				&& material.map.source.data
				&& material.map.source.data.isTextureActive     
				&& material.userData.ta_content                       
			) {        
				currentDown = obj; 
				var content = material.userData.ta_content;
				that.pointerData.mousedown = true; 
				doRaycast(content, intersects[i], material.userData.ta_flipped); 
				createjs.handleRemotePointer(that.pointerData.x, that.pointerData.y, "down", e, stage, e.pointerId);

				if (controls && controls.maxAzimuthAngle && content) {
					if (content.backingOrbit) {
						var p = content.globalToLocal(frame.mouseX, frame.mouseY);
						var b = content.backing;
						if (b && content.getObjectUnderPoint(p.x, p.y, 1) != b) {
							controls.enableRotate = false; 
						} else controls.enableRotate = true;
					} else {
						controls.enableRotate = false; 
					}
				}
				var e2 = new createjs.Event("raydown");  
				e2.mesh = that.mesh = obj;
				e2.material = that.material = material;
				e2.textureActive = that.textureActive = content;
				e2.intersect = that.intersect = intersects[i];
				that.dispatchEvent(e2);
				break;
			} else {
				break;
			}      
		}
	}


	that.doPointerUp = function(e) {
		XR = false;
		doUp(e);
	}
	window.addEventListener("pointerup", that.doPointerUp);	
	function doUp(e) {

		if (!that.raycast) return;

		that.pointerData.mousedown = false;
		if (controls && controls.maxAzimuthAngle) controls.enableRotate = true;  // orbitControls only  
		if (currentDown) {
			var e2 = new createjs.Event("rayup");
			e2.mesh = that.mesh;
			e2.material = that.material;
			e2.textureActive = that.textureActive;                    
			e2.intersect = that.intersect;
			that.dispatchEvent(e2);
		}
		currentDown = null;
		if (XR) {
			if (e.data && e.data.handedness == "left") e.pointerId = 2;
			else e.pointerId = 1;
		}
		createjs.handleRemotePointer(null, null, "up", e, stage, e.pointerId);    
	}            


	that.doPointerMove = function(e) {
		XR = false;
		doMove(e);
	}
	window.addEventListener("pointermove", that.doPointerMove);	
	function doMove(e, handed) {

		if (!that.raycast) return;

		if (XR) {
			var controller = e.target;
			tempMatrix.identity().extractRotation(controller.matrixWorld);
			raycaster.ray.origin.setFromMatrixPosition(controller.matrixWorld);
			raycaster.ray.direction.set(0, 0, -1).applyMatrix4(tempMatrix);
			if (handed == "left") e.pointerId = 2;
			else e.pointerId = 1;
		} else {
			var point;
			if (!zimThree || zimThree.resizeEvent) {
				point = {
					x: (e.clientX/window.innerWidth*2-1),
					y: (1-e.clientY/window.innerHeight*2)
				}
			} else {
				point = {
					x: (e.clientX/startW*2-1),
					y: (1-e.clientY/startH*2)
				}
			}
			raycaster.setFromCamera(point, camera);
		}
		var active = false;
		var obj, i, material;
		if (currentDown) {
			var intersects = raycaster.intersectObject(currentDown);
			if (intersects.length > 0) {
				obj = currentDown;
				if (obj.material && Array.isArray(obj.material)) {
					material = obj.material[intersects[0].face.materialIndex];
				} else if (obj.material) {
					material = obj.material;
				}
				if (material) {							
					var content = material.userData.ta_content;
					doRaycast(content, intersects[0], material.userData.ta_flipped);
					createjs.handleRemotePointer(that.pointerData.x, that.pointerData.y, "move", e, stage, e.pointerId);
					active = true;
					var e2 = new createjs.Event("raymove");
					e2.mesh = overMesh = that.mesh = obj;
					e2.material = overMaterial = that.material = material;
					e2.textureActive = that.textureActive = content;
					e2.intersect = that.intersect = intersects[0];
					that.dispatchEvent(e2);
				}                       
			}
		} else {
			var intersects = raycaster.intersectObjects(scene.children);
			for (i=0; i<intersects.length; i++) {
				obj = intersects[i].object;
				if (that.ignoreList.indexOf(obj) > -1) continue;

				if (that.threeMeshes.indexOf(obj) > -1) {
					if (obj.material && Array.isArray(obj.material)) {
						material = obj.material[intersects[i].face.materialIndex];
					} else if (obj.material) {
						material = obj.material;
					} else {
						break;
					}
				}
				if (material
					&& material.map 
					&& material.map.source 
					&& material.map.source.data
					&& material.map.source.data.isTextureActive
					&& material.userData.ta_content                   
				) { 
					var content = material.userData.ta_content;
					doRaycast(content, intersects[i], material.userData.ta_flipped);
					createjs.handleRemotePointer(that.pointerData.x, that.pointerData.y, "move", e, stage, e.pointerId);
					active = true;
					var e2 = new createjs.Event("raymove");
					e2.material = overMaterial = that.material = material;
					e2.mesh = overMesh = that.mesh = obj;
					e2.textureActive = that.textureActive = content;
					e2.intersect = that.intersect = intersects[i];
					that.dispatchEvent(e2);
					break;
				} else {
					break;
				}
			}
		}

		if (!active) {                    
			overMesh = null;
			overMaterial = null;
		}
		zim.TAM.setActive(that,active);

	}

	function doRaycast(content, intersects, flipped) {  
		if (!content || !content.getBounds) return;
		var b = content.getBounds();
		var x = flipped?(b.width-intersects.uv.x*b.width):intersects.uv.x*b.width;
		var y = (1-intersects.uv.y)*b.height;
		var uvp = content.localToGlobal(x,y);
		that.pointerData.x = uvp.x;
		that.pointerData.y = uvp.y;  
	}
}

this.add = function(actives) {
	var count = addActives(actives);            
	if (count > 0) {
		zim.TAM.updateTile(that, that.actives);                
	}
	return that;
}

this.remove = function(actives) {
	if (zot(actives)) actives = [];
	if (!Array.isArray(actives)) actives = [actives];
	var count = 0;
	zim.loop(actives, function(active) {
		if (createjs.remoteQueue) {
			var index = createjs.remoteQueue.indexOf(active);
			if (index >= 0) createjs.remoteQueue.splice(index, 1);
		}
		index = that.actives.indexOf(active);
		if (index >= 0) {
			that.actives.splice(index, 1);
			count++;
		}
		if (active.textureMap) delete active.textureMap.userData.ta_content;
		index = that.threeMeshes.indexOf(active);
		if (index >= 0) that.threeMeshes.splice(index, 1);
		// active.dispose();
	}, true);
	if (count > 0) {
		zim.TAM.updateTile(that, that.actives);
	}  
	return that;          
}

that.addMesh = function(mesh, layer) {
	if (!zot(layer)) mesh.layers.enable(layer);
	if (mesh.material) {
		var index = that.threeMeshes.indexOf(mesh);
		if (index < 0) that.threeMeshes.push(mesh);
		else return that;

		var materials;
		if (Array.isArray(mesh.material)) materials = mesh.material;
		else materials = [mesh.material];


		mesh.onBeforeRender = function() {
			if (mesh.userData.ta_viewID) clearTimeout(mesh.userData.ta_viewID);
			mesh.userData.ta_viewID = setTimeout(function(){
				mesh.userData.ta_view = false;
				if (createjs.remoteQueue) {
					// not in view
					zim.loop(mesh.userData.ta_content, function(c) {
						var ind = createjs.remoteQueue.indexOf(c);
						if (ind >= 0) createjs.remoteQueue.splice(ind, 1);
					},true);
				}
			}, 100);
			if (!mesh.userData.ta_view) {
				mesh.userData.ta_view = true;
				// in view
				zim.loop(mesh.userData.ta_content, function(c) {
					if (createjs.remoteQueue.indexOf(c) < 0) createjs.remoteQueue.push(c);
				});
			}
		}
		mesh.userData.ta_content = [];
		zim.loop(materials, function(material) {
			if (material
				&& material.map
				&& material.map.source 
				&& material.map.source.data
				&& material.map.source.data.content
			) {           
				var content = material.map.source.data.content;  
				mesh.userData.ta_content.push(content);
				content.mesh = mesh;
				mesh.textureActive = true; // flag that one of its materials has textureActive content
				material.userData.ta_content = content; // move it up so easier to access                            
				if (!content.textureMaps) content.textureMaps = [];
				var index = content.textureMaps.indexOf(material.map);
				if (index < 0) content.textureMaps.push(material.map);
				if (content.animated || content.interactive) if (!createjs.remoteQueue) createjs.remoteQueue = [];  
			}
		});                        
	}
	return that;
}	

that.dispose = function() {

	that.raycast = false;
	window.addEventListener("pointerdown", that.doPointerDown);
	window.removeEventListener("pointerup", that.doPointerUp);
	window.removeEventListener("pointermove", that.doPointerMove);

	that.controllerLeft.removeEventListener('selectstart', that.doLcDown); // ignoring select
	that.controllerLeft.removeEventListener('selectend', that.doLcUp);
	that.controllerLeft.removeEventListener('move', that.doLcMove);

	that.controllerRight.removeEventListener('selectstart', that.doRcDown); // ignoring select
	that.controllerRight.removeEventListener('selectend', that.doRcUp);
	that.controllerRight.removeEventListener('move', that.doRcMove);

	if (controls) {
		controls.enableRotate = true;
		controls.enabled = true;
	}
	zim.loop(that.actives, function(active) {
		active.dispose(); // calls textureActices.remove() for each before disposing
	});
	zim.TAM.remove(that);
	if (zim.TAM.count < 1) {
		zim.TAM.dispose();
		zim.TAM = null;
	}
	that.material = that.mesh = that.content = that.intersect = null;
}

}
zim.extend(zim.TextureActives, createjs.EventDispatcher, "dispose");
//-35.4

/*--
zim.TextureActivesManager = function(stage, toggleKey, damp)

TextureActivesManager
zim class extends a createjs EventDispatcher

DESCRIPTION
The TextureActivesManager is added automatically when a TextureActives object is made.
There is only one TextureActivesManager made.
It tiles all TextureActive objects across the ZIM stage (and beyond to the right).
It adds a slider and swiper to view the objects.
It adds a key (default t) and toggle() method to toggle between the three.js canvas and the ZIM canvas.

SEE the TextureActive and TextureActives examples

PARAMETERS 
stage (default the ZIMDefaultFrame's stage) the stage to operate on - provided internally
toggleKey (default "t") the key to toggle the viewer - will be the key set by the FIRST TextureActives object made 
can be set with the toggleKey property to a different key or -1 to disable
textureActives.manager.toggleKey = -1; // where textureActives is any TextureActives object
damp (default .2) the damping of the Swiper (1 being no damping)

METHODS
toggle(state) - toggles objects - leave state off for toggle or pass in true to see or false to hide
also see the toggle property
and show() and hide()
show() - show the ZIM canvas and hide the three.js canvas - also see toggle()
hide() - hide the ZIM canvas and show the three.js canvas - also see toggle()
dispose(obj) - disposes objects in the manager 

PROPERTIES 
type - holds the class name as a String
toggled - whether the ZIM canvas is showing (true) or the three.js canvas is showing (false)
	also see the toggle() method
toggleKey - get or set the key to toggle the TextureActives - default is "t" 
	set to -1 to remove toggling with the key
	this would be expected for final versions
	also see toggleKey parameter of TextureActives
tile - the tile containing the ZIM TextureActive objects
objects - a ZIM Dictionary of the TextureActives objects provided that holds their textureActive objects 
color - get or set the color of the stage for the ZIM Canvas 
outerColor - get or set the color outside the ZIM Canvas 
backing - the backing rectangle used for the swiper - this has a faint color 
nav - access to the ZIM Panel for the nav
slider - access to the ZIM Slider for the nav
swiper - access to the ZIM Swiper for swiping the panel - note, only works outside the TextureActive
--*///+35.6

zim.TextureActivesManager = function(stage, toggleKey, damp) {
	z_d("35.6");
	var that = this;
	this.type = "TextureActivesManager";

	that.color = zim.darker;
	that.outerColor = "black";

	var moveCheck = false;

	that.toggleKey = toggleKey || "t";

	if (zot(damp) || damp===true) damp = .2;

	var objs = that.objects = new zim.Dictionary(true); // unique
	var frame = stage.frame;

	var sP = new zim.Proportion({baseMin:1000, baseMax:9000, targetMin:-.1, targetMax:-.05, clamp:false});

	that.backing = new zim.Rectangle(100,100,zim.faint).addTo(stage,0);
	var updateList = [];
	that.updateTile = function(obj, textureActives, remove) {
		if (!remove) objs.add(obj, textureActives);
		var items = [];
		updateList = [];
		zim.loop(objs, function(obj, value) {
			zim.loop(value, function(item) {
				items.push(item);		
				item.loop(function(child) {
					if (child.type == "Scrambler") updateList.push(child);
					else if (child.type == "List") updateList.push(child);
					else if (child.type == "Window") updateList.push(child);
				});					
			});
		});
		if (items.length < 0) {
			var message = that.message = new zim.Rectangle(W,H,zim.yellow);
			new zim.Label("No TextureActives Added").center(message);
			items.push(message);
		}
		if (!that.tile) that.tile = new zim.Tile(items, items.length, 1, 20, 0, true).addTo(stage);
		else {
			that.tile.cols = items.length;
			that.tile.remake(items);
		}
		that.backing.scaleTo(that.tile,100,100,"full").siz(null,stage.height,true);

		if (that.swiper) that.swiper.sensitivity = zim.constrain(sP.convert(that.tile.width), -.1, -.01);

	}		

	this.addPointer = function(obj) {
		var doms = [];
		zim.loop(objs, function(o) {
			if (doms.indexOf(o.renderer.domElement) < 0) doms.push(o.renderer.domElement);
		});
		if (doms.indexOf(obj) < 0) doms.push(obj.renderer.domElement);
		if (!createjs.remotePointers) createjs.addRemotePointers(stage, doms);
		else createjs.remotePointers = doms;
		return true;
	}	
	
	this.setActive = function(obj, active) {
		obj.active = active;
		if (active) return;
		var result = zim.loop(objs, function(o) {
			if (o.active) return false;
		})
		if (!result) return;
		stage.mouseInBounds = false;
	}
	
	var downCheck = false;
	var nav = this.nav = new zim.Panel({
		width:200,
		height:80, 
		titleBar:"TextureActives",
		draggable:true,
		close:true
	}).pos(50,50,RIGHT,BOTTOM);
	var slider = this.slider = new zim.Slider({min:0, max:100, damp:true})
		.scaleTo(nav,80);
	slider.on("mousedown", function() {
		downCheck = true;
		that.swiper.enabled = false;
		protectOn();
	});
	slider.on("pressup", function() {			
		that.swiper.immediate(slider.currentValue);
		that.swiper.enabled = true;
		protectOff();					
		downCheck = false;
	});		

	nav.on("close", function() {
		that.hide();
		nav.addTo();
	});
	var lastVal = 0;
	this.ticker = zim.Ticker.add(function(){
		that.tile.x = -slider.currentValue*(that.tile.width-W)/100;
		if (moveCheck && !downCheck && lastVal != 0 && lastVal !=100 && 
			(slider.currentValue == 0 || slider.currentValue == 100)) protectOff();
		lastVal = slider.currentValue;			
	});
	nav.add(slider,0,true);
	nav.removeFrom();
	zim.Ticker.remove(that.ticker);

	function protectOn() {			
		if (moveCheck) return;
		moveCheck = true;
		zim.loop(updateList, function(child) {
			child.enabled = false;
		});
	}

	function protectOff() {
		if (!moveCheck) return;
		moveCheck = false;			
		zim.loop(updateList, function(child) {
			child.enabled = true;
			child.update();
		});
	}

	that.swiper = new zim.Swiper({
		swipeOn:that.backing, 
		target:slider, 
		property:"currentValue", 
		sensitivity:(that.tile?zim.constrain(sP.convert(tile.width), -.1, -.01):-.1),
		damp:damp
	});
	that.backing.on("mousedown", function() {
		lastVal = -100;
		protectOn();
	});
	that.swiper.on("swipestop", protectOff);


	that.toggled = false;
	var lastColor = frame.color;
	var lastOuter = frame.outerColor;
	this.show = function() {
		if (that.toggled) return; 
		frame.color = that.color;
		frame.outerColor = that.outerColor;
		// frame.color = darker;
		that.toggled = true;
		zim.Ticker.add(that.ticker);
		nav.addTo();
		zim.loop(objs, function(obj) {
			obj.lastRaycast = obj.raycast;
			obj.raycast = false;
			obj.renderer.domElement.style.display = "none";
		});

		if (createjs.remoteQueue) {				
			zim.loop(that.tile.items, function(item) {
				if (createjs.remoteQueue.indexOf(item) < 0) createjs.remoteQueue.push(item);
			});
		}
		frame.canvas.style.display = "block";  
		createjs.removeRemotePointers(stage);
		return this;
	}
	this.hide = function() {
		if (!that.toggled) return;
		frame.color = lastColor; 
		frame.outerColor = lastOuter; 
		that.toggled = false;
		zim.Ticker.remove(that.ticker);
		nav.removeFrom();
		var doms = [];
		zim.loop(objs, function(obj) {
			obj.raycast = obj.lastRaycast;
			obj.renderer.domElement.style.display = "block";
			doms.push(obj.renderer.domElement);
		});

		// loop through all meshes and then all content
		if (createjs.remoteQueue) {
			createjs.remoteQueue = []; // let it build again?
			zim.loop(that.tile.items, function(item) {
				if (item.mesh) item.mesh.userData.ta_view = false;
			});				
		}

		frame.canvas.style.display = "none";		
		createjs.addRemotePointers(stage, doms);
		return this;	
	}
	that.toggle = function(state) {
		if (zot(state)) state = !that.toggled;
		if (state && !that.toggled) that.show();
		else if (!state && that.toggled) that.hide();
		return this;
	}

	that.keyEvent = frame.on("keydown", function(e) {
		if (e.key==that.toggleKey) {
			if (that.toggled) that.hide();
			else that.show();
		}
	});

	that.remove = function(obj) {
		objs.remove(obj);
		that.updateTile(null, null, true);
	} 

	that.dispose = function() {		
		zim.loop(objs, function(obj) {
			obj.dispose();
		});
		that.hide();
		nav.dispose();
		frame.off("keydown", that.keyEvent);
		that.backing.removeAllEventListeners();
		that.backing.dispose();
		that.objects.dispose();
		that.tile.dispose();
		that.objects = that.tile = nav = null;
	}
	
}
zim.extend(zim.TextureActivesManager, createjs.EventDispatcher);
//-35.6


// SUBSECTION MANAGERS

/*--
zim.Manager = function()

DEPRECATED - as of ZIM ZIM 02, a GlobalManager is added to handle any resizing 

Manager
zim class

DESCRIPTION
used internally to make ResizeManager, GridManager and GuideManager
and in future perhaps OutlineManager

METHODS
** all methods return the manager for chaining except dispose which returns true
add(obj) - registers a object or array of objects with the manager
** the following methods will operate on all objects in manager if the object parameter is left empty
** if a specific object or an array of objects is provided then the methods will operate on those objects
remove(obj) - removes objects from the manager
resize(obj) - resizes objects in the manager
toggle(state, obj) - toggles objects - leave state off for toggle or pass in true to see or false to hide
dispose(obj) - disposes objects in the manager 
--*///+75
	zim.Manager = function(type) {
		z_d("75");
		var that = this;
		this.type = type;
		this.items = [];
		this.add = function(obj) {
			if (Array.isArray(obj)) that.items = that.items.concat(obj);
			else that.items.push(obj);
			return that;
		};
		var i,o;
		this.remove = function(obj) {
			if (!that) return;
			if (!obj) {
				that.items = [];
			} else {
				if (!Array.isArray(obj)) obj = [obj];
				for (i=obj.length-1; i>=0; i--) {
					o = obj[i];
					var index = that.items.indexOf(o);
					if (index != -1) that.items.splice(index, 1);
				}				
			}			
			return that;
		};
		this.resize = function(obj) {
			if (!that) return;
			if (!obj) {
				for (i=that.items.length-1; i>=0; i--) {
					if (!that.items[i].resize) that.items.splice(i, 1); // was disposed
					else that.items[i].resize();
				}
			} else {
				if (!Array.isArray(obj)) obj = [obj];
				for (i=obj.length-1; i>=0; i--) {
					o = obj[i];
					if (!o.resize && that.items.indexOf(o)!=-1) that.items.splice(that.items.indexOf(o), 1); // was disposed
					else o.resize();
				}				
			}			
			return that;
		};
		this.toggle = function(state, obj) {
			if (!that) return;
			if (!obj) {
				for (var i=that.items.length-1; i>=0; i--) {
					if (!that.items[i].resize) that.items.splice(i, 1); // was disposed
					else that.items[i].toggle(state);
				}
			} else {
				if (!Array.isArray(obj)) obj = [obj];
				for (i=obj.length-1; i>=0; i--) {
					o = obj[i];
					if (!o.resize && that.items.indexOf(o)!=-1) that.items.splice(that.items.indexOf(o), 1); // was disposed
					else o.toggle(state);
				}				
			}			
			return that;
		};
		this.dispose = function(obj) {
			if (!that) return;
			that.resize = null;
			if (!obj) {
				for (i=that.items.length-1; i>=0; i--) {
					if (!that.items[i].resize) that.items.splice(i, 1); // was disposed
					else that.items[i].dispose();
				}
				that.items = null;
			} else {
				if (!Array.isArray(obj)) obj = [obj];
				for (i=obj.length-1; i>=0; i--) {
					o = obj[i];
					// this is different than others as we are removing each from items
					if (that.items.indexOf(o)!=-1) that.items.splice(that.items.indexOf(o)); // was disposed
					if (o.dispose) o.dispose();
				}				
			}			
			return true;
		};
	};//-75
	
/*--
zim.ResizeManager = function()

DEPRECATED - as of ZIM ZIM 02, a GlobalManager is added to handle any resizing 

ResizeManager
zim class extends zim.Manager abstract class

DESCRIPTION
Add objects with a resize() method to a ResizeManager object and call a single resize() on the ResizeManager object
This will most likely go in a resize event on the Frame
Works with objects such as Layout, Pages, Grid, Guide, Accessibility, Loader and TextArea

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const resizeManager = new ResizeManager();
resizeManager.add([pages, layout, accessibility]);
// where these three objects have already been made
// *** Note that the Loader and TextArea are already resized if added to an Accessibility object that is resized
F.on("resize", ()=>{
	resizeManager.resize(); // without ResizeManager you would make three different resize() calls
})
END EXAMPLE

METHODS
add(obj) - adds object or an array of objects to the ResizeManager - returns the manager for chaining
	*** Note that the Loader and TextArea are already resized if added to an Accessibility object that is resized
remove(obj) - removes object or an array of objects from the ResizeManager - returns the manager for chaining
resize() - calls the resize() method of any object in the ResizeManager - returns the manager for chaining
dispose() - disposes the objects in the ResizeManager and the ResizeManager itself

PROPERTIES
type - holds the class name as a String
items - get or set an array of objects currently in the Manager

--*///+75.5
	zim.ResizeManager = function() {
		z_d("75.5");
		zim.Manager.call(this, "ResizeManager");
	};
	zim.ResizeManager.prototype = new zim.Manager();
	zim.ResizeManager.prototype.constructor = zim.ResizeManager;
	//-75.5

/*--
zim.TransformManager = function(objects, persistID)

TransformManager
zim class extends CreateJS EventDispatcher

DESCRIPTION
Manages multiple objects with transform() methods set.
Can use to show, hide, hideAll, add, remove and resize transform controls.
Also works with Squiggle(), Blob(), Layer(), Connectors() and Pack().
Can be used to automatically save any transforms and reload them again on refresh of Browser / App.
This uses localStorage.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const rect = new Rectangle(300, 200, green)
	.centerReg()
	.mov(-200)
	.transform();

const circ = new Circle(100, red)
	.centerReg()
	.mov(200)
	.transform();

const tm = new TransformManager([rect, circ], "sample");
// or use methods:
// tm.add([rect, circ]);
// tm.persist("sample"); // or add later to save transforms
END EXAMPLE

PARAMETERS
objects - (default null) adds the object(s) to the Transform Manager
	pass in a single object or an array of multiple objects
persistID - (default null) String id to make ZIM remember transforms of objects (uses localStorage)

METHODS
add(obj) - adds object or an array of objects to the TransformManager
remove(obj) - removes object or an array of objects to the TransformManager
show(obj) - show controls for an object that has a transform() set
hide(obj) - hides controls for an object that has a transform() set - still available with click
hideAll() - hides all controls - still available with click
resize() - calls the resize() method of any object in the ResizeManager
persist(id) - save data after every change and reload transforms when done - must provide an id
clearPersist(id) - clear persisting data - do this before adding shapes - must provide an id
savePersist() - with persist() already set, this will force a saving even without a transform event being captured
	if resize() after non-transform movement is called, then this is not needed
stopPersist() - no longer save data
dispose(removePersist, removeControls) - default just removes manager - keeps the data
	set removePersist to true to remove the persist data
	set removeControls to true to remove the transforms and beziers of all the items

PROPERTIES
type - holds the class name as a String
items - get or set (set not recommended) an array of objects currently in the TransformManager
currentObject - the last item to get transform tools if it still has the transform tools active
persistData - gets the persist data if it exists

EVENTS
Dispatches a "transformed" event when pressup on any of the controls or on click
	transformed event object has transformObject and transformType properties
	the transformType property has values of:
	 	FOR TRANSFORM: "select" (if not moved), "size", "move", "rotate", "stretch", "reg" "reset"
	 	FOR BLOB, SQUIGGLE: "move", "bezierPoint", "bezierHandle", "bezierSwitch"
		FOR CONNECTORS: "connection"
		FOR PACK: "change"
Adds "transformshow" and "transformhide" events for when click to hide or show controls
	these have a transformObject property to indicate what was shown or hidden
Dispatches, on each object, a "persistset" event when persist data is ready - could be delayed 50ms due to Layer being created
Dispatches a "persistcomplete" event when all persist data has been set + 100ms for layers to be set before applying controls

--*///+75.7
	zim.TransformManager = function(objects, persistID) {
		z_d("75.7");
		var that = this;
		this.type = "TransformManager";
		this.persistID = persistID;
		this.items = [];
		function setPersist(e) {
			if (!localStorage || (e && !e.pressup)) return;
			that.savePersist(e);
		}
		this.add = function(obj) {
			var newObj = [];
			if (Array.isArray(obj)) {newObj = obj;} else {newObj = [obj];}
			var o; var firstEver = false;
			for (var i=0; i<newObj.length; i++) {
				o = newObj[i];
				if (o.transformControls) o.originalVisible = o.transformControls.visible;

				// turn off all here and turn back on if first and !persistID
				// otherwise turn on after persist data is received
				if (o.toggle) o.toggle(false);
				if (that.items.length == 0 && i == 0) firstEver = true;
				if (o.type == "Blob" || o.type == "Squiggle") {
					if (!that.persistID) {
						if (firstEver) {
							firstEver = false;
							o.controlsVisible = true;
							that.currentObject = o;
						}
						// } else {
						// 	o.controlsVisible = false;
						// }
					}
					o.on("change", function(e) {
						var ev = new createjs.Event("transformed");
						ev.transformObject = e.target;
						ev.transformType = e.controlType;
						that.dispatchEvent(ev);
					});
					o.on("controlsshow", function(e) {
						var ev = new createjs.Event("transformshow");
						that.currentObject = ev.transformObject = e.target;
						that.dispatchEvent(ev);
					});
					o.on("controlshide", function(e) {
						var ev = new createjs.Event("transformhide");
						ev.transformObject = e.target;
						that.currentObject = null;
						that.dispatchEvent(ev);
					});
					o.on("update", function (e) {
						var ev = new createjs.Event("transformed");
						ev.transformObject = e.target;
						ev.transformType = e.controlType;
						that.dispatchEvent(ev);
					});
				} else if (o.type == "Connectors") {
					if (!that.persistID) {
						if (firstEver) {
							firstEver = false;
							that.currentObject = o;
						}
					}
					o.on("connection", function(e) {
						var ev = new createjs.Event("transformed");
						ev.transformObject = e.target;
						ev.transformType = "connection";
						that.dispatchEvent(ev);
					});
				} else if (o.type == "Pack") {
					if (!that.persistID) {
						if (firstEver) {
							firstEver = false;
							that.currentObject = o;
						}
					}
					o.on("change", function(e) {
						var ev = new createjs.Event("transformed");
						ev.transformObject = e.target;
						ev.transformType = "change";
						that.dispatchEvent(ev);
					});
				} else {
					var transObj = o.transformControls;
					if (!that.persistID) {
						if (firstEver && o.type != "Layer") {
							firstEver = false;
							if (o.originalVisible) {
								transObj.show();
								that.currentObject = o;
							}
						}
						// } else {
						// 	if (transObj) transObj.hide();
						// }
					}
					o.on("transformed", function(e) {
						var ev = new createjs.Event("transformed");
						ev.transformObject = e.target;
						ev.transformType = e.transformType;
						that.dispatchEvent(ev);
					});
					o.on("transformshow", function(e) {
						var ev = new createjs.Event("transformshow");
						that.currentObject = ev.transformObject = e.target;
						that.dispatchEvent(ev);
					});
					o.on("transformhide", function(e) {
						var ev = new createjs.Event("transformhide");
						ev.transformObject = e.target;
						that.currentObject = null;
						that.dispatchEvent(ev);
					});
				}
			}
			that.items = that.items.concat(obj);
			
			if (that.persist && !zot(that.persistID)) that.persist(that.persistID);
		};
		this.remove = function(obj) {
			if (zot(obj)) {that.items = []; return;}
			if (!Array.isArray(obj)) obj = [obj];
			var o;
			for (var i=0; i<obj.length; i++) {
				o = obj[i];
				if (that.currentObject == o) that.currentObject = null;
				// TODO: NEED TO FIX FOR OTHER TYPES OF OBJECTS AND THEIR EVENTS
				if (o.transformedEvent) {
					o.off("transformed", o.transformedEvent);
					o.transformedEvent = null;
				}
				if (o.type == "Blob" || o.type == "Squiggle") o.controlsVisible = false;
				else if (o.transformControls) o.transformControls.remove();
				var index = that.items.indexOf(o);
				if (index != -1) that.items.splice(index, 1);
			}
			if (persistID) {
				that.savePersist();
			}
		};
		this.show = function(obj) {
			if (zot(obj)) return;
			if (obj.type == "Blob" || obj.type == "Squiggle") {
				if (!obj.controlsVisible) obj.controlsVisible = true;
			} else {
				var transObj = obj.transformControls;
				if (!transObj || transObj.visible) return;
				transObj.show();
			}
			that.currentObject = obj;
		};
		this.hide = function(obj) {
			if (zot(obj)) return;
			if (that.currentObject == obj) that.currentObject = null;
			if (obj.type == "Blob" || obj.type == "Squiggle") {
				if (obj.controlsVisible) obj.controlsVisible = false;
			} else {
				var transObj = obj.transformControls;
				if (!transObj || transObj.visible) return;
				transObj.hide();
			}
		};
		this.hideAll = function(exception) {
			var transObj;
			var o;
			for (var i=0; i<that.items.length; i++) {
				o = that.items[i];
				if (!o || !(o.transformControls || o.update)) {
					that.items.splice(i); // was disposed
				} else {
					if (that.items[i]==exception) continue;
					if (o.type == "Blob" || o.type == "Squiggle") {
						if (o.controlsVisible) o.controlsVisible = false;
					} else {
						transObj = that.items[i].transformControls;
						if (transObj.visible) transObj.hide();
					}
				}
			}
			that.currentObject = null;
		};
		this.resize = function() {
			if (!that) return;
			var o;
			for (var i=0; i<that.items.length; i++) {
				o = that.items[i];
				if (!o || !(o.transformControls || o.update)) {
					that.items.splice(i); // was disposed
				} else {
					if (o.type == "Blob" || o.type == "Squiggle") {
						o.update();
					} else {
						o.transformControls.resize();
					}
				}
			}
			if (persistID) that.savePersist();
		};

		if (!zot(objects)) that.add(objects);
		var sorry = "TransformManager persist(persistID) - sorry, must provide id";
		this.persist = function(persistID) {
			var it,i;
			if (zot(persistID)) {
				if (zon) {zogy(sorry); return;}
			}
			that.persistID = persistID;
			var dispatchNum = 0;
			if (localStorage && localStorage[persistID]) {

				// TODO need to show current object controls here
								
				var data = that.persistData = JSON.parse(localStorage[persistID]);
				if (data.length == that.items.length) {
					
					for (i=0; i<that.items.length; i++) {
						if (data[i].controls) { // check transform rather than blob or squiggle - anything else have controls?
							that.currentObject = that.items[i];
						}
						if (data[i] && (data[i].type == "Blob" || data[i].type == "Squiggle")) {
							if (that.items[i].points.length != data[i].points.length) {
								that.items[i].points = data[i].points;
							}
							that.items[i].setData(data[i]);
							if (that.items[i] == that.currentObject) that.currentObject.toggle(true);
							dispatchNum++; // ZIM NFT added here... not sure if right but seems so
							if (dispatchNum == data.length) {
								setTimeout(function(){
									that.dispatchEvent("persistcomplete");
								}, 100);
							}
						} else if (data[i] && (data[i].type == "Connectors")) {		
							that.items[i].setSteps(data[i].steps);
							that.items[i].loc(data[i].x, data[i].y);
							that.items[i].sca(data[i].scale);
							dispatchNum++; 
							if (dispatchNum == data.length) {
								setTimeout(function(){
									that.dispatchEvent("persistcomplete");
								}, 100);
							}
						} else if (data[i] && (data[i].type == "Pack")) {		
							that.items[i].setOrder(data[i].order);
							that.items[i].outerWidth = data[i].outerWidth;
							that.items[i].outerHeight = data[i].outerHeight;
							dispatchNum++; 
							if (dispatchNum == data.length) {
								setTimeout(function(){
									that.dispatchEvent("persistcomplete");
								}, 100);
							}
						} else if (data[i]) {
							if (zot(that.items[i].transformControls)) {
								-function(){
									// fixed ZIM ZIM 00 - it was not being kept for closure so adjusted to itt
									var itt = it = that.items[i];
									var da = data[i];
									zim.interval(50, function(o) {
										if (itt.transformControls) {
											itt.transformControls.setData(da);
											itt.dispatchEvent("persistset");
											dispatchNum++;
											if (dispatchNum == data.length) {
												setTimeout(function(){
													if (itt == that.currentObject) that.currentObject.toggle(true);
													that.dispatchEvent("persistcomplete");
												}, 100);
												o.clear();
											}
										}
									}, 20, null, null, "ms");
								}();
							} else {
								that.items[i].transformControls.setData(data[i]);
								-function(){
									var itt = it = that.items[i];
									zim.interval(50, function(o) {
										itt.dispatchEvent("persistset");
										dispatchNum++;
										if (dispatchNum == data.length) {
											setTimeout(function(){
												if (itt == that.currentObject) that.currentObject.toggle(true);
												that.dispatchEvent("persistcomplete");
											}, 100);
											o.clear();
										}
									}, 20, null, null, "ms");
								}();
							}
						}
					}
				}
			}
			for (i=0; i<that.items.length; i++) {
				it = that.items[i];
				if (!it.transformedEvent) {
					if (it.type == "Blob" || it.type == "Squiggle") {
						it.transformedEvent = it.on("change", function(e){e.pressup=true; setPersist(e);});
						it.transformedUEvent = it.on("update", function(e){e.pressup=true; setPersist(e);});
						it.transformedSEvent = it.on("controlsshow", function(e){e.pressup=true; setPersist(e);});
						it.transformedHEvent = it.on("controlshide", function(e){e.pressup=true; setPersist(e);});
					} else if (it.type == "Connectors") {
						it.transformedEvent = it.on("connection", function(e){e.pressup=true; setPersist(e);});
					} else if (it.type == "Pack") {
						it.transformedEvent = it.on("change", function(e){e.pressup=true; setPersist(e);});
					} else {
						it.transformedEvent = it.on("transformed", setPersist);
						it.transformedSEvent = it.on("transformshow", setPersist);
						it.transformedHEvent = it.on("transformhide", setPersist);
					}
				}
			}
		};
		this.savePersist = function() {
			var data = [];
			for (var i=0; i<that.items.length; i++) {
				var it = that.items[i];
				if (it.type == "Blob" || it.type == "Squiggle") {
					if (it.recordData) data.push(it.recordData());
				} else if (it.type == "Connectors") {
					data.push({type:it.type, x:it.x, y:it.y, scale:it.scale, steps:it.getSteps()});
				} else if (it.type == "Pack") {
					data.push({type:it.type, outerWidth:it.outerWidth, outerHeight:it.outerHeight, order:it.getOrder()});
				} else {
					if (it.transformControls && it.transformControls.recordData) data.push(it.transformControls.recordData());
				}
			}
			that.persistData = data;
			localStorage[that.persistID] = JSON.stringify(data);
		};
		this.clearPersist = function(id) {
			if (zot(id)) {
				if (zon) {zogy(sorry); return;}
			}
			that.persistData = null;
			if (localStorage) localStorage.removeItem(id);
		};
		this.stopPersist = function() {
			for (var i=0; i<that.items.length; i++) {
				var it = that.items[i];
				if (it.transformedEvent) {
					if (it.type == "Blob" || it.type == "Squiggle") {
						it.off("change", it.transformedEvent);
						it.off("update", it.transformedUEvent);
						it.off("controlsshow", it.transformedSEvent);
						it.off("controlshide", it.transformedHEvent);
					} else if (it.type == "Connectors") {
						it.off("connection", it.transformedEvent);
					} else if (it.type == "Pack") {
						it.off("change", it.transformedEvent);
					} else {
						it.off("transformed", it.transformedEvent);
						it.off("transformshow", it.transformedSEvent);
						it.off("transformhide", it.transformedHEvent);
					}
					it.transformedEvent = null;
					it.transformedUEvent = null;
					it.transformedSEvent = null;
					it.transformedHEvent = null;
				}
			}
			that.persistData = null;
		};
		if (!zot(persistID)) that.persist(persistID);

		this.dispose = function(removePersist, removeControls) {
			if (zot(removePersist)) removePersist = true;
			that.removeAllEventListeners();
			if (that.persistID && removePersist) that.stopPersist();
			if (removeControls) {
				for (var i=0; i<that.items.length; i++) {
					var o = that.items[i];
					if (o.type == "Blob" || o.type == "Squiggle") o.dispose();
					else o.transformControls.dispose();
				}
			}
		};
	};
	zim.extend(zim.TransformManager, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-75.7

/*--
zim.GuideManager = function()

DEPRECATED - as of ZIM ZIM 02, a GlobalManager is added to handle any resizing 

GuideManager
zim class - extends the ZIM Manager abstract class

DESCRIPTION
Add Zim Guide objects to a GuideManager object and update or remove all guides at once.
Guides are handy to use but perhaps annoying to update and remove if you have many.
GuideManager keeps track of the guides and lets you update or dispose of them on command.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const manager = new GuideManager();
manager.add(new Guide());
manager.add(new Guide(false));

// or with pixels
// manager.add(new Guide(true, false));
// manager.add(new Guide(false, false));

// then you can remove all guides with
// manager.dispose();
// handy with guides on multiple Pages

// and in frame resize event we can resize all guides:
F.on("resize", ()=>{manager.resize();})
END EXAMPLE

PROPERTIES
type - holds the class name as a String
items - an array of all Guide objects added with add()

METHODS
add(guide) - registers a guide with the GuideManager
remove(guide) - removes guide from register
resize() - resizes all the guides in the GuideManager (ie. if stage changes)
toggle(state - default null) - toggle() will show controls if they are hidden or hide controls if they are showing
	alternatively, pass in true to show controls or false to hide controls
	note - method does not update the stage
dispose() - disposes all guides and the GuideManager

NOTE: to just hide guides, you use the G key
and to toggle percent and pixels use the P key
you can dispose guides individually or use this class to dispose all
disposing will remove the G, P key listener and the guide
--*///+77
	zim.GuideManager = function() {
		z_d("77");
		zim.Manager.call(this, "GuideManager");
	};
	zim.GuideManager.prototype = new zim.Manager();
	zim.GuideManager.prototype.constructor = zim.GuideManager;
	//-77

/*--
zim.GridManager = function()

DEPRECATED - as of ZIM ZIM 02, a GlobalManager is added to handle any resizing 

GridManager
zim class - extends a zim.Manager

DESCRIPTION
Add Zim Grid objects to a GridManager object and update or remove all grids at once.
Grids are handy to use but perhaps annoying to update and remove if you have many.
GridManager keeps track of the grids and lets you update or dispose of them on command.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const manager = new GridManager();
manager.add(new Grid());

// or with pixels
// manager.add(new Grid(null, false));

// then you can remove all grids with
// grid.dispose();
// handy with guides on multiple Pages

// and in frame resize event we can resize all grids:
F.on("resize", ()=>{manager.resize();})
END EXAMPLE

METHODS
add(grid) - registers a grid with the GridManager
remove(grid) - removes grid from the register
resize() - resizes all the grids in the GridManager (ie. if stage changes)
dispose() - disposes all grids and the GridManager

NOTE: to just hide grids, you use the G key
and to toggle percent and pixels use the P key
you can dispose grids individually or use this class to dispose all
disposing will remove the G key listener and the grid

PROPERTIES
type - holds the class name as a String
items - an array of all Grid objects added with add()
--*///+79
	zim.GridManager = function() {
		z_d("79");
		zim.Manager.call(this, "GridManager");
	};
	zim.GridManager.prototype = new zim.Manager();
	zim.GridManager.prototype.constructor = zim.GridManager;
	//-79

/*--
zim.LayoutManager = function()

DEPRECATED - as of ZIM ZIM 02, a GlobalManager is added to handle any resizing 

LayoutManager
zim class - extends a zim.Manager

DESCRIPTION
Add Zim Layout objects to a LayoutManager object and update them all at once.
You can remove all layout region bound shapes at once
as well as remove the B key to show the region bound shapes.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// these would be containers with your content
// make sure that bounds are set on containers
// you may want to hard code bounds for clarity
const header = new Rectangle(500, 200, blue);
const content = new Rectangle(600, 500, green);
const footer = new Rectangle(500, 200, blue);
S.addChild(header, content, footer);

// make the Layout - more useful for FULL scale mode
const layout = new Layout({
	holder:stage,
	regions:[
		{obj:header, marginTop:10, maxWidth:80, minHeight:10, valign:TOP},
		{obj:content, marginTop:5, maxWidth:90}, // note, middle gets no minHeight
		{obj:footer, marginTop:5, maxWidth:80, height:10}
	],
	lastMargin:5
});

// add to LayoutManager to resize or dispose all layouts together
const manager = new LayoutManager();
manager.add(layout);

F.on("resize", ()=>{
	manager.resize();
	S.update();
});

S.update();
END EXAMPLE

METHODS
** all methods return the manager for chaining
add(layout) - registers a layout or array of layouts with the manager
** the following methods will operate on all layouts in manager if the layout parameter is left empty
** if a specific layout or an array of layouts is provided then the methods will operate on those layouts
remove(layout) - removes layouts from the manager
resize(layout) - resizes layouts in the manager
toggle(state, layout) - toggles layout region bounds - leave state off for toggle or pass in true to see or false to hide
dispose(layout) - disposes layouts in the manager - including backgroundColors but not objects in the layouts

NOTE: to just hide bounds, you use the B key

PROPERTIES
type - holds the class name as a String
items - an array of all Layout objects added with add()
--*///+81
	zim.LayoutManager = function() {
		z_d("81");
		zim.Manager.call(this, "LayoutManager");
	};
	zim.LayoutManager.prototype = new zim.Manager();
	zim.LayoutManager.prototype.constructor = zim.LayoutManager;
	
	// zim.LayoutManager = function() {
	// 	z_d("81");
	// 	this.type = "LayoutManager";
	// 	var that = this;
	// 	this.items = [];
	// 	this.add = function(layout) {
	// 		that.items.push(layout);
	// 		return that;
	// 	};
	// 	this.resize = function() {
	// 		for (var i=0; i<that.items.length; i++) {
	// 			that.items[i].resize();
	// 		}
	// 		return that;
	// 	};
	// 	this.toggle = function(state) {
	// 		for (var i=0; i<that.items.length; i++) {
	// 			that.items[i].toggle(state);
	// 		}
	// 		return that;
	// 	};
	// 	this.disable = function() {
	// 		for (var i=0; i<that.items.length; i++) {
	// 			that.items[i].disable();
	// 		}
	// 		return that;
	// 	};
	// 	this.enable = function() {
	// 		for (var i=0; i<that.items.length; i++) {
	// 			that.items[i].enable();
	// 		}
	// 		return that;
	// 	};
	// 	this.remove = function(obj) {
	// 		if (zot(obj)) {that.items = []; return;}
	// 		if (!Array.isArray(obj)) obj = [obj];
	// 		var o;
	// 		for (var i=0; i<obj.length; i++) {
	// 			o = obj[i];
	// 			var index = that.items.indexOf(o);
	// 			if (index != -1) that.items.splice(index, 1);
	// 		}
	// 		return that;
	// 	};
	// 	this.dispose = function(a,b,disposing) {
	// 		for (var i=0; i<that.items.length; i++) {
	// 			that.items[i].dispose(); 
	// 		}
	// 		return true;
	// 	};
	// };//-81

/*--
zim.SelectionSet = function(selections)

SelectionSet
zim class

DESCRIPTION
Keeps track of selected objects or indexes, etc.
Just a wrapper for array manipulation:
Uses isSelected instead of indexOf()>=0
Uses remove() instead of splice(index, 1), etc.
Handles multiple select, matching other SelectionSet objects for add and remove, etc.
Use with a SelectionManager to control multiple Selection Set objects at once.
See: https://zimjs.com/explore/selectionTest.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const selectedTriangles = new SelectionSet();
const triangles = new Tile(new Triangle(), 5, 1, 50).center().mov(0,-200).cur();
triangles.on("click", e=>{
	selectedTriangles.toggle(e.target, F.ctrlKey); // multiple if ctrl down
	// need to loop through all to update
	triangles.loop(triangle=>{
		triangle.color = selectedTriangles.isSelected(triangle)?pink:black;
	});
	S.update();
});
END EXAMPLE

PARAMETERS
selections - (default []) an array of selected items or indexes, etc.

METHODS
clear() - clear selections
isSelected(item) - returns true if item is selected else false
toggle(item, multiple, match, unmatch) - toggle the item which calls add or remove below
	this is probably the most handy method - see parameter description below
add(item, multiple, match, unmatch) - add an item
	multiple will not remove other selected items
	match - pass in another SelectionSet to add the same item or index
	unMatch - pass in another SelectionSet to remove the same item or index if there
remove(item, multiple, match, unmatch) - remove an item
	multiple will not remove other selected items
	match - pass in another SelectionSet to remove the same item or index
	unMatch - pass in another SelectionSet to add the same item or index if there
dispose() -  clears list and sets to null

PROPERTIES
type - holds the class name as a String
items - an array of all Layout objects added with add()
--*///+81.5
	zim.SelectionSet = function(selections) {
		z_d("81.5");
		this.type = "SelectionSet";
		if (zot(selections)) selections = [];
		this.selections = selections;
		this.clear = function() {
			this.selections = [];
		};
		this.isSelected = function(item) {
			return this.selections.indexOf(item) >= 0;
		};
		// add will append if multiple or SelectionManager multiple is true
		// otherwise turns all other selections off and adds parameter selection
		this.add = function(item, multiple, match, unmatch) {
			if (zot(item)) return;
			if (zot(multiple)) {
				if (!zot(this.selectionManager)) multiple = this.selectionManager.multiple;
			}
			if (!zot(this.selectionManager)) {
				this.selectionManager.setCurrent(this);
				if (!multiple && this.selectionManager.multipleSets) this.selectionManager.clear();
			}
			if (!multiple ) this.clear();
			var ind = this.selections.indexOf(item);
			if (ind >= 0) return;
			this.selections.push(item);
			if (!zot(match)) {
				if (!Array.isArray(match)) match = [match];
				for (var i=0; i<=match.length; i++) {
					match[i].add(item, multiple);
				}
			}
			if (!zot(unmatch)) {
				if (!Array.isArray(unmatch)) unmatch = [unmatch];
				for (i=0; i<=unmatch.length; i++) {
					unmatch[i].remove(item, multiple);
				}
			}
		};
		this.remove = function(item, multiple, match, unmatch) {
			if (zot(item)) return;
			if (zot(multiple)) {
				if (!zot(this.selectionManager)) multiple = this.selectionManager.multiple;
			}
			if (!zot(this.selectionManager)) this.selectionManager.setCurrent(this);
			if (!multiple) this.clear();
			var ind = this.selections.indexOf(item);
			if (!zot(this.selectionManager)) {
				this.selectionManager.setCurrent(this);
				if (!multiple && this.selectionManager.multipleSets) this.selectionManager.clear();
			}
			if (!multiple ) this.clear();
			if (!multiple) this.clear();
			else if (ind >= 0) this.selections.splice(ind, 1);
			if (!zot(match)) {
				if (!Array.isArray(match)) match = [match];
				for (var i=0; i<=match.length; i++) {
					match[i].remove(item, multiple);
				}
			}
			if (!zot(unmatch)) {
				if (!Array.isArray(unmatch)) unmatch = [unmatch];
				for (i=0; i<=unmatch.length; i++) {
					unmatch[i].add(item, multiple);
				}
			}
		};
		this.toggle = function(item, multiple, match, unmatch) {
			if (this.isSelected(item)) this.remove(item, multiple, match, unmatch);
			else this.add(item, multiple, match, unmatch);
		};
		this.dispose = function() {
			this.clear();
			this.selections = null;
			return true;
		};
	};//-81.5

/*--
zim.SelectionManager = function(sets, multipleKey, multipleSets)

SelectionManager
zim class extends a CreateJS EventDispatcher

DESCRIPTION
Add Zim SelectionSet objects to a SelectionManager object and control multiple selection sets.
Used internally to control Squiggle and Blob point selections for multiple drags and mousemoves
Also provides key events along with undo event
See: https://zimjs.com/explore/selectionTest.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// manage two sets of SelectionSet objects:
const selectedCircles = new SelectionSet();
const selectedRects = new SelectionSet();
// add SelectionSet objects to manager and set ctrl to be multiple select
const selectionManager = new SelectionManager([selectedCircles, selectedRects], "ctrl");

const circles = new Tile(new Circle(), 5, 1, 50).center().cur();
const rects = new Tile(new Rectangle(), 5, 1, 50).center().mov(0,100).cur();
circles.on("click", e=>{
	// toggle current selected - SelectionManager will handle multiple select
	selectedCircles.toggle(e.target);
	setColors();
});
rects.on("click", e=>{
	selectedRects.toggle(e.target);
	setColors();
});
// need to loop through all objects to make sure their color did not change
function setColors() {
	circles.loop(circle=>{
		circle.color = selectedCircles.isSelected(circle)?red:black;
	});
	rects.loop(rect=>{
		rect.color = selectedRects.isSelected(rect)?red:black;
	});
	S.update();
}
END EXAMPLE

PARAMETERS
sets - (default null) a ZIM SelectionSet object or an array of SelectionSet objects to manage
multipleKey - (default null) a key ("shift", "ctrl", "meta", etc.) to use for multiple select (only within a SelectionSet)
multipleSets - (default true) set to false to only allow one set at a time to be selected on

METHODS
clear() - clears all SelectionSet objects in the SelectionManager
setCurrent(set) - sets the privided SelectionSet to the currentSet and clears the others
dispose() - removes key events

PROPERTIES
type - holds the class name as a String
sets - an array of all the SelectionSet objects
multipleKey - the key provided for multiple select ("shift", "ctrl", etc) - do not add "Key" as in "shiftKey"
multiple - true if the multipleSelect key is being pressed otherwise false
ctrlKey - true if the ctrlKey key is being pressed otherwise false
shiftKey - true if the shiftKey key is being pressed otherwise false
metaKey - true if the metaKey key is being pressed otherwise false

EVENTS
dispatches an "undo" event if a CTRL or META plus the U key is pressed
--*///+81.6
	zim.SelectionManager = function(sets, multipleKey, multipleSets) {
		z_d("81.6");
		this.cjsEventDispatcher_constructor();
		this.type = "SelectionManager";
		if (zot(sets)) sets = [];
		if (zot(multipleSets)) multipleSets = true;
		if (!Array.isArray(sets)) sets = [sets];
		this.sets = sets;
		this.multipleKey = multipleKey;
		this.multipleSets = multipleSets;
		this.multiple = false;
		var that = this;
		for (var i=0; i<sets.length; i++) {
			sets[i].selectionManager = this;
		}
		this.clear = function() {
			this.currentSet = null;
			for (var i=0; i<sets.length; i++) {
				sets[i].clear();
			}
		};
		this.setCurrent = function(set) {
			this.currentSet = set;
			for (var i=0; i<sets.length; i++) {
				if (sets[i] == set) continue;
				if (!this.multipleSets) sets[i].clear();
			}
		};
		var eDown = new createjs.Event("keydown");
		this.eventRemove = eDown.remove;
		this.keydownEvent = function(e) {
			e.remove = that.eventRemove;
			if (that.multipleKey) that.multiple = e[that.multipleKey+"Key"];
			that.ctrlKey = e.ctrlKey;
			that.shiftKey = e.shiftKey;
			that.metaKey = e.metaKey;
			that.dispatchEvent(e);
			if (e.keyCode==90 && (that.ctrlKey || that.metaKey)) {
				that.dispatchEvent("undo");
			}
		};
		WW.addEventListener("keydown", this.keydownEvent);
		
		this.keyupEvent = function(e) {
			if (that.multipleKey) that.multiple = e[that.multipleKey+"Key"];
			that.ctrlKey = e.ctrlKey;
			that.shiftKey = e.shiftKey;
			that.metaKey = e.metaKey;
			e.remove = that.eventRemove;
			that.dispatchEvent(e);
		}
		WW.addEventListener("keyup", this.keyupEvent);
		
		this.dispose = function () {
			this.clear();
			WW.removeEventListener("keydown", this.keydownEvent);
			WW.removeEventListener("keyup", this.keyupEvent);
		};
	};
	zim.extend(zim.SelectionManager, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-81.6

/*--
zim.Bind = function(connection, bindType, master, masterFilter, couple, smartDecimals, report, setDefault)

Bind
zim class

DESCRIPTION
Binds DisplayObject properties to data, for instance localStorage or server data
The property values can be any JSON valid data such as Number, String, Array or Object Literal

NOTE: see bind() methods of DisplayObjects like Containers, ZIM Shapes, Shapes, Bitmap, etc.

NOTE: see ZIM Base() in PHP for database access https://zimjs.com/php/base.zip

NOTE: see ZIM Skool Data lesson 09 https://zimjs.com/skool/lesson09.html
And asociated videos here https://zimjs.com/learnjavascript.html#lesson09

Bind has to() and from() methods that can be used to update data and properties as desired.
to() saves data and from() gets data and sets object properties.
These have filters to specify on which ids, objects or properties to act.
LOCALSTORAGE, POST and GET is supported as are these global ZIM constants.

The data has JSON.strigify() applied and will be sent as a data property
Bind has a master parameter that will be sent with all to() and from() calls
to() and from() calls will send a command property of either "to" or "from"
There is also an extra property that can be used to send an id, search term, etc.
These can be collected, for instance in PHP, as follows depending on the bindType
$_GET["data"], $_GET["master"], $_GET["command"], $_GET["extra"], $_GET["unique"] or
$_POST["data"], $_POST["master"], $_POST["command"], $_POST["extra"], $_POST["unique"]
Separating the data from the master, command and extra more readily allows JSON storage

GET uses ZIM asnyc() which is JSONp based and overcomes Cross Origin security issues
GET has a limit of 2048 - some servers are more but some are not
POST uses ZIM Ajax() which will work with the same server or one with CORS set accordingly
POST has a limit of roughly the computer memory
LOCALSTORAGE is also supported which stores the data on the user's computer

See: https://zimjs.com/ten/bind.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// LOCALSTORAGE example - synchronous so do not need callback
const b = new Bind();
// b.clear(); // clear localStorage memory

// circle's location will be remembered
const c = new Circle().center().bind("circle", ["x","y"]).drag();
c.on("pressup", ()=>{b.to();});

// TextArea's text will be remembered
const t = new TextArea().center().mov(0,-100).bind("text", ["text"]);
t.on("input", ()=>{b.to();});
END EXAMPLE

EXAMPLE
// A GET example - POST is the same - see comments in PHP template...

// get unique user id from components, etc.
// this could be added to the url for get
// but we will pass it in as master data which works for get or post
// to tell the to() and from() methods to always pass this master variable
var uid = "bindTest";
var url = "https://zimjs.com/ten/bind.php";

// from() will get any data from the url and store in Bind as data
// this will then be used as each object is bound
const b = new Bind(url, GET, uid).from(()=>{

	const c = new Circle(100,red)
		.loc(rand(W), rand(H))
		// the bind will also set properties to existing Bind data
		.bind("circle", ["x","y","level"])
		.drag();

	c.on("pressup", function() {
		// to() will send data to the server
		b.to();
	});

	const r = new Rectangle(200,200,blue)
		.loc(rand(W-200), rand(H-200))
		.bind("rect", {x:BOTH, y:BOTH, level:BOTH, alpha:TO})
		.drag();

	r.on("pressup", ()=>{
		b.to();
	});

	// b.to(); // would store random locations to start

	// would clear bindings and data
	// b.removeAllBindings(true, function (response) {
	//     zog(response);
	// });

	S.update();
});

// A PHP Template for GET with notes for POST
// See: https://zimjs.com/ten/bind.html for a full example with MySQLi database code
<?php

// ZIM Bind as of ZIM 10.9.0
// ZIM supports data binding of JSON ready properties on objects
// here is an example of the structure for binding to a database with GET
// GET uses ZIM async() which uses JSONp rather than AJAX
// POST uses ZIM ajax() and is similar - use for larger data

header('Content-type: text/javascript');

// ZIM Bind sends the following variables
// in this case, master is an id
// data is the JSON data to store
// command will be "to" or "from" to store or retrieve data
// extra could be a search term, etc. but not used in this example

// for POST - change these to $_POST["master"], etc.
$master = isset($_GET["master"]) ? $_GET["master"] : "";
$data = isset($_GET["data"]) ? $_GET["data"] : "";
$command = isset($_GET["command"]) ? $_GET["command"] : "";
$extra = isset($_GET["extra"]) ? $_GET["extra"] : "";

if ($command == "to") {

	// ZIM Bind.to() will send a data property in JSON format:
	// '{"id1":{"prop1":"value", "prop2":"value"}, "id2":{"prop3":"value"}}'
	// the JSON string can be stored at the id in the database
	// or separate fields can be stored by parsing the JSON data
	// looping and filling specific fields

	// check for master id
	if ($master=="") {echo "async.callbackTo('error: no id')"; exit;}

	// put data into database at id using MySQLi or PDO, etc.
	// then echo success or error in the following async format
	echo "async.callbackTo('success')";
	// echo "success"; // FOR POST

} else if ($command == "from") {

	// Bind from() requests the information
	// If all the data is requested then the data will be the string 'full'
	// so return the JSON string stored at the id for instance.
	// requests might also be provided in the following format:
	// '{"id":["prop1","prop2"], "id2":["prop3"]}'
	// and then return the data for the fields requested as a JSON string:
	// '{"id1":{"prop1":"value", "prop2":"value"}, "id2":{"prop3":"value"}}'

	// check for master id
	if ($master=="") {echo "async.callbackFrom('error: no id')"; exit;}

	// get data from database using MySQLi or PDO, etc.
	// return data in the following async format - for example:
	$json = '{"circle":{"x":200,"y":200},"rect":{"x":300,"y":300,"alpha":1}}';
	echo "async.callbackFrom($json)";
	// echo $json; // FOR POST

} else if ($command == "removeAll") {

	// if we want to reset the data the Bind object's removeAllBindings
	// can be called - the removeConnectionData defaults to true
	// and a command of "removeAll" will be called on the server

	// check for id
	if ($master=="") {echo "async.callbackRemoveAll('error: no id')"; exit;}

	// delete data from database using MySQLi or PDO, etc.
	echo "async.callbackRemoveAll('success')";
	// echo 'success'; // FOR POST
}
?>
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
connection - (default "zimBind") a localStorage string "example" or a URL to a server script
bindType - (default LOCALSTORAGE) or set to GET or POST
	For GET and POST a GET variable called type will be sent with either "get" or "post" value
	This is captured by ZIM Base() on the PHP side and used to manage variables and responses.
	LOCALSTORAGE - stores data in localStorage on the users computer
		and is syncronous so all data is automatically stored on to() and from()
	GET - sends data to a server script such as PHP or node using ZIM async() and JSONp
		as such, this should work from local computers and across different domains
		extra information can be placed on the URL in CGI format ?prop=value&prop=value
		the values (only) should be encodeURI() if spaces or special characters
		there is a limit of approximately 2048 characters
	POST - sends data to a server using an object which gets JSON.stringify applied
		this object can be retrieved via $_POST["data"] in PHP, etc.
		extra information can be placed on the URL in CGI format ?prop=value&prop=value
		the values (only) should be encodeURI() if spaces or special characters
		there is virtually no limit to the amount of data
		files will need to be on the same server or a CORS header set up
master - (default null) information to send with each server call (not localStorage)
	this could be an id, etc. and will have encodeURIComponent() applied
	eg. in php it can be received as $_GET["master"] or $_POST["master"] depending on bindType
masterFilter - (default null) a function to run before TO and after FROM
	this will receive the data (plus command and extra)
	command will be "to", "fromTo", "from", or "remove" - see to(), from(), remove() for details
	and must return the data - but the function can operate on the data
	eg. if data.id = "1_a" the filter function can set data.id = data.id.split("_").join("");
	The function must return data - this will modify before sending and after receiving
	If only one direction is desired use the command parameter in a conditional
	eg. if (command=="to") {etc.} - make sure to return the data in all cases
couple - (default false) - set to true to turn nested JSON into a single layer
 	The object will have _ between the id and the property name
	eg. {"circle":{"x":"10", "y":"20"},"count":{"currentValue":"0"}}
	is: {"circle_x":"10", "circle_y":"20", "count_currentValue":"0"}
	This allows data to be JSON decoded on the server
	and put more directly into table fields of the database
	The data will be automatically decoupled back to a double layer object on retrieval
smartDecimals - (default true) numbers > 1 have 1 decimal, numbers < 1 have two decimals
report - (default false) set to true to receive console Bind reports of each bind result
setDefault - (default null) by default the first Bind object is the zimDefaultBind object
	The zimDefaultBind is what DisplayObject bind() method will use unless bindObj is specified.
	Set the setDefault parameter to true to override any previous Bind objects as the default bind object.
	See also the default property

METHODS
** all methods return the object for chaining
add(id, obj, props, extra, filter) - adds a DisplayObject (Container, Bitmap, Circle, etc.) to the Bind object
	or use bind(id, props, filter, bindObj) method of DisplayObjects
	will also set properties to current Bind properties for GET and POST
	or get latest data for LOCALSTORAGE
		id - a string identifier - one id per object
		obj - a DisplayObject (display objects can have more than one id)
		props - an property as a string or an array of properties as strings
		extra (default null) extra information to be sent to the server (not localStorage)
			this could be an id or a search term, etc. it will have encodeURI() applied
			this can be received in php as $_GET["extra"] or $_POST["extra"] depending on bindType
		filter - (default null) a function to run before sending and after receiving data
			this will receive (data, command, extra, process) parameters
			command will be "to", "fromTo", "from", or "remove" - see to(), from(), remove() for details
			calling process.stop() will stop the current to() or from() call from proceeding
			the function must return the data - see Bind masterFilter parameter for more information
			note: the masterFilter if supplied will run as well before the filter
remove(targets, props, extra, filter, removeConnectionData, call) - remove a bind
	targets (default null) an object or id or an array of ids or objects to remove binds
	props (default null) a property or an array of properties to remove binds on only those properties
		or pass both targets and props to remove only properties on provided id or objects
	extra (default null) extra information to be sent to the server (not localStorage)
		this could be an id or a search term, etc. it will have encodeURI() applied
		this can be received in php as $_GET["extra"] or $_POST["extra"] depending on bindType
	filter (default null) a function to run before removing
		this will receive (data, command, extra, process) parameters - command will be "remove"
		calling process.stop() will stop the current to() or from() call from proceeding
		the function must return the data - see Bind masterFilter parameter for more information
		note: the masterFilter and the bind filter if supplied will run as well before the filter
	removeConnectionData (default true) remove connection data
		this will clear removed data from localStorage for LOCALSTORAGE setting
		a "remove" property will be sent to the server for GET or POST
		with a JSON {id1:["prop1","prop2"], id2:["prop3"]} format of removed items
	call is a callback function after the data is sent and received
	the callback function will receive a result "success" or "error ..." in its parameter
from(call, targets, props, extra, filter) - get bind data from the connection (localStorage or database)
	** accepts ZIM DUO normal parameters or configuration object literal with parameter names as propterties
	from() will also send to the server a command property with the value "from" (not for localStorage)
	in php this can be received as $_GET["command"] or $_POST["command"] depending on bindType
	call is a callback function after the data is received
		the callback function will receive data in its parameter of the data set
		the properties of the objects are set automatically by bind
	** the targets and props must have already been bound by bind.add() or obj.bind()
	targets (default null) is an object or id or array of objects or ids to receive the data
	props (default null) properties to receive the data
	 	or both targets and properties for properties of the targets to receive the data
	extra (default null) extra information to be sent to the server (not localStorage)
		this could be an id or a search term, etc. it will have encodeURI() applied
		this can be received in php as $_GET["extra"] or $_POST["extra"] depending on bindType
	filter (default null) a function to run before sending and after receiving data
		this will receive (data, command, extra, process) parameters
		command will be "fromTo" when sending data to server (requesting data)
		command will be "from" when receiving data from the server
		calling process.stop() will stop the current to() or from() call from proceeding
		the function must return the data - see Bind masterFilter parameter for more information
		note: the masterFilter and the bind filter if supplied will run as well before the filter
to(targets, props, extra, filter, smartDecimals, call) - send bind data to the connection (localStorage or database)
	** accepts ZIM DUO normal parameters or configuration object literal with parameter names as propterties
	to() will also send to the server a command property with the value "to" (not for localStorage)
	in php this can be received as $_GET["command"] or $_POST["command"] depending on bindType
	** the targets and props must have already been bound by bind.add() or obj.bind()
	targets (default null) is an object or id or array of objects or ids to send the data
	props (default null) properties to send the data
		or both targets and properties for properties of the targets to send the data
	extra (default null) extra information to be sent to the server (not localStorage)
		this could be an id or a search term, etc. it will have encodeURI() applied
		this can be received in php as $_GET["extra"] or $_POST["extra"] depending on bindType
	filter (default null) a function to run before sending data
		this will receive (data, command, extra) parameters - command will be "to"
		calling process.stop() will stop the current to() or from() call from proceeding
		the function must return the data - see Bind masterFilter parameter for more information
		note: the masterFilter and the bind filter if supplied will run as well before the filter
	smartDecimals (default bind smartDecimals) override the bind smartDecimals
		set to true to send numbers > 1 with 1 decimal or numbers < 1 with 2 decimals
	call is a callback function after the data is sent and received
	the callback function will receive a result in its parameter
	often with a success or error property or string
toUnique(targets, props, extra, filter, smartDecimals, call) - send bind data to the connection along with a unique=true variable
	This is the same as to() but sends a unqiue=true variable
	The unique variable can be tested for on the server
	and an appropriate resonse can be returned
	For instance, return false if the extra variable is being used as a key and it is not unique
	In normal binding, we would want to then update
	but is some cases, we might be trying to add a unqique object to bind to in the future
toLock(targets, props, extra, filter, smartDecimals, call) - like a to() but prevents old data from being stored
	A filter with command=="from" must be used to adjust data - see below for more.
	Use when multiple people are appending to or updating the same JSON data object.
	Do not use if users are simply overwriting all the data - just use a to() for that.
	SCENARIO:
		Imagine that there is a bind to a TextArea() filled with user comments
		Traditionally, each comment would be stored as a record (row) in the database table
		With binding, it is easier to store these as a JSON string in one record
		If two users have the JSON object at the same time and one updates the JSON object,
		the second user will not receive this update so their JSON object will be out of date
		When the second user sends their JSON object it will overwrite the first user's update
		The first user's update will be lost
	SENARIO:
		Imagine that there is a five star system that stores total stars and total voters in a JSON object
		It would be bad for a user to initially collect this data and then twenty minutes later,
		write to this data without getting the latest data.
	SOLUTION:
	toLock() solves this by fetching the latest data just before a user wants to update.
	This data is available in a filter when command=="from".
	The DATA MUST BE MODIFIED in the filter.  Then return the modified data and
	toLock() sends the modified data to the server.

	-- SERVER
	-- ZIM Base should be used in the PHP code - see https://zimjs.com/base/
	-- the database table should have a field called lockid of type varchar
	-- in the $command=="from" the record should be locked as follows:
	-- if ($lockid) $base->setLock("table_name", $id, $lockid);
	-- this assumes you are updating a record with an id - this can adjusted - see ZIM Base.

	** accepts ZIM DUO normal parameters or configuration object literal with parameter names as propterties
	** the targets and props must have already been bound by bind.add() or obj.bind()
	targets (default null) is an object or id or array of objects or ids to send the data
	props (default null) properties to send the data
		or both targets and properties for properties of the targets to send the data
	extra (default null) extra information to be sent to the server (not localStorage)
		this could be an id or a search term, etc. it will have encodeURI() applied
		this can be received in php as $_GET["extra"] or $_POST["extra"] depending on bindType
	filter (default null) a function that will run three times during the process
		this will receive (data, command, extra) parameters
		the commands for the three times will be:
		command "fromTo" before the from request for current data is sent and the record is locked
		command "from" current data is received but before bound properties are set with current data
			it is here that new data can be added to or updated in the filter data object
			as the data object is about to be used to update the bound properties
		command "to" before new properties are sent to be stored and the record unlocked
		calling process.stop() will stop the current to() or from() call from proceeding
		the function must return the data - see Bind masterFilter parameter for more information
		note: the masterFilter and the bind filter if supplied will run as well before the filter
	smartDecimals (default bind smartDecimals) override the bind smartDecimals
		set to true to send numbers > 1 with 1 decimal or numbers < 1 with 2 decimals
	call is a callback function after the data is sent and received
		the callback function will receive a result in its parameter
		often with a success or error property or string
stop() - stops current to() or from() from running any further - sets the stopped property to true
	there are also process parameters provided to each filter function
	a safer way of stopping a specific bind is calling stop() on the process - process.stop()
report() - logs to the console a snapshot of the current bind data as Bind {DATA} Report:
	note: normally, the console shows updated data rather than static data - for instance at log time
	report() logs a zim.copy(data) which will not change in the console if the data is updated
toggleReport(state - default null) - turns on or off reports - see Bind report parameter
	or pass in true to show reports or false to hide reports
applyData() - used internally to set object properties based on current bind data
updatefilter(id, func) - update a bind filter at an id - set func to null to remove bind filter
	note: the masterFilter can be adjusted with the masterFilter property
clear() - for LOCALSTORAGE, clear the localStorage[connection]
removeAllBindings(removeConnectionData, call) - removes bind data
	removeConnectionData (default true) remove connection data
		this will clear localStorage for LOCALSTORAGE setting
		or send variable "removeAll" to connection for GET and POST
	call is a callback function after the data is sent and received
	the callback function will receive a result "success" or "error ..." in its parameter

PROPERTIES
type - holds the class name as a String
data - the latest data held by bind - might not be all data depending on the last from() call parameters
connection - the localStorage string or the url for GET or POST
bindType - the type of connection LOCALSTORAGE, GET or POST
master - get or set the master data being sent with to() or from()
masterFilter - get or set the masterFilter function
	note: to update the filter for a bind, noBind() and bind() with a new function
couple - get or set whether the data is coupled as sent and uncoupled as received - see couple parameter
smartDecimals - if true numbers > 1 will have 1 decimal and numbers < 1 will have 2 decimals
default - get or set whether this is the zimDefaultBind
	the zimDefaultBind is what DisplayObject bind() method will use unless bindObj is specified
	see also the Bind setDefault parameter
stopped - setting will stop the current bind process - see stop() and filter process.stop()
	note: this is stopped - not stop - stop() is the method
ajax - if type is POST then this is a reference to the ZIM Ajax object being used
** the following info objects are available but relate to one another
** so adjust with care - would suggest add() and remove() to adjust
bindings - a bind info object in the format
	{id:{obj:object, props:["prop1", "prop2"]}, id2:etc.}
ids - an array of all ids
objIDs - a ZIM Dictionary of objects that holds an array of ids for each object
toIDs - an object of to() properties in the form {prop1:[id1, id2], prop2:[id3]}
fromIDs - an object of from() properties in the form {prop1:[id1, id2], prop2:[id3]}
--*///+81.8
	if (typeof zimDefaultBind == "undefined") var zimDefaultBind;
	zim.Bind = function(connection, bindType, master, masterFilter, couple, smartDecimals, report, setDefault) {
		var sig = "connection, bindType, master, masterFilter, couple, smartDecimals, report, setDefault";
		var duo; if (duo = zob(zim.Bind, arguments, sig, this)) return duo;
		z_d("81.8");
		this.type = "Bind";

		var that = this;

		// ZIM NFT MODULE ADJUST
        if (zot(connection) && localStorage && zot(zimDefaultBind) && (zot(bindType) || bindType==zim.LOCALSTORAGE)) {
            connection = "zimBind";
            bindType = zim.LOCALSTORAGE;
        } else if (connection && connection.match(/\/|\./)) {
            if (zot(bindType)) bindType = zim.GET; // default to async
            if (!connection.match(/\?/)) connection += "?";
            else connection += "&";
        } else if (connection && zot(bindType)) {
            bindType = zim.LOCALSTORAGE;
        }
        if (zot(smartDecimals)) smartDecimals = true; // numbers bigger that 1 round to 1 decimal else round to 3 decimals

		if (bindType==zim.LOCALSTORAGE && !localStorage) {
			if (zon) zogy("Bind() - no localStorage");
			that.error = "error - no localStorage";
		}

        this.connection = connection;
		this.bindType = bindType;
		this.master = master;
		this.masterFilter = masterFilter;
		this.smartDecimals = smartDecimals;
		if (zot(report)) report = false;
		
        if (!zimDefaultBind || setDefault) {
            zimDefaultBind = this;
        }
		Object.defineProperty(that, 'default', {
			get: function() {
				return that == zimDefaultBind;
			},
			set: function(value) {
				if (!value && zimDefaultBind == that) zimDefaultBind = null;
				else if (value) zimDefaultBind = that;
			}
		});

		if (this.bindType == zim.POST) {
            that.ajax = new zim.Ajax();
        }

        this.bindings = {}; // { id:{obj:obj, props:[props], filter:function(){}} }
        this.ids = []; // all ids
        this.data = {}; // stores latest from data
        this.objIDs = new zim.Dictionary(true); // { obj:[ids] }
        this.toIDs = {}; // { prop:[ids] }
        this.fromIDs = {}; // { prop:[ids] }

        this.add = function(id,obj,props,extra,filter) {
            if (zot(props) || zot(obj) || zot(id)) return that;
            if (that.bindings[id]) {
                if (that.bindings[id].obj != obj) {
                    if (zon) zogy("Bind() - id can be used with only one object");
                    return that;
                }
            } else {
                // add id
                if (that.ids.indexOf(id)<=0) that.ids.push(id);
                // create data id
                that.bindings[id] = {obj:obj, props:[]};

				if (!zot(filter) && typeof filter == "function") that.bindings[id].filter = filter;

                // create or add to that.objIDs object list of ids
                var list = that.objIDs.at(obj);
                if (list) {
                    if (list.indexOf(id)<0) list.push(id);
                } else {
                    that.objIDs.add(obj,[id]);
                }
            }
            if (!Array.isArray(props) && props.constructor != {}.constructor) {
                props = [props];
            }

            var dataProps = that.bindings[id].props;
            // add to that.toIDs and that.fromIDs and that.bindings
            if (Array.isArray(props)) {
                zim.loop(props, function (prop) {
                    addTo(that.toIDs, prop, id);
                    addTo(that.fromIDs, prop, id);
                    if (dataProps.indexOf(prop)<0) dataProps.push(prop);
                });
            } else {
                zim.loop(props, function (key, val) {
                    if (val == zim.BOTH || val == zim.TO) {
                        addTo(that.toIDs, key, id);
                    }
                    if (val == zim.BOTH || val == zim.FROM) {
                        addTo(that.fromIDs, key, id);
                    }
                    if (dataProps.indexOf(key)<0) dataProps.push(key);
                });
            }

            function addTo(arr, prop, id) {
                if (zot(arr[prop])) arr[prop] = [id];
                else if (arr[prop].indexOf(id)<0) arr[prop].push(id);
            }

			if (report) sendReport("Bind Report: ADD ["+id+"]", (props?" "+props:"")+(extra?" "+extra:""));

			if (that.bindType==zim.LOCALSTORAGE) {
				that.from(null, id, props, extra);
				if (!that.data || zim.isEmpty(that.data)) that.to(id, props);
			} else {
				applyFilters("bind", null, [filter], that.data, extra);
				that.applyData();
			}
			
			return that;
        };

		this.updatefilter = function(id, func) {
			var idObj = that.bindings[id];
			if (idObj) {
				if (zot(func)) {
					if (idObj.filter) delete idObj.filter;
				} else {
					if (typeof func == "function") idObj.filter = func;
				}
			}
			return that;
		};

        this.remove = function(targets, props, extra, filter, removeConnectionData, call) {
			var ids;
            if (!zot(targets) && !Array.isArray(targets)) targets = [targets];
            if (!zot(targets)) {
                ids = [];
                var objs = [];
                zim.loop(targets, function (target) {
                    if (typeof target == "string") ids.push(target);
                    else objs.push(target);
                });
            }
            if (!zot(props) && !Array.isArray(props)) props = [props];
			if (zot(removeConnectionData)) removeConnectionData = true;

			targets = ids.concat(objs);
			if (targets.length == 0) targets = null;
			var filtered = filterData("from", targets, props, false);
			var filteredFunctions = filtered[0];
			filtered = filtered[1];

			var f = applyFilters("remove", filter, filteredFunctions, filtered, extra);
			if (f == "stop") return;

			var rememberdFiltered = zim.copy(filtered);

            if (zot(props) || props.length==0) {
                // object can have more than one id
                // id can only be assigned to one object
                if (ids.length>0) {
                    zim.loop(ids, function (id) {
                        clearID(id, true);
                    });
                }

                if (objs.length>0) {
                    zim.loop(objs, function (obj) {
                        ids = that.objIDs.at(obj);
                        if (ids && ids.length>0) {
                            zim.loop(ids, function (id) {
                                clearID(id, false);
                            });
                        }
                        that.objIDs.remove(obj);
                    });
                }
            } else {
                // removing props of obj or id
                ids = []; // collect empty ids
                zim.loop(filtered, function (id, props) {
                    var data = that.bindings[id];
                    var arr = data.props;
                    zim.loop(props, function (p) {
                        var ind = arr.indexOf(p);
                        if (ind>=0) arr.splice(ind,1);
                        removeToFrom(p,id);
                    });
                    if (arr.length==0) ids.push(id);
                });
                if (ids.length>0) that.remove(ids);
            }

			function callbackRemove(result) {
				if (call && typeof call == "function") {
					if (couple) result = zim.couple(result);
					call(result);
				}
				if (report) sendReport("Bind Report: REMOVE"+(extra?" ["+extra+"]":""),result);
			}
			if (removeConnectionData) {
				var conType = "type="+that.bindType+"&";
				if (that.bindType==zim.LOCALSTORAGE) {
					that.to();
					callbackRemove("success");
				} else if (that.bindType==zim.GET) {
					f = JSON.stringify(rememberdFiltered);
					if (couple) f = zim.couple(f);
                    zim.async(that.connection + conType + "remove=" + f, callbackRemove, "callbackRemove");
                } else if (that.bindType==zim.POST) {
                    that.ajax.post(that.connection + conType, rememberdFiltered, callbackRemove, "remove");
                } else if (that.bindType==zim.SOCKET) {
                    // socket
                }                
			}

            function removeToFrom(p, id) {
                var arr, ind;
                arr = that.fromIDs[p];
                if (arr) {
                    ind = arr.indexOf(id);
                    if (ind>=0) arr.splice(ind,1);
                    if (arr.length == 0) delete that.fromIDs[p];
                }
                arr = that.toIDs[p];
                if (arr) {
                    ind = arr.indexOf(id);
                    if (ind>=0) arr.splice(ind,1);
                    if (arr.length == 0) delete that.toIDs[p];
                }
            }

            function clearID(id, checkEmpty) {
                var object = that.bindings[id].obj;
                var properties = that.bindings[id].props;
                var arr = that.objIDs.at(object);
                var ind = arr.indexOf(id);
                if (ind>=0) arr.splice(ind,1);
                if (checkEmpty && arr.length==0) objs.push(object); // object is empty
                ind = that.ids.indexOf(id);
                if (ind>=0) that.ids.splice(ind,1);
                zim.loop(properties, function (p) {
                    removeToFrom(p,id);
                });
                delete that.bindings[id];
            }
			return that;
        };

        function filterData(type, targets, props) {
			// returns [filteredFunctions, filteredData] for either to or from

			var filteredFunctions = [];
			var ids;
            if (zot(targets) && zot(props)) {
				if (type=="from" && that.bindType!=zim.LOCALSTORAGE) {
					zim.loop(that.bindings, function (b) {
						if (b.filter) filteredFunctions.push(b.filter);
					});
					return [filteredFunctions, "full"];
				}
                ids = that.ids;
            } else {
                if (!zot(targets) && !Array.isArray(targets)) targets = [targets];
                if (!zot(props) && !Array.isArray(props)) props = [props];
                if (targets) {
                    ids = [];
                    zim.loop(targets, function (target) {
                        if (typeof target == "string") {
							if (ids.indexOf(target)<0) ids.push(target);
                        } else {
                            var idList = that.objIDs.at(target);
                            if (idList) {
                                zim.loop(idList, function (id) {
                                    if (ids.indexOf(id)<0) ids.push(id);
                                });
                            }
                        }
                    });
                }
            }

            var filtered = {};
            if (ids) addIDs(props);
            else if (props) addProps();
            return [filteredFunctions, filtered];

            function addIDs(props) {
                zim.loop(ids, function (id) {
					var b = that.bindings[id];
                    if (!b) return; // continue
					if (b.filter) filteredFunctions.push(b.filter);
                    var o = b.obj;
                    // if props then will filter only those props
                    // otherwise gets all props for id
                    zim.loop(props?props:b.props, function (prop) {
                        // if prop is in that.toIDs add it to filtered list
                        var p = that.toIDs[prop];
                        if (p && p.indexOf(id)>=0) {
                            if (type=="from") {
                                if (!filtered[id]) filtered[id] = [];
                                filtered[id].push(prop);
                            } else { // type=="to"
                                if (!filtered[id]) filtered[id] = {};
                                var v = o[prop];
                                if (typeof v == "number" && that.smartDecimals) {
                                    if (v>1) v = zim.decimals(v,1);
                                    else v = zim.decimals(v,2);
                                }
                                filtered[id][prop] = zim.copy(v);
                            }
                        }
                    });
                });
            }
            function addProps() {
				var ids = []; // keep unique ids
                zim.loop(props, function (prop) {
                    zim.loop(that.toIDs[prop], function (id) {
						var b = that.bindings[id];
						if (ids.indexOf(id) < 0) { // could be same id for multiple props
							if (b.filter) filteredFunctions.push(b.filter);
							ids.push(id);
						}
                        var o = b.obj;
                        if (type=="from") {
                            if (!filtered[id]) filtered[id] = [];
                            filtered[id].push(prop);
                        } else { // type=="to"
                            if (!filtered[id]) filtered[id] = {};
                            var v = o[prop];
                            if (typeof v == "number" && that.smartDecimals) {
                                if (v>1) v = zim.decimals(v,1);
                                else v = zim.decimals(v,2);
                            }
                            filtered[id][prop] = zim.copy(v);
                        }
                    });
                });
            }
        }

		this.stopProcess = false;
		this.stop = function() {
			that.stopped = true;
		};
		var Process = function() {
			var that = this;
			that.stop = function() {that.stopped = true;};
		};
		function applyFilters(command, filter, filteredFunctions, filtered, extra) {
			var process = new Process();
			var dataCheck = (filtered!=null && !zim.isEmpty(filtered) && that.data);
			if (checkStop(process, extra)) return ["stop", filtered];
			if (that.masterFilter && typeof that.masterFilter=="function") {
				filtered = that.data = that.masterFilter(filtered, command, extra, process);
			}
			var result = zim.loop(filteredFunctions, function (f) {
				if (typeof f=="function") {
					if (checkStop(process, extra)) return "stop";
					filtered = that.data = f(filtered, command, extra, process);
				}
			});
			if (result=="stop" || checkStop(process, extra)) return ["stop", filtered];

			if (filter && typeof filter=="function") {
				filtered = that.data = filter(filtered, command, extra, process);
			}
			if (checkStop(process, extra)) return ["stop", filtered];
			if (dataCheck && !that.data && zon) zogy("Bind()"+(command?" ["+command+"]":"")+(extra?" ["+extra+"]":"")+" - warning, a filter may not have returned data");
			return ["go", filtered];
		}

		function checkStop(process, extra) {
			if (that.stopped || process.stopped) {
				sendReport("STOP"+(extra?" ["+extra+"]":""), process.stopped?"process stopped":"bind stopped");
				if (process.stopped) process.stop = null;
				else that.stopped = false;
				return true;
			}
		}

        this.to = function(targets, props, extra, filter, smartDecimals, call, lock, unique) {
			var sig = "targets, props, extra, filter, smartDecimals, call, lock, unique";
			var duo; if (duo = zob(that.to, arguments, sig)) return duo;

            var filtered = filterData("to", targets, props, smartDecimals);
			var filteredFunctions = filtered[0];
			filtered = filtered[1];

			var resp = applyFilters("to", filter, filteredFunctions, filtered, extra);
			filtered = resp[1];
			if (resp[0] == "stop") return;

			if (that.bindType==zim.LOCALSTORAGE) {
                localStorage[that.connection] = JSON.stringify(filtered);
				callbackTo(filtered);
            } else {
				var conType = "type="+that.bindType+"&";
				if (!filtered || zim.isEmpty(filtered)) return that;
                if (that.bindType==zim.GET) {
					var f = filtered;
					if (!zim.isJSON(f)) f = JSON.stringify(f);
					if (couple) f = zim.couple(f);
					if (report) sendReport("Bind Report: TO [bindings]",f);
					f = zim.urlEncode(f);
					var addMaster = !zot(that.master)?"&master="+zim.urlEncode(master):"";
					var addLock = !zot(lock)?"&lock="+zim.urlEncode(lock):"";
					var addUnique = !zot(unique)?"&unique="+zim.urlEncode(unique):"";
					var addExtra = !zot(extra)?"&extra="+zim.urlEncode(extra):"";
					var fLine = that.connection + conType + "command=to&data=" + f + addMaster + addLock + addUnique + addExtra;
					if (report) sendReport("Bind Report: TO [url]",fLine);
                    zim.async(fLine, callbackTo, "callbackTo");
				} else if (that.bindType==zim.POST) {
					that.ajax.master = master;
					that.ajax.couple = couple;
					that.ajax.lock = lock;
					that.ajax.unique = unique;
					if (report) sendReport("Bind Report: TO [bindings]",filtered);
                    that.ajax.post(that.connection + conType, filtered, "to", extra, callbackTo);
                // } else if (that.bindType==zim.SOCKET) {
                }
            }
			function callbackTo(result) {
				if (couple) result = zim.decouple(result);
				if (call && typeof call == "function") call(result);
				if (report) sendReport("Bind Report: TO"+(extra?" ["+extra+"]":" -"),result);
			}
			return that;
        }; // end to

		this.toLock = function(targets, props, extra, filter, smartDecimals, call) {
			var sig = "targets, props, extra, filter, smartDecimals, call";
			var duo; if (duo = zob(that.toLock, arguments, sig)) return duo;

			if (that.bindType.toLowerCase()=="localstorage") {
				that.to(targets, props, extra, filter, smartDecimals, call);
				return that;
			}
			var lock = zim.makeID();
			that.from(returnCall, targets, props, extra, filter, lock);
			function returnCall() {
				that.to(targets, props, extra, filter, smartDecimals, call, lock);
			}
			return that;
		};

		this.toUnique = function(targets, props, extra, filter, smartDecimals, call) {
			var sig = "targets, props, extra, filter, smartDecimals, call";
			var duo; if (duo = zob(that.toUnique, arguments, sig)) return duo;
			that.to(targets, props, extra, filter, smartDecimals, call, null, true);
			return that;
		};

		this.toggleReport = function(state) {
			if (!zot(state)) report = state;
			else report = !report;
			return that;
		};

		if (report) sendReport("Bind Report: CREATE ["+bindType.toUpperCase()+"]", connection + (master?" "+master:""));

		function sendReport(t,m) {
			if (that==zimDefaultBind) zogl(t,m);
			else zogd(t,m);
		}
		this.report = function() {
			var t = "Bind {DATA} Report:";
			var m = zim.copy(that.data);
			if (that==zimDefaultBind) zogl(t,m);
			else zogd(t,m);
			
			t = "Bind {BINDINGS} Report:";
			m = zim.copy(that.bindings);
			if (that==zimDefaultBind) zogl(t,m);
			else zogd(t,m);
			return that;
		};

        this.from = function(call, targets, props, extra, filter, lock) {
			var sig = "call, targets, props, extra, filter, lock";
			var duo; if (duo = zob(that.from, arguments, sig)) return duo;

            var filtered = filterData("from", targets, props, smartDecimals);
			var filteredFunctions = filtered[0];
			filtered = filtered[1];

			var resp = applyFilters("fromTo", filter, filteredFunctions, filtered, extra);
			filtered = resp[1];
			if (resp[0] == "stop") return;

            // set the properties according to data received
			var conType = "type="+that.bindType+"&";
            if (that.bindType == zim.LOCALSTORAGE) {
                if (!localStorage[that.connection] || localStorage[that.connection] == undefined) localStorage[that.connection] = '{}';
                that.data = JSON.parse(localStorage[that.connection]);
                callbackFrom(that.data);
			} else {
				if (that.bindType == zim.GET) {
					var f = filtered;					
					if (!zim.isJSON(f)) f = JSON.stringify(f);
					if (couple) f = zim.couple(f);
					if (report) sendReport("Bind Report: FROM [bindings]",f);
					f = zim.urlEncode(f);
					var addMaster = !zot(that.master)?"&master="+zim.urlEncode(master):"";
					var addLock = !zot(lock)?"&lock="+zim.urlEncode(lock):"";
					var addExtra = !zot(extra)?"&extra="+zim.urlEncode(extra):"";
					var fLine = that.connection + conType + "data=" + f + "&command=from"+addMaster+addLock+addExtra;
					if (report) sendReport("Bind Report: FROM [url]",fLine);
                    zim.async(fLine, callbackFrom, "callbackFrom");
                } else if (that.bindType == zim.POST) {
					that.ajax.master = master;
					that.ajax.couple = couple;
					that.ajax.lock = lock;
					if (report) sendReport("Bind Report: FROM [bindings]",filtered);
                    that.ajax.post(that.connection + conType, filtered, "from", extra, callbackFrom);
                } // add SOCKET one day
            }
			function callbackFrom(data) {
				that.data = data;
				if (couple) that.data = zim.decouple(that.data);
				// set up check, when using lock, to see if data has been changed in filter
				if (!zot(lock)) var origData = JSON.stringify(that.data);
				var resp = applyFilters("from", filter, filteredFunctions, that.data, extra);
				if (resp[0] == "stop") return;
				// if in toLock there is a change then apply the data
				// otherwise overwrite data with future to call
				var appliedCheck = false;
				if (zot(lock) || origData != JSON.stringify(that.data)) {
					appliedCheck = true;
					that.applyData();
				}
				if (report) sendReport("Bind Report: FROM"+(extra?" ["+extra+"]":" -"), appliedCheck?that.data:"data not applied in toLock()");
				if (call && typeof call == "function") call(that.data);
			}

            return that;
        }; // end from

        this.applyData = function() {
            zim.loop(that.data, function (id, props) {
                var binding = that.bindings[id];
                if (binding) {
                    var obj = that.bindings[id].obj;
                    zim.loop(props, function(prop, val) {
                        obj[prop] = val;
                    });
                }
            });
            return that;
        };

        this.clear = function() {
            if (that.bindType == zim.LOCALSTORAGE) localStorage.removeItem(that.connection);
			return that;
        };

        this.removeAllBindings = function(removeConnectionData, call) {
			if (zot(removeConnectionData)) removeConnectionData = true;
            this.bindings = {};
            this.ids = [];
            this.data = {};
            this.objIDs = new zim.Dictionary(true);
            this.toIDs = {};
            this.fromIDs = {};

			if (removeConnectionData) {
				var conType = "type="+that.bindType+"&";
				if (that.bindType==zim.LOCALSTORAGE) {
					that.clear();
					callbackRemoveAll("success");
				} else if (that.bindType==zim.GET) {
					var addMaster = !zot(that.master)?"&master="+encodeURI(master):"";
					zim.async(that.connection + conType + "command=removeAll"+addMaster, callbackRemoveAll, "callbackRemoveAll");
				} else if (that.bindType==zim.POST) {
					that.ajax.master = master;
					that.ajax.post(that.connection + conType, {}, "removeAll", null, callbackRemoveAll, "removeAll");
				} // add SOCKET one day				
			}
			function callbackRemoveAll(result) {
				if (call && typeof call == "function") (call)(result);
				if (report) sendReport("Bind Report: REMOVEALL",result);
			}
			return that;
        };
		

		return that;
	};
	//-81.8


// SUBSECTION CONTROLLERS

/*--
zim.Swipe = function(obj, distance, duration, isometric, overrideNoSwipe)

Swipe
zim class - extends a createjs.EventDispatcher

DESCRIPTION
Sets up capturing swipes on objects.
Dispatches a "swipe" event on swipe left, right, up, down.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const rect = new Rectangle(200, 200, blue).center();
const swipe = new Swipe(rect);
const distance = 100;
swipe.on("swipe", e=>{
	zog(e.swipeX); // -1, 0, 1  (for left, none and right)
	zog(e.swipeY); // -1, 0, 1  (for up, none and down)

	// move directly:
	// rect.x += distance * e.swipeX;
	// rect.y += distance * e.swipeY;
	// S.update();

	// or animate
	rect.animate({
		props:{
			x:rect.x+distance*e.swipeX,
			y:rect.y+distance*e.swipeY
		},
		time:.4,
		ease:"quadOut"
	});
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
obj - the object you want to swipe on
distance - (default 30) the distance in pixels to activate swipe
	might want to pass in a pixel distance based on percentage of stage
duration - (default .08) time in seconds to travel that distance (also see ZIM TIME constant)
	try https://zimjs.com/swipe.html for testing distance and time (speed)
isometric - (default false) set to true to rotate swiping test by 30 degrees
 	for swiping on ZIM game Board({isometric:true})
	left-right is from top left to bottom right (cols)
	top-bottom is from top right to bottom left (rows)
overrideNoSwipe - (default false) set to true to override any ZIM noSwipe settings
	for example, a Slider has zimNoSwipe set on its elements so swiping the list does not swipe a page in Pages

METHODS
enable() - set swipe to active (by default it is)
disable() - set swipe to inactive (sets active to false and does not dispatch)

PROPERTIES
type - holds the class name as a String
distance - the distance needed for swipe to activate
duration - the time from mousedown a swipe is measured for distance
direction - the direction of the last swipe (left, right, up, down or none)
obj - the object that was last swiped
active - Boolean true for dispatching swipes and false for not

EVENTS
dispatches a "swipe" event on every pressup (even if swipe failed and direction is none)
when a swipe event triggers
the Swipe event object has a swipeX and swipeY property that is -1,0, or 1
for left, none, or right OR up, none, down
the event object has an obj property as well for what object was swiped
also dispatches a "swipedown" event for convenience on a mousedown

LEGACY
the Swipe object provides a direction property of LEFT, RIGHT, UP, or DOWN
the Swipe object provides an obj property of what object was swiped on
for instance if e is the event object
then e.target is the Swipe object so use e.target.direction
did not dispatch a custom event due to lack of support in early IE
Swipe also dispatches a direction of "none" if the mouse movement is not a swipe
this can be used to snap back to an original location
--*///+70
	zim.Swipe = function(obj, distance, duration, isometric, overrideNoSwipe) {
		var sig = "obj, distance, duration, isometric, overrideNoSwipe";
		var duo; if (duo = zob(zim.Swipe, arguments, sig, this)) return duo;
		z_d("70");
		this.cjsEventDispatcher_constructor();
		this.type = "Swipe";

		if (zot(obj) || !obj.on) {zogy("zim controls - Swipe():\nPlease pass in object"); return;}
		if (zot(distance)) distance = 30; // pixels for swipe to count
		var timeType = getTIME(duration);
		if (zot(duration)) duration = timeType=="s"?.08:80; // ms to test pixels

		this.distance = distance;
		this.duration = duration;
		this.active = true;

		var startX;
		var startY;
		var downCheck;
		var mouseX;
		var mouseY;
		var timer;
		var that = this;
		
		var pmEvent;
		var puEvent;
		var mdEvent = obj.on("mousedown", function(e) {
			if (!that.active || (!overrideNoSwipe && e.target.zimNoSwipe)) return;
			that.obj = e.target;
			mouseX = startX = e.stageX/zim.scaX;
			mouseY = startY = e.stageY/zim.scaY;
			downCheck = true;
			that.dispatchEvent("swipedown");
			clearTimeout(timer);
			timer = setTimeout(function() {
				if (downCheck) {
					checkSwipe();
					downCheck = false;
				}
			}, that.duration*(timeType=="s"?1000:1));
			pmEvent = obj.on("pressmove", function(e) {
				mouseX = e.stageX/zim.scaX;
				mouseY = e.stageY/zim.scaY;
			});
			puEvent = obj.on("pressup", function() {
				if (downCheck) {
					checkSwipe();
					downCheck = false;
					clearTimeout(timer);
				}
			});

			function checkSwipe() {
				var ev = new createjs.Event("swipe");
				ev.obj = that.obj;
				ev.stageX = e.stageX/zim.scaX;
				ev.stageY = e.stageY/zim.scaY;
				ev.rawX = e.rawX/zim.scaX;
				ev.rawY = e.rawY/zim.scaY;
				ev.swipeX = ev.swipeY = 0;
				that.direction = "none";
				// may as well use 45 degrees rather than figure for aspect ratio

				if (isometric) {
					if (Math.abs(mouseX - startX) > that.distance || Math.abs(mouseY - startY) > that.distance) {
						// thought it was 30 degrees - turns out it is based on 90 degrees - so could calculate more easily...
						var angle = Math.atan2((mouseY - startY),(mouseX - startX))*180/Math.PI;
						angle = (angle+360)%360;
						if (angle>=270 && angle<360) {ev.swipeY = -1; that.direction="up";}
						else if (angle>=0 && angle<90) {ev.swipeX = 1;  that.direction="right";}
						else if (angle>=90 && angle<180) {ev.swipeY = 1;  that.direction="down";}
						else if (angle>=180 && angle<270) {ev.swipeX = -1; that.direction="left";}
					}
				} else {
					// 45 degree based
					if (Math.abs(mouseX - startX) > Math.abs(mouseY - startY)) {
						if (mouseX - startX > that.distance) {ev.swipeX = 1;  that.direction="right";}
						if (startX - mouseX > that.distance) {ev.swipeX = -1; that.direction="left";}
					} else {
						if (mouseY - startY > that.distance) {ev.swipeY = 1;  that.direction="down";}
						if (startY - mouseY > that.distance) {ev.swipeY = -1; that.direction="up";}
					}
				}
				that.dispatchEvent(ev);
			}
		});

		this.disable = function() {
			that.active = false;
		};

		this.enable = function() {
			that.active = true;
		};
		
		this.dispose = function() {
			if (mdEvent) obj.off("mousedown", mdEvent);
			if (pmEvent) obj.off("pressmove", pmEvent);
			if (puEvent) obj.off("pressup", puEvent);
		};
	};
	zim.extend(zim.Swipe, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-70

/*--
zim.Swiper = function(swipeOn, target, property, sensitivity, swiperType, min, max, damp, integer, factor, loop, pauseTime, otherSwiper)

Swiper
zim class - extends a createjs EventDispatcher

DESCRIPTION
Swiper lets you change a property of any object (with damping) by swiping.
In a sense, it is like an invisible Slider.
You pass in the DisplayObject to swipe on - stage, Container, Bitmap, etc.
You pass in which object holds the property to animate and the property name.
Then Swiper will change this property with damping based on a sensitivity you set.
You can use horizontal or vertical but to do both, you need to make two Swiper objects.
Originally made for controlling 3D objects like rotation and scale
based on swiping a rectangle beneath the 3D object that is the same color as the stage.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circle = new Circle(100, green).center();
// will move circle twice as fast as swipe
const swiper = new Swiper(S, circle, "x", 2);
END EXAMPLE

EXAMPLE
const man = new Rectangle(50, 100, brown).center();
// will move man up an down slowly within vertical bounds of stage
const swiper = new Swiper(man, man, "y", .5, false, 0, H-man.height);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
swipeOn - the DisplayObject to swipe on such as the stage or a Rectangle or Bitmap, etc.
target - the object that holds the property that you want to change
property - the property name as a String to change when swiping
	Note: the Swiper will stop if the property value is less than .5 - this handles motion and rotation well
	but if swiping for scale or alpha, etc. this may stop too soon
	so set the min and max and the swiper will adjust to be one thousandth the difference between the two
sensitivity - (default 1) the change in property is equal to the change in distance times the sensitivity
	set to 2 to change the property twice as fast as the swipe
	set to .5 to change the property half as fast as the swipe
	set to .001 to change the property very little while swiping
	set to -1 to go the opposite way (or -2, -.5, -.001, etc.)
swiperType - (default HORIZONTAL) or set to VERTICAL or RADIAL
min - (default null) if specified, the property value will not go below this number
	set min and max if swipe property is a small range - like for alpha or scale
max - (default null) if specified, the property value will not go above this number
	set min and max if swipe property is a small range - like for alpha or scale
damp - (default .1) the damp value with 1 being no damping and 0 being no movement
integer - (default false) set to true to round the property value
factor - (default 1) is going the same direction and -1 is going in opposite direction
loop - (default false) set to true to loop the property within the min and max values 
pauseTime - (default .2) time in seconds to call swipepause event (also see ZIM TIME constant)
 	triggers if no swipe motion and swipeOn is pressed
otherSwiper - (default null) pass in a second Swiper object 
	if the change in pixels is more on the other swiper then this swiper is not used 
	if the change in pixels is more on this swiper then this swiper is used

METHODS
immediate(val) - set the damping immediately to this value to avoid damping to value
dispose() - remove listeners and Ticker

PROPERTIES
type - holds the class name as a String
target - get or set the target for the property that you are changing
property - get or set the String property name that is being damped
desiredValue - the current value that the swiper is damping towards
sensitivity - get or set the sensitivity - see sensitivity parameter
min - read only get the min 
max - read only get the max 
damp - get or set the damp of the Swiper
enabled (default true) - set to false to disable the Swiper and visa versa

EVENTS
dispatches a "swipedown" event when swipe is started
dispatches a "swipemove" event when swipe is moving
dispatches a "swipeup" event when swipe is ended
dispatches a "swipepause" event when finger is not swiping but still down - see pauseTime parameter
dispatches a "swipestop" event when swipeup has happened and value has stopped changing (delay is due to damp)
--*///+69.5
	zim.Swiper = function(swipeOn, target, property, sensitivity, swiperType, min, max, damp, integer, factor, loop, pauseTime, otherSwiper) {
		var sig = "swipeOn, target, property, sensitivity, swiperType, min, max, damp, integer, factor, loop, pauseTime, otherSwiper";
		var duo; if (duo = zob(zim.Swiper, arguments, sig, this)) return duo;
		z_d("69.5");		

		this.cjsEventDispatcher_constructor();
		this.type = "Swiper";

		if (zot(swipeOn) || !swipeOn.getStage || !swipeOn.stage) {zogy("zim.Swiper() - please provide container on stage"); return;}
		if (zot(target)) return;
		if (zot(sensitivity)) sensitivity = 1;
		if (zot(swiperType)) swiperType = "horizontal";
		if (zot(damp)) damp = .1;
		if (damp===false) damp = 1;
		if (zot(integer)) integer = false;
		if (zot(factor)) factor = 1;
		if (zot(loop)) loop = false;
		var timeType = getTIME(pauseTime);
		if (zot(pauseTime)) pauseTime = timeType=="s"?.2:200;
		
		var that = this;
		var container = swipeOn;
		var startPos;
		var startVal;
		var desiredVal = that.desiredValue = target[property];
		var stage;
		this.target = target;
		this.property = property;
		this.sensitivity = sensitivity;		
		var downCheck = false;

		that.min = min;
		that.max = max;
		
		var frame = WW.zdf || swipeOn.stage?swipeOn.stage.frame:{};
		
		if (container.canvas) {
			stage = container;
			that.downEvent = container.on("stagemousedown", function(e) {
				downCheck = true;
				downHandler(e);
				that.moveEvent = container.on("stagemousemove", pressHandler);
				that.upEvent = container.on("stagemouseup", doUpStage);
				that.upEvent2 = frame.on("mouseupplus", doUpStage);
			});			
		} else {
			stage = container.stage;
			offMouseEvents();
			that.downEvent = container.on("mousedown", downHandler);
			that.moveEvent = container.on("pressmove", pressHandler);
			that.upEvent = container.on("pressup", doUpObj);
			that.upEvent2 = frame.on("mouseupplus", doUpObj);			
		}
		
		function doUpStage() {
			downCheck = false;
			container.off("stagemousemove", that.moveEvent);
			container.off("stagemouseup", that.upEvent);
			that.dispatchEvent("swipeup");
		}
		function doUpObj() {
			downCheck = false;
			that.dispatchEvent("swipeup");
		}

		var a1, a2, cent;
		var maxR = Math.sqrt(Math.pow(container.width,2)+Math.pow(container.height,2));
		var startPosX, startPosY;
		var moveCheck = false;
		function downHandler(e) {
			moveCheck = true;
			stage = e.target.stage;			
			cent = (container.parent?container.parent:container).localToGlobal(container.x,container.y);
			downCheck = true;
			if (swiperType == "radial") {
				startPosX = e.stageX/zim.scaX;
				startPosY = e.stageY/zim.scaY;
				a1 = Math.atan2(startPosY-cent.y, startPosX-cent.x)*zim.DEG;
			} else {
				startPos = swiperType=="horizontal"?e.stageX/zim.scaX:e.stageY/zim.scaY;
			}
			startVal = that.target[that.property];
			that.dispatchEvent("swipedown");
		}
		function pressHandler(e) {			
			if (!downCheck) return;			
			if (swiperType == "radial") {
				that.diff = zim.dist(startPosX, startPosY, e.stageX/zim.scaX, e.stageY/zim.scaY);
				a2 = Math.atan2(e.stageY/zim.scaY-cent.y, e.stageX/zim.scaX-cent.x)*zim.DEG;
				var si = zim.sign(a1-a2);
				if (Math.abs(a2-a1)>180) {
					downCheck = false;
					return;
				}
				that.diff = that.diff * si;
				var radialDist = Math.max(10,zim.dist(cent.x, cent.y, e.stageX/zim.scaX, e.stageY/zim.scaY));
				that.diff *= (maxR-radialDist)/maxR											
			} else {
				that.diff = startPos-(swiperType=="horizontal"?e.stageX/zim.scaX:e.stageY/zim.scaY);
			}
			if (otherSwiper) {
				if (Math.abs(that.diff) < Math.abs(otherSwiper.diff)) {
					that.override = true;
					otherSwiper.override = false;
				} else {
					that.override = false;
					otherSwiper.override = true;					
				}
			}
			if (that.override) return;
						
			if (Math.abs(that.diff) > 0) that.swiperMoving = true;
			desiredVal = startVal - that.diff*that.sensitivity*factor;
			if (!zot(min) && !zot(max) && loop) { // looping
				var lastDesiredVal = desiredVal;
				desiredVal = (desiredVal + (max-min)*10000 - min) % (max-min) + min;
				if (Math.abs(lastDesiredVal-desiredVal) > Math.abs(max-min)*.8) {
					that.immediate(desiredVal);
					startPos = swiperType=="horizontal"?e.stageX/zim.scaX:e.stageY/zim.scaY;
					startVal = that.target[that.property];
				}
			} else {
				if (!zot(min)) desiredVal = Math.max(desiredVal, min);
				if (!zot(max)) desiredVal = Math.min(desiredVal, max);
			}
			that.desiredValue = desiredVal;
			that.dispatchEvent("swipemove");
		}
		var swiperDamp = new zim.Damp(that.target[that.property], damp);
		var lastDesiredVal = desiredVal;
		var lastPausedVal = desiredVal;
		that.swiperTicker = zim.Ticker.add(function() {
			if (desiredVal == lastDesiredVal) {
				if (desiredVal != lastPausedVal) {
					if (that.pauseTimeout) that.pauseTimeout.clear();
					lastPausedVal = desiredVal;
					that.pauseTimeout = zim.timeout(pauseTime, function() {
						if (downCheck) that.dispatchEvent("swipepause");
						that.pauseTimeout = null;
					});
				}
			} else {
				lastPausedVal = null;
				lastDesiredVal = desiredVal;
				if (that.pauseTimeout) that.pauseTimeout.clear();
			}
			if (!that.swiperMoving) return;
			
			that.target[that.property] = integer?Math.round(swiperDamp.convert(desiredVal)):swiperDamp.convert(desiredVal);
			// if (!downCheck && Math.abs(that.target[that.property]-desiredVal) < ((!zot(max)&&!zot(min))?Math.abs(max-min)/1000:.5)) {
			if (moveCheck && !downCheck && Math.abs(that.target[that.property]-desiredVal) < Math.abs(sensitivity)/2) {
				that.swiperMoving = false;
				moveCheck = false;
				that.target[that.property] = desiredVal; // snap to final value
				that.immediate(that.target[that.property]);
				that.dispatchEvent("swipestop");
			} 
		}, stage);

		this.immediate = function(val) {
			swiperDamp.immediate(val);
			that.target[that.property] = integer?Math.round(val):val;
			that.desiredValue = desiredVal = val;
		};

		var _enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return _enabled;
			},
			set: function(value) {
				if (_enabled == value) return;
				if (value) {
					enable();
				} else {
					disable();
				}
				_enabled = Boolean(value);
			}
		});

		Object.defineProperty(that, 'desiredValue', {
			get: function() {
				return desiredVal;
			},
			set: function(value) {
				that.swiperMoving = true				
				desiredVal = value;
			}
		});
		
		Object.defineProperty(that, 'damp', {
			get: function() {
				return damp;
			},
			set: function(value) {
				damp = value;
				swiperDamp.damp = damp;
			}
		});

		function offStageEvents() {
			container.off("stagemousedown", that.downEvent);
			container.off("stagemousemove", that.moveEvent);
			container.off("stagemouseup", that.upEvent);
			frame.off("mouseupplus", that.upEvent2);
		}
		function offMouseEvents() {
			container.off("mousedown", that.downEvent);
			container.off("pressmove", that.moveEvent);
			container.off("pressup", that.upEvent);
			frame.off("mouseupplus", that.upEvent2);
		}

		function disable() {
			if (container.canvas) offStageEvents();
			else offMouseEvents();
			zim.Ticker.remove(that.swiperTicker);
		}

		function enable() {
			if (container.canvas) {
				that.downEvent = container.on("stagemousedown", that.downEvent);
			} else {
				that.downEvent = container.on("mousedown", that.downEvent);
				that.moveEvent = container.on("pressmove", that.moveEvent);
				that.upEvent = container.on("pressup", that.upEvent);
				that.upEvent2 = frame.on("mouseupplus", that.upEvent2);
			}
			that.immediate(that.target[that.property]);
			that.swiperTicker = zim.Ticker.add(that.swiperTicker, stage);
		}

		this.dispose = function() {
			disable();
			swiperDamp = null;
			that.swiperTicker = null;
		};
	};
	zim.extend(zim.Swiper, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-69.5

/*--
zim.MotionController = function(target, type, speed, axis, boundary, map, diagonal, damp, flip, orient, constant, firstPerson, turnSpeed, moveThreshold, stickThreshold, container, localBoundary, mouseMoveOutside, mousedownIncludes, minPercentSpeed, maxPercentSpeed, dampKeyup, rotate, mouseOutside)

MotionController
zim class - extends a createjs EventDispatcher

DESCRIPTION
MotionController lets you control an object (target) in a container (like the stage)
with "mousedown", "mousemove", "pressmove", "keydown", "gamebutton", "gamestick", "manual", etc. modes (types)
For instance, you can control a player in a game or a butterfly in field
SEE: https://zimjs.com/controller for more examples
SEE: https://zimjs.com/explore/sidescroller.html for keyboard work with Scroller, Sprite, Dynamo, Accelerator
SEE: https://zimjs.com/pen or https://zimjs.com/genpen (complex example)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const circle = new Circle(40, green).center();
const controller = new MotionController(circle); // circle moves to mouse press position with damping
END EXAMPLE

EXAMPLE
const rect = new Rectangle(50, 30, green).centerReg();
const controller = new MotionController({
	target:rect,
	type:"keydown",
	diagonal:true,
	damp:.1,
	rotate:true
});
END EXAMPLE

EXAMPLE
new MotionController({
	target:new Pen().addTo(), 
	type:"pressmove",
	damp:.5, // pen has damp too so can up this number
	speed:20
});
END EXAMPLE

EXAMPLE 
const background = new Pic("background.png").addTo(); // assuming loaded in Frame
const ball = new Circle().centerReg();
const scroller = new Scroller(background); 
const accelerator = new Accelerator(scroller);

// control speed of Accelerator with MotionController
new MotionController({
	target:accelerator,
	type:"mousemove", // or "pressmove"
	axis:HORIZONTAL,
	// the Scroller makes two backings - backing1 and backing2
	// allow pressing on both backings and ball to control scroller
	mousedownIncludes:[scroller.backing1, scroller.backing2, ball],
	speed:30,            
	minPercentSpeed:-1000,
	maxPercentSpeed:1000,
	boundary:new Boundary(0,0,W,0) // setting a boundary and speed will balance the control
});

// control position of ball with MotionController
new MotionController({
	target:ball,
	type:"mousemove",
	// allow press on Scroller backings
	mousedownIncludes:[scroller.backing1, scroller.backing2],
	speed:10            
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
target (default null) - the object you want to control
	example a circle to move across the stage
	can also be an Accelerator() to control percentSpeed
	if you only want data from the MotionController you can leave the target parameter as null (don't include it)
	can be a Pen() - both pen and motionController have damp parameter so probably adjust one or the other to 1
type - (default "mousedown") by default will move to where you press in the container
	set to "mousemove" to have the target follow the mouse movement
	set to "pressmove" to have target jump to mousedown position then follow while pressing - good for Pen
	set to "pressdrag" to have target follow mouse if pressed on and then dragged (dedicated to Shan Ruan)
	set to "keydown" to use keys to control the target (see map parameter)
	set to "gamebutton" to use gamepad buttons to control the target (see map parameter)
	set to "gamestick" to use gamepad stick(s) to control the target (see map parameter)
	set to "swipe" to use swipe to control the target
	set to "follow" to mousedown and hold and use F.follow() to keep moving towards mouse or press position
	set to "manual" to set your own with myController.convert() or myController.x and myController.y properties
	set to a ZIM DPad object to use the DPad to control the motion
speed - (default 7 or 20 if type is pressmove) pixels it will move each tick, keypress buttonpress, swipe, etc.
axis - (default BOTH or HORIZONTAL if target is Accelerator) or HORIZONTAL or VERTICAL (see diagonal parameter)
boundary - (default null) a ZIM Boundary object for the boundary
	the registration point of the target will stay within this boundary
	this boundary is relative to the stage (global)
	if the boundary object is a Blob, the target will stay within the Blob
	if a boundary relative to the object's parent is desired then set the localBoundary parameter to true
	the boundary is automatically added to mousedownIncludes
	ignored when target is Accelerator - use minPercentSpeed and maxPercentSpeed instead
map - (default null) an Array with left, right, up, down values (or array of values) as outlined below
 	- (default [[65,37], [68,39], [87,38], [83,40]] when type == "keydown") these are ADWS and arrows
	- (default [14, 15, 12, 13] when type == "gamebutton") these are DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DPAD_DOWN on a gamepad
	- (default [14, 15, 7, 6] when type == "gamebutton" and firstPerson == true) these are DPAD_LEFT, DPAD_RIGHT, RT, LT on a gamepad
	- (default [0, 0, 1, 1] when type == "gamestick") these are LSX, LSX, LSY, LSY on a gamepad
	- (default [[0,2], [0,2], [1], [1]] when type == "gamestick" and firstPerson == true) turn with left or right stick X, advance with left stick Y
		use [[0,2], [0,2], [1,3], [1,3]] for both sticks (first stick motion overrides second stick)
		Note: MotionController will only use the 0 and the 2 index for speed as the sticks use -1 to 1 values
		so you could not go only left with one stick and only right with another
		Note: stick values may exceed -1 and 1 on occasion (see also stickThreshold)
diagonal - (default true) set to false to lock movement to horizontal or vertical only
damp - (default .1 or .5 if type is pressmove) the damp value with 1 being no damping and 0 being no movement
flip - (default null) set to HORIZONTAL, VERTICAL or BOTH to flip the target when in negative direction
	flip will not work if the target starts rotated - so make the target a container and add a rotated object to the container
orient - (default false) set to true to face the direction of motion.  Start direction is 0 which is to the right.
	for example, a default ZIM Triangle points up so use triangle.rot(90)
	before adding to the motionController to make it point to the right
	Note that a target that is rotated will not pay attention to the flip parameter - see flip for solution.
constant - (default false) set to true to remove keyup or gamebutton up and always move in direction last key or button press
firstPerson - (default false) set to true for keydown, gamebutton and gamecontroller to go to first person mode
	in firstPerson, the direction starts facing up and by default up arrow is speed forward and left and right change rotation
	speed will be damped by damp parameter - also, map parameter changes if in firstPerson mode - see map parameter
turnSpeed - (default speed*.4) - the speed for turning in firstPerson mode - will be damped but damp parameter
moveThreshold - (default 5) pixels negative or positive to treat damped motion as stopped
stickThreshold - (default .2) gamepad stick axes values are from -1 to 1 but there is a lot of noise
	so consider within +- stickThreshold as no motion 0
container - (default zimDefaultFrame stage) the Container the target is in - the stage is most likely fine
	if container is specified, it must be on the stage when the MotionController is made
localBoundary - (default false) which means the boundary is global - set to true for a boundary in the object parent frame
mouseMoveOutside - (default true) set to false to not allow mouse movement outside the stage to affect motion
mousedownIncludes - (default null) a single object or array of objects (aside from the stage) to activate with mousedown
	For mousedown and pressmove types, the mousedown will activate on the stage only
	The controller assumes everything in the container will not activate the mousedown
	This lets you activate interface elements without moving to them ;-)
	If for instance, a backing is used other than the stage, just pass in the backing to this parameter
	See also the mousedownIncludes property
	The boundary is automatically added to mousedownIncludes
	If the container is provided and it has a backing property, this is added automatically to the mouseDownIncludes at the start 
	The backing can be removed from the mousedownIncludes property with mc.mousedownIncludes.splice(mc.mousedownIncludes.indexOf(mc.container.backing, 1));
minPercentSpeed - (default 0) if target is an Accelerator, the percentSpeed at the left or top of the stage (depending on axis)
minPercentSpeed - (default 100) if target is an Accelerator, the percentSpeed at the right or bottom of the stage (depending on axis)
dampKeyup - (default .3) damping applied to slow down Accelerator with keydown
rotate - (depreciated) the same as orient - kept for backwards compatibility as of ZIM Cat 01
mouseOutside - (default false) if a container or boundary is provided, set to true to start motion if pressing outside container or boundary

METHODS
pause(state, time) - state defaults to true and pauses the motionController (sets speed to 0)
	set state to false to unpause the motionController (sets speed to speed before pausing)
	set the time (default 0) to the seconds to take while slowing the motionController to 0 speed (also see ZIM TIME constant)
immediate(x, y) - set the damping immediately to this value to avoid damping to value - returns object for chaining
convert(x, y) - for manual mode, pass in x and y and damping and rotation will be calculated
dispose() - remove listeners and Ticker, Swiper and GamePad, where applicable

PROPERTIES
type - holds the class name as a String
target - the target that you are controlling
	target.x and target.y will give you damped x and y
x - the desired x position of the target before damping is applied (use this for manual input - or convert() method)
y - the desired y position of the target before damping is applied (use this for manual input - or convert() method)
dirX - the x direction the player is moving (-1,0,1)
dirY - the y direction the player is moving (-1,0,1)
rotation - read only rotation of the player in degrees
scaleX - read only scaleX of player (to get flip data if only using controller for data)
scaleY - read only scaleY of player (to get flip data if only using controller for data)
dampX - reference to the horizonal Damp object
dampY - reference to the vertical Damp object
dampKeyup - get or set keyup damping for when using an accelerator
paused - read only - true if paused and false if not - must be set with pause() method
speed - the speed setting which will be multiplied by direction
turnSpeed - the turn speed for firstPerson mode
axis - the axis (horizontal, vertical or both);
moving - get Boolean as to whether the target is moving (within moveThreshold)
movingX - get Boolean as to whether the target is moving in x direction (within moveThreshold)
movingY - get Boolean as to whether the target is moving in y direction (within moveThreshold)
boundary - get or set the Boundary object
gamepad - reference to GamePad object if applicable - allows you to use this for more events like jumping, shooting, etc.
moveThreshold - the maximum value (+-) within which movement is considered stopped
stickThreshold - the maximum value (+-) within which the gamepad stick axes values are considered 0
mousedownIncludes - an array of objects that the mousedown will work on - along with the stage
	note: if manually setting this and there is a boundary then add the boundary to the mousedownIncludes as well
enabled - set to false to disable or true to enable MotionController - can toggle with enabled = !enabled

ALSO: adds a motionController property to target referencing the MotionController object

EVENTS
dispatches a "change" event for changes in direction with dir as property of event object
	that will hold LEFT, RIGHT, UP, DOWN, null (no direction)
dispatches a "mousedown" event if type is "mousedown" or "pressmove"
dispatches a "pressing" event if type is "pressmove" - note, this dispatches even if not moving
dispatches a "moving" event if target is moving and "startmoving" and "stopmoving" events
--*///+69.7
	zim.MotionController = function(target, type, speed, axis, boundary, map, diagonal, damp, flip, orient, constant, firstPerson, turnSpeed, moveThreshold, stickThreshold, container, localBoundary, mouseMoveOutside, mousedownIncludes, minPercentSpeed, maxPercentSpeed, dampKeyup, rotate, mouseOutside) {
		var sig = "target, type, speed, axis, boundary, map, diagonal, damp, flip, orient, constant, firstPerson, turnSpeed, moveThreshold, stickThreshold, container, localBoundary, mouseMoveOutside, mousedownIncludes, minPercentSpeed, maxPercentSpeed, dampKeyup, rotate, mouseOutside";
		var duo; if (duo = zob(zim.MotionController, arguments, sig, this)) return duo;
		z_d("69.7");

		this.cjsEventDispatcher_constructor();
		this.type = "MotionController";

		var that = this;

		var stage;
		var message = "zim MotionController(): Please pass in a reference to the stage or a container on the stage";
		if (zot(container)) {
			if (WW.zdf) {
				stage = container = WW.zdf.stage;
			} else {
				zogy(message);
				return;
			}
		} else if (zot(container.stage)) {
			if (WW.zdf) {
				stage = WW.zdf.stage;
			} else {
				zogy(message);
				return;
			}
		} else {
			stage = container.stage;
		}
		var frame = stage.frame;

		if (!zot(orient)) rotate = orient; // renamed parameter to orient

		if (zot(target)) {target = new zim.Container(1,1, null, null, false);} // make a surrogate if only wanting controller data
		var accelerator = target.type == "Accelerator";
		if (zot(speed)) speed = type=="pressmove"?20:7;
		if (!zot(type) && type.type == "DPad") {
			var dPad = type;
			type = "manual";
			if (zot(axis)) axis = dPad.axis;
			if (axis == "all") axis = "both";
			dPad.on("change", function() {
				that.convert(target.x+dPad.dirX*speed, target.y+dPad.dirY*speed);
			});
		}
		if (zot(type) || (type != "mousemove" && type != "pressmove" && type != "pressdrag" && type != "keydown" && type != "gamebutton" && type != "gamestick" && type != "swipe" && type != "follow" && type != "manual")) type = "mousedown";
		if (zot(axis)) axis = accelerator?"horizontal":"both"; // horizontal, vertical, both
		if (type == "keydown" && zot(map)) map = [[65,37], [68,39], [87,38], [83,40]]; // left right up down
		if (type == "gamebutton" && zot(map)) {
			if (firstPerson) {
				map = [14, 15, zim.GamePad.RT, zim.GamePad.LT]; // DPAD_LEFT, DPAD_RIGHT, RT, LT on gamepad
			} else {
				map = [14, 15, 12, 13]; // DPAD_LEFT, DPAD_RIGHT, DPAD_UP, DPAD_DOWN on gamepad
			}
		}
		if (type == "gamestick" && zot(map)) {
			if (firstPerson) {
				map = [[0,2], [0,2], [1], [1]]; // TURN: LSX or RSX, LSX or RSX, SPEED: LSY, LSY - on gamepad
			} else {
				map = [0, 0, 1, 1]; // LSX, LSX, LSY, LSY - Left Stick on gamepad
			}
		}

		if (type == "gamestick" && zot(map)) map = [0, 0, 1, 1]; // LSX, LSX, LSY, LSY - Left Stick on gamepad
		if (zot(diagonal)) diagonal = true;
		if (axis == "horizontal" || axis == "vertical") diagonal = false;
		if (zot(damp) || damp===true) damp = (type=="keydown" || type=="gamebutton") ? 1: (type=="pressmove"?.5:.1);
		if (damp === false) damp = 1;
		if (zot(firstPerson)) firstPerson = false;
		if (zot(turnSpeed)) turnSpeed = speed * .4;
		if (zot(moveThreshold)) moveThreshold = 4;
		if (zot(stickThreshold)) stickThreshold = .2;
		if (zot(mouseMoveOutside)) mouseMoveOutside = true;
		stage.mouseMoveOutside = mouseMoveOutside;
		if (zot(mousedownIncludes)) mousedownIncludes = [];
		if (!Array.isArray(mousedownIncludes)) mousedownIncludes = [mousedownIncludes];
		if (target.type == "Pen" && !target.move) {
			mousedownIncludes.push(target, target.paper);
		} else {
			mousedownIncludes.push(target);
		}
		if (boundary && boundary.getBounds) {
			if (mousedownIncludes) {
				if (mousedownIncludes.indexOf(boundary) == -1) mousedownIncludes.push(boundary);
			} else mousedownIncludes = [boundary]; 
		}
		target.motionController = this;
		// if (zot(mousedownExcludes)) mousedownExcludes = [];
		// if (!Array.isArray(mousedownExcludes)) mousedownExcludes = [mousedownExcludes];
		this.mousedownIncludes = mousedownIncludes;
		if (container && container.backing) this.mousedownIncludes.push(container.backing);
		// this.mousedownExcludes = mousedownExcludes;
		if (zot(dampKeyup)) dampKeyup = .3;

		if (boundary && boundary.type!="Blob") {	
			target.x = zim.constrain(target.x, boundary.x, boundary.x+boundary.width);
			target.y = zim.constrain(target.y, boundary.y, boundary.y+boundary.height);				
		}		

		that.dampKeyup = dampKeyup;
		this.dirX = 0;
		this.dirY = 0;
		this.speed = speed;
		this.turnSpeed = turnSpeed;
		this.axis = axis;
		this.target = target;
		this.moveThreshold = moveThreshold;
		this.stickThreshold = stickThreshold;
		this.boundary = boundary;
		target.zimMCStartAngle = target.rotation;

		var speedX = that.speed; // speedX and speedY hold proportioned speed based on angle
		var speedY = that.speed;
		var flipRotation = 0; // records if we need to adjust rotation if flipped
		that.rotation = target.zimMCStartAngle; // holds the pre-damped angle of the target

		var proportion;
		var bb;
		if (accelerator) {
			bb = container.getBounds();
			var dist;
			if (!bb || (axis == "vertical" && !bb.height) || (axis != "vertical" && !bb.width)) dist = 1000;
			else dist=axis=="vertical"?bb.height:bb.width;
			if (zot(minPercentSpeed)) minPercentSpeed = 0;
			if (zot(maxPercentSpeed)) maxPercentSpeed = 100;
			if (zot(this.target.percentSpeed)) this.target.percentSpeed = (maxPercentSpeed-minPercentSpeed)/2;
			that.x = dist/2; // holds the pre-damped x and y position of the target
			that.y = dist/2;
			proportion = new zim.Proportion(0,dist,minPercentSpeed, maxPercentSpeed);
		} else {
			that.x = this.target.x; // holds the pre-damped x and y position of the target
			that.y = this.target.y;
		}

		var originalScaleX = that.scaleX = target.scaleX;
		var originalScaleY = that.scaleY = target.scaleY;

		// INPUTS
		// set up collecting the desired x and y based on various inputs:
		// keydown, gamebutton
		// mousedown, mousemove
		// gamestick
		// swipe
		// otherwise the setting is manual and MotionController x and y can be provided through calculate(x,y) method
		var mouseEvent;
		var mouseEvent2;
		var mouseEvent3;
		var mouseEvent4;
		var pressing = false;
		var moveCheck = false;
		var under, i, a, gamepad, first;

		if (type == "keydown" || type == "gamebutton") {

			// which keys or buttons handle left, right, up, down are provided by the map parameter
			// this can be either a number or an array of numbers
			// so normalize this to always hold an array
			for (i=0; i<4; i++) {
				if (!Array.isArray(map[i])) map[i] = [map[i]];
			}
			var down = [0,0,0,0];
			var ord = []; // order the keys are pressed - so when we release, we can set to last currently pressed key
			var way = ["X","X","Y","Y"];
			var dir = [-1,1,-1,1];
			// var names = [LEFT,RIGHT,UP,DOWN];
			// var rots = [-180,0,-90,90];
			var d = {dirX:0, dirY:0}; // local directions for key and button - this.dirX and this.dirY are used in Ticker

			if (type == "keydown") {
				var keydownEvent = frame.on("keydown", doDown);
			} else {
				gamepad = that.gamepad = new zim.GamePad();
				var buttondownEvent = gamepad.on("buttondown", doDown);
			}

			if (zot(constant)) {
				if (type == "keydown") {
					var keyupEvent = frame.on("keyup", doUp);
				} else {
					var buttonupEvent = gamepad.on("buttonup", doUp);
				}
			}

			// use a ticker to position the desired x and y properties
			// we will then tween to these properties in the mainTicker later
			first = {rotation:0, speedX:that.speed, speedY:that.speed};
			var keyTicker = zim.Ticker.add(function() {
				if (firstPerson) {doFirstPerson(d); return;}
				var sX = that.speed;
				var sY = that.speed;
				if (that.axis == "both" && d.dirX != 0 && d.dirY != 0) {
					var trig = doTrig(d.dirX, d.dirY); // note - keys need to place desired x and y in a unit manner (or else target never goes anywhere)
					sX = trig.speedX;
					sY = trig.speedY;
				}
				if (that.axis == "horizontal" || that.axis == "both") {
					that.x += sX * d.dirX;
				}
				if (that.axis == "vertical" || that.axis == "both") {
					that.y += sY * d.dirY;
				}
				calculate();
			}, stage);
		} else if (type == "mousedown" || type == "mousemove") {			
			mouseEvent = stage.on("stage" + type, function(e){				
				stage = e.target.stage;
				var pp;
				var con;
				if (!mouseOutside && that.boundary && !that.boundary.type=="Blob") con = that.boundary;
				else if (!mouseOutside && container && container.boundsToGlobal) con = container.boundsToGlobal();
				if (con) {
					pp = {x:e.stageX/zim.scaX, y:e.stageY/zim.scaY};					
					if (
						pp.x < con.x || pp.x > con.x+con.width ||
						pp.y < con.y || pp.y > con.y+con.height
					) return;
				}
				if (type == "mousedown") {					
					if (!Array.isArray(that.mousedownIncludes)) that.mousedownIncludes = [that.mousedownIncludes];
					if (that.mousedownIncludes.indexOf(container)<0) {
						for (i=0; i<container.numChildren; i++) {
							var child = container.getChildAt(i);
							if (that.mousedownIncludes.indexOf(child)==-1 && child.mouseEnabled && child.hitTestPoint && child.hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY)) return;
						}
					}
					that.dispatchEvent("mousedown");
				}				
				var p = container.globalToLocal(mouseMoveOutside?e.rawX/zim.scaX:e.stageX/zim.scaX, mouseMoveOutside?e.rawY/zim.scaY:e.stageY/zim.scaY);
				that.x = p.x; that.y = p.y;				
				calculate();
			});
		} else if (type == "pressmove" || type == "pressdrag" || type == "follow") {
			if (target.type == "Pen") target.write = false;
			mouseEvent = stage.on("stagemousedown", function(e) {
				var pp;
				// if (target.type == "Pen" || type == "pressmove") {
				var con;
				if (!mouseOutside && that.boundary && !that.boundary.type=="Blob") con = that.boundary;
				else if (!mouseOutside && container && container.boundsToGlobal) con = container.boundsToGlobal();
				if (con) {
					pp = {x:e.stageX/zim.scaX, y:e.stageY/zim.scaY};					
					if (
						pp.x < con.x || pp.x > con.x+con.width ||
						pp.y < con.y || pp.y > con.y+con.height
					) return;
				}
				// }
				if (that.boundary && that.boundary.type=="Blob" && (type=="pressmove" || type=="pressdrag")) {
					pp = {x:e.stageX/zim.scaX, y:e.stageY/zim.scaY};
					if (!that.boundary.shape.hitTestPoint(pp.x,pp.y)) return;
				}	
				if (type == "pressdrag" && !target.hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY)) return;
				moveCheck = false;
				if (!Array.isArray(that.mousedownIncludes)) that.mousedownIncludes = [that.mousedownIncludes];
				var inCheck = false;
	
				if (that.mouseDownIncludes) under = stage.getObjectUnderPoint(e.stageX, e.stageY, 1);

				for (i=0; i<that.mousedownIncludes.length; i++) {
					if (under && that.mousedownIncludes[i].hitTestPoint && that.mousedownIncludes[i].hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY) && that.mousedownIncludes[i].contains(under)) {
						inCheck = true;
					}
				}
				if (!inCheck) {
					for (i=0; i<container.numChildren; i++) {
						var child = container.getChildAt(i);
						// returning on first container?
						if (that.mousedownIncludes.indexOf(child)==-1 && child.mouseEnabled && child.hitTestPoint && child.hitTestPoint(e.stageX/zim.scaX, e.stageY/zim.scaY)) return;
					}
				}
				var p = container.globalToLocal(mouseMoveOutside?e.rawX/zim.scaX:e.stageX/zim.scaX, mouseMoveOutside?e.rawY/zim.scaY:e.stageY/zim.scaY);

				if (type!="follow" && type!="pressdrag") that.immediate(
					((axis=="both"||axis=="horizontal")?p.x:null),
					((axis=="both"||axis=="vertical")?p.y:null)
				);

				calculate();
				that.dispatchEvent("mousedown");
				pressing = true;				
				that.moveX = mouseMoveOutside?e.rawX/zim.scaX:e.stageX/zim.scaX;
				that.moveY = mouseMoveOutside?e.rawY/zim.scaY:e.stageY/zim.scaY;
				mouseEvent2 = stage.on("stagemousemove", function(e){
					that.moveX = mouseMoveOutside?e.rawX/zim.scaX:e.stageX/zim.scaX;
					that.moveY = mouseMoveOutside?e.rawY/zim.scaY:e.stageY/zim.scaY;
					if (type!="follow") moveMe();
				});
				if (mouseEvent4) zim.Ticker.remove(mouseEvent4);
				if (type=="follow") mouseEvent4 = zim.Ticker.add(moveMe);
				if (target.type == "Pen") {
					target.write = true;
					target.paper.noMouse(); // no need to drag others while drawing
					target.zimDragCheck = true;
				}
			});
			mouseEvent3 = stage.on("stagemouseup", function(){
				if (target.type == "Pen") {
					target.write = false;
					target.paper.mouse();
					target.zimDragCheck = false;
					if (moveCheck) target.stopCheck();
				}
				if (mouseEvent4) zim.Ticker.remove(mouseEvent4);
				stage.off("stagemousemove", mouseEvent2);
				pressing = false;
			});			

		} else if (type == "gamestick") {
			gamepad = this.gamepad = new zim.GamePad();
			for (i=0; i<4; i++) { // make map hold arrays
				if (!Array.isArray(map[i])) map[i] = [map[i]];
			}
			first = {rotation:target.zimMCStartAngle, speedX:that.speed, speedY:that.speed};
			var stickEvent = gamepad.on("data", function(e) {

				d = {dirX:0, dirY:0};
				// map = [[0,2], [0,2], [1,3], [1,3]]
				for (i=0; i<map[0].length; i++) {
					a = e.axes[map[0][i]];
					if (Math.abs(a) > that.stickThreshold) {
						d.dirX = a;
						break;
					}
				}
				for (i=0; i<map[2].length; i++) {
					a = e.axes[map[2][i]];
					if (Math.abs(a) > that.stickThreshold) {
						d.dirY = a;
						break;
					}
				}

				if (firstPerson) {doFirstPerson(d); return;}

				that.x += that.speed*d.dirX;
				that.y += that.speed*d.dirY;
				calculate();
			});
		} else if (type == "swipe") {
			var swiperX = new zim.Swiper(stage, that, "x", .8);
			var swiperY = new zim.Swiper(stage, that, "y", .8, false);
			var swiperEvent = swiperX.on("swipemove", function() {
				calculate();
			});
		}
		
		function doDown(e) {
			var key = type=="keydown"?e.keyCode:e.buttonCode;
			var inOrd;
			for (i=0; i<4; i++) {
				if (map[i].indexOf(key) > -1) {
					if (!diagonal && that.axis=="both") d.dirX = d.dirY = 0;
					d["dir"+way[i]] = dir[i];
					down[i] = 1;
					inOrd = ord.indexOf(i);
					if (inOrd == 0) return; // already last pressed
					if (inOrd > 0) ord.splice(inOrd,1); // take key out if already down
					ord.unshift(i); // add index to start of ord array
					return;
				}
			}
		}
		
		function doUp(e) {
			var key = type=="keydown"?e.keyCode:e.buttonCode;
			var inOrd;
			for (i=0; i<4; i++) {
				if (map[i].indexOf(key) > -1) {
					down[i] = 0;
					inOrd = ord.indexOf(i);
					if (inOrd >= 0) ord.splice(inOrd,1);
					if (that.axis != "both" || diagonal) { // either just one direction or can have both dirX and dirY
						d["dir"+way[i]] = -down[Math.floor(i/2)*2] +down[Math.floor(i/2)*2+1]; // the other might be down
					} else { // only use last pressed key for dirX or dirY but not both
						if (ord.length > 0) {
							d["dir"+way[i]] = 0;
							var iOrd = ord[0];
							d["dir"+way[iOrd]] = dir[iOrd];
						} else {
							d.dirX = d.dirY = 0;
						}
					}
					return;
				}
			}
		}
		
		function moveMe() {
			var p = container.globalToLocal(that.moveX, that.moveY);
			that.x = p.x; that.y = p.y;
			calculate();
			if (target.type == "Pen" && !moveCheck && target.drawing) moveCheck = true;
		}		

		function doFirstPerson(d) {
			first.rotation += d.dirX * that.turnSpeed;
			that.rotation = first.rotation;
			first.speedX = Math.sin(first.rotation*Math.PI/180) * that.speed * -d.dirY;
			first.speedY = - Math.cos(first.rotation*Math.PI/180) * that.speed * -d.dirY;
			that.x += first.speedX;
			that.y += first.speedY;
			return;
		}

		// CALCULATE
		// each input calls calculate to determine the angle of direction
		// and the speed along each axis, speedX and speedY
		function calculate() {

			// trig() returns an object with speedX, speedY and rotation properties
			var diffX = that.x-(accelerator?that.target.percentSpeed:that.target.x);
			var diffY = that.y-(accelerator?that.target.percentSpeed:that.target.y);
			var trig = doTrig(diffX, diffY);

			speedX = trig.speedX;
			speedY = trig.speedY;

			if (!rotate) return;
			if (!zot(trig.angle)) that.rotation = trig.angle+target.zimMCStartAngle;
			if (zot(that.rotation)) {
				that.rotation = that.target.rotation;
				return; // when no motion purposely left null so stopped target keeps rotation
			}

			that.rotation += flipRotation; // if flipped we need to add 180 to rotation

			// make sure angle damps to shortest direction - this is tricky
			var newR = normalizeAngle(that.rotation);
			var oldR = that.target.rotation = normalizeAngle(that.target.rotation);
			if (Math.abs(newR-oldR) > 180) {
				if (oldR > newR) {
					oldR -= 360; // put current rotation behind new rotation so damps clockwise
				} else {
					newR -= 360; // put new rotation behind current rotation so damps counterclockwise
				}
			}
			that.dampR.immediate(oldR); // required otherwise damping equation has mind of its own
			that.target.rotation = oldR; // make sure to set this again as we may have changed oldR for proper rotational direction when damped
			that.rotation = newR;
		}
		function normalizeAngle(a) {
			return (a % 360 + 360) % 360;
		}
		function doTrig(diffX, diffY) {
			var sX = that.speed;
			var sY = that.speed;
			var sA; // keep angle null if no movement - so that last rotation during movement is kept when movement stops
			var hyp = Math.sqrt(Math.pow(diffX, 2) + Math.pow(diffY, 2));
			if (hyp > 0) {
				sX = Math.abs(diffX) / hyp * that.speed;
				sY = Math.abs(diffY) / hyp * that.speed;
				sA = 90 - Math.atan2(diffX, diffY)*180/Math.PI;
			}
			return {speedX:sX, speedY:sY, angle:sA};
		}


		// TICKER FOR ALL
		// damp movement and rotation to desired x and y

		var lastX = this.x; // blobs
		var lastY = this.y;
		var lastXX = this.x; // damp 1 for moving
		var lastYY = this.y;
		var tempX = this.x = accelerator?dist/2:this.target.x;
		var tempY = this.y = accelerator?dist/2:this.target.y;

		this.dampX = new zim.Damp(tempX, damp);
		this.dampY = new zim.Damp(tempY, damp);
		this.dampR = new zim.Damp(this.target.rotation, damp);
		var lastDirX=0;
		var lastDirY=0;

		var mainTicker = zim.Ticker.add(function() {	
			if (type == "manual") calculate();
			if (that.boundary && that.boundary.type!="Blob") {				
				that.x = zim.constrain(that.x, that.boundary.x, that.boundary.x+that.boundary.width);
				that.y = zim.constrain(that.y, that.boundary.y, that.boundary.y+that.boundary.height);				
			}
			// tempX and tempY head towards the desired x and y
			// at the speed set by calculate and in the direction it needs to go calculated here
			// we then damp the actual motion using the dampX or dampY zim.Damp object's convert method
			if (that.axis == "horizontal" || that.axis == "both") {
				that.dirX = zim.sign(that.x-tempX);
				if (Math.abs(that.x-tempX) < speedX) {
					tempX = that.x;
				} else {
					tempX += that.dirX*speedX;
				}
				if (d && d.dirX==0) {
					var desired = that.boundary?that.boundary.width/2:stage.width/2;
					var newTempX = that.x-(that.x-desired)*(accelerator?that.dampKeyup:0);
					tempX = newTempX;
					that.x = tempX;
				}
				if (accelerator && bb && bb.width) that.target.percentSpeed = proportion.convert((that.dampX.convert(tempX)));
				else that.target.x = that.dampX.convert(tempX);

			}	
			
			if (that.axis == "vertical" || that.axis == "both") {
				that.dirY = zim.sign(that.y-tempY);
				if (Math.abs(that.y-tempY) < speedY) {
					tempY = that.y;
				} else {
					tempY += zim.sign(that.y-tempY)*speedY;
				}
				if (d && d.dirY==0) {
					desired = that.boundary?that.boundary.height/2:stage.height/2;
					var newTempY = that.y-(that.y-desired)*(accelerator?that.dampKeyup:0);
					tempY = newTempY;
					that.y = tempY;
				}
				if (accelerator && bb && bb.height) that.target.percentSpeed = proportion.convert(that.dampY.convert(tempY));
				else that.target.y = that.dampY.convert(tempY);
			}
			
			if (that.boundary && that.boundary.type=="Blob") {
				if (that.boundary.shape.hitTestPoint(that.target.x,that.target.y)) {
					lastX = that.target.x;
					lastY = that.target.y;										
				} else {
					that.target.x = that.x = lastX;
					that.target.y = that.y = lastY;
					that.immediate(lastX, lastY);
				}
			}		
			
			if (type == "pressmove" && pressing) that.dispatchEvent("pressing");

			// set moving properties
			if (damp==1) {
				that.movingX = Math.round(lastXX-that.x) != 0;
				that.movingY = Math.round(lastYY-that.y) != 0;
				lastXX = that.x;
				lastYY = that.y;
			} else {
				that.movingX = Math.abs(tempX-(accelerator?that.target.percentSpeed:that.target.x)) > that.moveThreshold;
				that.movingY = Math.abs(tempY-(accelerator?that.target.percentSpeed:that.target.y)) > that.moveThreshold;
			}
			if (that.moving && !(that.movingX || that.movingY)) {
				that.dispatchEvent("stopmoving");
			} else if (!that.moving && (that.movingX || that.movingY)) {
				that.dispatchEvent("startmoving");
			}
			that.moving = that.movingX || that.movingY;
			if (that.moving) that.dispatchEvent("moving");

			// check for last direction change and dispatch event and flip if necessary
			if (that.dirX != lastDirX || that.dirY != lastDirY) {
				var e = new createjs.Event("change");
				var options;
				if (that.dirX != lastDirX) {
					options = ["left", null, "right"];
					e.dir = options[that.dirX+1];
					lastDirX = that.dirX;
					if (!target.zimMCStartAngle && (flip == "horizontal" || flip == "both")) {
						that.scaleX = target.scaleX = that.dirX?Math.abs(target.scaleX)*that.dirX:target.scaleX;
						if (originalScaleX != 0 && Math.round(that.scaleX/originalScaleX) == -1) {
							flipRotation = 180;
						} else {
							flipRotation = 0;
						}
					}
				} else {
					options = ["up", null, "down"];
					e.dir = options[that.dirY+1];
					lastDirY = that.dirY;
					if (!target.zimMCStartAngle && (flip == "vertical" || flip == "both")) {
						that.scaleY = target.scaleY = that.dirY?-Math.abs(target.scaleY)*that.dirY:target.scaleY;
						if (originalScaleY != 0 && Math.round(that.scaleY/originalScaleY) == -1) {
							flipRotation = 180;
						} else {
							flipRotation = 0;
						}
					}
				}
				that.dispatchEvent(e);
			}

			// damp the rotation - but not if the angle is null which happens when no movement
			// this keeps the last angle during movement rather than setting it to 0 which is not right
			if (rotate && !zot(that.rotation)) {
				that.target.rotation = that.dampR.convert(that.rotation);
			}

		}, stage);


		this.immediate = function(x,y,r) {
			if (!zot(x) && that.dampX) {
				that.dampX.immediate(x);
				if (accelerator) that.x = that.target.percentSpeed = tempX = x;
				else that.x = that.target.x = tempX = x;
				if (swiperX) swiperX.immediate(x);
			}
			if (!zot(y) && that.dampY) {
				that.dampY.immediate(y);
				if (accelerator) that.y = that.target.percentSpeed = tempY = y;
				else that.y = that.target.y = tempY = y;
				if (swiperY) swiperY.immediate(y);
			}
			if (!zot(r) && that.dampR) {
				that.dampR.immediate(r);
				that.rotation = that.target.rotation = r;
			}
			lastX = that.x;
			lastY = that.y;
			return that;
		};

		this.convert = function(x,y) {
			if (!zot(x)) that.x = x;
			if (!zot(y)) that.y = y;
			calculate();
		};

		// cannot animate speed with animate() - it conflicts with extra
		Object.defineProperty(that, 'pausingSpeed', {
			get: function() {
				return that.speed;
			},
			set: function(amount) {
				that.speed = amount;
			}
		});

		this.paused = false;
		var lastSpeed;

		this.pause = function(state, time, reset) {
			if (zot(state)) state = true;
			if (zot(time)) time = 0;
			if (zot(reset)) reset = false;
			if (state) {
				lastSpeed = that.speed;
				if (time > 0) {
					zim.animate({target:that, obj:{pausingSpeed:0}, ticker:false, time:time, call:function() {
						that.speed = 0;
						that.paused = true;
						that.enabled = false;
						that.immediate(that.target.x, that.target.y);
						that.dispatchEvent("pause");
					}});
					
					if (reset) {
						pressing = false;
						if (mouseEvent2) stage.off("stagemousemove", mouseEvent2);
						if (mouseEvent4) zim.Ticker.remove(mouseEvent4);
						if (target.type == "Pen") {
							target.write = false;
							target.zimDragCheck = false;
						}
						if (mouseEvent3) stage.off("stagemouseup", mouseEvent3);
						if (moveCheck) target.stopCheck();							
						if (type == "keydown") {
							if (keyupEvent) frame.off("keyup", keyupEvent);
						} else {
							if (buttonupEvent) gamepad.off("buttonup", buttonupEvent);
						}
					} // end reset						
					
				} else {
					that.speed = 0;
					that.paused = true;
					that.enabled = false;
					that.immediate(that.target.x, that.target.y);
					setTimeout(function() {that.dispatchEvent("pause");}, 10);
				}
			} else {
				that.enabled = true;
				if (time > 0) {
					zim.animate({target:that, obj:{pausingSpeed:lastSpeed}, ticker:false, time:time, call:function() {
						that.speed = lastSpeed;
						that.paused = false;
					}});
				} else {
					that.speed = lastSpeed;
					that.paused = false;
				}
			}
			return that;
		};


		var _enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return _enabled;
			},
			set: function(value) {
				if (_enabled == value) return;
				if (value) {
					enable();
					that.paused = false;
				} else {
					disable();
					that.paused = true;
				}
				_enabled = Boolean(value);
			}
		});
		function enable() {
			if (type == "keydown") {
				keydownEvent = frame.on("keydown", keydownEvent);
				if (keyupEvent) keyupEvent = frame.on("keyup", keyupEvent);
				keyTicker = zim.Ticker.add(keyTicker, stage);
			} else if (type == "gamebutton") {
				buttondownEvent = gamepad.on("buttondown", buttondownEvent);
				if (buttonupEvent) buttonupEvent = gamepad.on("buttonup", buttonupEvent);
				keyTicker = zim.Ticker.add(keyTicker, stage);
			} else if (type == "gamestick") {
				stickEvent = gamepad.on("data", stickEvent);
			} else if (type == "swipe") {
				swiperX.enabled = true;
				swiperY.enabled = true;
				if (swiperEvent) swiperEvent = swiperX.on("swipemove", swiperEvent);
			} else if (type == "mousedown" || type == "mousemove") {
				mouseEvent = stage.on("stage" + type, mouseEvent);
			} else if (type == "pressmove") {
				mouseEvent = stage.on("stagemousedown", mouseEvent);
				if (mouseEvent2) mouseEvent2 = stage.on("stagemousemove", mouseEvent2);
				if (mouseEvent3) mouseEvent3 = stage.on("stagemouseup", mouseEvent3);
			}
			mainTicker = zim.Ticker.add(mainTicker, stage);
		}
		function disable() {
			if (type == "keydown") {
				frame.off("keydown", keydownEvent);
				frame.off("keyup", keyupEvent);
				zim.Ticker.remove(keyTicker);
			} else if (type == "gamebutton") {
				gamepad.off("buttondown", buttondownEvent);
				gamepad.off("buttonup", buttonupEvent);
				zim.Ticker.remove(keyTicker);
			} else if (type == "gamestick") {
				gamepad.off("data", stickEvent);
			} else if (type == "swipe") {
				swiperX.enabled = false;
				swiperY.enabled = false;
				swiperX.off("swipemove", swiperEvent);
			} else if (type == "mousedown" || type == "mousemove") {
				stage.off("stage" + type, mouseEvent);
			} else if (type == "pressmove") {
				stage.off("stagemousedown", mouseEvent);
				stage.off("stagemousemove", mouseEvent2);
				stage.off("stagemouseup", mouseEvent3);
			}
			zim.Ticker.remove(mainTicker);
		}
		this.dispose = function() {
			disable();
			if (gamepad) gamepad.dispose();
			if (swiperX) swiperX.dispose();
			if (swiperY) swiperX.dispose();
		};

	};
	zim.extend(zim.MotionController, createjs.EventDispatcher, "enabled", "cjsEventDispatcher");
	//-69.7

/*--
zim.GamePad = function()

GamePad
zim class - extends a createjs EventDispatcher

DESCRIPTION
GamePad connects to Game Controllers as inputs using the HTML navigator.getGamepads API
Dispatches buttondown and buttonup events for the following common buttons:

"A","B","X","Y", (or for Triangle, Circle, Cross and Square)
"LB","RB","LT","RT", (for left bumper, right bumper, left trigger, right trigger)
"BACK","START",
"LS","RS", (for left stick press, right stick press)
"DPAD_UP","DPAD_DOWN","DPAD_LEFT","DPAD_RIGHT"

The event object will have a button property telling which button is pressed using the string values above
Dispatches a "data" event constantly to get axes data for the sticks (and constant data for the buttons)
The event object in this case will have axes and buttons properties
The axes property is an array of four numbers for the left and right stick's x and y properies (-1 to 1)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const gamepad = new GamePad();
gamepad.on("buttondown", e=>{
	// only fires once per button press (unlike constant keydown event)
	zog(e.button); // LT for instance for Left trigger
	if (e.button == "LT") {
		zog("left trigger is down");
	}
	zog(e.buttonCode); // 6
	if (e.buttonCode == GamePad.LT) {
		zog("another way to do catch left trigger down");
	}
});

gamepad.on("buttonup", e=>{
	zog(e.button); // LT for instance for Left trigger
}

gamepad.on("data", e=>{
	// fires constantly in a requestAnimationFrame
	zog(e.axes[0]); // left stick x or horizontal data from -1 to 1 (lots of decimal noise)
	zog(e.axes[GamePad.LTX]); // another way of accessing left stick x
	zog(e.buttons[9]); // true or false depending on if the START button is pressed
	zog(e.buttons[GamePad.START]); another way to find if the START button is pressed
});
END EXAMPLE

METHODS
dispose() - removes all listeners and cancels requestAnimationFrame

PROPERTIES
type - holds the class name as a String
connected - Boolean true if connected and false if not connected (may need to press key, etc)
currentIndex - get or set the index of the controller
	gives multiple controller support - make two GameController objects and set different indexes
data - object that holds buttons (raw data - slightly different than buttons below) and axes properties
buttons - an array of Booleans as to whether the button is pressed
	the order of the buttons match the order of the constants below
constants: A,B,X,Y,LB,RB,LT,RT,BACK,START,LS,RS,DPAD_UP,DPAD_DOWN,DPAD_LEFT,DPAD_RIGHT
	GamePad.A == 0
	GamePad.B == 1, etc. up to
	GamePad.DPAD_RIGHT == 15
axes - an array of four stick values from -1 to 1
	for left x and y and right x and y values (or horizontal and vertical values)
constants: LSX,LSY,RSX,RSY
	GamePad.LSX == 0
	GamePad.LSY == 1
	GamePad.RSX == 2
	GamePad.RSY == 3

EVENTS
dispatches a "gamepadconnected" and gamepaddisconnected when connected and disconnected
	these have an event object with index and id properties - the index and id may not work in chrome
dispatches a "buttondown" event with button and buttonCode properties
dispatches a "buttonup" event with button and buttonCode properties
dispatches a "data" event with axes and buttons array properties
	these can be handled as outlined in the description and examples
--*///+69.8
	zim.GamePad = function() {
		z_d("69.8");
		this.type = "GamePad";

		this.cjsEventDispatcher_constructor();
		if (!navigator.getGamepads) {this.error = true; if (zon) {zogy("zim.GamePad() - no browser support");} return;} // if no gamepad support
		var processPad;
		WW.addEventListener("gamepadconnected", init);
		this.currentIndex = 0;
		var that = this;
		function init(eventObject) {
			that.connected = true;
			dispatch("gamepadconnected", eventObject);
			var startData = navigator.getGamepads()[that.currentIndex];
			that.lastData = [];
			for (var i=0; i<startData.buttons.length; i++) {
				that.lastData[i] = startData.buttons[i].pressed;
			}
			function doPad() {
				processPad = requestAnimationFrame(doPad);
				that.data = navigator.getGamepads()[that.currentIndex];
				if (!that.data) return;
				var currentData = that.buttons = [];
				var e;
				for (var i=0; i<that.data.buttons.length; i++) {
					currentData[i] = that.data.buttons[i].pressed;
					if (currentData[i] != that.lastData[i]) {
						that.lastData[i] = currentData[i];
						if (currentData[i]) {
							// button was up and now is down
							// chose to dispatch only once unlike a keydown
							// if we want constant data then use data event and e.buttons
							e = new createjs.Event("buttondown");
						} else {
							e = new createjs.Event("buttonup");
						}
						e.buttonCode = i;
						e.button = gamePadButtons[i];
						that.dispatchEvent(e);
					}
				}
				e = new createjs.Event("data");
				e.axes = that.axes = that.data.axes;
				e.buttons = that.buttons;
				that.dispatchEvent(e);
			}
			doPad();
		}
		var gamepadCheck = setInterval(function() { // for chrome
			if (navigator.getGamepads && navigator.getGamepads()[0]) {
				if (!that.connected) init();
				clearInterval(gamepadCheck);
			}
		}, 500);
		function dispatch(type, eventObject) {
			var e = new createjs.Event(type);
			e.index = eventObject.gamepad.index;
			e.id = eventObject.gamepad.id;
			e.buttons = eventObject.gamepad.buttons;
			e.axes = eventObject.gamepad.axes;
			that.dispatchEvent(e);
		}
		var disconnectEvent = function(e) {
			if (e.gamepad.index == that.currentIndex) {
				cancelAnimationFrame(processPad);
				that.connected = false;
				that.dispatchEvent("gamepaddisconnected");
			}
		}
		WW.addEventListener("gamepaddisconnected", disconnectEvent);
		
		this.dispose = function() {
			WW.removeEventListener("gamepadconnected", init);
			WW.removeEventListener("gamepaddisconnected", disconnectEvent);
			cancelAnimationFrame(processPad);
			clearInterval(gamepadCheck);
			that.connected = false;
		};
	};
	var gamePadButtons = ["A","B","X","Y","LB","RB","LT","RT","BACK","START","LS","RS","DPAD_UP","DPAD_DOWN","DPAD_LEFT","DPAD_RIGHT"];
	for (z_i=0; z_i<gamePadButtons.length; z_i++) zim.GamePad[gamePadButtons[z_i]] = z_i;
	var gamePadAxes = ["LSX","LSY","RSX","RSY"];
	for (z_i=0; z_i<gamePadAxes.length; z_i++) zim.GamePad[gamePadAxes[z_i]] = z_i;
	zim.extend(zim.GamePad, createjs.EventDispatcher, null, "cjsEventDispatcher");
	//-69.8

/*--
zim.Portal = function(obj, lands)

Portal
zim class - extends a CreateJS EventDispatcher
Dedicated to Stephen Hawkings - may he be portal on!

DESCRIPTION
Turn an object into a portal that lets the user enter the portal to change lands, etc.
The portal works based on mouseover (or press for mobile)
The lands need to be stacked in a Container with the first land at the top.
Portal will pass users throught the lands and loop at the end back to the first land.
Alternatively, if loop is turned to false, Portal will backtrack the user through the lands
Pass the container of lands into the lands parameter - most often you will have two lands, but more are fine too!
Alternatively, the portal can be used without lands - and you can customize what you want to happen with portal events.

The object will be used as a mask to show the next land.
You can set the alpha of the object to any value above .01 to hide the object and show the land (do not use 0)
If your object is a ZIM shape, you can use rgba(0,0,0,.01) as the color and still have an opaque borderColor

SEE: https://zimjs.com/portal/

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
F.loadAssets(["researchbuilding.jpg", "jungle.jpg"]);
F.on("complete", ()=>{
	const lands = new Container(W, H).addTo();
	const jungle = new Pic("jungle.jpg")
		.scaleTo(lands)
		.center(lands);
	const researchBuilding = new Pic("researchbuilding.jpg")
		.scaleTo(lands)
		.center(lands);
	const portalObject = new Circle(118, faint, pink, 16, true)
		.addTo(stage)
		.pos(580, 470)
		.animate({obj:{rotation:"360"}, time:70, ease:"linear", loop:true});
	const portal = new Portal(portalObject, lands);
	portal.on("enter", function() {
		// play a sound here!
	});

	// use enabled to turn on and off portal
	timeout(1, ()=>{portal.enabled = false; portalObject.pauseAnimate(true);});
	timeout(5, ()=>{portal.enabled = true; portalObject.pauseAnimate(false);});

	S.update();
}); // assets loaded
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
obj - the Display Object that will be the portal
lands - (default null) optional container of "lands" or display objects to portal through
	The Display Objects in the lands container (lands) should be on the stage
	The lands are adjusted by Portal so the currentLand is the second child and the nextLand is the first child.
	This is due to how the masking works.
	Inserting new lands or removing lands below an index of lands.numChildren-2 is okay
	Use addTo(lands, index) or removeFrom(lands).
	If you adjust either of the top two lands in the container, this will affect what is see on stage.

METHODS
dispose() - remove the events - the obj and lands will be left as is - manually remove these if needed

PROPERTIES
type - holds the class name as a String
portal - a reference to the portal obj
enabled - Boolean as to whether the portal is active or not
currentLand - get or set the active land if lands is provided
nextLand - get (read only) the next land to go to if lands is provided

EVENTS
dispatches an enter event on mouseover of the portal and an exit event on mouseout
--*///+69.96
	zim.Portal = function(obj, lands) {
		var sig = "obj, lands";
		var duo; if (duo = zob(zim.Portal, arguments, sig, this)) return duo;
		z_d("69.96");

		if (zot(obj) || !obj.stage) return;
		this.type = "Portal";

		var that = this;

		var landCheck = (lands && lands.numChildren && lands.numChildren > 0);
		if (landCheck) {
			var currentLand = lands.getChildAt(lands.numChildren-1);
			var nextLand = lands.getChildAt(lands.numChildren-2);
			lands.setChildIndex(nextLand, lands.numChildren-1);
			nextLand.setMask(obj);
		}
		function setPortal() {
			lands.setChildIndex(currentLand, 0); // send to back
			currentLand = nextLand;
			nextLand = lands.getChildAt(lands.numChildren-2);
			lands.setChildIndex(nextLand, lands.numChildren-1);
			currentLand.setMask(null);
			nextLand.setMask(obj);
			obj.stage.update();
		}

		obj.on(zim.mobile()?"mousedown":"mouseover", function() {
			if (!that._enabled) return;
			if (landCheck) setPortal();
			that.dispatchEvent("enter");
		});

		obj.on(zim.mobile()?"pressup":"mouseout", function() {
			if (!that._enabled) return;
			that.dispatchEvent("exit");
		});

		Object.defineProperty(this, 'portal', {
			get: function() {
				return obj;
			},
			set: function(s) {
				if (zot(s) || !s.stage){
					if (zon) {zogy("zim.Portal() - please provide a Display Object to act as the portal"); return;}
				}
				nextLand.setMask(obj);
			}
		});

		Object.defineProperty(this, 'currentLand', {
			get: function() {
				return currentLand;
			},
			set: function(land) {
				if (!lands.contains(land)) return;
				while(land != currentLand) {
					setPortal();
				}
			}
		});

		Object.defineProperty(this, 'nextLand', {
			get: function() {
				return nextLand;
			},
			set: function() {
				if (zon) {zogy("zim.Portal() - nextLand is read only - remake Portal to change"); return;}
			}
		});

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				that._enabled = value;
			}
		});

	};
	zim.extend(zim.Portal, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	//-69.96

/*--
zim.Physics = function(gravity, borders, scroll, frame)

Physics
zim module 
** MUST import zim_physics - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
The Physics class provides a wrapper for the Box2D physics engine.
Both Box2D and the ZIM physics JavaScript files must be imported after ZIM.
Once installed, physics can be turned on for ZIM DisplayObjects such as:
Rectangle, Circle, Triangle, Bitmap, Label, Sprite, Shape, etc.

NOTE: The DisplayObjects used in Physics should have center registration and be on the stage
or in a non-transformed Container at 0,0 on the stage.

Use the DisplayObject's addPhysics() method to add the object to a physics world.
This will also add more methods and properties to the DisplayObject.
The physics world can be set up ahead of time with new Physics()
or if a world is not already created the addPhysics() method will make a default world.
The default world will have a boundary of the frame and gravity of 10 (normal gravity).

SHAPES
By default the physics body shape will be a rectangle that matches the bounding box of the DisplayObject.
However, a Circle will be have a physics circle and a Triangle will have a physics triangle.
"circle", "rectangle" or "triangle" can be passed in to the addPhysics() method to override the actual shape.
The expand parameter can be used to make the physics object bigger or smaller than the bounds.

PHYSICS
Objects have impulse(), force(), spin() and torque() methods to push them around and spin them.
impulse() is a one time push like shooting a pool ball
force() is a force over time like gravity or wind and is applied in a Ticker, keydown, etc.
spin() is a one time spin of the object around its center
torque() will rotate the object over time and is applied in a Ticker, keydown, etc.
The physics class has a join() method that can join objects in a variety of physics joints.
The physics class has a drag() method to specify which objects are draggable.
There is a debug() method to see the physics world behind ZIM.
The world can be set up to be bigger than the frame and follow() an object.
Objects are given a control() method to use keyboard keys to move the object.
Contact can be tested for with contact() and contactEnd()
each which receive a callback function that is provided with the other contacting body

BOX2D
https://box2d.org/documentation or
https://www.box2dflash.org/docs/2.0.2/manual
Box2D has many other features that can be accessed as well.
Note that the ZIM Physics makes much of this easier
so start with ZIM and use the Box2D docs and manuals for custom requirements.
The Physics class has a world poperty that refers to the Box2D world.
Each ZIM DisplayObject with physics() turned on has a body property
that refers to the Box2D body and a physics property that refers to its Physics object.
See the properties listed below for more information.

SEE: https://zimjs.com/physics/ for examples

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// add a rectangle to a default Physics world,
// set it draggable and turn debug mode on
const rect = new Rectangle().centerReg().addPhysics(); // center registration for rectangular objects
rect.physics.drag();
rect.physics.debug();
// note: we would usually make a Physics() object first (see below)
END EXAMPLE

EXAMPLE
// create a world with no gravity (viewed from top like air-hockey)
const physics = new Physics(0);
const circle = new Circle(50,blue,grey).center().addPhysics({restitution:1.1}); // how bouncy
// make sure to reg(CENTER) or centerReg() any rectangular objects
const rect = new Rectangle(30,400).reg(CENTER).pos(70,0,LEFT,CENTER).addPhysics(false); // static - do not move
const tri = new Triangle(150,150,150,green,grey).pos(200,0,LEFT,CENTER).addPhysics({linear:10}); // does not slide easily
physics.drag(); // note: to add a boundary use the borders parameter of Physics()
// test to see if circle hits rectangle
// contact callback function receives ZIM object (and physics body as next param)
// a ZIM border will have a type = "Border" and a side = LEFT, RIGHT, TOP, "bottom"
// but it is not really a ZIM Rectangle but just an object literal placeholder
circle.contact(obj=>{
	if (obj == rect) {
		rect.color = red;
		timeout(.3, ()=>{
			rect.color = black;
			// circle.noContact(); // could only check once...
		})
	}
});
END EXAMPLE

EXAMPLE
// control a ball with a DPad - better than keys for mobile
const physics = new Physics(0);
const ball = new Circle().center().addPhysics();
const dPad = new DPad().pos(40,40,LEFT,BOTTOM);
ball.control(dPad, 80);
END EXAMPLE

EXAMPLE
// attach a physics object to a ZIM object 
// this is like a mousejoint similar to drag() but attached to an object rather than the mouse 
// so a physics object can follow a ZIM drag() or animate() or wiggle(), etc.
// the original distance between the objects is maintained like a distance joint
// see https://zimjs.com/valentines/puppets.html
// see https://zimjs.com/valentines/puppets2.html
const physics = new Physics(0);
const control = new Triangle().center().mov(0,-100).drag(); // or animate() or wiggle()
const ball = new Circle().center().addPhysics();
physics.attach(control, ball); // physics ball will be moved by triangle
END EXAMPLE

PARAMETERS - FOR PHYSICS
** supports DUO - parameters or single object with properties below
gravity - (default 10) the gravity force in the downward direction
borders - (default the frame bounds) a ZIM Boundary() object or object literal with x, y, width and height properties
	this makes physics body rectangles around the physics world
	pass in "none" for no borders
	you can remove border bodies afterwards with physics.remove(physics.borderTop)
	and then borderLeft, borderRight and borderBottom
scroll - (default false) set to true to be able to scroll the stage x an y
 	This will let you follow a physics object - see follow() method
frame - (default zdf) the zim.Frame object

METHODS - FOR PHYSICS - see also OBJECT METHODS and BODY METHODS below
borders(boundary) - (default frame bounds) a ZIM Boundary() object or an object literal {} with x, y, width and height
	pass in "none" for no borders - also see borders parameter
	will remove old borders bodies before making new
drag(array) - drag all physics objects (with dynamic set to true)
	array - (default null) pass in an object or an array of objects to drag
	Note: physics dragging is applied on the Physics class to not overwrite traditional ZIM drag() on DisplayObjects
noDrag(array) - stop dragging all physics objects or pass in an array
	array - (default null) pass in an object or an array of objects to stop dragging
pause(type) - pauses physics if type is true (default), resumes physics if type is false
join(obj1, obj2, point1, point2, minAngle, maxAngle, type) - creates and returns a physics joint
	** supports DUO - parameters or single object with properties below
	obj1 - the first ZIM DisplayObject (with physics turned on) to join together
	obj2 - the second ZIM DisplayObject (with physics turned on) to join together
	point1 - (default center of object) the anchor point of the joint on the first object
	point2 - (default center of object) this is only needed on a distance joint
	minAngle - (default null) the minimum angle the joint can make from its starting angle
	maxAngle - (default null) the maximum angle the joint can make from its starting angle
	type - (default "weld") the type of joint
		set to "distance" to keep the same distance between two object anchors
		set to "revolute" to rotate objects around a fixed point relative to the first object
		set to "weld" to fix the objects together
break(joint) - break a joint created with join()
	to use, store the result of the join() method in a variable and pass that variable in to break()
attach(control, obj) attach a physics object (obj) to a ZIM object (control) to like a mousejoint to the ZIM object not the mouse 
	the control can then be animated, wiggled, dragged and the physics object will follow it
	returns an id to be able to unattach
		const id = physics.attach(triangle, circle);
		timeout(2, ()=>{physics.unattach(id)});
unattach(id) unattach a physics object from the ZIM object based on the stored id from attach();
buoyancy(height, denisity, linear, angular) returns a Box2D buoyancy controller.  Then need to add() or remove() objects 
	height - (default H/2) is pixels from bottom of the stage 
	density - (default 3) density of fluid - the higher the more an object floats
	linear - (default 4) linear damping to reduce movement
	angular - (default 4) angular damping to reduce rotation
		the buoyancy controller will have the following methods:
		add(obj) - add object with physics or an array of objects with physics to buoyancy controller
			returns buoyancy object for chaining
		remove(obj) - remove object or an array of objects from buoyancy controller
			returns buoyancy object for chaining
		clear() - remove all objects from buoyancy controller
			returns buoyancy object for chaining
		dispose() - deletes buoyancy controller
debug() - activates the debugging - returns object for chaining
updateDebug() - updates the debug canvas if the frame has been scaled (put in frame resize event)
removeDebug() - removes the debug canvas - you can add it again later (or toggle, etc.)
// FOR BODIES ONLY (legacy - but may not need a visual ZIM object)
makeRectangle(width, height, ... all addPhysics() params) - makes a Box2D body in the shape of a rectangle - see parameters
makeCircle(radius, ... all addPhysics() params) - makes a Box2D body in the shape of a circle - see parameters
makeTriangle(a, b, c, ... all addPhysics() params) - makes a Box2D body in the shape of a triangle
	all three add x, y and rotation properties to body (use at start)
	all three support ZIM DUO single parameter as an object using param names as keys
remove(body) - removes a physics body - use on border bodies, for instance
	this is for physics bodies only - use obj.removePhysics() to remove physics from ZIM DisplayObjects
addMap(body, asset) - sets x, y, rotation of ZIM asset to Box2D body
	this can be automatically done by using the physics() method on the ZIM DisplayObject
removeMap(body) - removes mapping (then probably will want to remove body and removeChild)
	see the removePhysics() method of a ZIM DisplayObject
dispose() - stops the update, removes debug if there - you still need to remove ZIM assets
	a delay of 50 ms might be needed before disposing children to let the physics dispose 
*** also see zim.Ticker below for methods to add and remove functions from update function

PROPERTIES - FOR PHYSICS - see also OBJECT PROPERTIES and BODY PROPERTIES below
world - the Box2D world that is made
frame - the Frame the physics is operating on
	see: https://zimjs.com/expand/physics.html for example
	note: will have to call drag() again if changing frames
	note: may have to redo borders if frame has different dimensions
scale (read only) scale used in world (constant 30)
step (read only) step used in world (constant 20)
timeStep - 1/step - set to 0 to pause physics but also see paused() method
	could animate this property to slow down or speed up physics
gravity - get or set gravity used in world 
paused (read only) whether physics has been paused with pause() method
scroll - get or set the scroll of the physics world
	see the Physics scroll parameter and the follow() method of objects
Ticker - gives access to update function to add your own functions:
	physics.Ticker.add(function, after)
		after defaults to true for after world step and force clear
		set after to false to run function before world step
	physics.Ticker.remove(function)
controlObj - the ZIM DisplayObject being controlled by the obj.control() method
followObj - the ZIM DisplayObject being followed by the obj.follow() method
borderTop - the top border physics body of the world if it exists
borderBottom - the bottom border physics body of the world if it exists
borderLeft - the left border physics body of the world if it exists
borderRight - the right border physics body of the world if it exists

METHODS - FOR OBJECTS - also see BODY METHODS below
** the ZIM DisplayObject comes with an addPhyics() method
** for reference, here are the docs for the addPhysics() method
** all the methods below addPhysics are the methods added to the DisplayObject
addPhysics(dynamic, contract, shape, friction, linear, angular, density, bounciness, maskBits, categoryBits, physics, restitution, sensor)
	** supports DUO - parameters or single object with properties below
	dynamic - (default true) - set to false to not move the physics body (static)
	contract - (default 0) - make the physics body smaller (or bigger with negative) than bounds
	shape - (default object shape) - "rectangle" for any object other than Circle, Dial and Triangle
	 	but can specify a "circle" for a Sprite or Bitmap, for instance - to try and match shape
		custom polygon bodies can also be made with manual Box2D and then use physics.addMap()
		but the only shapes available automatically are "rectangle", "circle", "triangle"
	friction - (default .8) - how sticky will the body act - set to 0 to slide.
	linear - (default .5) - linear damping which slows the movement - set to 0 for no damping
	angular - (default .5) - angular damping which slows the rotation - set to 0 for no damping
	density - (default 1) - the density that can affect what happens with collisions
	bounciness - (default 0) - how bouncy the object is - 0 is not bouncy 4 is crazy bouncy
	maskBits - (default null) - used with categoryBits to determine which bodies will collide with which other bodies
		as soon as maskBits is specified, the body will collide only with the categoryBits provided to the maskBits parameter
		1 will collide with bodies that do not have categoryBits specified including the borders
		to test collision with bodies that have categoryBits specified, use the pipe (|) as follows:
		1|2 will also collide with bodies having categoryBits of 2 specified
		so if another body has categoryBits of 4 then the bodies would not collide.
		1|2|4 would also collide with 4 but not bodies with categoryBits of 8, etc.
		2|4 would pass through any bodies without categoryBits of 2 or 4 including the borders
	categoryBits - (default 1) - a collision category - by default, bodies are in category 1
		use with maskBits to say which bodies will collide with which other bodies
		the values are bit fields https://en.wikipedia.org/wiki/Bit_field so can have the following values:
		can be 2, 4, 8, 16, 32, 64, 128, 256, etc. up to 15 powers of 2
	physics - (default zimDefaultPhysics)
	restitution - (default bounciness) - replaced by bounciness - kept for backwards compatibility
	sensor - (default false) - set to true to make object not interact but still trigger contact() and contactEnd() 
		this is like the Box2D hitTest for non interaction
removePhysics() - lets you remove the DisplayObject from the physics world
	to add back to the physics world, use the addPhysics() method
impulse(x, y, targetX, targetY) - add a one-time force on the object like a hitting a pool ball
	x - (default 0) the force in the x direction
	y - (default 0) the force in the y direction
	targetX - (default center of object) the x location on the object where the force acts
	targetY - (default center of object) the y location on the object where the force acts
force(x, y, targetX, targetY) - add a force over time on the object like a gravity or wind
	this is applied in a new Ticker or on keydown, etc. many times
	just applying the force once will not do anything - use an impulse() for that
	x - (default 0) the force in the x direction
	y - (default 0) the force in the y direction
	targetX - (default center of object) the x location on the object where the force acts
	targetY - (default center of object) the y location on the object where the force acts
spin(amount) - add a one time turning force to an object
torque(amount) - add a turning force over time on the object
	this is applied in a new Ticker or on keydown, etc. many times
	just applying the torque once will hardly do anything - use an spin() for that
setLinearVelocity(x, y) - set the linear velocity - this overrides current forces
	so might look unnatural as setLinearVelocity(0,0) will stop the object moving
setAngularVelocity(amount) - set the angular velocity - this overrids current forces
	so might look unnatural as setAngularVelocity(0) will stop the object spinning
sleep() - puts object to sleep so no physics calculations are done
wake() - wakes up object from sleep so physics calculations are done
follow(damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, borderOriginal)
	moves stage to to follow ZIM object
	set the scroll parameter of Physics to true
	pass in null for obj to stop following - then can position stage with x and y
	** supports DUO - parameters or single object with properties below
	damp - (default .05) the damping of the motion of the stage - 1 moves faster, 0 not at all
	dampY - (default damp) can set to damp vertical movement at a separate rate
	leftOffset - (default 0)
	rightOffset - (F.width)
		the object will try and move to leftOffset when moving right and rightOffset when moving left
		this counters the damping so that the user can see in the direction of motion
		when the object is not being controled it moves to the average between left and right offsets
	upOffSet - (default 0)
	downOffSet - (default F.height)
		same as offsets above but in the y direction
	offsetDamp - (default .02) the damping for moving the object to the offset
	offsetDampY - (default offsetDamp) - damping for moving the object to the y offset if desired to be different than x
	horizontal - (default true) set to false to not follow horizontally
	vertical - (default true) set to false to not follow vertically
	borderLock - (default true) locks follow to borders if borders are not "none"
	borderOriginal - (default false) set to true to lock follow to original borders even if removed
control(type, speed, speedY, horizontal, vertical) - control object with arrows
	see noControl() to turn off object control
	** supports DUO - parameters or single object with properties below
	type - (default "both") or set "wasd" or "arrows" or a ZIM DPad object
	speed - (default 200) the speed of the object motion (also speed property on object)
	speedY - (default speed) or set to specify a different y speed than the x speed (also speedY property on object)
	horizontal - (default true) set to false to not control horizontal motion
	vertical - (default true) set to false to not control vertical motion
customControl(dir, speed, speedY) - available only if control() is set.
	pass in LEFT, RIGHT, UP, DOWN and optional speed (otherwise uses control() speed) 
	for operating object with buttons or accelerometer for instance
	these will then take the place of keys or DPad
noControl() - remove control for an object set with control()
contact(call) - run the call function when object's body contacts another body
	the callback function receives two parameters - the ZIM object and the Physics body that the object has hit
	a border will have a type = "Border" and a side = LEFT, RIGHT, TOP, "bottom"
	but it is not really a ZIM Rectangle but just an object literal placeholder
	Also see sensor parameter to trigger contact but with no physics interaction
contactEnd(call) - run the call function when object's body ends contacts with another body
	the callback function receives two parameters - the ZIM object and the Physics body that the object has hit
	a border will have a type = "Border" and a side = LEFT, RIGHT, TOP, "bottom"
	but it is not really a ZIM Rectangle but just an object literal placeholder
	Also see sensor parameter to trigger contact but with no physics interaction
noContact() - remove contact call
noContactEnd() - remove contactEnd call

PROPERTIES - FOR OBJECTS - see also BODY PROPERTIES below
dynamic - set to true for dynamic and false for static
	there is also kinematic that can be set using the obj.body.SetType(1)
speed - get or set the speed of an object that is controlled by control()
speedY - get or set the speedY of an object that is controlled by control()
** normal x, y, rotation or pos(), loc(), rot() will not work with physics!
** see the BODY loc(x,y) METHOD and the rotation PROPERTY below
** these should really not be set at all in the physics world
** but rather let the forces, etc. work them out
** it is best to set traditional properties before calling physics()

METHODS - FOR BODY (a physics engine body)
loc(x,y) - generally, we should not manually adjust x and y but rather use forces - returns body for chaining
	but for resetting things, etc. use zimObj.body.loc(x, y)
	Do not use zimObj.loc() or zimObj.x or zimObj.y - these will only work BEFORE adding physics
rot(angle) - set the rotation property of the body of the phsyics object - returns body for chaining
	Do not use zimObj.rot() or zimObj.rotation - these will only work BEFORE adding physics
** for scale, another object will need to be made
** the ZIM DisplayObject body property provides access to the following Box2D methods (note, all start with uppercase):
** commonly used methods are handled through ZIM wrapper methods on the DisplayObject
** see https://www.box2dflash.org/docs/2.1a/reference/ for very basic docs
Advance() ApplyForce() ApplyImpulse() ApplyTorque() CreateFixture() CreateFixture2() DestroyFixture()
GetAngle() GetAngularDamping() GetAngularVelocity() GetContactList() GetControllerList() GetDefinition()
GetFixtureList() GetInertia() GetJointList() GetLinearDamping() GetLinearVelocity()
GetLinearVelocityFromLocalPoint() GetLinearVelocityFromWorldPoint() GetLocalCenter() GetLocalPoint(
GetLocalVector() GetMass() GetMassData() GetNext() GetPosition() GetTransform() GetType() GetUserData()
GetWorld() GetWorldCenter() GetWorldPoint() GetWorldVector() IsActive() IsAwake() IsBullet() IsFixedRotation()
IsSleepingAllowed() Merge() ResetMassData() SetActive() SetAngle() SetAngularDamping() SetAngularVelocity()
SetAwake() SetBullet() SetFixedRotation() SetLinearDamping() SetLinearVelocity() SetMassData() SetPosition()
SetPositionAndAngle() SetSleepingAllowed() SetTransform() SetType() SetUserData() ShouldCollide()
Split() SynchronizeFixtures() SynchronizeTransform() b2Body() connectEdges()

PROPERTIES - FOR BODY (a physics engine body)
zimObj - the ZIM Object that the body is mapped to
** traditional properties should be set before calling phyics()
** but the following properties are provided
x - deprecated - please use the BODY's loc(x, y) method - note: zimObj.body.loc() is not the same as the zimObj.loc() method
y - deprecated - please use the BODY's loc(x, y) method - note: zimObj.body.loc() is not the same as the zimObj.loc() method
rotation - the rotation of the body (degrees) - setting this will also rotate the ZIM DisplayObject
	Also see obj.body.SetFixedRotation() to stop the physics body from rotating https://zimjs.com/zapp/print/Z_C6SBW
	And the counter rotation technique here: https://zimjs.com/data/

GLOBAL VARIABLES
** Making a new Physics() or using physics() on a ZIM DisplayObject
** gives global shortcut access to the following Box2D classes:
** these all have methods and properties https://www.box2dflash.org/docs/2.1a/reference/
b2Vec2 = Box2D.Common.Math.b2Vec2;
b2BodyDef = Box2D.Dynamics.b2BodyDef;
b2Body = Box2D.Dynamics.b2Body;
b2FixtureDef = Box2D.Dynamics.b2FixtureDef;
b2Fixture = Box2D.Dynamics.b2Fixture;
b2World = Box2D.Dynamics.b2World;
b2PolygonShape = Box2D.Collision.Shapes.b2PolygonShape;
b2CircleShape = Box2D.Collision.Shapes.b2CircleShape;
b2MouseJointDef = Box2D.Dynamics.Joints.b2MouseJointDef;
b2DistanceJointDef = Box2D.Dynamics.Joints.b2DistanceJointDef;
b2RevoluteJointDef = Box2D.Dynamics.Joints.b2RevoluteJointDef;
b2WeldJointDef = Box2D.Dynamics.Joints.b2WeldJointDef;
b2AABB = Box2D.Collision.b2AABB;
b2DebugDraw = Box2D.Dynamics.b2DebugDraw;
b2BuoyancyController = Box2D.Dynamics.Controllers.b2BuoyancyController;
b2ContactListener = Box2D.Dynamics.b2ContactListener;
--*///+69.97
	WW.zimContactListener = null; // global so dispose() in physics can access this
	var zimContactBeginList;
	var zimContactEndList;
	function setPhysics(obj, dynamic, contract, shape, friction, linear, angular, density, restitution, maskBits, categoryBits, sensor) {
		z_d("69.97");

		if (zot(contract)) contract = 0;
		if (shape == "rectangle") obj.body = obj.physics.makeRectangle(obj.width-contract, obj.height-contract, dynamic, friction, angular, density, restitution, maskBits, categoryBits, linear, sensor);
		else if (shape == "circle") obj.body = obj.physics.makeCircle(obj.width/2-contract, dynamic, friction, angular, density, restitution, maskBits, categoryBits, linear, sensor);
		else if (shape == "triangle") {
			if (zot(obj.a)) {
				obj.a = obj.width;
				obj.b = obj.c = Math.sqrt(Math.pow(obj.a/2,2) + Math.pow(obj.height,2));
			}
			obj.body = obj.physics.makeTriangle(obj.a-contract, obj.b-contract, obj.c-contract, dynamic, friction, angular, density, restitution, maskBits, categoryBits, linear, sensor);
		} else if (shape == "poly") {	
			var points = [];
			obj.reg(0,0,true);
			var objP = obj;
			if (obj.scale != 1) {
				objP = obj.clone().transformPoints("scale", obj.scale);
			}
			if (contract) objP = obj.clone().transformPoints("scale", (Math.max(0, 1-contract/((obj.width+obj.height)/4))));
			zim.loop(objP.points, function(point) {
				points.push({x:point[0], y:point[1]})
			});	
			obj.body = obj.physics.makePoly(points, obj.width, obj.height, dynamic, friction, angular, density, restitution, maskBits, categoryBits, linear, sensor);
		}

		obj.body.x = obj.x;
		obj.body.y = obj.y;
		obj.body.rotation = obj.rotation;
		obj.physics.addMap(obj.body, obj);

		obj.impulse = function(x, y, targetX, targetY) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			var defaultTarget = obj.body.GetWorldCenter();
			if (zot(targetX)) targetX = defaultTarget.x*obj.physics.scale;
			if (zot(targetY)) targetY = defaultTarget.y*obj.physics.scale;
			obj.body.ApplyImpulse(new WW.b2Vec2(x, y), new WW.b2Vec2(targetX/obj.physics.scale, targetY/obj.physics.scale));
			return obj;
		};
		obj.force = function(x, y, targetX, targetY) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			var defaultTarget = obj.body.GetWorldCenter();
			if (zot(targetX)) targetX = defaultTarget.x*obj.physics.scale;
			if (zot(targetY)) targetY = defaultTarget.y*obj.physics.scale;
			obj.body.ApplyForce(new WW.b2Vec2(x, y), new WW.b2Vec2(targetX/obj.physics.scale, targetY/obj.physics.scale));
			return obj;
		};
		obj.setLinearVelocity = function(x, y) {
			obj.body.SetLinearVelocity(new WW.b2Vec2(x,y));
			return obj;
		};
		obj.setAngularVelocity = function(amount) {
			obj.body.SetAngularVelocity(amount);
			return obj;
		};
		obj.spin = function(amount) {
			if (zot(amount)) amount = 10;
			obj.body.ApplyTorque(amount*1000);
			return obj;
		};
		obj.torque = function(amount) {
			if (zot(amount)) amount = 10;
			obj.body.ApplyTorque(amount);
			return obj;
		};

		obj.follow = function(damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, borderOriginal) {
			var sig = "damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, borderOriginal";
			var duo; if (duo = zob(obj.follow, arguments, sig)) return duo;
			obj.physics.follow(obj, damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, borderOriginal);
			return obj;
		};
		obj.noFollow = function() {
			obj.physics.follow(null);
			return obj;
		};

		obj.control = function(type, speed, speedY, horizontal, vertical) {
			var sig = "type, speed, speedY, horizontal, vertical";
			var duo; if (duo = zob(obj.control, arguments, sig)) return duo;
			obj.physics.control(obj, type, speed, speedY, horizontal, vertical);
			return obj;
		};
		obj.customControl = function(dir, speed, speedY) {
			var sig = "dir, speed, speedY";
			var duo; if (duo = zob(obj.customControl, arguments, sig)) return duo;
			obj.physics.customControl(dir, speed, speedY);
			return obj;
		};
		obj.noControl = function() {
			obj.physics.noControl(obj);
			return obj;
		};

		obj.sleep = function() {
			obj.body.SetAwake(false);
			return obj;
		};
		obj.wake = function() {
			obj.body.SetAwake(true);
			return obj;
		};

		function makeContact() {
			WW.zimContactListener = new WW.b2ContactListener();
			zimContactBeginList = new zim.Dictionary(true);
			zimContactEndList = new zim.Dictionary(true);
			WW.zimContactListener.BeginContact = beginContact;
			WW.zimContactListener.EndContact = endContact;
			function beginContact(e) {
				var match = zimContactBeginList.at(e.m_fixtureB.GetBody());
				if (match) match(e.m_fixtureA.GetBody().zimObj, e.m_fixtureA.GetBody());
				match = zimContactBeginList.at(e.m_fixtureA.GetBody());
				if (match) match(e.m_fixtureB.GetBody().zimObj, e.m_fixtureB.GetBody());
			}
			function endContact(e) {
				var match = zimContactEndList.at(e.m_fixtureB.GetBody());	
				if (match) match(e.m_fixtureA.GetBody().zimObj, e.m_fixtureA.GetBody());				// else {
				match = zimContactEndList.at(e.m_fixtureA.GetBody());
				if (match) match(e.m_fixtureB.GetBody().zimObj, e.m_fixtureB.GetBody());
			}
			obj.physics.world.SetContactListener(WW.zimContactListener);
		}
		obj.contact = function(f) {
			if (!WW.zimContactListener) makeContact();
			zimContactBeginList.add(obj.body, f);
			return obj;
		};
		obj.noContact = function() {
			zimContactBeginList.remove(obj.body);
			return obj;
		};
		obj.contactEnd = function(f) {
			if (!WW.zimContactListener) makeContact();
			zimContactEndList.add(obj.body, f);
			return obj;
		};
		obj.noContactEnd = function() {
			zimContactEndList.remove(obj.body);
			return obj;
		};
		if (!obj.hasOwnProperty("dynamic")) {
			Object.defineProperty(obj, 'dynamic', {
				get: function() {
					return obj.body.GetType() == 2;
				},
				set: function(val) {
					obj.body.SetType(val==true?2:0);
				}
			});	
		}
	}
	//-69.97

/*--
zim.TimeLine = function(objects, width, startPaused, barColor, buttonColor, themeColor, corner, ticks, damp, loop, noLoop, call, style, group, inherit)

TimeLine
zim class extends zim Container which extends a createjs Container

DESCRIPTION
Automatically adds a ZIM Silder that scrubs through animations added to the Timeline.
There is a play and pause and a menu with speed, labels, loop, trails and color settings.
This will most-likely be used for learning - for testing animations, etc. 
The pop-up menu button can be removed with timeline.menu.removeFrom();
The menu can be cleared with timeline.pane.contentContainer.removeAllChildren();
Or the menu can customized with timeline.pane.add(someObject);

SEE: https://zimjs.com/015/timeline.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const icon = F.makeIcon({box:clear })
	.reg(CENTER)
	.loc(150,450)
	.alp(0)
	.sca(0)
	.animate({
		props:[
			{props:{scale:2, alpha:1, x:300}},
			{props:{x:850}, time:2},
			{props:{rotation:360, scale:1, alpha:0}}
		]
	});

new Rectangle().reg(CENTER).pos(70,100,LEFT,BOTTOM).animate({
	props:{rotation:90}, 
	rewind:true,
	loop:true
});

const path = new Squiggle({showControls:false}).transformPoints("scale", 2).pos(0,100,CENTER);
new Circle(50,red).addTo().rot(90).animate({path:path},4)

new Timeline(); // note, the Timeline will be automatically added at the bottom
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
objects - (default all objects on stage with animations) an object or array of objects with animations
width - (default stage width / 2) the width of the Timeline
startPaused - (default false) set to true to start paused
barColor - (default tin) the color of the slider bar
buttonColor - (default light) the icon color of the buttons
themeColor - (default purple) the backgroundColor of the buttons and the menu pane
corner - (default 5) set the corner of the Timeline - can use and array too
ticks - (default false) set to true to add ticks and labels to the slider
damp - (default false) set to true or a number between 0 and 1 like .2 with lower numbers being more damping
loop - (default true) set to false to not loop the animations
noLoop - (default false) set to true to prevent individual objects from looping as Timeline is played
call - (default false) callback function to call when done or looping
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setThemeColor(color) - set the theme color - does not have to be the colors in the menu
dispose() - get rid of all events and objects - the animations will still work.
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
type - holds the class name as a String
backing - access to the backing rectangle
shade - access to the left backing
shade2 - access to the right backing
slider - access to the slider
controls - access to the left button
menu - access to the right button
pane - access to the menu pane
title - access to the title in the menu
icon - access to the ZIM icon in the menu
list - access to the list in the menu
themeColor - get the current theme color
--*///+69.971
zim.Timeline = function(objects, width, startPaused, barColor, buttonColor, themeColor, corner, ticks, damp, loop, noLoop, call, style, group, inherit) {
	var sig = "objects, width, startPaused, barColor, buttonColor, themeColor, corner, ticks, damp, loop, noLoop, call, style, group, inherit";
	var duo; if (duo = zob(zim.Timeline, arguments, sig, this)) return duo;
	z_d("69.971");	
	this.group = group;
	var DS = style===false?{}:zim.getStyle("Timeline", group, inherit);

	var S = this.stage?this.stage:zimDefaultFrame.stage; 
	var F = S.frame;
	var W = S.width;
	var H = S.height;

	if (zot(startPaused)) startPaused=DS.startPaused!=null?DS.startPaused:false;
	if (zot(loop)) loop=DS.loop!=null?DS.loop:true;
	if (zot(noLoop)) noLoop=DS.noLoop!=null?DS.noLoop:false;
	if (zot(barColor)) barColor=DS.barColor!=null?DS.barColor:zim.tin;
	if (zot(buttonColor)) buttonColor=DS.buttonColor!=null?DS.buttonColor:zim.light;
	if (zot(themeColor)) themeColor=DS.themeColor!=null?DS.themeColor:zim.purple;
	if (zot(width)) width=DS.width!=null?DS.width:W*.5;        
	if (zot(ticks)) ticks=DS.ticks!=null?DS.ticks:true;	
	if (zot(damp)) damp=DS.damp!=null?DS.damp:false;	
	if (zot(corner)) corner=DS.corner!=null?DS.corner:5;
	var height = 50;

	this.zimContainer_constructor(width,height,null,null,false);
	this.type = "Timeline";

	var that = this;
	var obj = objects;
	var tc = zim.toBW(F.color);

	if (zot(obj)) {
		if (!zim.animatedObjects || !zim.animatedObjects.objects) {
			zogy("ZIM Timeline - add Timeline after animated objects");
			return that;
		}
		obj = zim.copy(zim.animatedObjects.objects);
	}
	if (!Array.isArray(obj)) obj = [obj];          

	var startTime = Date.now();
	var endTime = 0;
	zim.loop(obj, function(o){
		o.pauseAnimate();
		if (o.tweenEndTime && o.tweenEndTime > endTime) endTime = o.tweenEndTime;
	})
	var totalTime = Math.ceil((endTime - startTime) / 1000);
	
	var backing = this.backing = new zim.Rectangle(width, height, barColor, null, null, corner).alp(.8).addTo(that);
	var b = tc=="#000000"?0:1;
	var shade = this.shade = new zim.Rectangle(height-b, height-b*2, black, null, null, [corner,0,0,corner]).alp(.7).pos(b,b,LEFT,TOP,that);
	var shade2 = this.shade2 = new zim.Rectangle(height-b, height-b*2, black, null, null, [0,corner,corner,0]).alp(.7).pos(b,b,RIGHT,TOP,that);
				
	var pause = new zim.Container(50,50).alp(.9);
	new zim.Rectangle(7,24,white).center(pause).mov(-6);
	new zim.Rectangle(7,24,white).center(pause).mov(6);
	var control = that.controls = new zim.Button({
		icon:new zim.Triangle(30,30,30,white).reg(null,16).rot(90).alp(.9),
		toggleIcon:pause.reg("center"),
		downBackgroundColor:zim.purple.darken(.2),
		width:50,
		height:50,
		corner:25
	}).scaleTo(backing,null,70).center(shade).addTo(that).expand(10).tap(function() {
		slider.pauseAnimate(!control.toggled);		
	});
	if (!startPaused) control.toggle();

	var hamburger = new zim.Container(50,50).reg("center").alp(.8).expand(10);
	new Rectangle(24,5,zim.white).center(hamburger).mov(0, -8);
	new Rectangle(24,5,zim.white).center(hamburger)
	new Rectangle(24,5,zim.white).center(hamburger).mov(0, 8);
	var first = true;
	var menu = that.menu = new zim.Button({
		icon:hamburger,
		downBackgroundColor:zim.purple.darken(.2),
		width:50,
		height:50,
		corner:25
	}).scaleTo(backing,null,70).center(shade2).addTo(that).tap(function(){
		pane.show();
		if (first) pane.loc(that.x, that.y).mov(that.width-pane.width/2, -pane.height/2-10);		
	});	

	function doSpeed(s) {
		slider.rate = s;
		tl.speed = s;
		that.trailInterval.time = trailProportion.convert(tl.speed);
		try {
			if (localStorage) localStorage.zim_tl = JSON.stringify(tl);
		} catch (err) {}
	}
	function doLabels(checked) {
		slider.ticks.vis(checked);
		slider.labels.vis(checked);
		S.update();
		tl.labels = checked;
		try {
			if (localStorage) localStorage.zim_tl = JSON.stringify(tl);
		} catch (err) {}
	}     
	function doLoop(checked) {
		loop = checked;  
		tl.looping = checked;
		try {
			if (localStorage) localStorage.zim_tl = JSON.stringify(tl);          
		} catch (err) {} 
	}  
	function doTrails(checked) {	
		trailsOff();	
		if (checked) {
			slider.percentComplete = 0;
			setTimeout(function() {
				trailsOn();
			}, 50);
		} 
		tl.trailing = checked;
		try {
			if (localStorage) localStorage.zim_tl = JSON.stringify(tl);
		} catch (err) {}
	}    
	function doColor(color) {
		zim.loop([control,menu], function(b) {
			b.backgroundColor = color;
			b.toggleBackgroundColor = color;
			b.rollBackgroundColor = color.lighten(.2);
			b.rollToggleBackgroundColor = color.lighten(.2);
			b.downBackgroundColor = color.darken(.2);
		});
		pane.backing.color = color;
		speed.slider.bar.color = color;
		S.update();
		tl.color = color;
		try {
			if (localStorage) localStorage.zim_tl = JSON.stringify(tl);
		} catch (err) {}
		return this;
	}   
	this.setThemeColor = doColor;
	
	var speed = zim.List.slider("speed", 0, 2, 1, doSpeed,.1);
	var labels = zim.List.checkBox("labels", false, doLabels);
	var looping = zim.List.checkBox("loop", false, doLoop);
	var trailing = zim.List.checkBox("trails", false, doTrails);
	var color = zim.List.colorPicker("color", zim.purple, new zim.ColorPicker({
		colors:[zim.purple,zim.pink,zim.red,zim.orange,zim.brown,zim.green,zim.blue,zim.grey,zim.black],
		cols:9
	}), doColor);
	
	var title = this.title = new zim.Container(300, 25).noMouse();
		new zim.Rectangle(500, 70, zim.black.toAlpha(.4)).pos(0,-45,CENTER,TOP,title)
		this.icon = F.makeIcon({edges:"white", box:faint, slats:["white","white","white","white","white"]})
			.alp(.6)
			.scaleTo(title,null,140)
			.pos(7,-10,"left","center",title);
		new zim.Label({text:"Z  I  M  -  T  I  M  E  L  I  N  E", color:"white"}).alp(.6).sca(.47).loc(51,-4,title);
		new zim.Line(219, 1, "white").alp(.6).center(title).mov(8,3);

	var pop = this.list = new zim.List({
		width:300,
		height:260,
		backdropColor:clear,
		borderWidth:-1,
		shadowColor:-1,
		viewNum:6,
		padding:12,
		scrollBarV:false,
		list:[speed, labels, looping, trailing, color], 
		swipe:false
	});
	speed.slider.bar.color = zim.purple;
	pop.tabs.mov(0,8)
	var pane = that.pane = new zim.Pane({
		width:pop.width,
		height:pop.height+40,
		backgroundColor:zim.purple,
		backdropColor:zim.faint,
		draggable:true,
		corner:8,
		content:pop,
		resets:false
	});
	pane.contentContainer.mov(0,20);
	pane.backing.on("pressmove", function() {
		first = false;
	}, null, true); // apply once
	title.scaleTo(pane.contentContainer,100).pos(0,2,"center","top",pane.contentContainer).setMask(pane.backing)
		
	var slider = that.slider = new zim.Slider({
		min:0,
		max:totalTime, 
		inside:true,
		barColor:barColor,
		barWidth:height,
		barLength:width-height*2-12,
		tickColor:tc.toAlpha(.8),
		damp:damp,
		useTicks:true,
		tickScale:1,
		tickStep:.1,
		semiTicks:4,
		semiTickScale:1,
		useLabels:true,
		labelColor:tc.toAlpha(.8)
	}).center(that,1);
	slider.bar.dye(zim.faint)
	slider.currentValue = 0;
	slider.ticks.mov(0,-20);
	slider.bar.widthOnly = slider.bar.width+14 

	new zim.Triangle({color:zim.dark}).alp(.3).scaleTo(slider.button, 70, 90, "full").center(slider.button);
						
	slider.animate({
		props:{currentValue:slider.max},
		time:slider.max,
		ease:"linear",
		startPaused:startPaused,
		loop:true,
		loopWait:.5,
		loopWaitCall:function() {
			if (!loop) {
				slider.pauseAnimate();
				control.toggle(false);
				slider.currentValue = slider.max    	                  
			}
			if (h) that.trailInterval.pause();
			if (call && typeof call == "function") call(); 		
		},
		loopCall:function() {						
			zim.loop(obj, function(o) {	
				o.percentComplete = 0;
			});
		}
	});
	
	slider.bar.on("mousedown", function() {
		slider.latestTween.percentComplete = slider.currentValue/slider.max*100;
	});
	var lastPlay = true;
	slider.button.on("mousedown", function(){
		lastPlay = slider.animating;
		slider.pauseAnimate(); 
	});
	slider.button.on("pressup", function() {
		if (lastPlay) slider.pauseAnimate(false);
		slider.latestTween.percentComplete = slider.currentValue/slider.max*100;
	});

	that.keyEvent = F.on("keydown", function(e) {
		if (e.key==" ") {
			if (control.toggled) {
				control.toggle(false);
				slider.pauseAnimate(true);
			} else {
				control.toggle(true);
				slider.pauseAnimate(false);
			}
		}
	});

	that.tickerID = zim.Ticker.add(function(){
		var val = Math.min(100, that.slider.currentValue / totalTime * 100) - .01;
		zim.loop(obj, function(o) {
			var nt = startTime+val/100*(endTime-startTime)-o.tweenStartTime;
			if (noLoop) o.percentComplete = Math.max(0, Math.min(100, nt/(o.tweenEndTime-o.tweenStartTime)*100));		
			o.percentComplete = nt/(o.tweenEndTime-o.tweenStartTime)*100;
		});                   
	});

	var h;	
	function blit() {
		zim.loop(obj, function(o) {	
			var c = o.clone().addTo(h).alp(.05);
			c.color = clear;
			c.borderColor = tc;
		});
		h.updateCache("source-over");
		h.disposeAllChildren();
	}
	that.trailInterval = zim.interval(.05, function() {
		if (slider.animating && speed.slider.currentValue > 0) blit();
	});
	that.trailInterval.pause();

	function trailsOn() {
		if (!that.trails) {
			h = new zim.Container(W,H).addTo(S,0).cache();
			that.trails = new zim.Bitmap(h.cacheCanvas).addTo(S,1);
			that.trailInterval.pause(false);
		}
	}

	function trailsOff() {
		if (that.trails) {
			that.trailInterval.pause();
			that.trails.dispose();
			that.trails = null;
			h.dispose();
			h = null;	
		}
	}

	// localStorage.removeItem("zim_tl")
	var trailProportion = new zim.Proportion(.1,2,.1,.01);
	try {
		if (localStorage) {
			var tl = localStorage.zim_tl;
			if (!tl) tl = JSON.stringify({speed:1, labels:ticks, looping:false, trailing:false, color:purple});
			tl = JSON.parse(tl);            
			doSpeed(tl.speed);
			speed.slider.currentValue = tl.speed;
			speed.stepper.currentValue = tl.speed;
			doLabels(tl.labels);
			labels.checkBox.checked = tl.labels;
			doLoop(tl.looping);
			looping.checkBox.checked = tl.looping;
			doColor(tl.color);
			color.colorPicker.selectedColor = tl.color; 
			color.swatch.color = tl.color;
			color.colorLabel.text = tl.color.toUpperCase();       
			if (tl.trailing) {
				trailsOn();
			}
			trailing.checkBox.checked = tl.trailing;
			that.trailInterval.time = trailProportion.convert(tl.speed);
		}
	} catch (err) {}
	
	this.pos(0,20,"center","bottom");

	if (themeColor != zim.purple) doColor(themeColor);

	this.dispose = function(a,b,disposing) {
		zim.Ticker.remove(that.tickerID);
		F.off("keydown", that.keyEvent);
		if (!disposing) this.zimContainer_dispose(true);		
		return true;		
	}
	if (style!==false) zim.styleTransforms(this, DS);	

}
zim.extend(zim.Timeline, zim.Container, "dispose", "zimContainer", false);
//-69.971


// SUBSECTION EFFECTS

/*--
zim.BlurEffect = function(blurX, blurY, quality, style, group, inherit)

BlurEffect
zim class extends createjs BlurFilter

DESCRIPTION
Blurs a DisplayObject in the x and/or y direction with a quality 
Can be passed in to effect() method to apply effect.
Properties can be changed and updated and then updateEffects() called.
Properties can be animated and wiggled.
Use noEffect("blur") to remove blur effect.

SEE: https://zimjs.com/cat/effects.html

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// add a blur effect then remove it after 2 seconds
const rect = new Rectangle()
	.center()
	.effect(new BlurEffect(20, 20));
timeout(2, ()=>{
	rect.noEffect(); 
	// // or if other effects to keep use: 
	// rect.noEffect("blur"); 
	// // or to update effect use:
	// rect.effects.blur.blurY = 200;
	// rect.updateEffects();
	// // can also store effect in variable and access properties on the variable
	// // rather than on the effects property of the object
	S.update();
});
END EXAMPLE

EXAMPLE
// add a 200 blurX effect and animate it to 0 rewind and looping
STYLE = {blurX:200} // just showing using style...
new Pic("image.png") // preloaded asset
	.center()
	.effect(new BlurEffect())
	.animate({
		props:{"effects.blur.blurX":0},
		time:.7,
		rewind:true,
		rewindWait:.5,
		loop:true
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
blurX - |ZIM VEE| (default 10) the blur in the x
blurY - |ZIM VEE| (default 10) the blur in the y
quality - |ZIM VEE| (default 1) the number of effect iterations
	A value of 2 will produce a smoother effect, but take twice as long to run, etc.
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly


METHODS
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
** a reference to the effect object is also avalailable as obj.effects.blur 
** after setting these properties call obj.updateEffects()
** animate() and wiggle() do this automatically
blurX - the blur in the x
blurY - the blur in the y
quality - the number of effect iterations
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

--*///+69.972
	zim.BlurEffect = function(blurX, blurY, quality, style, group, inherit) {
		var sig = "blurX, blurY, quality, style, group, inherit";
		var duo; if (duo = zob(zim.BlurEffect, arguments, sig, this)) return duo;
		z_d("69.972");	
		this.group = group;
		var DS = style===false?{}:zim.getStyle("BlurEffect", group, inherit);

		// OCT
		if (zot(blurX)) blurX=DS.blurX!=null?DS.blurX:10;
		if (zot(blurY)) blurY=DS.blurY!=null?DS.blurY:10;
		if (zot(quality)) quality=DS.quality!=null?DS.quality:1;
		
		// VEE
		var oa = remember(blurX, blurY, quality);	
		this.veeObj = {blurX:oa[0], blurY:oa[1], quality:oa[2]};
		function remember() {return arguments;} 
		blurX = zik(blurX);
		blurY = zik(blurY);
		quality = zik(quality);
			
		this.createjsBlurFilter_constructor(blurX, blurY, quality);
		this.type = "BlurEffect";		
		
		this.clone = function(exact) {
			return new zim.BlurEffect(
				(exact||!zim.isPick(oa[0]))?blurX :oa[0],
				(exact||!zim.isPick(oa[1]))?blurY :oa[1],
				(exact||!zim.isPick(oa[2]))?quality :oa[2],
				style,this.group,inherit
			);
		};
	}	
	zim.extend(zim.BlurEffect, createjs.BlurFilter, "clone", "createjsBlurFilter", false);
	//-69.972

/*--
zim.GlowEffect = function(color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject, style, group, inherit)

GlowEffect
zim class extends createjs BlurFilter
Originally from https://github.com/u-kudox/Filters_for_EaselJS
and https://github.com/sky0014/Filters_for_EaselJS - with thanks

DESCRIPTION
Adds a glow around or inside a DisplayObject.
Can be passed in to effect() method to apply effect.
Properties can be changed and updated and then updateEffects() called.
Properties can be animated and wiggled.
Use noEffect("glow") to remove glow effect.

SEE: https://zimjs.com/cat/effects.html

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// add a glow effect with knockout then remove it after 2 seconds
const rect = new Rectangle()
	.center()
	.effect(new GlowEffect({color:pink, blurX:50, blurY:50, knockout:true}));
timeout(2, ()=>{
	rect.noEffect(); 
	// // or if other effects to keep use: 
	// rect.noEffect("glow"); 
	// // or to update effect use:
	// rect.effects.glow.blurY = 200;
	// rect.updateEffects();
	// // can also store effect in variable and access properties on the variable
	// // rather than on the effects property of the object
	S.update();
});
END EXAMPLE

EXAMPLE
// add a 200 blurX effect then animate it to 0 rewind and looping
STYLE = {blurX:200} // just showing using style...
new Pic("image.png") // preloaded asset
	.center()
	.effect(new GlowEffect())
	.animate({
		props:{"effects.glow.blurX":0},
		time:.7,
		rewind:true,
		rewindWait:.5,
		loop:true
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
color - |ZIM VEE| (default white) the color of the effect
alpha - |ZIM VEE| (default 1) the alpha of the effect
blurX - |ZIM VEE| (default 30) the blur in the x
blurY - |ZIM VEE| (default 30) the blur in the y
strength - |ZIM VEE| (default 1) the strength is how thickly the effect is applied
quality - |ZIM VEE| (default 1) the number of effect iterations
	A value of 2 will produce a smoother effect, but take twice as long to run, etc.
inner - |ZIM VEE| (default false) set to true to add the effect to the inside of the object
knockout - |ZIM VEE| (default false) set to true to cut out where the object is (including the effect)
hideObject - |ZIM VEE| (default false) set to true to hide the object but leave effect beneath
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
** a reference to the effect object is also avalailable as obj.effects.glow 
** after setting these properties call obj.updateEffects()
** animate() and wiggle() do this automatically
color - the color of the effect
alpha - the alpha of the effect
blurX - the blur in the x
blurY - the blur in the y
strength - the strength is how thickly the effect is applied
quality - the number of effect iterations
inner - boolean whether to add the effect to the inside of the object
knockout - boolean whether to cut out where the object is (including the effect)
hideObject - boolean whether to true to hide the object but leave effect beneath
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

--*///+69.9725
	zim.GlowEffect = function(color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject, style, group, inherit) {
		var sig = "color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject, style, group, inherit";
		var duo; if (duo = zob(zim.GlowEffect, arguments, sig, this)) return duo;
		z_d("69.9725");	
		this.group = group;
		var DS = style===false?{}:zim.getStyle("GlowEffect", group, inherit);

		// OCT
		if (zot(color)) color=DS.color!=null?DS.color:zim.white;
		if (zot(alpha)) alpha=DS.alpha!=null?DS.alpha:1;
		if (zot(blurX)) blurX=DS.blurX!=null?DS.blurX:30;
		if (zot(blurY)) blurY=DS.blurY!=null?DS.blurY:30;
		if (zot(strength)) strength=DS.strength!=null?DS.strength:1;
		if (zot(quality)) quality=DS.quality!=null?DS.quality:1;		
		if (zot(inner)) inner=DS.inner!=null?DS.inner:false;
		if (zot(knockout)) knockout=DS.knockout!=null?DS.knockout:false;
		if (zot(hideObject)) hideObject=DS.hideObject!=null?DS.hideObject:false;
		
		// VEE
		var oa = remember(color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject);	
		this.veeObj = {color:oa[0], alpha:oa[1], blurX:oa[2], blurY:oa[3], strength:oa[4], quality:oa[5], inner:oa[6], knockout:oa[7], hideObject:oa[8]};
		function remember() {return arguments;} 

		blurX = zik(blurX); // inherits these properties
		blurY = zik(blurY);
		quality = zik(quality);

		color = zik(color); // will convert after setting color getter setter

		this.alpha = zik(alpha); // these properties are original		
		this.strength = zik(strength);
		this.inner = zik(inner);
		this.knockout = zik(knockout);		
		this.hideObject = zik(hideObject);		

		this.createjsBlurFilter_constructor(blurX, blurY, quality);
		this.type = "GlowEffect";	
		this.usesContext = true;	

		this.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {
			// from https://github.com/u-kudox/Filters_for_EaselJS with thanks
			if ((this.alpha <= 0 || this.strength <= 0) && !this.knockout) {
				return true;
			}
			targetCtx = targetCtx || ctx;
			if (targetX === undefined) targetX = x;
			if (targetY === undefined) targetY = y;
			var tImgData = targetCtx.getImageData(targetX, targetY, width, height);
			var tData = tImgData.data;
			var dCvs = document.createElement("canvas");
			dCvs.width = width;
			dCvs.height = height;
			var dCtx = dCvs.getContext("2d", {willReadFrequently:true});
			var dImgData = dCtx.getImageData(0, 0, width, height);
			var dData = dImgData.data;
			var inner = this.inner;
			var red = this._red;
			var green = this._green;
			var blue = this._blue;
			for (var i = 0, l = dData.length; i < l; i += 4) {
				var ia = i + 3;
				var alpha = tData[ia];
				if (!inner) {
					if (alpha !== 0) {
						dData[i] = red;
						dData[i + 1] = green;
						dData[i + 2] = blue;
						dData[ia] = alpha;
					}
				} else {
					if (alpha !== 255) {
						dData[i] = red;
						dData[i + 1] = green;
						dData[i + 2] = blue;
						dData[ia] = 255 - alpha;
					}
				}
			}
			dCtx.putImageData(dImgData, 0, 0);
			var strength = this.strength;
			if (0 < strength) {
				this.createjsBlurFilter_applyFilter(dCtx, 0, 0, width, height);
				if (255 < strength) strength = 255;
				for (var j = 1; j < strength; j++) {
					dCtx.drawImage(dCvs, 0, 0);
				}
			}
			var ga = this.alpha;
			if (ga < 0) ga = 0;
			else if (1 < ga) ga = 1;
			var gco;
			if (this.knockout) {
				if (inner) gco = "source-in";
				else gco = "source-out";
			} else {
				if (this.hideObject) {
					if (inner) gco = "source-in";
					else gco = "copy";
				} else {
					if (inner) gco = "source-atop";
					else gco = "destination-over";
				}				
			}		
			
			targetCtx.save();
			targetCtx.setTransform(1, 0, 0, 1, 0, 0);
			targetCtx.globalAlpha = ga;
			targetCtx.globalCompositeOperation = gco;
			targetCtx.drawImage(dCvs, targetX, targetY);
			targetCtx.restore();
			return true;
		};	

		Object.defineProperty(this, "color", {
			get : function() {
				return this._red << 16 | this._green << 8 | this._blue;
			},
			set : function(value) {
				value = zim.convertColor(value, "hexNumber"); // to hexNumber					
				this._red = value >> 16 & 0xFF;
				this._green = value >> 8 & 0xFF;
				this._blue = value & 0xFF;
			}
		});		
		this.color = color;

		this.clone = function(exact) {
			return new zim.GlowFilter(
				(exact||!zim.isPick(oa[0]))?color :oa[0],
				(exact||!zim.isPick(oa[1]))?alpha :oa[1],
				(exact||!zim.isPick(oa[2]))?blurX :oa[2],
				(exact||!zim.isPick(oa[3]))?blurY :oa[3],
				(exact||!zim.isPick(oa[4]))?quality :oa[4],
				(exact||!zim.isPick(oa[5]))?strength :oa[5],
				(exact||!zim.isPick(oa[6]))?inner :oa[6],
				(exact||!zim.isPick(oa[7]))?knockout :oa[7],
				(exact||!zim.isPick(oa[8]))?knockout :oa[8],
				style,this.group,inherit
			);
		};
	}	
	zim.extend(zim.GlowEffect, createjs.BlurFilter, ["clone","applyFilter"], "createjsBlurFilter", false);
	//-69.9725

/*--
zim.ShadowEffect = function(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject, style, group, inherit)

ShadowEffect
zim class extends createjs BlurFilter
Originally from https://github.com/u-kudox/Filters_for_EaselJS
and https://github.com/sky0014/Filters_for_EaselJS - with thanks

DESCRIPTION
Makes a drop shadow on a DisplayObject - more customizable than ZIM sha()
Can be passed in to effect() method to apply effect.
Properties can be changed and updated and then updateEffects() called.
Properties can be animated and wiggled.
Use noEffect("shadow") to remove shadow effect.

SEE: https://zimjs.com/cat/effects.html

NOTE: ZIM sha() wraps a CreateJS Shadow() which seems to put shadow on borders too 
The ShadowEffect() does not put shadows on borders - which is good. 

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// add a shadow effect when dragging and remove on pressup
const rect = new Rectangle()
	.center()
	.drag();
rect.on("mousedown", ()=>{
	rect.effect(new ShadowEffect());
	S.update();
});
rect.on("pressup", function () {
	rect.noEffect("shadow"); 
	S.update();
});
END EXAMPLE

EXAMPLE
// add a 200 blurX effect then animate the angle rewind and looping
STYLE = {blurX:200} // just showing using style...
new Pic("image.png") // preloaded asset
	.center()
	.effect(new ShadowEffect())
	.animate({
		props:{"effects.shadow.angle":90},
		time:.7,
		rewind:true,
		rewindWait:.5,
		loop:true
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
distance - |ZIM VEE| (default 10) the distance of the effect
angle - |ZIM VEE| (default 45) the angle of the effect
color - |ZIM VEE| (default black) the color of the effect
alpha - |ZIM VEE| (default .4) the alpha of the effect
blurX - |ZIM VEE| (default 15) the blur in the x
blurY - |ZIM VEE| (default 15) the blur in the y
strength - |ZIM VEE| (default 1) the strength is how thickly the effect is applied
quality - |ZIM VEE| (default 1) the number of effect iterations
	A value of 2 will produce a smoother effect, but take twice as long to run, etc.
inner - |ZIM VEE| (default false) set to true to add the effect to the inside of the object
knockout - |ZIM VEE| (default false) set to true to cut out where the object is (including the effect)
hideObject - |ZIM VEE| (default false) set to true to hide the object but leave effect beneath
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
** a reference to the effect object is also avalailable as obj.effects.blur 
** after setting these properties call obj.updateEffects()
** animate() and wiggle() do this automatically
distance - the distance of the effect
angle - the angle of the effect
color - the color of the effect
alpha - the alpha of the effect
blurX - the blur in the x
blurY - the blur in the y
strength - the strength is how thickly the effect is applied
quality - the number of effect iterations
inner - boolean whether to add the effect to the inside of the object
knockout - boolean whether to cut out where the object is (including the effect)
hideObject - boolean whether to true to hide the object but leave effect beneath
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

--*///+69.973
	zim.ShadowEffect = function(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject, style, group, inherit) {
		var sig = "distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject, style, group, inherit";
		var duo; if (duo = zob(zim.ShadowEffect, arguments, sig, this)) return duo;
		z_d("69.973");	
		this.group = group;
		var DS = style===false?{}:zim.getStyle("ShadowEffect", group, inherit);

		// OCT
		if (zot(distance)) distance=DS.distance!=null?DS.distance:10;
		if (zot(angle)) angle=DS.angle!=null?DS.angle:45;
		if (zot(color)) color=DS.color!=null?DS.color:zim.black;
		if (zot(alpha)) alpha=DS.alpha!=null?DS.alpha:.4;
		if (zot(blurX)) blurX=DS.blurX!=null?DS.blurX:15;
		if (zot(blurY)) blurY=DS.blurY!=null?DS.blurY:15;
		if (zot(strength)) strength=DS.strength!=null?DS.strength:1;
		if (zot(quality)) quality=DS.quality!=null?DS.quality:1;		
		if (zot(inner)) inner=DS.inner!=null?DS.inner:false;
		if (zot(knockout)) knockout=DS.knockout!=null?DS.knockout:false;
		if (zot(hideObject)) hideObject=DS.hideObject!=null?DS.hideObject:false;
		
		// VEE
		var oa = remember(distance, angle, color, alpha, blurX, blurY, strength, quality, inner, knockout, hideObject);	
		this.veeObj = {distance:oa[0], angle:oa[1], color:oa[2], alpha:oa[3], blurX:oa[4], blurY:oa[5], strength:oa[6], quality:oa[7], inner:oa[8], knockout:oa[9], hideObject:oa[10]};
		function remember() {return arguments;} 

		blurX = zik(blurX); // inherits these properties
		blurY = zik(blurY);
		quality = zik(quality);

		color = zik(color); // will convert after setting color getter setter
		distance = zik(distance); 		
		angle = zik(angle); 
		
		var that = this;
		
		this.alpha = zik(alpha); // these properties are original
		this.strength = zik(strength);
		this.inner = zik(inner);
		this.knockout = zik(knockout);		
		this.hideObject = zik(hideObject);		

		this.createjsBlurFilter_constructor(blurX, blurY, quality);
		this.type = "ShadowEffect";	
		this.usesContext = true;	
		
		Object.defineProperty(this, "angle", {
			get : function() {
				return angle;
			},
			set : function(value) {
				angle = value = (value % 360 + 360) % 360;
				setOffset(distance, value);				
			}
		});		
		this.angle = angle;	
				
		Object.defineProperty(this, "distance", {
			get : function() {
				return distance;
			},
			set : function(value) {
				distance = value;
				setOffset(value, angle);
			}
		});
		this.distance = distance;
				
		function setOffset(distance, angle) {
			var r = angle * zim.RAD;
			that._offsetX = Math.cos(r) * distance;
			that._offsetY = Math.sin(r) * distance;
		}
		
		Object.defineProperty(this, "color", {
			get : function() {
				return this._red << 16 | this._green << 8 | this._blue;
			},
			set : function(value) {
				value = zim.convertColor(value, "hexNumber"); // to hexNumber
				this._red = value >> 16 & 0xFF;
				this._green = value >> 8 & 0xFF;
				this._blue = value & 0xFF;
			}
		});		
		this.color = color;		
		

		this.applyFilter = function(ctx, x, y, width, height, targetCtx, targetX, targetY) {			
			if ((this.alpha <= 0 || this.strength <= 0) && (!this.knockout && !this.hideObject)) {
				return true;
			}
			targetCtx = targetCtx || ctx;
			if (targetX === undefined) targetX = x;
			if (targetY === undefined) targetY = y;
			var tImgData = targetCtx.getImageData(targetX, targetY, width, height);
			var tData = tImgData.data;
			var dCvs = document.createElement("canvas");
			dCvs.width = width;
			dCvs.height = height;
			var dCtx = dCvs.getContext("2d", {willReadFrequently:true});
			var dImgData = dCtx.getImageData(0, 0, width, height);
			var dData = dImgData.data;
			var inner = this.inner;
			var red = this._red;
			var green = this._green;
			var blue = this._blue;
			for (var i = 0, l = dData.length; i < l; i += 4) {
				var ia = i + 3;
				var alpha = tData[ia];
				if (!inner) {
					if (alpha !== 0) {
						dData[i] = red;
						dData[i + 1] = green;
						dData[i + 2] = blue;
						dData[ia] = alpha;
					}					
				} else {
					if (alpha !== 255) {
						dData[i] = red;
						dData[i + 1] = green;
						dData[i + 2] = blue;
						dData[ia] = 255 - alpha;
					}
				}
			}
			dCtx.putImageData(dImgData, 0, 0);
			var strength = this.strength;
			if (0 < strength) {
				this.createjsBlurFilter_applyFilter(dCtx, 0, 0, width, height);
				if (255 < strength) strength = 255;
				for (var j = 1; j < strength; j++) {
					dCtx.drawImage(dCvs, 0, 0);
				}
			}
			var ga = this.alpha;
			if (ga < 0) ga = 0;
			else if (1 < ga) ga = 1;
			var gco;
			if (this.knockout) {
				if (inner) gco = "source-in";
				else gco = "source-out";
			} else {
				if (this.hideObject) {
					if (inner) gco = "source-in";
					else gco = "copy";
				} else {
					if (inner) gco = "source-atop";
					else gco = "destination-over";
				}
			}			
			targetCtx.save();
			targetCtx.setTransform(1, 0, 0, 1, 0, 0);
			targetCtx.globalAlpha = ga;
			targetCtx.globalCompositeOperation = gco;
			targetCtx.drawImage(dCvs, targetX + this._offsetX, targetY + this._offsetY);
			targetCtx.restore();
			return true;
		};		
		
		this.getBounds = function(rect) {
			
			// if (this.inner) {
			// 	return rect;
			// } else {
				var bounds = this.createjsBlurFilter_getBounds(rect);
				var ox = this._offsetX;
				var oy = this._offsetY;
				if (ox !== 0) {
					if (ox < 0) {
						bounds.x += ox;
						bounds.width += -ox;
					} else {
						bounds.width += ox;
					}
				}
				if (oy !== 0) {
					if (oy < 0) {
						bounds.y += oy;
						bounds.height += -oy;
					} else {
						bounds.height += oy;
					}
				}
				
				return bounds;
			// }
		};

		this.clone = function(exact) {
			return new zim.ShadowFilter(
				(exact||!zim.isPick(oa[0]))?distance :oa[0],
				(exact||!zim.isPick(oa[1]))?angle :oa[1],
				(exact||!zim.isPick(oa[2]))?color :oa[2],
				(exact||!zim.isPick(oa[3]))?alpha :oa[3],
				(exact||!zim.isPick(oa[4]))?blurX :oa[4],
				(exact||!zim.isPick(oa[5]))?blurY :oa[5],
				(exact||!zim.isPick(oa[6]))?quality :oa[6],
				(exact||!zim.isPick(oa[7]))?strength :oa[7],
				(exact||!zim.isPick(oa[8]))?inner :oa[8],
				(exact||!zim.isPick(oa[9]))?knockout :oa[9],
				(exact||!zim.isPick(oa[10]))?hideObject :oa[10],
				style,this.group,inherit
			);
		};
	}	
	zim.extend(zim.ShadowEffect, createjs.BlurFilter, ["clone","getBounds","applyFilter"], "createjsBlurFilter", false);
	//-69.973

/*--
zim.ThresholdEffect = function(redValue, greenValue, blueValue, passColor, failColor, style, group, inherit)

ThresholdEffect
zim class extends createjs Filter

DESCRIPTION
Applies a color for above a value and below a value for each color channel.
Channels or pass and fail can be turned off with -1

SEE: https://zimjs.com/016/threshold.html

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// html red for colors above half intensity (128/256) and html blue for colors below half intenstity
new Pic("file.jpg").center().effect(new FilterEffect(128, 128, 128, "red", "blue"));
END EXAMPLE

EXAMPLE
// lots of black but save real colors if above 180 in all channels - but will probably want to play with settings.
new Pic("file.jpg").center().effect(new FilterEffect(180, 180, 180, -1, "black"));
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
redValue - |ZIM VEE| (default 128) the threshold amount on the red channel
    channels have values from 0-255 so 128 is in the middle (50%) 
    set to 0 pass all this channel so more pass color will be shown where red is 
    if the pass color is turned off then the red channel will show
    set to 255 to fail all this channel so more fail color will be shown where red is
    if the fail color is turned off then this value will not affect the final image
    set to -1 to keep all the red channel color and not include the red channel in the threshold
greenValue - |ZIM VEE| (default 128) the threshold amount on the green channel - see redValue for more info
blueValue - |ZIM VEE| (default 128) the threshold amount on the green channel - see greenValue for more info
passColor - |ZIM VEE| (default white) the color for above the threshold - set to -1 to keep original color where above the threshold
failColor - |ZIM VEE| (default black) the color for below the threshold - set to -1 to keep original color where below the threshold
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
** a reference to the effect object is also avalailable as obj.effects.blur 
** after setting these properties call obj.updateEffects()
** animate() and wiggle() do this automatically
redValue - get or set the red channel threshold - must use obj.updateEffects()
redValue - the red channel threshold - must use obj.updateEffects()
redValue - the red channel threshold - must use obj.updateEffects()
passColor - the color for above the threshold - must use obj.updateEffects()
failColor - the color for above the threshold - must use obj.updateEffects()
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

--*///+69.9735
    zim.ThresholdEffect = function(redValue, greenValue, blueValue, passColor, failColor, style, group, inherit) {
        var sig = "redValue, greenValue, blueValue, passColor, failColor, style, group, inherit";
        var duo; if (duo = zob(zim.ThresholdEffect, arguments, sig, this)) return duo;
        z_d("69.9735");	
        this.group = group;
        var DS = style===false?{}:zim.getStyle("BlurEffect", group, inherit);

        // OCT
        if (zot(redValue)) redValue=DS.redValue!=null?DS.redValue:128;
        if (zot(greenValue)) greenValue=DS.greenValue!=null?DS.greenValue:128;
        if (zot(blueValue)) blueValue=DS.blueValue!=null?DS.blueValue:128;
        if (zot(passColor)) passColor=DS.passColor!=null?DS.passColor:zim.white;
        if (zot(failColor)) failColor=DS.failColor!=null?DS.failColor:0;

        zim.convertColor(passColor);
        
        // VEE
        var oa = remember(redValue, greenValue, blueValue, passColor, failColor);	
        this.veeObj = {redValue:oa[0], greenValue:oa[1], blueValue:oa[2], passColor:oa[3], failColor:oa[4]};
        function remember() {return arguments;} 
        this.redValue = redValue = zik(redValue);
        this.greenValue = greenValue = zik(greenValue);
        this.blueValue = blueValue = zik(blueValue);
        passColor = zik(passColor);
        failColor = zik(failColor);
        if (passColor != -1) passColor = zim.convertColor(passColor, "hexnumber");
        if (failColor != -1) failColor = zim.convertColor(failColor, "hexnumber");
        var _passColor = passColor;
        var _failColor = failColor;

            
        this.createjsFilter_constructor();
        this.type = "ThresholdEffect";		

        Object.defineProperty(this, "passColor", {
			get : function() {
				return _passColor;
			},
			set : function(value) {
                passColor = zik(value);
                if (passColor != -1) passColor = zim.convertColor(passColor, "hexnumber");
                _passColor = passColor;
			}
		});
        Object.defineProperty(this, "failColor", {
			get : function() {
				return _failColor;
			},
			set : function(value) {
                failColor = zik(value);
                if (failColor != -1) failColor = zim.convertColor(failColor, "hexnumber");
                _failColor = failColor;
			}
		});
        
        this.clone = function(exact) {
            return new zim.ThresholdEffect(
                (exact||!zim.isPick(oa[0]))?redValue :oa[0],
                (exact||!zim.isPick(oa[1]))?greenValue :oa[1],
                (exact||!zim.isPick(oa[2]))?blueValue :oa[2],
                (exact||!zim.isPick(oa[3]))?passColor :oa[3],
                (exact||!zim.isPick(oa[4]))?failColor :oa[4],
                style,this.group,inherit
            );
        };
    }	
    zim.extend(zim.ThresholdEffect, createjs.Filter, "clone", "createjsFilter", false);

    zim.ThresholdEffect.LUM_R = 0.213;
    zim.ThresholdEffect.LUM_G = 0.715;
    zim.ThresholdEffect.LUM_B = 0.072;

	zim.ThresholdEffect.prototype._applyFilter = function (imageData) {
		// Local references for speed.
		var pixels = imageData.data,
				r = this.redValue,
				g = this.greenValue,
				b = this.blueValue,
				pass = this.passColor,
				fail = this.failColor;   

		for(var i = 0, l=pixels.length; i<l; i+=4) {
			if (
                (r==-1 || pixels[i] >= r) && 
                (g==-1 || pixels[i+1] >= g) && 
                (b==-1 || pixels[i+2] >= b)
             ) {
				if (pass == -1) { continue; }
			    if (r!=-1) pixels[i] = pass >> 16;
				if (g!=-1) pixels[i+1] = pass >> 8 & 0x00FF;
				if (b!=-1) pixels[i+2] = pass & 0x0000FF;
			} else {
				if (fail == -1) { continue; }
				if (r!=-1) pixels[i] = fail >> 16;
				if (g!=-1) pixels[i+1] = fail >> 8 & 0x00FF;
				if (b!=-1) pixels[i+2] = fail & 0x0000FF;
			}
		}
		return true;
	};
//-69.9735
		
/*--
zim.ColorEffect = function(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset, style, group, inherit)

ColorEffect
zim class extends createjs ColorFilter

DESCRIPTION
Changes the colors in a DisplayObject including Shapes and Bitmaps.

BACKGROUND
Bitmaps are made up of four channels - red, green, blue and alpha (transparency).
Each channel has 256 values from 0 to 255.
O is dark and 255 is light.
If we multiply the blue channel by 0 we would get no blue colors. 
If we multiply the blue channel by .5 we would get half as bright blue colors 
and multiplying by 1 would leave the blue colors as they are.
Offsetting the colors negative makes them darker and positive makes them lighter.

SEE: hue, saturation, brightness and contrast DisplayObject properties as well

SEE: the keyOut() method of Bitmap(), Pic() and SVG() that has a replacement color parameter

SEE: color property of Shapes or backgroundColor property of Components 
to change colors directly including animating color from one color to another with animate()

Can be passed in to effect() method to apply effect.
Properties can be changed and updated and then updateEffects() called.
Properties can be animated and wiggled.
Use noEffect("color") to remove color effect.

SEE: https://zimjs.com/cat/effects.html

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// animate an image so it has no red and green (leave it the blue) rewind and loop
new Pic("image.png") // preloaded asset
	.center()
	.effect(new ColorEffect())
	.animate({
		props:{"effects.color.redMultiplier":0, "effects.color.redMultiplier":0},
		time:.7,
		rewind:true,
		rewindWait:.5,
		loop:true
	});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
redMultiplier - |ZIM VEE| (default 1) the amount to multiply the red channel of the object
greenMultiplier - |ZIM VEE| (default 1) the amount to multiply the green channel of the object
blueMultiplier - |ZIM VEE| (default 1) the amount to multiply the blue channel of the object
alphaMultiplier - |ZIM VEE| (default 1) the amount to multiply the alpha channel of the object
redOffset - |ZIM VEE| (default 0) the amount to Offset the red channel of the object - between -255 and 255
greenOffset - |ZIM VEE| (default 0) the amount to Offset the green channel of the object - between -255 and 255
blueOffset - |ZIM VEE| (default 0) the amount to Offset the blue channel of the object - between -255 and 255
alphaOffset - |ZIM VEE| (default 0) the amount to Offset the alpha channel of the object - between -255 and 255
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
** a reference to the effect object is also avalailable as obj.effects.blur 
** after setting these properties call obj.updateEffects()
** animate() and wiggle() do this automatically
redMultiplier - the amount to multiply the red channel of the object
greenMultiplier - the amount to multiply the green channel of the object
blueMultiplier - the amount to multiply the blue channel of the object
alphaMultiplier - the amount to multiply the alpha channel of the object
redOffset - the amount to Offset the red channel of the object - between -255 and 255
greenOffset - the amount to Offset the green channel of the object - between -255 and 255
blueOffset - the amount to Offset the blue channel of the object - between -255 and 255
alphaOffset - the amount to Offset the alpha channel of the object - between -255 and 255
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

--*///+69.9735
	zim.ColorEffect = function(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset, style, group, inherit) {
		var sig = "redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset, style, group, inherit";
		var duo; if (duo = zob(zim.ColorEffect, arguments, sig, this)) return duo;
		z_d("69.9735");	
		this.group = group;
		var DS = style===false?{}:zim.getStyle("ColorEffect", group, inherit);

		// OCT
		if (zot(redMultiplier)) redMultiplier=DS.redMultiplier!=null?DS.redMultiplier:1;
		if (zot(greenMultiplier)) greenMultiplier=DS.greenMultiplier!=null?DS.greenMultiplier:1;
		if (zot(blueMultiplier)) blueMultiplier=DS.blueMultiplier!=null?DS.blueMultiplier:1;
		if (zot(alphaMultiplier)) alphaMultiplier=DS.alphaMultiplier!=null?DS.alphaMultiplier:1;
		if (zot(redOffset)) redOffset=DS.redOffset!=null?DS.redOffset:0;
		if (zot(greenOffset)) greenOffset=DS.greenOffset!=null?DS.greenOffset:0;
		if (zot(blueOffset)) blueOffset=DS.blueOffset!=null?DS.blueOffset:0;
		if (zot(alphaOffset)) alphaOffset=DS.alphaOffset!=null?DS.alphaOffset:0;
		
		// VEE
		var oa = remember(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset);
		this.veeObj = {redMultiplier:oa[0], greenMultiplier:oa[1], blueMultiplier:oa[2], alphaMultiplier:oa[3], redOffset:oa[4], greenOffset:oa[5], blueOffset:oa[6], alphaOffset:oa[7]};
		function remember() {return arguments;} 
		redMultiplier = zik(redMultiplier);
		greenMultiplier = zik(greenMultiplier);
		blueMultiplier = zik(blueMultiplier);
		alphaMultiplier = zik(alphaMultiplier);
		redOffset = zik(redOffset);
		greenOffset = zik(greenOffset);
		blueOffset = zik(blueOffset);
		alphaOffset = zik(alphaOffset);
			
		this.createjsColorFilter_constructor(redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset);
		this.type = "ColorEffect";		
		
		this.clone = function(exact) {
			return new zim.ColorEffect(
				redMultiplier, greenMultiplier, blueMultiplier, alphaMultiplier, redOffset, greenOffset, blueOffset, alphaOffset,
				(exact||!zim.isPick(oa[0]))?redMultiplier:oa[0],
				(exact||!zim.isPick(oa[1]))?greenMultiplier:oa[1],
				(exact||!zim.isPick(oa[2]))?blueMultiplier:oa[2],
				(exact||!zim.isPick(oa[2]))?alphaMultiplier:oa[3],
				(exact||!zim.isPick(oa[2]))?redOffset:oa[4],
				(exact||!zim.isPick(oa[2]))?greenOffset:oa[5],
				(exact||!zim.isPick(oa[2]))?blueOffset:oa[6],
				(exact||!zim.isPick(oa[2]))?alphaOffset:oa[7],
				style,this.group,inherit
			);
		};
	}	
	zim.extend(zim.ColorEffect, createjs.ColorFilter, "clone", "createjsColorFilter", false);
	//-69.9735

/*--
zim.MultiEffect = function(hue, saturation, brightness, contrast, style, group, inherit)

MultiEffect
zim class extends createjs ColorMatrixFilter

DESCRIPTION
Sets the hue, saturation, brightness and contrast of a DisplayObject.

CONVENIENCE EFFECTS
ZIM provides hue, saturation, brightness and contrast properties for DisplayObjects:
	obj.hue = 100;
These are easier to use than the MultiEffect class directly. 

Can be passed in to effect() method to apply effect.
Properties can be changed and updated and then updateEffects() called.
Properties can be animated and wiggled.
Use noEffect("hue") to remove hue effect.

SEE: https://zimjs.com/cat/effects.html

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// change hue, saturation, brightness and contrast of image then change back
new Pic("image.png") // preloaded asset
	.center()
	.effect(new MultiEffect(20, -50, -20, 10));
timeout(2, ()=>{
	rect.noEffect(); 
	// // or if other effects to keep use: 
	// rect.noEffect("multi"); 
	// // or to update effect use:
	// rect.effects.multi.amount = 200;
	// rect.updateEffects();
	// // can also store effect in variable and access properties on the variable
	// // rather than on the effects property of the object
	S.update();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
hue - |ZIM VEE| (default 0) the hue (color tint) of the effect (-180 to 180)
saturation - |ZIM VEE| (default 0) the saturation (how much color) of the effect (-100 to 100)
brightness - |ZIM VEE| (default 0) the brightness (lightness) of the effect (-255 to 255)
contrast - |ZIM VEE| (default 0) the contrast (light versus dark) of the effect (-100 to 100)
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
adjustColor(hue, saturation, brightness, contrast) - adjust all or some colors at once - parameters support |ZIM VEE|
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

PROPERTIES
** a reference to the effect object is also avalailable as obj.effects.blur 
** after setting these properties call obj.updateEffects()
** animate() and wiggle() do this automatically
hue - the hue (color tint) of the effect (-180 to 180)
saturation - the saturation (how much color) of the effect (-100 to 100)
brightness - the brightness (lightness) of the effect (-255 to 255)
contrast - the contrast (light versus dark) of the effect (-100 to 100)
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

--*///+69.974
	zim.MultiEffect = function(hue, saturation, brightness, contrast, style, group, inherit) {
		var sig = "hue, saturation, brightness, contrast, style, group, inherit";
		var duo; if (duo = zob(zim.MultiEffect, arguments, sig, this)) return duo;
		z_d("69.974");	
		this.group = group;
		var DS = style===false?{}:zim.getStyle("MultiEffect", group, inherit);

		// OCT
		if (zot(hue)) hue=DS.hue!=null?DS.hue:0;
		if (zot(saturation)) saturation=DS.saturation!=null?DS.saturation:0;
		if (zot(brightness)) brightness=DS.brightness!=null?DS.brightness:0;
		if (zot(contrast)) contrast=DS.contrast!=null?DS.contrast:0;
		
		// VEE
		var oa = remember(hue, saturation, brightness, contrast);
		this.veeObj = {hue:oa[0], saturation:oa[1], brightness:oa[2], contrast:oa[3]};	
		function remember() {return arguments;} 
		hue = zik(hue);
			
		this.createjsColorMatrixFilter_constructor(new createjs.ColorMatrix().adjustColor(brightness, contrast, saturation, hue));
		this.type = "MultiEffect";
		
		this.adjustColor = function(h, s, b, c) {
			if (!zot(hue)) hue=zik(h);
			if (!zot(saturation)) saturation=zik(s);
			if (!zot(brightness)) brightness=zik(b);
			if (!zot(contrast)) contrast=zik(c);
			this.matrix.reset().adjustColor(h, s, b, c);
		}		
		
		Object.defineProperty(this, "brightness", {
			get : function() {
				return brightness;
			},
			set : function(value) {
				brightness = zik(value);
				this.matrix.reset().adjustColor(brightness, contrast, saturation, hue);
			}
		});	
		
		Object.defineProperty(this, "contrast", {
			get : function() {
				return contrast;
			},
			set : function(value) {
				contrast = zik(value);
				this.matrix.reset().adjustColor(brightness, contrast, saturation, hue);
			}
		});	
		
		Object.defineProperty(this, "saturation", {
			get : function() {
				return saturation;
			},
			set : function(value) {
				saturation = zik(value);
				this.matrix.reset().adjustColor(brightness, contrast, saturation, hue);
			}
		});	
		
		Object.defineProperty(this, "hue", {
			get : function() {
				return hue;
			},
			set : function(value) {
				hue = zik(value);
				this.matrix = new createjs.ColorMatrix().adjustColor(brightness, contrast, saturation, hue)
				this.applyFilter();
			}
		});	
		
		this.clone = function(exact) {
			return new zim.MultiEffect(
				(exact||!zim.isPick(oa[0]))?hue:oa[0],
				(exact||!zim.isPick(oa[0]))?saturation:oa[0],
				(exact||!zim.isPick(oa[0]))?brightness:oa[0],
				(exact||!zim.isPick(oa[0]))?contrast:oa[0],
				style,this.group,inherit
			);
		};
	}	
	zim.extend(zim.MultiEffect, createjs.ColorMatrixFilter, "clone", "createjsColorMatrixFilter", false);
	//-69.974

/*--
zim.AlphaEffect = function(mask, style, group, inherit)

AlphaEffect
zim class extends createjs AlphaMaskFilter

DESCRIPTION
Applies an alpha mask to a DisplayObject 

BACKGROUND
Images have an alpha channel with values from 0-255 
with 0 being completely see through and 255 completely opaque.

A regular mask shows the masked object through the mask 
where the mask has any alpha greater than 0.
And a regular mask in ZIM needs to be a Shape.

When the AlphaEffect() is applied to a target object 
it sets the alpha of the target object 
to the alpha of the mask passed in to the effect.
It replaces the alpha channel of the object with the alpha channel of the mask.
The mask can be a PNG with varying levels of alpha 
or a shape with a gradient alpha using an rgba() color.
This means we can fade the edges of the image!

Can be passed in to effect() method to apply effect.
Properties can be changed and updated and then updateEffects() called.
Properties can be animated and wiggled.
Use noEffect("alpha") to remove alpha effect.

NOTE: This works best if the object and the mask are in the same location
and have the same bounds.  Beware, circles have negative x and y bound positions.
So if masking a circle, put the circle in a dimensioned Container(radius*2, radius*2) 
then add the effect(new AlphaEffect()) to the container.

SEE: 
https://zimjs.com/explore/alphaeffect.html
https://zimjs.com/explore/alphaMask.html
https://zimjs.com/explore/mask.html
https://zimjs.com/cat/effects.html

NOTE: Effects are quite processor intensive so use sparingly.
Each effect processes every pixel - when animating this results in hundreds of thousands of loops.
ZIM has wrapped the CreateJS filters, filter property, caching and cacheUpdate system
to make accessing filters easy - but apps will slow down if they are over-used.
Keep the quality at 1 for animating filters at a decent framerate.
Consider pre-processing images if effects do not have to be dynamic.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// add alpha mask effect with a transparent background png
// ** preload the pic.png in the Frame call or with F.loadAssets()
const tile = new Tile(new Circle(10, purple), 20, 20)
	.center()
	.effect(new AlphaEffect(new Pic("pic.png")))
	.drag({all:true});
END EXAMPLE

EXAMPLE
// add alpha mask as a gradient crop for an image
// ** preload the pic.png in the Frame call or with F.loadAssets()
const pic = new Pic("pic.png").center();
const gradient = new RadialColor(
	[clear,black],[.3,.5], // colors and ratios
	pic.width/2,pic.height/2,Math.max(pic.width/2,pic.height/2), // start x, y and radius (or use Math.min())
	pic.width/2,pic.height/2,0 // end x, y and radius
);
pic.effect(new AlphaEffect(new Rectangle(pic.width, pic.height, gradient)));
END EXAMPLE

EXAMPLE
// mask a Circle with a Container containing animated Rectangles
// add Circle to dimensioned Container otherwise negative x and y bounds of Circle breaks cacheCanvas

const mask = new Container(300,200).center();
// animating first rectangle in negative so start it moved in the container 
// so it will not animate less than 0 in the container
new Rectangle().loc(50,0,mask).animate({props:{x:"-50"}, rewind:true, loop:true});
new Rectangle().loc(150,100,mask).animate({props:{x:"50"}, rewind:true, loop:true});

// make the container the same size as above
// with the same registration point - just makes things easier
const c = new Container(300,200).center();
new Circle(100,red).center(c);
c.effect(new AlphaEffect(mask, true))
Ticker.add(()=>{c.updateEffects();});    
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
mask - |ZIM VEE| a ZIM Bitmap (or Canvas object) that will be the mask for the object
	or can be any ZIM DisplayObject - this will be cached and use the cacheCanvas as the mask 
	so for instance, could use a Rectangle with a GradientColor or RadialColor for a gradient mask
dynamic - (default false) set to true if mask is changing - also need to updateEffect() on object
boundary - (default null) add a ZIM Boundary() if the mask is changing size - see dynamic
	note: this Boundary should start at 0,0 as a negative value causes problems with the cacheCanvas.  See the last example above.
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

METHODS
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
ALSO See the CreateJS Easel Docs for Filter methods, such as: getBounds()

--*///+69.9745
	zim.AlphaEffect = function(mask, dynamic, boundary, style, group, inherit) {
		var sig = "mask, dynamic, boundary, style, group, inherit";
		var duo; if (duo = zob(zim.AlphaEffect, arguments, sig, this)) return duo;
		z_d("69.9745");
		this.group = group;
		var DS = style===false?{}:zim.getStyle("AlphaEffect", group, inherit);

		// OCT
		if (zot(mask)) mask=DS.mask!=null?DS.mask:null;
		if (zot(dynamic)) dynamic=DS.dynamic!=null?DS.dynamic:null;
		if (zot(boundary)) boundary=DS.boundary!=null?DS.boundary:null;

		this.alphaMask = mask;
		var that = this;
		if (dynamic) this.ticker = zim.Ticker.add(function(){that.alphaMask.updateCache()});

		// VEE
		var oa = remember(mask);	
		this.veeObj = {mask:oa[0]};
		function remember() {return arguments;} 
		mask = zik(mask);		
		if (mask.type == "Bitmap") mask = mask.image;
		else if (mask.cache) mask = boundary?mask.cache(boundary.x,boundary.y,boundary.width,boundary.height).cacheCanvas:mask.cache().cacheCanvas;


		this.createjsAlphaMaskFilter_constructor(mask);
		this.type = "AlphaEffect";		

		this.clone = function(exact) {
			return new zim.AlphaEffect(
				(exact||!zim.isPick(oa[0]))?mask :oa[0],
				dynamic,
				style,
				this.group,
				inherit
			);
		}
	}	
	zim.extend(zim.AlphaEffect, createjs.AlphaMaskFilter, "clone", "createjsAlphaMaskFilter", false);
	//-69.9745

/*--
zim.Pixel = function(obj, amount, amountY, blur, dynamic, blendmode, boundary, expand, amountFactor, blurFactor, style, group, inherit)

Pixel
zim class extends ZIM Bitmap which extends CreateJS Bitmap

DESCRIPTION
Uses raw canvas processing to pixilate a Display Object.
This is not a pixel by pixel process like the ZIM Effects (BlurEffect, GlowEffect, etc.)
So the speed is very fast.
The Display Object is cached, scaled down and scaled back up with image smoothing disabled. 
The scaling proceedure is actually faster than scaling with image smoothing turned on. 
This effect has been available on the canvas all along, ZIM Pixel makes it easier to use.

SEE: 
https://zimjs.com/zim/pixel.html
https://zimjs.com/zim/pixel2.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// pixelate a Circle
const circle = new Pixel(new Circle(200,red)).center().drag();
END EXAMPLE

EXAMPLE
F.color = darker;
function makePixel() {
	return new Pixel(new Circle(40,[pink,blue,purple]),.3)
		.alp(.5)
		.reg(CENTER);
}
new Emitter({
	obj:makePixel,
	force:{min:.5, max:2},
	gravity:0,
	life:3,
	shrink:false,
	layers:BOTTOM,
	animation:{
		props:{rotation:[-360, 360]}, 
		time:{min:1,max:10}, 
		ease:"linear", 
		loop:true
	}
}).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
obj - |ZIM VEE| (default Tile of Circles) the object to pixilate - the original will still exist. 
	in theory, this can be any DisplayObject such as a Circle(), Button(), Container(), Pic(), etc.
amount - |ZIM VEE| (default .5) the amount to pixelate from 0-1.
	the granularity depends on the amountFactor which is also from 0-1.
	at a lower amountFactor, the 0-1 amount will focus on smaller pixilations.
	at a higher amountFactor, the 0-1 amount will focus on bigger pixilations.
	if an amountY is set then this will be the amountX
amountY - |ZIM VEE| (default 0) the amount to pixelate in the vertical. Also see amount.
blur - |ZIM VEE| (default 0) the amount to blur (0-1) the image before pixilating (this is a scaling blur so fast)
	also see blurFactor
	set blurFacter low to concentrate blur on smaller amounts
	set blurFactor high to concentrate blur on larger amounts
dynamic - (default false) set to true if changing the object the original object that is being pixelated 
blendmode - |ZIM VEE| (default null) the blendmode to apply when updating Pixel
boundary - (default obj.getBounds()) the boundary for the caching - use a ZIM Boundary() object, etc.
expand - (default 0) an amount of pixels to expand the boundary by (or contract if negative)
	can be a number for all sides, an array of [left/right, top/bottom] or [left,top,right,bottom]
amountFactor - |ZIM VEE| (default .6) the range (0-1) to concentrate the amount parameter on 
	a lower value will concentrate amount on smaller pixels
	a higher value will concentrate amount on larger pixels
blurFactor - |ZIM VEE| (default .6) the range (0-1) to concentrate the blur parameter on
	a lower value will concentrate blur on smaller amounts
	a higher value will concentrate blur on larger amounts
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
update() - update the Pixel Bitmap if the object changes 
	if dynamic parameter is set to true there is no need to update()
clone(exact) - clone the effect - set exact to true to match the ZIM VEE values exactly on cloning
dispose() - clear any update Ticker and dispose the Bitmap 

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Bitmap methods, such as:
on(), off(), getBounds(), setBounds(), dispatchEvent(), etc.

PROPERTIES
type - holds the class name as a String
amount - get or set the amount to pixelate (also see amountFactor)
amountX - get or set the amountX to pixelate (also see amountFactor)
amountY - get or set the amountY to pixelate (also see amountFactor)
amountFactor - get or set the concentration for the amount (see amount parameter for more info)
blur - get or set the amount to blur (also see blurFactor)
blurFactor - get or set the concentration for the blur (see blur parameter for more info)
veeObj - an object with ZIM VEE original parameters:value allowing the ZIM VEE values to be referenced
	for instance, obj.prop = Pick.choose(obj.veeObj.prop); will reset the the prop to the result of the original ZIM VEE value

ALSO: see ZIM Bitmap for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

--*///+69.9747
	zim.Pixel = function(obj, amount, amountY, blur, dynamic, blendmode, boundary, expand, amountFactor, blurFactor, style, group, inherit) {
		var sig = "obj, amount, amountY, blur, dynamic, blendmode, boundary, expand, amountFactor, blurFactor, style, group, inherit";
		var duo; if (duo = zob(zim.Pixel, arguments, sig, this)) return duo;
		z_d("69.9747");
		
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Pixel", group, inherit);
		
		if (zot(obj)) obj=DS.obj!=null?DS.obj:null;	
		if (zot(amount)) amount=DS.amount!=null?DS.amount:.5;
		if (zot(amountY)) amountY=DS.amountY!=null?DS.amountY:null;					
		var lockAmount = false; 
		if (amountY==null) {
			lockAmount = true;
			amountY = amount;
		}
		if (zot(blur)) blur=DS.blur!=null?DS.blur:0;
		if (zot(dynamic)) dynamic=DS.dynamic!=null?DS.dynamic:false;
		if (zot(blendmode)) blendmode=DS.blendmode!=null?DS.blendmode:null;		
		if (zot(boundary)) boundary=DS.boundary!=null?DS.boundary:new zim.Boundary(obj.getBounds());
		if (zot(expand)) expand=DS.expand!=null?DS.expand:0;		
		if (zot(amountFactor)) amountFactor=DS.amountFactor!=null?DS.amountFactor:.6;
		if (zot(blurFactor)) blurFactor=DS.blurFactor!=null?DS.blurFactor:.6;
				
		var oa = remember(obj, amount, amountY, blur, blendmode, amountFactor, blurFactor);
		this.veeObj = {obj:oa[0], amount:oa[1], amountY:oa[2], blur:oa[3], blendmode:oa[4], amountFactor:oa[5], blurFactor:oa[6]};
		function remember() {return arguments;} 
		obj = zik(obj);
		amount = zik(amount);
		amountY = zik(amountY);
		blur = zik(blur);
		blendmode = zik(blendmode);
		amountFactor = zik(amountFactor);
		blurFactor = zik(blurFactor);		
		
		if (expand) {
			if (Array.isArray(expand)) {
				if (expand.length == 1) boundary.contract(-expand);
				else if (expand.length == 2) boundary.contract(-expand[0], -expand[1]);
				else boundary.contract(-expand[0], -expand[1], -expand[2], -expand[3]);
			} else {
				boundary.contract(-expand);
			}
		}
		var aF = zim.constrain(amountFactor*10,0,10);
		var bF = zim.constrain(blurFactor*10,0,10);
				
		var that = this;
				
		var aX = Math.pow(Math.E,-amount*aF);  
		var aY = Math.pow(Math.E,-amountY*aF);       
		var bL = Math.pow(Math.E,-blur*bF);
				
		if (zot(obj)) obj = new zim.Tile(new zim.Circle(20,[zim.green,zim.blue,zim.yellow,zim.pink,zim.purple]),5,5,5,5);
						
		var canv1 = document.createElement('canvas');
		var ctx1 = canv1.getContext('2d');
		var canv = document.createElement('canvas');
		var ctx = canv.getContext('2d');
		
		var lastBL = bL;
		this.update = function() {
						
			if (!obj.cacheCanvas || bL!=lastBL) {
				obj.cache(boundary.x,boundary.y,boundary.width,boundary.height,bL);
				lastBL = bL;
			}
			else obj.updateCache(blendmode);
		
			var oW = obj.width;
			var oH = obj.height;
			var w = obj.width*aX;
			var h = obj.height*aY;
						
			canv1.width = oW;
			canv1.height = oH;          
			
			canv.width = oW;
			canv.height = oH;   
				
			// ZIM seems to reset these if not done just before operation
			ctx.msImageSmoothingEnabled = false;
			ctx.mozImageSmoothingEnabled = false;
			ctx.webkitImageSmoothingEnabled = false;
			ctx.imageSmoothingEnabled = false;    
				
			// not sure why the visual width and height change sometimes - can't figure it out
			// maybe the scaling relates to power of two?  If anyone knows, let us know.
			ctx1.drawImage(obj.cacheCanvas, 0, 0, w, h);
			ctx.drawImage(canv1, 0, 0, w, h, -expand*obj.scale, -expand*obj.scale, canv.width+expand*2*obj.scaleX, canv.height+expand*2*obj.scaleY);
		}
		this.update();
		
		this.zimBitmap_constructor(canv);
		if (dynamic) {
			this.dynamicTicker = zim.Ticker.add(function() {
				that.update();
			});
		}    
		
		Object.defineProperty(this, "amount", {
			get : function() {
				return amount;
			},
			set : function(value) {
				amount = value;                
				aX = Math.pow(Math.E,-amount*aF);  
				if (lockAmount) {
					aY = Math.pow(Math.E,-amount*aF);
					amountY = amount;
				}
				that.update();
			}
		});		
		
		Object.defineProperty(this, "amountX", {
			get : function() {
				return amount;
			},
			set : function(value) {
				amount = value;     
				lockAmount = false;           
				aX = Math.pow(Math.E,-amount*aF); 
				that.update();
			}
		});		
		
		Object.defineProperty(this, "amountY", {
			get : function() {
				return amountY;
			},
			set : function(value) {
				amountY = value;  
				lockAmount = false;               
				aY = Math.pow(Math.E,-amountY*aF); 
				that.update();
			}
		});	
		
		Object.defineProperty(this, "amountFactor", {
			get : function() {
				return amountFactor;
			},
			set : function(value) {
				amountFactor = value;  
				aF = zim.constrain(amountFactor*10,0,10); 
				aX = Math.pow(Math.E,-amount*aF);  
				aY = Math.pow(Math.E,-amountY*aF); 
				that.update();
			}
		});	
		
		Object.defineProperty(this, "blur", {
			get : function() {
				return blur;
			},
			set : function(value) {
				blur = value;                
				bL = Math.pow(Math.E,-blur*bF); 
				that.update();
			}
		});	
		
		Object.defineProperty(this, "blurFactor", {
			get : function() {
				return blurFactor;
			},
			set : function(value) {
				blurFactor = value;  
				bF = zim.constrain(blurFactor*10,0,10); 
				bL = Math.pow(Math.E,-blur*bF); 
				that.update();
			}
		});	
		
		Object.defineProperty(this, "dynamic", {
			get : function() {
				return dynamic;
			},
			set : function(value) {
				if (dynamic == value) return;
				dynamic = value;
				if (dynamic) {
					if (that.dynamicTicker) that.dynamicTicker = zim.Ticker.add(that.dynamicTicker); 
					else that.dynamicTicker = zim.Ticker.add(that.update);
				} else {
					if (that.dynamicTicker) zim.Ticker.remove(that.dynamicTicker);
				}
			}
		});	
		
		this.dispose = function(){
			if (that.dynamicTicker) zim.Ticker.remove(that.dynamicTicker);
			this.zimBitmap_dispose();
		}
		
		if (style!==false) zim.styleTransforms(this, DS); // global function - would have put on DisplayObject if had access to it
		
		this.clone = function(exact) {			
			return that.cloneProps(new zim.Pixel((exact||!zim.isPick(oa[0]))?obj:oa[0], (exact||!zim.isPick(oa[1]))?amount:oa[1], (exact||!zim.isPick(oa[2]))?amountY:oa[2], (exact||!zim.isPick(oa[3]))?blur:oa[3], dynamic, (exact||!zim.isPick(oa[4]))?blendmode:oa[4], boundary, expand, (exact||!zim.isPick(oa[5]))?amountFactor:oa[5], (exact||!zim.isPick(oa[6]))?blurFactor:oa[6], style, this.group, inherit));
		};
		
	}
	zim.extend(zim.Pixel, zim.Bitmap, ["clone", "dispose"], "zimBitmap", false);	
	//-69.9747	
	
   
/*--
zim.Parallax = function(layers, damp, auto, stage, startPaused, mouseMoveOutside, clamp)

Parallax
zim class

DESCRIPTION
Takes objects as layers and sets properties based on an input,
for instance, each layer could move a different x based on position of mouseX
or each layer could scale a different amount based on scroll of y.
The types of input are mouseX, mouseY, scrollX, scrollY or custom.
The types of properties to change could be x, y, scaleX, scaleY, rotation, alpha, frameNumber, etc.
Parallax allows scale to be a property which scales scaleX and scaleY together.
Parallax allows frame to be a property and calls gotoAndStop() on a Sprite frame.
Parallax really just manages multiple ProportionDamp objects.
For proper parallax, the objects closer move more than the objects farther back.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make assets to move around
// these could be pictures, shapes, containers, etc.
const backing = new Rectangle(800, 200, "yellow").center();
const mid = new Rectangle(400, 200, "green").center().mov(0,20);
const front = new Circle(60, red).center().mov(0,80);

// make Parallax object - here we move with stage mouseX and mouseY
const parallax = new Parallax([
	{obj:backing, prop:"x", propChange:50}, {obj:backing, prop:"y", propChange:40, input:"mouseY"},
	{obj:mid, prop:"x", propChange:100}, {obj:mid, prop:"y", propChange:80, input:"mouseY"},
	{obj:front, prop:"x", propChange:150}, {obj:front, prop:"y", propChange:100, input:"mouseY"}
], .1);

S.update();
END EXAMPLE

EXAMPLE
// interact outside a stage
// this example has a small stage in the middle of the HTML page
// see https://zimjs.com/explore/parallax.html
const parallax = new Parallax({mouseMoveOutside:true, startPaused:true});
const colors = series(black, white);
new Rectangle(W, H).center()
loop(10, (i, total)=>{
	var rect = new Rectangle(W*(1-i/10), H*(1-i/10), colors()).center();
	parallax.addLayer({
		obj:rect,
		input:"mouseX", // default so don't need...
		prop:"x", // default so don't need...
		propChange:40*i,
		inMin:-1000,
		inMax:W+1000
	});
	parallax.addLayer({
		obj:rect,
		input:"mouseY",
		prop:"y",
		split:true,
		propChange:40*i,
		inMin:-500,
		inMax:H+500
	});
});

// starting the parallax paused so this will unpause when mouse is over stage
S.on("stagemousemove", e=>{
	if (S.mouseInBounds) { // now that state is set to move outside...
		// go immediately to the target input - needs to be done for each layer
		var targets = [];
		loop(10, function (i) {
			targets.push(e.stageX, e.stageY)
		});
		parallax.immediate(targets); // pass in the array
		parallax.pause(false); // start the parallax
		e.remove(); // end event
	}
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
layers - (default null) an array of layer objects, the format as below
	Example: to move an obj 200 px in the x as the window scrolls from 100 to 300 px in the y
		[{obj:obj, prop:"x", propChange:200, input:"scrollY", inMin:100, inMax:300, factor:1, integer:false}, etc.]
	obj - the object whose property is being changed
	prop - the property that is being changed
	propChange - how much you want the property to change
	input - (default mouseX) but can also be mouseY, scrollX, scrollY
	inMin - (default 0) minimum input range
	inMax - (default W (for x prop) H (for y prop)) maximum input range
	factor - (default 1) set factor to -1 to change in the opposite direction
	integer - (default false) set to true to round the value to an integer
	split - (default true for mouseX, false for others) centers input so half output is on one side and half on the other
	immediate - (default null) set to a value to set property immediately take that value without damping from current property value
	Example 2: a traditional mouse move parallax for one object
		[{obj:obj, prop:"x", propChange:100}, {obj:obj, prop:"y", propChange:50, input:"mouseY"}, etc.]
	you would probably have more objects to follow
	or you can add these one at a time with the p.addLayer({layer object properties});
damp - (default .1) the damp value with 1 being no damping and 0 being no movement
auto - (default true) uses the specified input
	if auto is set to false, you must make your own new Ticker and use the step(input) method
stage - (default the default frame's stage) the stage - specify this if multiple stages
startPaused - (default false) set to true to start parallax paused - set paused(false) to unpause it
mouseMoveOutside - (default true) set to false to not allow mouse movement outside the stage to affect motion
clamp - (default true) set to false to allow range outside min and max
NOTE: ticker and fps parameters have been removed - see zim.Ticker to set

METHODS
addLayer({layer object properties}) - adds a layer - returns object for chaining
removeLayer(index) - removes a layer based on order added - returns object for chaining
step(input) - used when auto is false to send in custom input data - returns object for chaining
immediate([]) - an array of inputs for each layer used to immediately set the target value with no damping - returns object for chaining
pause(state) - pauses or unpauses the parallax - state defaults to true - see also startPaused - returns object for chaining
dispose() - removes listeners

PROPERTIES
type - holds the class name as a String
damp - allows you to dynamically change the damping
paused - read-only boolean whether the parallax is paused - see pause() and startPaused property
--*///+68
	zim.Parallax = function(layers, damp, auto, stage, startPaused, mouseMoveOutside, clamp) {
		var sig = "layers, damp, auto, stage, startPaused, mouseMoveOutside, clamp";
		var duo; if (duo = zob(zim.Parallax, arguments, sig, this)) return duo;
		z_d("68");
		this.type = "Parallax";

		if (zot(stage)) {
			if (layers && layers[0] && layers[0].obj && layers[0].obj.stage) {
				stage = layers[0].obj.stage;
			} else if (WW.zdf) {
				stage = WW.zdf.stage;
			} else {
				return;
			}
		}
		if (zot(auto)) auto = true;
		else auto = false;
		if (zot(startPaused)) startPaused = false;
		if (zot(mouseMoveOutside)) mouseMoveOutside = false;

		var sW = stage.getBounds().width;
		var sH = stage.getBounds().height;
		stage.mouseMoveOutside = mouseMoveOutside;

		var that = this;
		that.stageEvent = stage.on("stagemousemove", function (e) {
			that.mouseX = e.rawX/zim.scaX;
			that.mouseY = e.rawY/zim.scaY;
		});

		// public properties
		var _damp = (zot(damp)) ? .1 : damp;

		// public methods (do not get hoisted so define early)
		// addLayer works as a public method
		// and also is called from the object in case we add layers via the Parallax object parameters
		// the function prepares ProportionDamp objects for two values
		// and stores them on the layer object
		// and also stores the desired amounts on the layer objects themselves
		// finally, the layer object is added to the myLayers private property
		// the timer then loops through these layers and handles things from there
		// obj, distanceX, distanceY, minX, minY, maxX, maxY, factor, integer, split
		this.addLayer = function(layer) {
			//{obj, prop, propChange, input, inMin, inMax, factor, integer}
			if (zot(layer.obj) || zot(layer.prop) || zot(layer.propChange)) return;
			var obj = {obj:layer.obj, prop:layer.prop};
			obj[obj.prop] = layer.propChange;
			if (zot(layer.input)) layer.input = "mouseX";
			obj.input = layer.input;
			obj.split = zot(layer.split) ? ((layer.input == "mouseX" && auto) ? true : false) : layer.split;

			var inMin = (zot(layer.inMin)) ? 0 : layer.inMin;
			var inMax = (zot(layer.inMax)) ? ((layer.input == "mouseX" || layer.input == "scrollX") ? sW : sH) : layer.inMax;
			var factor = (zot(layer.factor)) ? 1 : layer.factor;
			var integer = (zot(layer.integer)) ? false : layer.integer;

			// baseMin, baseMax, targetMin, targetMax, damp, factor, targetRound, clamp
			obj["p_"+obj.prop] = new zim.ProportionDamp(inMin, inMax, 0, obj[obj.prop], _damp, factor, integer, clamp);
			if (obj.prop == "scale") {
				obj["s_"+obj.prop] = obj.obj.scaleX; // helper to allow scale to be property
			} else if (obj.prop == "frame") {
				obj["s_"+obj.prop] = obj.obj.currentFrame;
			} else {
				obj["s_"+obj.prop] = obj.obj[obj.prop]; // obj.s_x = obj.obj.x for example
			}
			if (!zot(layer.immediate)) obj["p_"+obj.prop].immediate(layer.immediate);
			myLayers.push(obj);
			return that;
		};

		this.removeLayer = function(index) {
			if (zot(index)) return;
			var layer = myLayers[index];
			layer["p_"+layer.prop].dispose();
			myLayers.splice(index,1);
			return that;
		};

		this.immediate = function(array) {
			var o;
			for (var i=0; i<myLayers.length; i++) {
				o = myLayers[i];
				o["p_"+o.prop].immediate(array[i]);
			}
			return that;
		};

		this.dispose = function() {
			stage.off("stagemousemove", that.stageEvent);
			myLayers = null;
			if (auto) zim.Ticker.remove(zimTicker);
			return true;
		};

		// private properties
		// here are any layers that come in from Parallax object parameters
		layers = (zot(layers)) ? [] : layers;

		// we now are going to process these layers with the public addLayer method
		// this will add the processed layers to the private property, myLayers
		var myLayers = [];
		for (var i=0; i<layers.length; i++) {
			this.addLayer(layers[i]);
		}

		if (auto) {
			var zimTicker = zim.Ticker.add(animate, stage);
			if (startPaused) zim.Ticker.remove(zimTicker);
		}

		// loop though our layers and apply the converted proportion damping
		function animate() {
			that.step();
		}

		this.step = function(custom) {
			var o; var input;
			for (var i=0; i<myLayers.length; i++) {
				o = myLayers[i];
				if (zot(custom)) {
					if (o.input == "mouseX") input = that.mouseX;
					else if (o.input == "mouseY") input = that.mouseY;
					else if (o.input == "scrollX") input = zim.scrollX();
					else if (o.input == "scrollY") input = zim.scrollY();
				} else {
					input = custom;
				}
				// damp object at property to start value + converted goal based on input
				if (o.prop == "scale") {
					o.obj.scaleX = o.obj.scaleY = o["s_"+o.prop] + o["p_"+o.prop].convert(input);
				} else if (o.prop == "frame") {
					o.obj.gotoAndStop(o["s_"+o.prop] + o["p_"+o.prop].convert(input));
				} else {
					o.obj[o.prop] = o["s_"+o.prop] + o["p_"+o.prop].convert(input);
					// for x on mouseX we split the destination range in two for a centered parallax
					// if (o.input == "mouseX" && auto) o.obj[o.prop] -= o[o.prop] / 2;
					if (o.split) o.obj[o.prop] -= o[o.prop] / 2;
				}
			}
			return that;
		};

		that.paused = startPaused;
		that.pause = function(state) {
			if (zot(state)) state = true;
			if (that.paused != state) {
				that.paused = state;
				if (zimTicker) {
					if (!state) zimTicker = zim.Ticker.add(zimTicker);
					else zim.Ticker.remove(zimTicker);
				}
			}
			return that;
		}

		Object.defineProperty(that, 'damp', {
			get: function() {
				return _damp;
			},
			set: function(value) {
				_damp = value;
				var o;
				for (var i=0; i<myLayers.length; i++) {
					o = myLayers[i];
					o["p_"+o.prop].damp = _damp;
				}
			}
		});

	};//-68

/*--
zim.Flipper = function(front, back, interactive, time, vertical, flipped, ease, frontPress, backPress, reverse, continuous, style, group, inherit)

Flipper
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Flipper lets you flip between two DisplayObjects.
It has a back and a front that can be any display object.  You press it and it flips.  
The flip() method allows you to programmatically flip it or pass in true or false to flip on or off.  
A flipped property tells you if it is flipped. 
There is a "flip" event for when it starts to flip and a "flipped" event for when it is done flipping.

See: https://zimjs.com/cat/flipper.html
See: https://zimjs.com/elearning/match.html
See: https://codepen.io/zimjs/pen/LYRxprK

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
STYLE = {borderColor:dark, borderWidth:2};
const front = F.makeIcon().sca(2.5);
const back = new Page(front.width, front.height, blue, green, 1);
const label = new Label("ZIM Flipper").center(back);
const card = new Flipper(front, back).center();
END EXAMPLE

EXAMPLE 
const page1 = new Page(400,600,red,purple);    
// Find emoji and paste from here 
// https://emojipedia.org/clockwise-vertical-arrows/
// or use Pizzazz_02 https://zimjs.com/bits/view/icons.html
new Emoji("\ud83d\udd03", 60, true)
	.expand()
	.ble("darken")
	.pos(20,20,RIGHT,TOP,page1)
	.tap(() => {flipper.flip();});
	
const page2 = new Page(400,600,yellow,orange)
new Emoji("\ud83d\udd03", 60, true)
	.expand()
	.ble("darken")
	.pos(20,20,RIGHT,TOP,page2)
	.tap(() => {flipper.flip();});
	
const flipper = new Flipper({
	front:page1, 
	back:page2,
	reverse:true,
	interactive:true,
	frontPress:false, // optional
	backPress:false  // optional
}).center();

// add after card is in place so can set drag boundary
const circ = new Circle().center(page1).drag(page1);

// set drag after card has been flipped to set drag boundary
const rect = new Rectangle().center(page2);

flipper.on("flipped", ()=>{
	rect.drag(page2);
}, null, true); // once
END EXAMPLE 

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
front - (default F.makeIcon().sca(2)) a DisplayObject for the front (this will be centerReg() in Flipper)
back - (default new Page(front.width, front.height, dark)) a DisplayObject for the back (this will be centerReg() in Flipper)
interactive - (default false) set to true if items in front or back need to be interactive
	which will add default mousedown flip events on backing if there is a backing (like on a ZIM Page) or on whole side
	if interactive is true then mouseChildren properties of the sides are automatically set to false
time - (default .2) the time in Seconds for flipping (also see ZIM TIME constant)
vertical - (default false) set to true to make card flip vertically
flipped - (default false) start the card flipped
easeRoot - (default "quad") the type of easing like "back", "elastic", "bounce" but just the root - not the "In" or "Out" part
frontPress - (default true) set to false to make the card NOT flip on mousedown of the front
backPress - (default true) set to false to make the card NOT flip on mousedown of the back
reverse - (default false) set to true to flip in the opposite direction
continuous - (default false) set to true to flip continously in the same direction
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
flip(state, time) - flip the card or specify a true or false for first parameter to either go to flipped or non-flipped
	time defaults to the Flipper() time parameter
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
flipped - true if showing back or false if showing front
front - the front DisplayObject
	will be given an other property to the back DisplayObject
	will be given an flipper property to the flipper object
back - the back DisplayObject
	will be given an other property to the front DisplayObject
	will be given an flipper property to the flipper object

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

ACTIONEVENT
This component is affected by the general ACTIONEVENT setting
The default is "mousedown" - if set to something else the component will act on click (press)

EVENTS
dispatches a "flip" event when the fipper starts the flip
dispatches a "flipped" event when the fipper ends the flip

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+68.5
	zim.Flipper = function(front, back, interactive, time, vertical, flipped, easeRoot, frontPress, backPress, reverse, continuous, style, group, inherit) {
		var sig = "front, back, interactive, time, vertical, flipped, easeRoot, frontPress, backPress, reverse, continuous, style, group, inherit";
		var duo; if (duo = zob(zim.Flipper, arguments, sig, this)) return duo;
		z_d("68.5");

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Flipper", this.group, inherit);

		if (zot(front)) front = DS.front!=null?DS.front:WW.zdf.makeIcon().sca(2);
		if (zot(back)) back = DS.back!=null?DS.back:new zim.Page(front.width, front.height, zim.dark);
		this.front = front;
		this.back = back;
		if (flipped) { // want ES6 decompose
			var temp = front;
			front = back;
			back = temp;
		}
		var w = Math.max(front.width,back.width);
		var h = Math.max(front.height,back.height);

		this.zimContainer_constructor(w,h);
		this.type = "Flipper"; // need to get styles before constructor but must set type after calling constructor

        var timeType = getTIME(time);
		if (zot(time)) time = DS.time!=null?DS.time:timeType=="s"?.2:200;
		if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:false;
		if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:false;
		if (zot(flipped)) flipped = DS.flipped!=null?DS.flipped:false;
		if (zot(easeRoot)) easeRoot = DS.easeRoot!=null?DS.easeRoot:"quad";
		if (zot(frontPress)) frontPress = DS.frontPress!=null?DS.frontPress:true;
		if (zot(backPress)) backPress = DS.backPress!=null?DS.backPress:true;
		if (zot(reverse)) reverse = DS.reverse!=null?DS.reverse:false;
		if (zot(continuous)) continuous = DS.continuous!=null?DS.continuous:false;
		var startFlipped = flipped;

		this.flipped = flipped;
		var that = this;

		front.centerReg(this);
		var obj;
		if ((frontPress && !flipped) || (backPress && flipped)) {
			obj = (interactive && front.backing)?front.backing:front;
			obj.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function() {spin(front,back);});
			obj.cur();
		}
		if ((backPress && !flipped) || (frontPress && flipped)) {
			obj = (interactive && back.backing)?back.backing:back;
			obj.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function() {spin(back,front,-1);});
			obj.cur();
		}
		front.oScale = front.scale;
		back.oScale = back.scale;
		front.flipper = that;
		front.other = back;
		back.flipper = that;
		back.other = front;
		if (!interactive) front.mouseChildren = back.mouseChildren = false;

		this.flip = function(state, time) {
			if (state == that.flipped) return;
			if (!that.flipped) spin(startFlipped?back:front,startFlipped?front:back,1,time);
			else spin(startFlipped?front:back,startFlipped?back:front,-1,time);
		};
		function spin(f, b, d, t) { // current front, back, direction
			if (zot(d)) d = 1;
			d *= reverse?-1:1;
			if (continuous) d = reverse?startFlipped?1:-1:startFlipped?-1:1;
			if (zot(t)) t = time;
			that.flipped = !that.flipped;
			that.dispatchEvent("flip");
			if (t==0) {
				that.removeAllChildren();
				b.scale = b.oScale;
				b.skewX = b.skewY = 0;
				b.centerReg(that);
				that.dispatchEvent("flipped");
				return;
			}
			var props1,props2;
			if (vertical) {
				props1 = {skewX:-90*d, scaleY:f.oScale/2};
				props2 = {skewX:0, scaleY:b.oScale};
				b.ske(90*d,0).sca(b.oScale,b.oScale/2);
			} else {
				props1 = {skewY:-90*d, scaleX:f.oScale/2};
				props2 = {skewY:0, scaleX:b.oScale};
				b.ske(0,90*d).sca(b.oScale/2,b.oScale);
			}
			f.animate({
				props:props1,
				time:time,
				ease:easeRoot+"In",
				call:function() {
					f.removeFrom();
					b.centerReg(that).animate({
						props:props2,
						time:time,
						ease:easeRoot+"Out",
						call:function () {
							that.dispatchEvent("flipped");
						}
					});
				}
			});
		}

		if (style!==false) zim.styleTransforms(this, DS);
			this.clone = function() {
			return that.cloneProps(new zim.Flipper(front.clone(), back.clone(), interactive, time, vertical, flipped, easeRoot, frontPress, backPress, reverse, continuous, style, this.group, inherit));
		};
	};
	zim.extend(zim.Flipper, zim.Container, "clone", "zimContainer");
	//-68.5
	
/*--
zim.Book = function(width, height, pages, startPage, rollUp, radius, backgroundColor, arrows, handleHTML)

Book
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Creates a book with pages that flip like a real book.
The user can flip pages by dragging the pages or using the arrows.
The pages can be turned with code using nextPage() and prevPage() methods
and specific pages can be turned to with the gotoPage() method.

The pages are passed in as an array and can include interactivity.

Book is different than ZIM Pages which have transitions and do not "flip".

See: https://zimjs.com/cat/book.html 
See: https://zimjs.com/five/book.html - for a simple book of images made in five minutes!
See: https://zimjs.com/darklo - an example with SLam DarkLo pottery.

NOTE: Book might need a last page on the right to work properly
if that is the case just add an extra blank page with F.color if needed.

NOTE: Using horizontal pages currently makes the page turning glitchy - will look into it soon - Feb 23, 2023

NOTE: do not use transparent pages or the book workings will be revealed 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// The pages in the book can be fully interactive 
// but here is an example of just loading images into the book
// note - import ZIM and CreateJS in a script file above 
// copy the template from https://zimjs.com/code.html 

const path = "covers/"; // the folder with the images
const assets = ["build.jpg", "castle.jpg", "ganymede.jpg", "lastyear.jpg", "martian.jpg"];
new Frame(FIT, 1024, 768, darker, darker, ready, assets, path);
function ready() {

    // get one picture to find the size of the book 
    const pic = new Pic("build.jpg");   
    new Book(pic.width*2, pic.height, assets).center();

} // end of ready
END EXAMPLE

EXAMPLE
STYLE = {width:W/2, color:series(blue, pink, yellow, green)};
// add anything you want to each of these Pages
const page1 = new Page();
const page2 = new Page();
const page3 = new Page();
const page4 = new Page();
const pages = [page1, page2, page3, page4];
// 0 (default) will show only page 0 at right - like a cover
// 1 will show page 0 and page 1 to start - like an open book
new Book(W, H, pages, 1).addTo(); 
END EXAMPLE

EXAMPLE 
// to remove interactivity remove the stage and frame events 
// these get added in a slight delay, so remove them in a slight delay
timeout(.1, ()=>{
	S.off("stagemousedown", book.stageEvent);
	F.off("keydown", book.keydown);
});

// to add the interactivity again use:
book.stageEvent = S.on("stagemousedown", book.stageEvent);
book.keydown = F.on("keydown", book.keydown);
// (note, the events are reassigned to the properties)
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
width - (default zimDefaultFrame width) the width of the book (including both sides)
height - (default zimDefaultFrame height) the height of the book
pages - an array of DisplayObjects to show as pages
	or pass in an asset string - for instance an image to show an image
	these images can be preloaded with the asset parameter of Frame
	do not use transparent pages or the book workings will be revealed 
startPage - (default 0) 0 will start with a "cover" at right.
	setting this to 1 will start with no "cover" but rather a left page and a right page showing 
	setting to 2 will have a "cover" but initially show page 1 and 2 (not the cover), etc. 
rollUp - (default 1) seconds before showing a corner hint - set to false to not show the corner
radius - (default false) pages will use full page to drag unless a radius is set 
	then the drag corner will be available at the radius distance from the bottom corners 
backgroundColor - (default clear) the backing color of the book (if first or last page is a single page)
arrows - (default true (.2 seconds)) set to true or the number of seconds for arrows to turn page.  See also ZIM TIME constant
handleHTML - (default true) set to false to not automatically remove and add the HTML overlays for Loader, TextArea or Tag objects

METHODS
nextPage(time) - animate the page to the next page at provided time in seconds (default .1).  See also ZIM TIME constant
prevPage(time) - animate the page to the previous page at provided time in seconds (default .1).  See also ZIM TIME constant
gotoPage(num, time) - animate to a page at provided time in seconds (default .1).  See also ZIM TIME constant
changeFrame(frame) - use this method if book is moved to another frame
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
page - get or set the index number of page - will animate at a .1 speed (see gotoPage())
	when asked for this will be the right hand page index
pageNext - get the next page if rollPress has triggered (see rollPress event)
	the next page is the right hand page index
	so if going right, not actually the next page but one more
directPage - get or set the index number of a page - will NOT animate in going to the page
	note: the book must be on the stage (or in a container on the stage) before using this property
direction - get the direction the page is animating to - either LEFT or RIGHT
	or if asked for on roll events will tell LEFT or RIGHT side
lastPage - get the index number of the page that was just animated (available in page event)
	note: pages may skip by 2
pages - read only array of pages - this are the original pages array passed in
	note: at this time, the Book must be remade to add or remove pages
peel - the peel ZIM Shape
backPrev - read only page behind the right side peel roll corner 
backNext - read only page behind the left side peel roll corner
moving - get whether the page is being animated 
handleHTML - get or set whether to automatically handle HTML overlays for Loader, TextArea or Tag objects

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "page" event when the page is turned
dispatches a "pageanimate" event when the page starts to animate to new page
dispatches a "pageturn" event when gotoPage() or page property starts to turn a page (not user dragged page)
dispatches a "pagedone" event when gotoPage() or page property finishes animating its last page (not user dragged page)
dispatches a "rollup" event when corner starts to roll up if rollup is true
dispatches a "rollpress" event when page (or corner when radius) is pressed for rolling up - see page and direction properties
dispatches a "rolldown" event when corner finishes rolling down

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+68.7
	zim.Book = function(width, height, pages, startPage, rollUp, radius, backgroundColor, arrows, handleHTML) {
		var sig = "width, height, pages, startPage, rollUp, radius, backgroundColor, arrows, handleHTML";
		var duo; if (duo = zob(zim.Book, arguments, sig, this)) return duo;
		z_d("68.7");
				
		if (zot(width)) width = WW.zdf?WW.zdf.stage.width:1024;
		if (zot(height)) height = WW.zdf?WW.zdf.stage.height:768;	
						
		this.zimContainer_constructor(width,height);
		this.type = "Book"; 
		
		if (zot(pages)) pages = [];
		if (zot(startPage)) startPage = 0;
		if (zot(rollUp)) rollUp = true;
		if (zot(backgroundColor)) backgroundColor = zim.darker;
		if (zot(arrows)) arrows = true;
		if (zot(handleHTML)) handleHTML = true;
		this.handleHTML = handleHTML;
		
		var timeType = getTIME();
			
		var that = this;					
		if (pages.length==0) return;		
		that.backing = new zim.Rectangle(width-2, height-2, backgroundColor);
		zim.loop(pages, function (p,i) {
			if (typeof p == "string") {
				pages[i] = zim.asset(p);				
			}
			pages[i].zimBookIndex = i;
			preparePage(p);
		});
		
		that.added(init);   
		var stage;    
		var frame; 
		var i;    
		function init(s) {		
			stage = s;	
			frame = stage.frame;							
			var peel = that.peel = new zim.Shape();
						
			var leftPage;
			var pageFore;                
			var pagePrev;         
			
			var rightPage
			var pageBack;
			var pageNext;
			var lastPage;               
			
			that._currentPage = startPage;
			function toPage(num) {
				that._currentPage = num;
				that.removeAllChildren();
				that.backing.loc(1,1,that); 
				that.setMask(that.backing);                   
				peel.addTo(that);
				peel.c().f(zim.black).dr(0,0,0,0);
				that.moving = false;
													
				// backwards                    
				if (pages[num-1]) {
					leftPage = pages[num-1].reg(0,0).rot(0).loc(0,0,that);
				} else if (num > 0) {                        
					lastPage.reg(0,0).rot(0).loc(0,0,that).setMask(null);
				}     

				if (pages[num-2]) {
					pageFore = pages[num-2].reg(width/2,height).loc(0,height,that).rot(-90);
				} else {
					pageFore = new zim.Rectangle(width/2,height,backgroundColor).reg(width/2,height).loc(0,height,that).rot(-90);
				}
				if (pages[num-3]) {
					pagePrev = pages[num-3].rot(0).loc(0,0,that).setMask(peel);  
				} else {
					pagePrev = new zim.Rectangle(width/2,height,backgroundColor).loc(0,0,that).setMask(peel);  
				}     
					
				// forewards
				if (pages[num]) {
					rightPage = pages[num].rot(0).reg(0,0).pos(0,0,zim.RIGHT,zim.TOP,that); 
				} else {
					// need to make a first or last page here
					stage.update();
					return;
				}                                     
				if (pages[num+1]) {
					pageBack = that.backNext = pages[num+1].reg(0,height).loc(width,height,that).rot(90);
				} else {
					pageBack = that.backNext = new zim.Rectangle(width/2,height,backgroundColor).reg(0,height).loc(width,height,that).rot(90);
					lastPage = pageBack;
				}
				if (pages[num+2]) {
					pageNext = that.backPrev = pages[num+2].rot(0).pos(0,0,zim.RIGHT,zim.TOP,that).setMask(peel);  
				} else {
					pageNext = that.backPrev = new zim.Rectangle(width/2,height,backgroundColor).pos(0,0,zim.RIGHT,zim.TOP,that).setMask(peel);  
				}                
				stage.update();                                                       
			} 
			toPage(startPage); 
			
			Object.defineProperty(that, 'directPage', {
				get: function() {
					return that._currentPage;
				},
				set: function(num) {
					offHTML();
					if (startPage%2==1) {
						num = Math.ceil(num/2)*2-1
					} else {
						num = Math.ceil(num/2)*2
					}
					if (num==that.page) return;	
					else if (num>that.page) { 
						pageBack.reg(0,0);   
						pageNext.setMask(null); 						  
					} else { 
						pageFore.reg(0,0);   
						pagePrev.setMask(null);    
					}
					toPage(num); 
					that.moving = false; 
					turningCheck = false; 
					that.currentW = 0;   
					that.currentH = 0; 
					onHTML();
				}
			});
			
			var turningCheck = false;			
						
			that.currentW = 0;
			that.currentH = 0;
			
			that.moving = false;
			
			function setStageEvent() {
				that.stageEvent = stage.on("stagemousedown", function () {
					if (!that.hitTestPoint(frame.mouseX, frame.mouseY)) return;
					var w;
					var h;
																				
					if (that.moving) return;
					
					var point = that.globalToLocal(frame.mouseX, frame.mouseY);
					if (point.x < 0 || point.x > width ||  point.y < 0 || point.y > height) return;
															
					// hit area is circle area around bottom corners but within book
					if (radius > 0) {
						if (zim.dist(point, new zim.Point(0,height)) > radius && zim.dist(point, new zim.Point(width,height)) > radius) return;  
					}                
					
					var side = point.x > width / 2 ? "right" : "left";
					if (side == "right" && that._currentPage >= pages.length-1) return;
					if (side == "left" && that._currentPage <= 1) return;
					
					that.moving = true;
										
					if (side=="right") {						
						rightPage.addTo(that);
						pageBack.addTo(that);
						pageNext.addTo(that);
						that.pageNext = pageNext.zimBookIndex;
					} else {
						leftPage.addTo(that);
						pageFore.addTo(that);
						pagePrev.addTo(that);
						if (that.rolledUp) setPeel(0, 0, "right");
						that.pageNext = pageFore.zimBookIndex;
					}
					offHTML();
					
					that.direction = side;
					that.dispatchEvent("rollpress");
															
					that.moveEvent = stage.on("stagemousemove", function () {
						if (rollUpTimeout) {
							rollUpTimeout.clear();
							rollUpTimeout = null;
						}
						var point = that.globalToLocal(frame.mouseX, frame.mouseY);     
						if (side=="right") {                   
							w = width-point.x; 
						} else {
							w = point.x;
						}     
						h = height-point.y+w; // needed - according to user testing
						that.currentW = w = zim.constrain(w, 0, width/2);
						that.currentH = h = zim.constrain(h, 0, height);
						setPeel(w,h,side); // in a function so can call it to animate page back
					});
				
					that.upEvent = stage.on("stagemouseup", function () {
						stage.off("stagemousemove", that.moveEvent);
						if (turningCheck) return;                    
						rollDown(w,h,side);
					}, null, true); // once
				
				}); // end stagemousedown
			}
			setStageEvent();
			
			
			that.rollUp = function(w,h,side,time,ease) {
				if (that.moving) return;
				if (side == "right" && that._currentPage >= pages.length-1) return;
				if (side == "left" && that._currentPage <= 1) return;
				if (side=="right") {
					rightPage.addTo(that);
					pageBack.addTo(that);
					pageNext.addTo(that);
				} else {
					if (that.rolledUp) setPeel(0, 0, "right");		
					leftPage.addTo(that);
					pageFore.addTo(that);
					pagePrev.addTo(that);
				}
				that.moving = true;
				if (zot(time)) time = timeType=="s"?.5:.5/1000;				
				if (zot(ease)) ease = null;
				that.animate({                        
					props:{currentW:w, currentH:h},
					time:time,
					ease:ease,
					call:function () {                            
						zim.Ticker.remove(ticker);
						that.moving = false;
						setPeel(w, h, side);                                                                                   
					}
				});
				var ticker = zim.Ticker.add(function() {
					setPeel(that.currentW, that.currentH, side);
				});                    
			}   
			if (rollUp !== false) {
				that.rolledUp = true;
				if (rollUp===true) rollUp = timeType=="s"?1:1/1000;
				var rollUpTimeout = zim.timeout(rollUp,function(){
					that.rollUp(60,130,"right",.5);
					that.dispatchEvent("rollup");
				}); 
			}
			that.rollDown = function(w,h,side,time) {
				if (that.moving) return;
				if (side == "right" && that._currentPage >= pages.length-1) return;
				if (side == "left" && that._currentPage <= 1) return;
				rollDown(w,h,side,time);				
			}           
			function rollDown(w,h,side,time) {  
				that.moving = true;
				that.rolledUp = false;
				if (zot(time)) time = timeType=="s"?.7:.7/1000;
				that.animate({                        
					props:{currentW:0, currentH:0},
					time:time,
					call:function () {
						zim.Ticker.remove(ticker);                            
						setPeel(0, 0, side);
						that.moving = false;
						onHTML();
						that.dispatchEvent("rolldown");
					}
				});
				var ticker = zim.Ticker.add(function() {
					setPeel(that.currentW, that.currentH, side);
				});				
			}                
							
			function setPeel(w, h, side) {   
				var a;
				if (side=="right") {                 
					peel
						.c()
						.mt(width, height)
						.lt(width-w, height)
						.lt(width, height-h)
						.cp();                
					a = Math.atan2(w,h);
					pageBack                            
						.loc(width-(w+w*Math.cos(2*a)), height-w*Math.sin(2*a))
						.rot(a*2*zim.DEG);                
					if (!turningCheck && w >= width/2 && h >= height) nextPage();
				} else {                        
					peel
						.c()
						.mt(0, height)
						.lt(w, height)
						.lt(0, height-h)
						.cp();                
					a = Math.atan2(w,h);
					pageFore
						.loc(w+w*Math.cos(2*a), height-w*Math.sin(2*a))
						.rot(-a*2*zim.DEG);                
					if (!turningCheck && w >= width/2 && h >= height) prevPage();
				}                                    
				stage.update()
			}
			
			function nextPage() {
				offHTML();
				turningCheck = true;
				that.moving = true;
				if (that.moveEvent) stage.off("stagemousemove", that.moveEvent);
				if (that.upEvent) stage.off("stagemouseup", that.upEvent);
				that.currentW = 0;
				that.currentH = 0;
				that.lastPage = zim.constrain(that._currentPage);
				that.direction = "right";	
				that.pageNext = pageNext.zimBookIndex;
				that.dispatchEvent("pageanimate");				
				that.animate({
					ease:"quadOut",
					props:{currentW:width/2},
					time:.3,
					timeUnit:"s",
					call:function () {
						zim.Ticker.remove(ticker);   
						pageBack.reg(0,0);   
						pageNext.setMask(null); 
						toPage(that._currentPage+2); 
						that.moving = false; 
						turningCheck = false; 
						that.currentW = 0;   
						that.currentH = 0; 
						onHTML();   
						that.dispatchEvent("page");
					}
				});
				var ticker = zim.Ticker.add(function() {
					peel
						.c()
						.mt(width, height)
						.lt(width/2, height)
						.lt(width-that.currentW, 0)
						.lt(width, 0)
						.cp();       
				});                    
				pageBack.reg(width/2,height).loc(width/2, height, that).animate({
					props:{rotation:0}, time:.3, ease:"quadOut",timeUnit:"s"
				});
			}
	
			function prevPage() {	
				offHTML();						
				turningCheck = true;
				that.moving = true;
				if (that.moveEvent) stage.off("stagemousemove", that.moveEvent);
				if (that.upEvent) stage.off("stagemouseup", that.upEvent);
				that.currentW = 0;
				that.currentH = 0;
				that.lastPage = zim.constrain(that._currentPage);
				that.direction = "left";
				that.pageNext = pageFore.zimBookIndex;
				that.dispatchEvent("pageanimate");
				that.animate({
					ease:"quadOut",
					props:{currentW:width/2},
					time:.3,
					timeUnit:"s",
					call:function () {
						zim.Ticker.remove(ticker);   
						pageFore.reg(0,0);   
						pagePrev.setMask(null); 
						toPage(that._currentPage-2); 
						that.moving = false;   
						turningCheck = false;   
						that.currentW = 0;   
						that.currentH = 0;   
						onHTML();
						that.dispatchEvent("page");            
					}
				});
				var ticker = zim.Ticker.add(function() {                        
					peel
						.c()
						.mt(0, height)
						.lt(width/2, height)
						.lt(that.currentW, 0)
						.lt(0, 0)
						.cp();        
				});
				pageFore.reg(0,height).loc(width/2, height, that).animate({
					props:{rotation:0}, 
					time:.3, 
					timeUnit:"s",
					ease:"quadOut"
				});
			}                
					
			if (arrows) {
				if (arrows===true) arrows = .2;
				that.keydown = frame.on("keydown", function (e) {
					if (e.keyCode==39) that.nextPage(arrows);
					else if (e.keyCode==37) that.prevPage(arrows);
				});
			}		
			
			that.changeFrame = function(f) {
				if (that.stageEvent) stage.off("stagemousedown", that.stageEvent);
				if (that.moveEvent) stage.off("stagemousemove", that.moveEvent);
				if (that.upEvent) stage.off("stagemouseup", that.upEvent);
				frame = f;
				stage = f.stage;
				setStageEvent();
				return that;
			}
			
			// that.page = startPage;
			onHTML();
		
		} // end init  	 
		
		that.nextPage = function(speed) {
			if (zot(that.rollUp)) {setTimeout(function () {that.nextPage(speed);}, 10); return that;}
			if (that.moving) return;                    
			that.rollUp(width/2+.1, height+.1, "right", speed, "quadIn");   
		}
		that.prevPage = function(speed) {
			if (zot(that.rollUp)) {setTimeout(function () {that.prevPage(speed);}, 10); return that;}
			if (that.moving) return;			
			that.rollUp(width/2+.1, height+.1, "left", speed, "quadIn"); 
		}		
		that.gotoPage = function(num, speed) {
			if (zot(that.rollUp)) {setTimeout(function () {that.gotoPage(num, speed);}, 10); return that;}
			num = zim.constrain(num, 0, that.pages.length-1);
			if (zot(speed)) speed = timeType=="s"?.3:300;
			var t = speed + (timeType=="s"?.35:350);
			that.pageInterval = zim.interval(t, function (obj) {
				var imm = false;
				if (that._currentPage < num) that.nextPage(speed);
				else if (that._currentPage > num) that.prevPage(speed);
				else imm = true;
				that.dispatchEvent("pageturn");
				if (obj.count == obj.total-1) {
					if (imm) {
						onHTML();	
						that.dispatchEvent("pagedone");
					} else {
						zim.timeout(t, function () { 
							onHTML();							
							that.dispatchEvent("pagedone");
						});		
					}									
				}
			}, Math.floor(Math.abs(num-that._currentPage)/2+1), true);
		}
		
		function preparePage(p) {
			if (!p.addChild) return; // might be just a string representing an image
			// record any TextArea, Loader or Tags:
			p.zimHTMLList = new zim.Dictionary();
			if (that.handleHTML) removeHTML(p);
		}
		
		function addHTML(p) {	
			if (zot(p) || !p.addChild) return;
			p.removedHTML = false;
			for (i=0; i<p.zimHTMLList.length; i++) {
				p.addChildAt(p.zimHTMLList.values[i].obj, p.zimHTMLList.values[i].depth);				
			}		
		}

		function removeHTML(p) {
			if (p.removedHTML || !p.addChild) return;
			p.removedHTML = true;
			p.zimHTMLList.clear(); // re-add just in case depth changes or tag is removed
			var ch,i;
			for (i=0; i<p.numChildren; i++) { // record depths first
				ch = p.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					var obj = {obj:ch, depth:p.getChildIndex(ch)};
					p.zimHTMLList.add(ch, obj);
				}
			}
			for (i=p.numChildren-1; i>=0; i--) { // remove textareas and loaders second
				ch = p.getChildAt(i);
				if (ch.type == "TextArea" || ch.type == "Loader" || ch.type == "Tag") {
					p.removeChild(ch);
				}
			}
		}
		
		function onHTML() {
			if (!that.handleHTML) return;
			if (that.pages[that.page]) addHTML(that.pages[that.page]); 
			if (that.pages[that.page-1]) addHTML(that.pages[that.page-1]);
		}
		function offHTML() {
			if (!that.handleHTML) return;
			if (that.pages[that.page]) removeHTML(that.pages[that.page]); 
			if (that.pages[that.page-1]) removeHTML(that.pages[that.page-1]);
		}		
		
		Object.defineProperty(that, 'page', {
			get: function() {
				return that._currentPage;
			},
			set: function(num) {
				that.gotoPage(num, timeType=="s"?.1:100);
			}
		});
		
		Object.defineProperty(that, 'pages', {
			get: function() {
				return pages;
			},
			set: function() {
				if (zon) zogy("Book() - pages is read only");
			}
		});

		this.dispose = function(a,b,disposing) {
			if (that.stageEvent) stage.off("stagemousedown", that.stageEvent);
			if (that.moveEvent) stage.off("stagemousemove", that.moveEvent);
			if (that.upEvent) stage.off("stagemouseup", that.upEvent);
			if (that.keydown) frame.off("keydown", that.keydown);
			that.removeFrom();
			if (!disposing) this.zimContainer_dispose(true);
			return true;
		};                
	}      

zim.extend(zim.Book, zim.Container, ["clone", "dispose"], "zimContainer");
//-68.7

/*--
zim.Scrambler = function(tile, keys, keyProperty, scramble, time, wait, num, shadowColor, shadowBlur, swap, swapLock, style, group, inherit)

Scrambler
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Takes a ZIM Tile and scrambles its items allowing the items to be dragged to unscramble.
Works on horizontal, vertical or grid versions of Tile (as in one column, one row or multiples)
Dispatches a "complete" event when done.
Can pass in an optional keys array that must match key properties
or an existing property of type keyType.
This allows, for instance, matching duplicate letters or colors.

See: https://zimjs.com/cat/scrambler.html

NOTE: if using Adobe Animate then use the latest ZIM version of CreateJS - see https://zimjs.com/cdn/

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// tile a rectangle with a color series, a dark border of width 3
// 4 columns and 1 row with a spacingH of 10
const tile = new Tile(new Rectangle(100,100,series(orange, green, blue, pink)), 4, 1, 10);

// add the tile to the Scrambler - by default it scrambles
const scrambler = new Scrambler(tile).center();

// when the tile is unscrambled it calls the complete function
scrambler.on("complete", ()=>{
	zogg("Yay!");
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
tile - an ZIM Tile
keys (default null) - An optional array of values that the order of the tile must match
	Without keys, Scrambler will match the exact starting order
	but sometimes there are multiple answers like two letter Ts or three color blues
	To solve this issue, a keys array can be provided
	Each tile should be given a key property to match the desired keys array
	For instance if keys = ["big", "small", "big", "small", "medium"]
	then each tile item should be given a item.key = "big", etc.
	The "complete" event will be dispatched when the tile key properties are in the order of the keys
	Also see keyProperty below for an alternative.
keyProperty (default null) - An optional tile item property to use to match the keys array (must have a keys array)
	For example, if keys = ["L", "O", "V", "E", "L", "Y"]
	There are two "L" items so matching the starting order is not necessary
	as the L items could be swapped and still be a correct answer
	If the items are ZIM Label objects (use the Label backing property to make tiles)
	then set the keyProperty to "text" and this will be used to match the keys array
	Another example - if keys = [blue, green, blue, red]
	then set keysArray to "color" if a set of Rectangles are tiled with these colors
scramble (default true) - set to false to not scramble the tile - see also the scramble() method
time (default null) - if scramble is set, this is the time in seconds to animate the scramble - see also ZIM TIME constant
wait (default null) - if scramble is set, this is the time in seconds to wait to scramble - see also ZIM TIME constant
num (default 1) - the number of times it will scramble within the time given if a time is given otherwise always just one
	this is good to scramble a small number of things - for instance set to 3 to visibly scramble 4 things...
shadowColor - (default rgba(0,0,0,.3)) set to -1 for no shadow
shadowBlur - (default 5) how blurred the shadow is if the shadow is set
swap - (default false) set to true to not automatically shift tiles and swap the dragged tile with the tile that is dropped on
swapLock - (default false) set to true to lock tiles that are in the right spot - will set swap to true
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
scramble(time, wait, num) - scramble the tile - this is done by default when making the Scrambler
 	but the default can be set to false and scramble called manually - or to rescramble, etc.
	time and wait default to 0 and are the seconds to animate and wait to animate - also see ZIM TIME constant
	num is how many times to scramble within the time - set to 3 for instance to scramble a small number of items
	note that the tiles cannot be dragged from when called to when done scrambling
	returns object for chaining
solve(time, wait, disable) - solve the tile - so arrange the tile in the start order
	time and wait default to 0 and are the seconds to animate and wait to animate - also see ZIM TIME constant
	disable defaults to true and will stop the tile items from being draggable after solved
	this uses a noMouse() so mouse() can be called on each tile item at a later point if desired
test() - returns true if tiles match starting orientation or keys if keys provided
testItem(item, index) - test a specific item in the Scrambler to see if correct - index is optional otherwise it will calculate it
	note - there is a "complete" event and complete property so usually there is no need to test an item
update() - if the Scrambler is moved in its container, call update() to reset drag boundary
clone() - makes a copy with properties such as x, y, etc. also copied
dispose() - removes from parent, removes event listeners - must still set outside references to null for garbage collection

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
tile - reference to the ZIM Tile used
complete - get whether the Scrambler is complete - also see the "complete" event
starts - an array of start indexes (will be [0,1,2,3...])
order - get or set an array of the current index order (will be the scrambled order - eg. [3,2,0,1...])

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "complete" event when the tile changes to the same order as the start order
dispatches a "scrambled" event when the tile is finished scrambling

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+67.35
	zim.Scrambler = function(tile, keys, keyProperty, scramble, time, wait, num, shadowColor, shadowBlur, swap, swapLock, style, group, inherit) {
		var sig = "tile, keys, keyProperty, scramble, time, wait, num, shadowColor, shadowBlur, swap, swapLock, style, group, inherit";
		var duo; if (duo = zob(zim.Scrambler, arguments, sig, this)) return duo;
		z_d("67.35");

		this.zimContainer_constructor(null,null,null,null,false);
		this.type = "Scrambler";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(tile)) tile = DS.tile!=null?DS.tile:tile;
		if (zot(keys)) keys = DS.keys!=null?DS.keys:null;
		if (zot(keyProperty)) keyProperty = DS.keyProperty!=null?DS.keyProperty:null;
		if (zot(scramble)) scramble = DS.scramble!=null?DS.scramble:true;
		if (zot(time)) time = DS.time!=null?DS.time:0;
		if (zot(wait)) wait = DS.wait!=null?DS.wait:0;
		if (zot(num)) num = DS.num!=null?DS.num:1;
		if (zot(shadowColor)) shadowColor=DS.shadowColor!=null?DS.shadowColor:"rgba(0,0,0,.3)";
		if (zot(shadowBlur)) shadowBlur=DS.shadowBlur!=null?DS.shadowBlur:5;
		if (zot(swap)) swap=DS.swap!=null?DS.swap:false;
		if (zot(swapLock)) swapLock=DS.swapLock!=null?DS.swapLock:false;
		if (swapLock) swap = true;

		if (zot(tile)) tile = new zim.Tile(new zim.Rectangle(100,100,zim.series(zim.silver,zim.tin,zim.grey,zim.dark,zim.darker)),5,1,5);
		tile.addTo(this);
		var that = this;
		that.tile = tile;
		that.complete = true;
		var timeType = getTIME(time);
		getTIME(wait);
		var tileWidth = (tile.width+tile.spacingH)/tile.cols;
		var tileHeight = (tile.height+tile.spacingV)/tile.rows;
		
		var frame = WW.zdf;        		
		var scramblerID = zim.makeID(null,10);

		var startX, startY;
		var lastTile;
		var dCheck = false;
		tile.pointers = {};
		tile.on("mousedown", function (e) {		
			if (dCheck) return;	
			dCheck = true;	
			offOthers(e.target);
			that.myDownCheck = true;
			lastTile = e.target;
			var id = "id"+Math.abs(e.pointerID+1);
			tile.pointers[id] = true;
			startX = e.target.x;
			startY = e.target.y;
			if (swapLock) {
				var current = tile.current;
				if (that.testItem(e.target, current.indexOf(e.target))) {
					e.target.noMouse();
					e.target.noDrag();
					e.target.locked = true;
					that.myDownCheck = dCheck = false;
					onOthers();
					return;
				}
			}
			
			if (shadowColor != -1 && shadowBlur > 0) {
				var shad = new createjs.Shadow(shadowColor, 3, 3, shadowBlur);
				if (e.target.backing) e.target.backing.shadow = shad;
				else e.target.shadow = shad;
			}	
			
			// createjs does not do pressup or turn off pressmove when up over iframe 
			// so use mouseupplusonly 
			// also need normal mouseup with pointer ids to stop multitouch
			if (frame) {
				if (!that.scrmu) that.scrmu = frame.on("mouseupplusonly", function(e) {  
					if (that.myDownCheck) { 
						that.myDownCheck = false; 
						var pp = zim.loop(tile.pointers, function(p,v) {return v;});
						if (!pp) tile.pointers["id0"] = true;
						e = {target:lastTile, pointerID:e.pointerID?pp:-1};
						doUp(e);
					}					
				});	
			}
			if (that.upEvent) tile.off("pressup", that.upEvent);
			that.upEvent = tile.on("pressup", function(e) {
				var id = "id"+Math.abs(e.pointerID+1);
				if (!tile.pointers[id]) return;
				// that.myDownCheck = dCheck = false;				
				doUp(e);
			});
			

			function doUp(e) {
				var id = "id"+Math.abs(e.pointerID+1);
				if (!tile.pointers[id]) return;
				delete tile.pointers[id];
				var good = true;				
				// dCheck = false;
				// onOthers();
				if (that.moveEvent) tile.off("pressmove", that.moveEvent);
				if (swapLock) {
					var cbg = e.target.boundsToGlobal();
					var index = tile.hitTestGrid(tile.width, tile.height, tile.cols, tile.rows, cbg.x+cbg.width/2, cbg.y+cbg.height/2, null, null, tile.spacingH, tile.spacingV, null, "open");
					if (zot(index)) good = false;
					else {
						var currentTile = current[index[0]];
						if (e.target == currentTile) good = false;
						else good = !that.testItem(currentTile, index[0]);
					}
				}
				if (swap && good) doMove(e);   
											
				// e.target.mouseEnabled = false;
				e.target.dragPaused = true;
				e.target.animate({
					props:{x:startX, y:startY},
					time:.1,
					id:scramblerID,
					timeUnit:"seconds",
					pauseOnBlur:false,
					call:done,
					params:e
				});
			}	
			function done(e) {
				if (!that.complete && that.test()) {
					that.complete = true;
					that.dispatchEvent("complete");
				}
				if (shadowColor != -1 && shadowBlur > 0) {
					if (e.target.backing) e.target.backing.shadow = null;
					else e.target.shadow = null;
				}

				that.mySownCheck = dCheck = false;
				onOthers();
				// e.target.mouseEnabled = true;
				e.target.dragPaused = false;				
			}    
			if (!swap) {
				if (that.moveEvent) tile.off("pressmove", that.moveEvent);
				that.moveEvent = tile.on("pressmove", function (e) {
					// get current and current row and col
					doMove(e);
				});
			}
		});

		function doMove(e) {
			var current = e.target;
			current.stopAnimate();
			var cbg = current.boundsToGlobal();
			var cdata = tile.hitTestGrid(tile.width, tile.height, tile.cols, tile.rows, cbg.x+cbg.width/2, cbg.y+cbg.height/2, null, null, tile.spacingH, tile.spacingV, null, "open");
			if (zot(cdata)) return;
			
			zim.loop(tile, function (t) {
				// t.paused===false means it is animating
				// is a bug in animate where if animate is interupted it may be left in a paused false state
				// stopAnimate will reset it
				if (t==current || t.paused===false) return; // continue loop

				var tbg = t.boundsToGlobal();				
			
				var tdata = tile.hitTestGrid(tile.width, tile.height, tile.cols, tile.rows, tbg.x+tbg.width/2, tbg.y+tbg.height/2, null, null, tile.spacingH, tile.spacingV, null, "open");
				if (zot(tdata)) return;				

				var temp;
				// current row == tile row 
				if (cdata[2]==tdata[2] && ((t.x>=current.x && t.x<=current.x+tileWidth/2) || (t.x<=current.x && t.x>=current.x-tileWidth/2))) {
					temp = t.x;
					// t.mouseEnabled = false;
					t.top().ord(-1);
					t.animate({
						props:{x:startX},
						time:.2,
						id:scramblerID,
						timeUnit:"seconds",
						call:function () {
							// t.mouseEnabled = true;
							if (!dCheck) t.dragPaused = false;
							if (swap && !that.complete && that.test()) {
								that.complete = true;
								that.dispatchEvent("complete");
							}
						}
					});
					startX = temp;
				}
				// current column == tile column
				if (cdata[1]==tdata[1] && ((t.y>=current.y && t.y<=current.y+tileHeight/2) || (t.y<=current.y && t.y>=current.y-tileHeight/2))) {
					temp = t.y;
					// t.mouseEnabled = false;
					t.top().ord(-1);					
					t.animate({
						props:{y:startY},
						time:.201,
						override:false,
						id:scramblerID,
						timeUnit:"seconds",
						call:function () {
							// t.mouseEnabled = true;
							if (!dCheck) t.dragPaused = false;
							if (swap && !that.complete && that.test()) {
								that.complete = true;
								that.dispatchEvent("complete");
							}
						}
					});
					startY = temp;
				}
			}, true);			
		}
		
		function offOthers(target) {
			tile.loop(function (t) {
				// if (t!=target) t.noMouse();
				if (t!=target) t.dragPaused = true;
			});
		}
		function onOthers() {
			tile.loop(function (t) {
				if (!t.locked && !t.animating) t.dragPaused = false;
				// if (!t.locked) t.mouse();
			});
		}

		this.test = function () {
			var current = tile.current;
			return zim.loop(current, function (item, i) {
				if (zot(item)) return false;
				if (!that.testItem(item, i)) return false;
			});
		};

		this.testItem = function(item, i) {
			if (zot(item)) return;
			if (zot(i)) i = tile.current.indexOf(item);
			if (keys) {
				var key = zot(keyProperty)?item.key:item[keyProperty];
				if (key != keys[i]) return false;
			} else {
				if (tile.items[i] != item) return false;
			}
			return true;
		};

		this.update = function() {
			tile.noDrag();
			tile.drag({boundary:tile, singleTouch:true});
			return this;
		}

		this.starts = [];
		var order = [];
		zim.loop(tile.rows*tile.cols, function (i) {
			order.push(i);
		});
		var startOrder = order.slice();

		tile.loop(function (t) {
			t.mouseChildren = false; // added ZIM NFT 00 patch
			that.starts.push({x:t.x, y:t.y});
		});

		this.inactive = false;
		this.scramble = function(time, wait, num) {

			that.myDownCheck = false;

			if (zot(wait)) wait = 0;
			if (zot(time)) time = 0;
			if (zot(num) || time==0) num = 1;

			offScrambler();
			zim.timeout(wait, function () {
				if (time>0) zim.interval(time/num, doScramble, num, true);
				else doScramble();
			});
			setTimeout(function () {
				that.complete = false;
				tile.loop(function (t) {
					t.mouse();
					t.locked = false;
				});
				that.mouse();
				tile.drag({boundary:tile, singleTouch:true});	
				dCheck = false;			
			}, timeType=="s"?(wait+time)*1000:wait+time);
			function doScramble() {
				var answer = true;
				var times = 0;
				// if rand order does not produce an answer then we are good!
				while (answer && times<50) {
					times++;
					zim.shuffle(order);
					answer = zim.loop(order, function (o, i) {
						var item = tile.getChildAt(o);
						if (keys) {
							var key = zot(keyProperty)?item.key:item[keyProperty];
							if (key != keys[i]) return false;
						} else {
							if (tile.items[i] != item) return false;
						}
					});
				}
				// scramble location (not tile.remake()) to order
				moveTiles(order, time/num);
				zim.timeout(time, function () {
					that.dispatchEvent("scrambled");
				})
			}
			return that;
		};

		if (scramble) {
			that.scramble(time, wait, num);
		} else {
			that.added(function () {
				tile.drag({boundary:tile, singleTouch:true});
			});
		}

		function offScrambler() {
			if (that.upEvent) tile.off("pressup", that.upEvent);
			if (that.moveEvent) tile.off("pressmove", that.moveEvent);

			tile.noDrag();
			if (wait+time>0) {
				that.noMouse();
			}
		}

		function moveTiles(order, time, wait) {

			zim.stopAnimate(scramblerID);

			// not children but items - which never change from start
			zim.loop(tile.items, function (item, i, t) {
				var start = that.starts[order[i]];
				if (time) {
					item.animate({
						props:{x:start.x, y:start.y},
						time:time,
						ease:wait?"quadInOut":"quadOut",
						wait:wait,
						timeUnit:"seconds",
						id:scramblerID
					});
				} else {
					item.loc(start);
					if (that.stage) {
						item.drag({boundary:tile, singleTouch:true});
					} else {
						if (i==t-1) {
							that.added(function () {
								tile.drag({boundary:tile, singleTouch:true});
							});
						}
					}
				}
			});
		}

		this.solve = function(time, wait, disable) {
			if (zot(disable)) disable = true;
			if (zot(wait)) wait = 0;
			if (zot(time)) time = 0;
			if (wait+time==0 && disable) that.noMouse();

			setTimeout(function () {
				order = startOrder.slice();
				offScrambler();
				moveTiles(order, time, 0, disable);
			}, timeType=="s"?wait*1000:wait);

			if (!disable) {
				setTimeout(function () {
					that.mouse();
					tile.drag({boundary:tile, singleTouch:true});
				}, timeType=="s"?(wait+time)*1000:wait+time);
			}
		};

		this._enabled = true;
		Object.defineProperty(that, 'enabled', {
			get: function() {
				return that._enabled;
			},
			set: function(value) {
				zenable(that, value);
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		});
		
		Object.defineProperty(that, 'order', {
			get: function() {
				var newOrder = [];
				var answer = zim.loop(tile.current, function (t) {
					if (!t) return false;
					newOrder.push(t.tileNum);
				});
				if (!answer || newOrder.length != order.length) return order;
				order = newOrder;
				return order;
			},
			set: function(value) {	
				var newItems = [];
				zim.loop(value, function (i) {
					newItems.push(tile.items[i]);
				})
				tile.remake(newItems);
				if (tile.stage) tile.stage.update()			
			}
		});	

		this.dispose = function(a,b,disposing) {
			if (that.scrmu) frame.off("mouseupplus", that.scrmu);	
			tile.removeAllEventListeners();
			if (!disposing) {
				that.zimContainer_dispose(true);
				if (that.stage) that.stage.update();
			}
			return true;
		};

		if (style!==false) zim.styleTransforms(this, DS);
		this.clone = function() {
			return that.cloneProps(new zim.Scrambler(tile.clone(), keys, keyProperty, scramble, time, wait, num, shadowColor, shadowBlur, swap, swapLock, style, that.group, inherit));
		};
	};
	zim.extend(zim.Scrambler, zim.Container, ["clone", "dispose"], "zimContainer", false);
//-67.35

/*--
zim.Scroller = function(backing, speed, direction, horizontal, gapFix, stage, container, backing2, style, group, inherit)

Scroller
zim class extends a createjs.EventDispatcher

DESCRIPTION
Scroller animates a backing either horizontally or vertically (not both).
The Scroller object will create a clone of the backing
and animate and swap the backgrounds when needed.

NOTE: A scroller can be added to a Accelerator object
this will allow the percentSpeed to be synched with other Scroller and Dynamo objects
See https://zimjs.com/zide/
See https://zimjs.com/explore/sidescroller.html (with keys)

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const one = new Rectangle(1200, 400, red);
F.makeCircles().center(one);
S.addChild(one);

const scroller = new Scroller(one);

S.update();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
backing - an object to animate (make start and end edges match to be seemless)
speed - (default 1) how fast in pixels per second the animation is going
direction - (default 1) set to -1 for left or down
horizontal - (default true) set to false to animate vertically
	you can adjust the speed and direction properties dynamically
	you cannot adjust the backings and horizontal dynamically
	to change your animation, dispose() of the Scroller object and make a new one
	disposing just removes the ticker - you have to remove the backings
	NOTE: the gapFix and ticker parameters have been removed - see zim.Ticker
gapFix - (default 0) if a thin line appears when changing speed - try setting to 1 or 2
stage - (default background.stage) if the background is not on the stage then need to pass the stage it will be on
container - (default stage) what bounds are used for wrapping the background

METHODS
pause(state, time) - state defaults to true and pauses the scroller (sets speed to 0)
	set state to false to unpause the scroller (sets speed to speed before pausing)
	set the time (default 0) to the seconds to take while slowing the scroller to 0 speed (also see ZIM TIME constant)
dispose() - get rid of the event listeners - you need to remove the backings (see backing properties)

PROPERTIES
type - holds the class name as a String
backing1 - the original backing passed in
backing2 - the cloned backing made from the original backing
speed - how fast the animation is going in pixels per frame
baseSpeed - the scroller speed when it was first made (or can override)
	used to determine percentage speed for percentSpeed property
percentSpeed - get or set the percentage of the baseSpeed - eg. 100 is at the baseSpeed
	this allows you to animate multiple scrollers relative to one another
	See ScrollerManager class
percentComplete - get or set the percentage the scroller has moved 
	the percentage is the distance/width*100 for horizontal or distance/height*100 for vertical
direction - 0 for no direction, either left (-1) or right (1) if horizontal or up (-1) or down (1) if not horizontal
paused - read only - true if paused and false if not - must be set with pause() method

EVENTS
Dispatches a "pause" event when paused is complete (sometimes a delay to slow to pause)
--*///+69
	zim.Scroller = function(backing, speed, direction, horizontal, gapFix, stage, container, backing2, style, group, inherit) {
		var sig = "backing, speed, direction, horizontal, gapFix, stage, container, backing2, style, group, inherit";
		var duo; if (duo = zob(zim.Scroller, arguments, sig, this)) return duo;

		z_d("69");
		this.cjsEventDispatcher_constructor();
		this.type = "Scroller";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(backing)) backing = DS.backing!=null?DS.backing:null;
		if (zot(backing)) return;

		var b1 = this.backing1 = backing;
		if (zot(b1) || !b1.getBounds) return;
		var b2;
		if (zot(backing2)) {
			b2 = this.backing2 = backing.clone(true);
		} else {
			b2 = backing2;
		}		
		if (zot(horizontal)) horizontal = DS.horizontal!=null?DS.horizontal:true;
		if (zot(gapFix)) gapFix = DS.gapFix!=null?DS.gapFix:0;
		if (zot(container)) container = DS.container!=null?DS.container:null;
		if (zot(stage)) stage = DS.stage!=null?DS.stage:null;

		var that = this;

		// here are the public properties that can be changed
		if (zot(speed)) speed = DS.speed!=null?DS.speed:1;
		this.speed = speed;
		var lastSpeed = this.baseSpeed = this.speed;
		if (zot(direction)) direction = DS.direction!=null?DS.direction:1;
		this.direction = direction;
		var scale = horizontal ? b1.scaleX : b1.scaleY;

		if (b1.type == "AC") {
			zogy("ZIM Scroller(): please provide Pic() with dimensions for backing objects");
			return;
		}
		if (!b1.getBounds()) {
			zogy("ZIM Scroller(): please setBounds() on backing objects");
			return;
		}
		if (!stage && !b1.stage) {
			zogy("ZIM Scroller(): please pass in stage parameter or add backing objects to stage to start");
			return;
		}
		if (!b1.parent) {
			zogy("ZIM Scroller(): please add object to container or stage before adding to Scroller");
			return;
		}
		b1.parent.addChildAt(b2, b1.parent.getChildIndex(b1));
		stage = stage||b1.stage;
		if (zot(container)) container = stage;
		if (!container.getBounds()) {zogy("zim display - Scroller(): please setBounds() on container or stage if no container"); return;}

		var w = b1.getBounds().width*scale-gapFix;
		var h = b1.getBounds().height*scale-gapFix;

		var viewW;
		var viewH;

		if (horizontal) {
			b2.x = w;
		} else {
			b2.y = h;
		}

		var pausing = false; // for in the act of pausing
		var zimTicker = zim.Ticker.add(animate, stage);

		function animate() {
			if (!viewW) {
				viewW = container.getBounds().width;
				viewH = container.getBounds().height;
			}
			// pausing the ticker does not really pause the ticker (weird)
			if (that.speed == 0 || that.direction == 0) {return;}

			if (horizontal) {
				b1.x -= that.speed*that.direction;
				if (b1.x < b2.x) {
					b2.x = b1.x + w;
				} else {
					b2.x = b1.x - w;
				}
				if (that.direction * that.speed > 0) {
					if (b2.x < 0 && b1.x < b2.x) {
						b1.x = b2.x + w;
					} else if (b1.x < 0 && b2.x < b1.x) {
						b2.x = b1.x + w;
					}
				} else {
					if (b2.x > viewW && b2.x > b1.x) {
						b2.x = b1.x - w;
					} else if (b1.x > viewW && b1.x > b2.x) {
						b1.x = b2.x - w;
					}
				}
			} else {
				b1.y -= that.speed*that.direction;
				if (b1.y < b2.y) {
					b2.y = b1.y + h;
				} else {
					b2.y = b1.y - h;
				}
				if (that.direction * that.speed > 0) {
					if (b2.y < 0 && b1.y < b2.y) {
						b1.y = b2.y + h;
					} else if (b1.y < 0 && b2.y < b1.y) {
						b2.y = b1.y + h;
					}
				} else {
					if (b2.y > viewH && b2.y > b1.y) {
						b2.y = b1.y - h;
					} else if (b1.y > viewH && b1.y > b2.y) {
						b1.y = b2.y - h;
					}
				}
			}
		}

		this.paused = false;
		this.pause = function(state, time) {
			if (zot(state)) state = true;
			if (zot(time)) time = 0;
			if (state) {
				lastSpeed = that.speed;
				if (time > 0) {
					pausing = true;
					zim.animate({target:that, obj:{pausingSpeed:0}, ticker:false, time:time, call:function() {
						that.speed = 0;
						that.paused = true;
						pausing = false;
						that.dispatchEvent("pause");
					}});
				} else {
					pausing = false;
					that.speed = 0;
					that.paused = true;
					setTimeout(function() {that.dispatchEvent("pause");}, 10);
				}
			} else {
				pausing = false;
				if (time > 0) {
					zim.animate({target:that, obj:{pausingSpeed:lastSpeed}, ticker:false, time:time, call:function() {
						that.speed = lastSpeed;
						that.paused = false;
						pausing = false;
					}});
				} else {
					that.speed = lastSpeed;
					that.paused = false;
				}
			}
			return that;
		};

		Object.defineProperty(that, 'percentSpeed', {
			get: function() {
				if (that.baseSpeed == 0) return NaN;
				return that.speed / that.baseSpeed * 100;
			},
			set: function(percent) {
				if (pausing || that.paused) return;
				that.speed = that.baseSpeed * percent / 100;
			}
		});

		Object.defineProperty(that, 'pausingSpeed', {
			get: function() {
				if (that.baseSpeed == 0) return NaN;
				return that.speed / that.baseSpeed * 100;
			},
			set: function(percent) {
				that.speed = that.baseSpeed * percent / 100;
			}
		});
		
		Object.defineProperty(that, 'percentComplete', {
			get: function() {		
				if (horizontal) {
					if (b1.x < 0 && b1.x > b2.x) return -b1.x/b1.width*100;							
					else return (-b2.x/b2.width*100+1000000000)%100;	
				} else {
					if (b1.y < 0 && b1.y > b2.y) return -b1.y/b1.height*100;		
					else return (-b2.y/b2.height*100+1000000000)%100;	
				}
			},
			set: function(percent) {			
				percent = (percent+1000000000)%100;
				if (horizontal) {
					b1.x = -percent*b1.width/100;
					b2.x = b1.x+w;
				} else {
					b1.y = -percent*b1.height/100;
					b2.y = b1.y+h;
				}
			}
		});

		if (style!==false) zim.styleTransforms(this, DS);

		this.dispose = function() {
			zim.Ticker.remove(zimTicker);
			// if (that.backing1) that.backing1.dispose(); // leaving them around...
			// if (that.backing2) that.backing2.dispose();
			return true;
		};
	};
	zim.extend(zim.Scroller, createjs.EventDispatcher, null, "cjsEventDispatcher");
	//-69


/*--
zim.Dynamo = function(sprite, speed, label, startFrame, endFrame, update, reversible, flip, flipVertical, style, group, inherit)

Dynamo
zim class - extends a createjs EventDispatcher

DESCRIPTION
A Dynamo can run any Sprite animation at varying speeds
You pass in an optional label, or start and end frames to define the animation frames
You can animate a Dynamo using speed or percentSpeed
percentSpeed is handy for animating at speeds relative to other animations and scrollers
You can control Dynamo speeds with mouse position - or in a Parallax object
A Dynamo loops automatically - you can pause it (with optional slowing or optional frame) and unpause it (with optional quickening)
You can also get or set its frame property at which point, it will loop from there (unless paused)
A Dynamo dispatches a "change" event every time the frame changes
and a loop event every time it loops to the start and a paused event when paused

NOTE: A Dynamo requires constant S.update() to run the Sprite
A Ticker.add(function () { // speed Code}) or just new Ticker.always() will provide the update

NOTE: A Dynamo can be added to a Accelerator object (and then to a MotionController)
this will allow the percentSpeed to be synched with other Scroller and Dynamo objects
See https://zimjs.com/zide/
See https://zimjs.com/explore/sidescroller.html

NOTE: Dynamo is an alternative to a Sprite.run() where you provide a set time for animation
but you can pause a Dynamo and then use run() and then unpause the Dynamo when the run is done
If you are controlling the Dynamo in a new Ticker.add() function,
then make sure to remove() the new Ticker function when the Dynamo is paused

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// *** the Sprite will not run with a Dynamo unless there is a constant S.update()
// The new Ticker will provide a constant S.update() so that is good!

// we have a sprite of a guy and it has a "walk" animation
// we can make this run faster and slower with an accelerator:
// we pass in a speed of 30 fps and this becomes the baseSpeed

const dynamo = new Dynamo({sprite:sprite, speed:30, label:"walk", reversible:false});
Ticker.add(()=>{
	// the sprite will run at 0 speed when the cursor is at the left of the stage
	// and get faster as the cursor moves to the right
	// at the middle it will be 30 fps and at the right it will be 60 fps
	dynamo.percentSpeed = F.mouseX/W*100*2;
});

// Here we apply damping and make the sprite play backwards at the left of half stage
var dynamo = new Dynamo(sprite, 30, "walk");
Ticker.add(()=>{
	// will play backwards at 30 fps at left and forwards at 30 fps at right
	// it will stop at half the stage width
	// reversible false means it will not walk backwards
	// but rather it will flip and walk in the left direction when the speed is negative
	dynamo.percentSpeed = F.mouseX/W*200 - 100;
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
sprite - the sprite to control
speed - (default 30) the frames per second at which to animate the sprite
label - (default null) the label of the sprite to play (see Sprite)
startFrame - (default 0) the frame to start the animation (ignored if a label is provided)
endFrame - (default sprite.totalFrames) the frame to end the animation (ignored if a label is provided)
update - (default false) set to true to update the stage (only do this if you are not already updating the stage!)
reversible - (default true) will allow percentSpeed to be negative and reverse the animation.  Set to false to use absolute value.
flip - (default true if reversible is false) will flip the scaleX of the sprite if speed is negative and reversible is set to false.
	the pairing of reversible false and flip true will make a Sprite turn and walk the other way if the speed is negaitive
	Note: also see the scaleX property
flipVertical - (default false) flip the Sprite in the vertical if the speed is negative (note also see the scaleY property)

METHODS
pause(state, time, frame) - the way to pause or unpause a Dynamo affecting the sprite animating
	state - (default true) true pauses and setting the state to false will unpause the animation
	time - (default 0) time in milliseconds to slow the animation down if pausing or speed it up if unpausing
	frame - (default null) which frame to pause on - overrides time (unless you want to do the calculation...)
dispose() - cancels the requestAnimationFrame

PROPERTIES
type - holds the class name as a String
frames - an array of frame numbers the Dynamo is acting on according to label, or startFrame, endFrame
frame - the current frame of the Dynamo - this is sequential relative to frames
	whereas the actual Sprite frame may be different as labels can specify non-consecutive frame numbers
totalFrames - the total frames in frames (may be different than the Sprite's total frames)
percentSpeed - get or set the percentage of the baseSpeed - eg. 100 is a the baseSpeed
	this is what you should animate to speed up and slow down the sprite
	this allows you to set the speed relative to other Sprites and Scrollers
speed - get or set the speed of the sprite in frames per second
baseSpeed - the start speed given in frames per second unless changed with this property
	this affects the percentSpeed so usually it is not adjusted - but it can be
paused - read only - whether the Dynamo is paused or not (by using the pause() method)
scaleX - starts with the original scaleX of the Sprite
	if you flip the sprite and are scaling the Sprite manually, then also set the scaleX of the dynamo to match
scaleY - starts with the original scaleY of the Sprite
	if you flip the sprite and are scaling the Sprite manually, then also set the scaleY of the dynamo to match

EVENTS
dispatches a "change" event when the Dynamo changes frame
dispatches a "loop" event when the Dynamo loops (possibly in reverse)
dispatches a "pause" event when the Dynamo is paused - could be delayed
--*///+69.2
	zim.Dynamo = function(sprite, speed, label, startFrame, endFrame, update, reversible, flip, flipVertical, style, group, inherit) {
		var sig = "sprite, speed, label, startFrame, endFrame, update, reversible, flip, flipVertical, style, group, inherit";
		var duo; if (duo = zob(zim.Dynamo, arguments, sig, this)) return duo;

		z_d("69.2");
		this.cjsEventDispatcher_constructor();
		this.type = "Dynamo";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(sprite)) sprite = DS.sprite!=null?DS.sprite:null;
		if (zot(sprite)) return;

		var frames = this.frames = sprite.parseFrames(label, startFrame, endFrame, true); // last true is fromDynamo
		if (frames.length == 0) return;
		this.totalFrames = frames.length;
		var _frame = 0; // frame for getter and setter methods
		if (zot(speed)) speed = DS.speed!=null?DS.speed:30;
		if (zot(reversible)) reversible = DS.reversible!=null?DS.reversible:true;
		var lastSpeed = this.baseSpeed = this.speed = speed;
		if (zot(update)) update = DS.update!=null?DS.update:false;
		if (zot(flip)) flip = DS.flip!=null?DS.flip:null;
		if (zot(flip) && reversible == false) flip = true;

		var that = this;
		var requestID;
		var speedFactor;
		var lastTime = Date.now();
		var currentTime;
		var wait;
		var endFrameRequest;
		var pausing = false; // for in the act of pausing
		that.scaleX = sprite.scaleX;
		that.scaleY = sprite.scaleY;
		function doDynamo() {
			requestID = requestAnimationFrame(doDynamo);
			speedFactor = frames[_frame].s;
			if (that.speed == 0 || speedFactor == 0) return;
			wait = 1000/Math.abs(that.speed)*speedFactor;
			currentTime = Date.now();
			if (currentTime - lastTime > wait) {
				lastTime = currentTime;
				var nextFrame = that.frame+((that.speed>0 || !reversible)?1:-1);
				var loopCheck = false;
				if (nextFrame >= frames.length) {loopCheck = true; nextFrame = 0;}
				if (nextFrame < 0) {loopCheck = true; nextFrame = frames.length-1;}
				that.frame = nextFrame;
				if (flip) {
					if (that.speed < 0) sprite.scaleX = -that.scaleX;
					else sprite.scaleX = that.scaleX;
				}
				if (flipVertical) {
					if (that.speed < 0) sprite.scaleY = -that.scaleY;
					else sprite.scaleY = that.scaleY;
				}
				if (loopCheck) that.dispatchEvent("loop");
				that.dispatchEvent("change");
				if (update && sprite.stage) sprite.stage.update();
				if (!zot(endFrameRequest) && endFrameRequest == that.frame) {
					pausing = false;
					that.speed = 0;
					that.paused = true;
					that.dispatchEvent("pause");
				}
			}
		}
		doDynamo();

		this.paused = false;
		this.pause = function(state, time, frame) {
			if (zot(state)) state = true;
			if (state == that.paused) return;
			if (zot(time)) time = 0;
			if (state) {
				lastSpeed = that.speed;
				if (typeof frame == "undefined") {					
					if (time > 0) {
						pausing = true;
						zim.animate({target:that, obj:{pausingSpeed:0}, ticker:false, time:time, call:function() {
							pausing = false;
							that.speed = 0;
							that.paused = true;
							that.dispatchEvent("pause");
						}});
					} else {
						pausing = false;
						that.speed = 0;
						that.paused = true;
						setTimeout(function() {that.dispatchEvent("pause");}, 10);
					}
				} else {
					pausing = true;
					endFrameRequest = frame;
				}
			} else {
				endFrameRequest = null;
				if (time > 0) {
					pausing = true;
					zim.animate({target:that, obj:{pausingSpeed:lastSpeed}, ticker:false, time:time, call:function() {
						pausing = false;
						that.speed = lastSpeed;
						that.paused = false;
					}});
				} else {
					pausing = false;
					that.speed = lastSpeed;
					that.paused = false;
				}
			}
			return that;
		};

		Object.defineProperty(that, 'frame', {
			get: function() {
				return _frame;
			},
			set: function(frame) {
				_frame = Math.round(frame) % frames.length;
				var f = frames[_frame];
				if (zot(f)) return;
				sprite.frame = f.f;
			}
		});

		Object.defineProperty(that, 'percentSpeed', {
			get: function() {
				if (that.baseSpeed == 0) return NaN;
				if (pausing || that.paused) {
					return lastSpeed / that.baseSpeed * 100;
				} else {
					return that.speed / that.baseSpeed * 100;
				}
			},
			set: function(percent) {
				if (pausing || that.paused) {
					lastSpeed = that.baseSpeed * percent / 100;
					return;
				}
				that.speed = that.baseSpeed * percent / 100;
			}
		});

		Object.defineProperty(that, 'pausingSpeed', {
			get: function() {
				if (that.baseSpeed == 0) return NaN;
				return that.speed / that.baseSpeed * 100;
			},
			set: function(percent) {
				that.speed = that.baseSpeed * percent / 100;
			}
		});

		if (style!==false) zim.styleTransforms(this, DS);

		this.dispose = function() {
			cancelAnimationFrame(requestID);
		};
	};
	zim.extend(zim.Dynamo, createjs.EventDispatcher, null, "cjsEventDispatcher");
	//-69.2

/*--
zim.Accelerator = function(objects)

Accelerator
zim class extends a createjs.EventDispatcher

DESCRIPTION
An Accelerator lets you set percentSpeed properties of multiple objects
such as Scroller and Dynamo (Dynamic Sprite) objects
or an object animating with animate() and the dynamic parameter set
All these have a percentSpeed property
which can be set by the Accelerator to operate the speeds.
They can also be paused and paused over time.
An Accelerator object lets you control these from one place

See: https://zimjs.com/explore/sidescroller.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const rect = new Rectangle()
	.centerReg()
	.animate({props:{rotation:360}, ease:"linear", dynamic:true});
const accel = new Accelerator(rect);
// adjust speed of the animation by mousedown
// 0% at left, 50% in middle, 100% at right, etc.
new MotionController(accel);
// or
new MotionController({target:accel, type:"mousemove", minPercentSpeed:-200, maxPercentSpeed:200});
// will change speed from -200% to 200% as cursor is moved across screen
END EXAMPLE

EXAMPLE
// assuming we have scroller1, scroller2 and a sprite
// each of these would have a speed set so the scene animates nicely
const accelerator = new Accelerator([scroller1, scroller2, sprite]);

// here we increase the speed then decrease the speed of the whole scene:
animate({target:accelerator, obj:{percentSpeed:200}, time:1, rewind:true, ticker:false});

// here we change the speed of the whole scene based on the x position of the mouse
// at the very left, the speed is -200 percent and at the right the speed is 200 percent
// in the center, the speed is 0 - damping is optional but always looks better!
const damp = new Damp(accelerator.percentSpeed);
Ticker.add(()=>{
	var newSpeed = (F.mouseX-W/2)/(W/2)*100*2;
	accelerator.percentSpeed = damp.convert(newSpeed);
});
END EXAMPLE

PARAMETERS
objects - (default null) registers Scroller or Dynamo objects the Accelerator
	pass in a single object or an array of multiple objects

METHODS
add(objects) - registers Scroller or Dynamo objects with the Accelerator
	pass in a single object or an array of multiple objects
	returns the Accelerator object for chaining
remove(objects) - unregisters a Scroller or Dynamo
	pass in a single object or an array of multiple objects
	returns the Accelerator object for chaining
pause(state, time, frameNumber) - pause (default) or unpause all the objects added to the Accelerator
	state - (default true) set to false to unpause the objects added to the Accelerator
	time - (default 0) time in milliseconds to slow down to a speed of 0 and pause
		the pause event and paused property will be set after the time has passed
		time is ignored if a frameNumber is provided
	frameNumber - (default null) get sprites to animate to the frameNumber (probably good for one sprite!)
		setting this will make the scene ignore the time parameter above
dispose() - calls dispose() on all the objects

PROPERTIES
type - holds the class name as a String
percentSpeed - adjusts the speed relative to the baseSpeed of each items in the Accelerator - eg. 100 is at the baseSpeed
	this can be dynamically changed to change all speeds relatively
paused - (read only) whether the Accelerator is paused or not - only tracks if the pause() method is used
items - an array of all objects added with add()
--*///+69.3
	zim.Accelerator = function(objects) {
		z_d("69.3");
		this.cjsEventDispatcher_constructor();

		var that = this;
		this.type = "Accelerator";
		this.paused = false;
		this.items = [];
		this.paused = false;
		this._percentSpeed = 100;
		this.add = function(objects) {
			var list;
			if (Array.isArray(objects)) {list = objects;} else {list = [objects];}
			var ind;
			for (var i=0; i<list.length; i++) {
				ind = that.items.indexOf(list[i]);
				if (ind < 0) that.items.push(list[i]);
			}
			return that;
		};
		if (objects) this.add(objects);
		this.remove = function(objects) {
			var list;
			if (Array.isArray(objects)) {list = objects;} else {list = [objects];}
			var ind;
			for (var i=0; i<list.length; i++) {
				ind = that.items.indexOf(list[i]);
				if (ind >= 0) that.items.splice(ind,1);
			}
			return that;
		};
		this.pause = function(state, time, frameNumber) {
			if (zot(state)) state = true;
			if (state == that.paused) return;
			var pausingItems = [];
			if (state) {
				if (!zot(frameNumber)) time = null;
				// if we pause the scene with a time delay or frameNumber
				// then the pause may not happen right away
				// so leave the other animations going like scrollers until the pause
				var waiting = false;
				for (var i=0; i<that.items.length; i++) {
					// if time and not totalFrames and scroller - or - dynamo and (time or frameNumber)
					if ((!zot(time) && zot(frameNumber) && !that.items[i].totalFrames) || that.items[i].totalFrames && (!zot(time) || !zot(frameNumber))) {
						that.items[i].pause(true, time, frameNumber); // frameNumber ignored by scroller
						waiting = true;
						pausingItems[i] = 1;
						that.items[i].on("pause", function(){
							if (!that.paused) {
								pauseAll(true);
								that.paused = true;
								that.dispatchEvent("pause");
							}
						}, null, true);
					}
				}
				// not waiting so pause all
				if (!waiting) {
					pauseAll();
					that.paused = true;
					setTimeout(function() {that.dispatchEvent("pause");}, 10);
				}
			} else {
				that.paused = false;
				pauseAll();
			}
			function pauseAll() {
				for (var i=0; i<that.items.length; i++) {
					// pauseAll does not need to pause the ones we were waiting for and are now done...
					if (pausingItems[i] != 1) {
						that.items[i].pause(state);
					}
				}
			}
		};
		Object.defineProperty(that, 'percentSpeed', {
			get: function() {
				return that._percentSpeed;
			},
			set: function(percent) {
				that._percentSpeed = percent;
				for (var i=0; i<that.items.length; i++) {
					that.items[i].percentSpeed = percent;
				}
			}
		});
		this.dispose = function() {
			for (var i=0; i<that.items.length; i++) {
				that.items[i].dispose();
			}
			that.items = null;
			return true;
		};
	};
	zim.extend(zim.Accelerator, createjs.EventDispatcher, null, "cjsEventDispatcher");
	//-69.3

/*--
zim.Emitter = function(obj, width, height, interval, num, life, fade, shrink, warm, decayTime, decayStart, trace, traceFadeTime, traceShiftX, traceShiftY, angle, force, gravity, wind, layers, animation, random, horizontal, vertical, sink, sinkForce, cache, events, startPaused, pool, poolMin, particles, focusWarm, style, group, inherit)

Emitter
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
A particle emitter - so this makes and animates display objects like shapes or bitmaps
Particle emitters are often used for things like fireworks, fire, smoke, sparks, falling objects, etc.
The Emitter is filled with options so have a look at the doc parameters
Here are some examples:
https://zimjs.com/particles/

NOTE: consider the Emitter as somewhat experimental and pushing the bounds of the canvas
In future versions we will look into adding CreateJS StageGL (WebGL) examples / support (it might work already)
The Emitter certainly can make excellent and workable effects
But it can also bog the browser if pushed to extremes or sometimes if left going
This possibly means there are memory leaks - we have been doing our best to track things down
The Emitter is reporting an expected number of children so any leaks might be beyond ZIM control

NOTE: each particle starts at the center of the container width and height
If the trace parameter is true then the particle is put in a container that does not move
and the particle moves inside that container as the container is cached with the source-over composite operation
The currentParticle property and all the event objects' particle parameter is the moving particle
However, the children of the Emitter, will be slightly different in each case:
when trace is false, the children of the Emitter container are any active particles
when trace is true, the children of the Emitter container are the containers that hold the active particles
If you have moved, scaled or rotated the Emitter or its container,
then you will want to use var point = myEmitter.localToGlobal(particle.x, particle.y)
and get point.x and point.y to find the location of the particle relative to the stage coordinates

PARTICLES CONTAINER
By default, the Emitter will make a Container and place it beneath itself when added to the stage.
by separating the particles from the emitter, it allows the emitter to be moved without all the particles moving
the container will be given a type of "Particles"

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a bunch of spewing pink circles affected by gravity
const emitter = new Emitter(new Circle(5, pink))
	.centerReg();
END EXAMPLE

EXAMPLE
// use a sink to attract the particles
const sink = new Circle(10, pink).centerReg().alp(0);
// make one of three types of particles and randomize the colors
const particles = new Emitter({
	obj:[
		new Circle(20,null,darker,2),
		new Rectangle(30,30,null,darker,2),
		new Triangle(40,40,40,null,darker,2)
	],
	random:{color:[blue, green, pink, yellow, orange]},
	interval:.02, // default
	life:5,
	decayTime:1, // default
	sink:sink,
	sinkForce:.5,
	gravity:0,
	force:1,
	cache:mobile(), // default
})
	.centerReg()
	.sca(2);
END EXAMPLE 

EXAMPLE 
// use warm:true to start with rings already emitted
const emitter = new Emitter({
	obj:new Circle({
		radius:10,
		borderColor:white,
		borderWidth:30,
		strokeObj:{ignoreScale:true}
	}),
	warm:true,
	force:0,
	gravity:0,
	shrink:false,
	fade:false,
	life:3,
	interval:.5,
	animation:{props:{scale:40}, time:3, ease:"linear"}
}).center();
emitter.particles.setMask(new Rectangle(400,400).center().alp(0));
END EXAMPLE

EXAMPLE
// use a StageGL Frame and createjs.SpriteSheetBuilder for circles:
new Frame({ready, scale:FIT, width:1024, height:768, gpu:true});
function ready() {
	// if we pass in just a Circle then we would have to turn on cache
	// and cache on WebGL counts as an image for each one
	// whereas a SpriteSheet just counts as an image for all of the particles
	// so build a SpriteSheet from the Circle
	var builder = new createjs.SpriteSheetBuilder();
	builder.addFrame(new Circle(50, purple));
	builder.build();
	const emitter = new Emitter({
		obj:new Sprite({spriteSheet:builder.spriteSheet}),
		num:10, // ten Sprites made every .02 seconds for about 1000 particles per second
		life:2,
		interval:.02,
		gravity:0,
		force:2
	}).centerReg();
}

// see more examples at https://zimjs.com/particles
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
obj - |ZIM VEE| (default blue, green, pink Circles) a display object to clone - eg. new Circle(10, green);
	can also specify a shape config object with the following properties to draw inside a shape as an alternative to the trace property
	{type:"shape", s:white, ss:1, f:red, sd:{noPick:[20, 10]}, offset:3}
	the parameters accept ZIM VEE values except the type and sd as it requires an array as a final value
	type:"shape" is required.  s is setStroke, ss is setStrokeStyle, sd and offset are setStrokeDash in CreateJS
	line thickness (ss) is currently not staying in the latest CDN CreateJS - this is working in the NEXT build
width - (default 300) the width of the Emitter container - used as cache bounds for trace if trace is true
height - (default 300) the height of the Emitter container - used as cache bounds for trace if trace is true
	these dimensions will affect performance if the trace parameter is true so use carefully
	also see the traceShiftX and traceShiftY to specify the caching rectangle position
interval - |ZIM VEE| (default .02) the time in seconds between emitting particles
num - |ZIM VEE| (default 1) the number of particles emitted each interval
life - |ZIM VEE| (default 1) the time in seconds the particle will exist (also see ZIM TIME constant - same for all times)
fade - (default true) Boolean to fade the particle (alpha 0) - set to false to not fade out the particle over the decayTime
shrink - (default true unless trace is true) Boolean to shrink the particle (scale 0) - set to false to not shrink the particle over the decayTime
warm - (default null) set true to make particles ahead of time to look like the emitter has been running
	set to true to use life/duration as from then on there would be repeat - or set to a desired number of particles
	this will temporarily turn off the pooling to make the warmed particles 
decayTime - (default 1) time in seconds to fade and / or shrink the particle - ends animation at the life time unless decayStart is set
decayStart - (default null) time in seconds to start the decayTime otherwise decay (fade and shrink) ends at the end of life time
trace - (default false) Boolean set to true to leave trails by caching each particle with source-over composite operation
traceFadeTime - (default decayTime) time in s to fade out traced particle to 0 alpha at the end of the particle life time
traceShiftX - (default 0) x amount to shift the cache rectangle for the traced particle
traceShiftY - (default 0) y amount to shift the cache rectangle for the traced particle
	the particle starts centered in the width and height of the Emitter container
	if you have particles falling - for instance fireworks, you can shift the cache rectangle down to see more trails
	and then place the Emitter up higher on the stage
angle - |ZIM VEE| (default {min:0, max:360}) the angle the particle will emit (0 is along the positive x axis)
	if you want to shoot particles in one direction just use angle = 20
	if you want something shooting up on either side of the y axis you can use:
	angle = {min:-90-20, max:-90+20}; this may be easier to visualize
	if you want to emit at 45 or 90 then use [45, 90]
force - |ZIM VEE| (default 5) the force for the emitter to shoot the partice at an angle
	if you want to shoot a variety use force = {min:2, max:10} etc.
gravity - (default 9.8) the force of gravity going down - can be negative to make particles float up
wind - (default 0) a force you can apply in the horizontal direction either negaitive for left or positive for right
layers - (default TOP) where to place the current particle being emitted - values are TOP, BOTTOM, and RANDOM
animation - |ZIM VEE| (default null) a zim animate config object to apply to the particle
	This is the whole zim DUO object to pass to animate - including a props parameter that holds the animation object
	To pass in two or more animations on the same particle then use {noPick:[{animation1}, {animation2}, {etc.}]}
random - (default null) an object holding properties to animate, each property holding a ZIM VEE Value object for Pick.choose() to pick from per particle
	eg: {color:[red, white, green], scale:{min:1, max:2}} // scale is a convienence property for both scaleX and scaleY
horizontal - (default false) start the particles across the emitter's width at the top of the emitter (unless vertical is set to true)
vertical - (default false) start the particles across the emitter's height at the left of the emitter (unless horizontal is set to true)
sink - (default null) an object with x and y properties (can be a display object) that the particles will be pulled to (or pushed if sinkForce is negative)
sinkForce - |ZIM VEE| (default 10 if sink) the force particles are moved towards the sink location
cache - (default mobile() or false if gpu) Boolean to cache each particle - helpful if complex shape or text 
	Bitmap, Pic, Sprite will not be cached.
events - (default false) Boolean - set to true to receive events from Emitter
startPaused - (default false) Boolean - set to true to start the Emitter in the paused state
pool - (default true) Boolean if true, makes as many particles as it needs before recycling particles
	this improves performance as new particles do not need to be made and old ones remove
	see also the clearPool() method to start collecting a new type of particle, etc.
poolMin - (default 0) a minimum number of pooled particles before new particles are no longer made (if pool is true)
	eg. setting poolMin to 100 would make 100 particles and then start reusing these particles for performance
	if you set pool to true and do not specify a poolMin then ZIM will calculate the needed number to properly recycle
	but you can override this number if you want a larger pool for more selection
particles - (default null) a container for the particles
	by default, the Emitter will make a Container and place it beneath itself when added to the stage.
	by separating the particles from the emitter, it allows the emitter to be moved without all the particles moving
	the container will be given a type of "Particles"
focusWarm - (default true) if Emitter window pauses on blur and comes back in focus Emitter will warm (see warm parameter)
	can set to a number or false or leave as true to use life/interval as the number of particles to instantly create
	this parameter is independent of the warm parameter - so will run even if warm is null

METHODS
spurt(num, time, restart) - shoots particles (usually would pause Emitter before doing this)
	supports ZIM DUO config object
	num - |ZIM VEE| (default null) number of particles to emit according to Emitter settings
	time - |ZIM VEE| (default null) alternatively, time in seconds to emit particles according to Emitter settings
		if both num and time are provided the faster one will stop the emitting
		dispatches three different spurt events - see events
	restart (default false) set to true to restart the particles when spurted (removes old particles)
pauseEmitter(state, restart, freeze, immediate) - pause or unpause the Emitter
	state (default true) will pause the emitter or set to false to unpause the emitter
		this will set the read only paused property to true or false accordingly
	restart (default false) set to true to restart the particles when unpaused
		otherwise continues the particles from where they were
	freeze (default false) set to true to freeze the particles
		othewise pause just stops emitting and existing particles continue their life
	immediate (default false) set to true to emit right away after unpausing
		otherwise just emits on normal schedule
clearPool() - clear the pool of particles - use if you change the obj or its properties (no effect if pool parameter is false)
resize(width, height) - resizes the Emitter container and any cache bounds for new particles
hasProp(property as String) - returns true if property exists on object else returns false
clone() - makes a copy with properties such as x, y, etc. also copied
	all current properties will be cloned except for startPaused for which the initial parameter value is cloned
dispose() - removes event listeners from Window and content and removes any new Ticker functions

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
** All the PARAMETERS are available as PROPERTIES to get and set (except for the force and cache parameters - and width and height act differently)
emitterForce - get and set force - do not use force property - due to conflict with physics force
emitterPaused - read only Boolean as to whether the Emitter is paused or not - see also pauseEmitter() method
particles - a reference to the Container that holds the particles
	particles has noMouse() set to if interaction is desired use emitter.particles.mouse()
	this container will be given a type of "Particles"
currentParticle - the latest particle emitted
	if trace is false then this is myEmitter.getChildAt(myEmitter.numChildren-1);
	if trace is true then this is myEmitter.getChildAt(myEmitter.numChildren-1).getChildAt(0);
particlesEmitted - the number of particles that have been made / emitted
spurtNum - total number of particles to spurt (when spurt() is called)
spurtCount - number of particles spurted so far (when spurt() is called)
zimInterval - the interval used to create particles
zimTicker - the ticker used to animate particles
** CHILD PROPERTIES - each child has a particle (if trace is true) or is a particle (if trace is false)
particle -  a reference to the particle for the child (could be to itself)
particleNormal - true or false if particle is not decaying or fizzing
particleDecaying - true or false if decaying - particle is currently animating to either scale 0 or alpha 0
particleFizzing - true or false if fizzing - trace container is currently animating to alpha 0

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
** the below events all have a particle property that gives access to the particle (not the particle container for a traced particle - ask for the particle.parent for that)
dispatches a "spurted" event once the spurt() method is finished emitting particles
dispatches a "spurtdecayed" event once the last spurted particle decays (fade / shrink)
dispatches a "spurtfizzed" event once the last spurted particle's life ends
** the below events only trigger if the events parameter is set to true (default is false for slight performance edge)
dispatches an "emitted" event when a particle is made
dispatches a "decayed" event when the particle's decayStart + decayTime ms has elapsed
dispatches a "fizzed" event when the particle's life ms has elapsed

ALSO: see the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+69.9
zim.Emitter = function(obj, width, height, interval, num, life, fade, shrink, warm, decayTime, decayStart, trace, traceFadeTime, traceShiftX, traceShiftY, angle, force, gravity, wind, layers, animation, random, horizontal, vertical, sink, sinkForce, cache, events, startPaused, pool, poolMin, particles, focusWarm, style, group, inherit) {
	var sig = "obj, width, height, interval, num, life, fade, shrink, warm, decayTime, decayStart, trace, traceFadeTime, traceShiftX, traceShiftY, angle, force, gravity, wind, layers, animation, random, horizontal, vertical, sink, sinkForce, cache, events, startPaused, pool, poolMin, particles, focusWarm, style, group, inherit";
	var duo; if (duo = zob(zim.Emitter, arguments, sig, this)) return duo;
	z_d("69.9");

	this.type = "Emitter";
	this.group = group;
	var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

	if (zot(obj)) obj = DS.obj!=null?DS.obj:[new zim.Circle(20,zim.pink),new zim.Circle(20,zim.green),new zim.Circle(20,zim.blue)];
	if (zot(width)) width = DS.width!=null?DS.width:300;
	if (zot(height)) height = DS.height!=null?DS.height:300;
	var timeType = getTIME(interval);
	if (zot(interval)) interval = DS.interval!=null?DS.interval:timeType=="s"?.02:20;
	if (typeof interval == "number") interval = Math.max(timeType=="s"?.01:10, interval);
	if (zot(num)) num = DS.num!=null?DS.num:1;
	if (zot(trace)) trace = DS.trace!=null?trace.size:false;	
	if (zot(traceShiftX)) traceShiftX = DS.traceShiftX!=null?DS.traceShiftX:0;
	if (zot(traceShiftY)) traceShiftY = DS.traceShiftY!=null?DS.traceShiftY:0;
	checkTIME(life, timeType);		
	if (zot(life)) life = DS.life!=null?DS.life:timeType=="s"?1:1000;
	if (zot(fade)) fade = DS.fade!=null?DS.fade:true;
	if (zot(shrink)) shrink = DS.shrink!=null?DS.shrink:trace?false:true;
	if (zot(warm)) warm = DS.warm!=null?DS.warm:null;	
	checkTIME(decayTime, timeType);
	if (zot(decayTime)) decayTime = DS.decayTime!=null?DS.decayTime:timeType=="s"?1:1000;
    if (zot(traceFadeTime)) traceFadeTime = DS.traceFadeTime!=null?DS.traceFadeTime:decayTime;
	if (zot(angle)) angle = DS.angle!=null?DS.angle:{min:0, max:360};
	if (zot(force)) force = DS.force!=null?DS.force:5;
	if (zot(gravity)) gravity = DS.gravity!=null?DS.gravity:9.8;
	if (zot(wind)) wind = DS.wind!=null?DS.wind:0;
	if (zot(layers)) layers = DS.layers!=null?DS.layers:"top"; // bottom, random
	if (zot(width)) width = DS.width!=null?DS.width:100;
	if (zot(height)) height = DS.height!=null?DS.height:100;
	if (zot(horizontal)) horizontal = DS.horizontal!=null?DS.horizontal:false;
	if (zot(vertical)) vertical = DS.vertical!=null?DS.vertical:false;
	if (zot(sink)) sink = DS.sink!=null?DS.sink:null;
	if (!zot(sink) && zot(sinkForce)) sinkForce = DS.sinkForce!=null?DS.sinkForce:10;
	if (zot(events)) events = DS.events!=null?DS.events:false;
	if (zot(startPaused)) startPaused = DS.startPaused!=null?DS.startPaused:false;
	if (zot(pool)) pool = DS.pool!=null?DS.pool:true;
	if (zot(poolMin)) poolMin = DS.poolMin!=null?DS.poolMin:0;
	if (zot(particles)) particles = DS.particles!=null?DS.particles:new zim.Container();
	if (zot(focusWarm)) focusWarm = DS.focusWarm!=null?DS.focusWarm:true;
	if (obj.type == "shape") focusWarm = false;
 	
	particles.type = "Particles";
	particles.emitter = this;

	this.zimContainer_constructor(width, height, null, null, false);
	this.type = "Emitter";
	var that = this;

	this.regX = width/2; // new auto center reg
	this.regY = height/2;

	// might want many of these as dynamic properties - sigh.
	that.obj = obj; that.particles = particles;
	that.interval = interval; that.num = num;
	that.life = life; that.fade = fade; that.shrink = shrink;
	that.decayTime = decayTime;  that.decayStart = decayStart;
	that.trace = trace; that.traceFadeTime = traceFadeTime,
	that.traceShiftX = traceShiftX; that.traceShiftY = traceShiftY;
	that.angle = angle, that.emitterForce = force;
	that.gravity = gravity; that.wind = wind;
	that.layers = layers; that.animation = animation; that.random = random;
	that.horizontal = horizontal; that.vertical = vertical;
	that.sink = sink; that.sinkForce = sinkForce;
	that.events = events; that.startEmitterPaused = that.emitterPaused = startPaused;
	that.pool = pool; that.poolMin = poolMin;

	that.particlesEmitted = 0;
	var poolList = [];
	var poolIndex = 0;
	var poolCount = 0;	

	var emitterTicker;
	var stage;
	zim.added(that, addedToStage);
	function addedToStage(s) {

		that.emitterPaused = null; // will set back using that.startEmitterPaused

		that.on("added", function () {
			// added in ZIM 014
			zim.loop(that.particles, function(particle) {
				particle.visible = false;
			});
			that.particles.addTo(that.parent);
		});
		stage = s;
		if (zot(cache)) {
			if (stage.isWebGL) {
				cache = false;
			} else {
				cache = zim.mobile();
			}
		}
		if (cache) stage.snapToPixelEnabled = true;
		if (stage) {
			var myIndex = that.parent.getChildIndex(that);
			that.parent.addChildAt(particles, myIndex); // add particles beneath emitter in emitter's container
			// particles.x = that.x;
			// particles.y = that.y;
			if (!horizontal && !vertical) that.centerReg(null, null, false);

			//-------------   INTERVAL
			// var counter = 0;
			// var time = Date.now();
			// that.interval = 1000 / 60;				


			that.zimInterval = zim.interval(that.interval, runEmitter, null, true, true); // true for immediate, true for pause on blur
			
			function runEmitter() {

				// counter++;
				// zog(decimals(counter/(Date.now() - time)*1000,5));

				var maxLifeNum = zim.isPick(that.life)?zim.Pick.getMinMax(that.life).max:that.life;
				if (zot(maxLifeNum)) maxLifeNum = timeType=="s"?1:1000;
	
				if (that.startEmitterPaused) {that.pauseEmitter(); return;}
				// want to leave that.obj as it was provided
				// but for creation we will normalize it as an Array
				obj = Array.isArray(that.obj)?that.obj:[that.obj];
				if (obj.length <= 0) return;

				var minInterval; // used to calculate max pool
				var maxNum;
				function sortNumber(a,b) {return a - b;}
				if (Array.isArray(that.interval)) {
					that.interval.sort(sortNumber);
					minInterval = that.interval[0];
				} else if (that.interval.constructor == {}.constructor){
					minInterval = that.interval.min;
				} else {
					minInterval = that.interval;
				}
				if (Array.isArray(that.num)) {
					that.num.sort(sortNumber);
					maxNum = that.num[that.num.length-1];
				} else if (that.num.constructor == {}.constructor){
					maxNum = that.num.max;
				} else {
					maxNum = that.num;
				}				
                
				zim.loop(zim.Pick.choose(that.num), function() {
					
					if (that.decayTime > 0) {
						var decay = {};
						if (that.shrink) decay.scale=0;
						if (that.fade) decay.alpha=0;
					}
					var container, t, particle;
                    
                    // zog(that.pool, poolList.length > 0, poolCount >= Math.max(that.poolMin, (maxLifeNum/minInterval)*maxNum+15))
					
                    if (that.pool && poolList.length > 0 && poolCount >= Math.max(that.poolMin, (maxLifeNum/minInterval)*maxNum+15)) { // USE POOL... throw in an extra 5 for good measure
						
						container = poolList[(poolIndex++)%poolList.length];
						container.visible = true;
						particle = container.trace?container.getChildAt(0):container;
													
						if (particle.emitShape) {
							t = particle.template;
							particle.graphics.c().s(t.s?zim.Pick.choose(t.s):null).ss(t.ss?zim.Pick.choose(t.ss):null).sd(t.sd?zim.Pick.choose(t.sd):null, t.offset?zim.Pick.choose(t.offset):null);
						}
						if (container.trace && container.cacheCanvas) {
							container.updateCache();
						}
						if (that.layers == "top") {
							if (particle.emitShape) container.addTo(particles, null, false);
							else container.addTo(particles, particles.numChildren-1, false);
						} else {
							if (particle.emitShape) container.addTo(particles, that.layers=="bottom"?0:zim.rand(particles.numChildren), false);
							else container.addTo(particles, that.layers=="bottom"?0:zim.rand(particles.numChildren), false);
						}                        
						if (!that.trace) container.reg("center");
						
						container.scaleX = 1;
						container.scaleY = 1;
						container.alpha = container.originalAlpha;
						// particle.alpha = particle.originalAlpha;
						particle.scaleX = particle.originalScaleX;
						particle.scaleY = particle.originalScaleY;
						particle.rotation = particle.originalRotation;
						particle.color = particle.originalColor;
						particle.endSpurt = false;	

						
					} else { // END POOL, START NOT POOL
                        
						poolCount++;
						container;
						if (that.trace) {
							container = new zim.Container(width,height, null, null, false);
							container.trace = true;
						}

						var template = zim.Pick.choose(zim.shuffle(obj)[0]);
						if (template.type == "shape") { // shape needs to be top left whereas others need to be centerReg
							t = template;
							// {type:"shape", s:"white", ss:2, f:null, sd:[20, 10], offset:3}
							// line thickness is currently not staying in the latest CDN CreateJS - this is working in the NEXT build
							particle = new zim.Shape(1,1,null,null,null,false);
							particle.emitShape = true;
							particle.template = t;
							particle.graphics.s(t.s?zim.Pick.choose(t.s):null).ss(t.ss?zim.Pick.choose(t.ss):null).sd(t.sd?zim.Pick.choose(t.sd):null, t.offset?zim.Pick.choose(t.offset):null);
							if (that.trace) {
								particle.addTo(container, null, false);
							} else {
								if (that.layers == "top") {
									particle.addTo(particles, null, false);
								} else {
									particle.addTo(particles, that.layers=="bottom"?0:zim.rand(particles.numChildren), null, false);
								}
							}
						} else { // others need to be centerReg                            
							particle = template.clone();                            
							if (!particle.centerReg) zimify(particle);
							if (that.trace) {
								particle.centerReg(container).loc(-1000,-1000); // cache was drawing this in center - perhaps missing an update so just move it away
								// particle.centerReg(container)
							} else {
								if (that.layers == "top") {
									particle.centerReg(particles);
								} else {
									particle.centerReg(particles, that.layers=="bottom"?0:zim.rand(particles.numChildren));
								}
							}                           
						}

						if (that.trace) { // still need to add the container if there is one
							if (that.layers == "top") {
								container.addTo(particles, null, false);
							} else {
								container.addTo(particles, that.layers=="bottom"?0:zim.rand(particles.numChildren), false);
							}  
							container.cache(that.traceShiftX, that.traceShiftY, (stage?stage.width:1200)+2*that.traceShiftX, (stage?stage.height:1000)+2*that.traceShiftY);
						}

						if (!that.trace) container = particle;
						container.particle = particle;
						container.originalAlpha = container.alpha;
						particle.originalAlpha = particle.alpha;
						particle.originalScaleX = particle.scaleX;
						particle.originalScaleY = particle.scaleY;
						particle.originalRotation = particle.rotation;
						particle.originalColor = particle.color;
						

					} // END NOT POOL


					that.currentParticle = particle;
					that.particlesEmitted++;

					container.particleNormal = true;
					container.particleDecaying = false;
					container.particleFizzing = false;

					var angle = zim.Pick.choose(that.angle);
					var speed = zim.Pick.choose(that.emitterForce);
					var speedX = speed*Math.cos(angle*Math.PI/180);
					var speedY = speed*Math.sin(angle*Math.PI/180);
					particle.info = {
						position: {x:that.x, y:that.y},
						velocity: {x:speedX, y:speedY},
						sink:zot(that.sinkForce)?null:zik(that.sinkForce)
					};
					if (that.horizontal) particle.info.position = {x:that.x-that.regX+zim.rand(0, that.width), y:that.y-that.regY+(that.vertical?that.height/2:0)};
					if (that.vertical) particle.info.position = {x:that.x-that.regX+(that.horizontal?that.width/2:0), y:that.y-that.regY+zim.rand(0, that.height)};
					if (particle.emitShape) {							
						particle.graphics.mt(particle.info.position.x, particle.info.position.y);
					} else {							
						particle.x = particle.info.position.x,
						particle.y = particle.info.position.y;
					}
					
					particle.alpha = particle.originalAlpha;

                    if (particle.type=="Sprite") {
                        var fNum = Math.floor(Math.random()*particle.totalFrames);
                        particle.run({startFrame:fNum, endFrame:fNum});
                    }
					if (that.random) {
						// {color:[blue, pink, yellow, orange]}
						zim.loop(that.random, function(property, options) {
							var val = zim.Pick.choose(options);
							if (property == "scale") {
								particle.sca(val);
							} else if (property == "frame" && particle.run) {
								particle.run({startFrame:val, endFrame:val});
							} else {
								if (property == "x") {
									particle.info.position.x = (that.horizontal || that.vertical)?val:val+width/2;
								} else if (property == "y") {
									particle.info.position.y = (that.horizontal || that.vertical)?val:val+height/2;
								}
								if ((property == "x" || property == "y") && particle.emitShape) {
									particle.graphics.mt(particle.info.position.x, particle.info.position.y);
								}
								particle[property] = val;
								if (particle.emitShape) {particle.x=0; particle.y = 0;} // just adjust info for x and y of shape
							}
						});
					}

					if (
						cache && 
						!particle.emitShape && 
						particle.type!="Pic" && 
						particle.type!="Bitmap" && 
						particle.type!="Sprite"
					) particle.cache(particle.getBounds().x-10,particle.getBounds().y-10,particle.getBounds().width+20,particle.getBounds().height+20);

					//-------------    DECAY, FADE, SHRINK, FIZZ

					// do not shrink shapes as registration is at 0,0 not at the particle
					var shrinkMe = particle.emitShape?false:that.shrink;

					var myLife = (container?container:particle).life = zik(that.life);

					if (that.decayTime > 0 && (that.fade || shrinkMe || (that.trace && that.traceFadeTime > 0))) {
						// zog(pool)		
						if (that.trace && that.traceFadeTime > 0) {
                            // zog("here")
							container.animate({
								obj:{alpha:0},
								time:that.traceFadeTime,
								wait:myLife-that.traceFadeTime,
								waitedCall:function(t) {
									t.particleNormal = false;
									t.particleFizzing = true;
								},
								call:fizz,
								override:true,
								id:"decay"
							});
						}
						if (that.fade || shrinkMe) {
							var o = {};
							if (that.fade) o.alpha = 0;
							if (shrinkMe) {
								o.scaleX = 0;
								o.scaleY = 0;
							}
					
							// animate seems messed up - recording as if seconds when ms is set
							particle.animate({
								obj:o,
								time:that.decayTime,
								wait:zot(that.decayStart)?myLife-that.decayTime:that.decayStart,
								waitedCall:function(t) {
									if (t.parent != that) t = t.parent; // access container if there is one
									t.particleNormal = false;
									t.particleDecaying = true;
								},
								call:function(t) {
									if (that.events) sendEvent("decayed", t);
									if (t.endSpurt) sendEvent("spurtdecayed", t);
									if (!(that.trace && that.traceFadeTime > 0)) {
										if (zot(that.decayStart) || that.decayStart+that.decayTime>that.life) {
											if (t.parent) fizz(t.parent.trace?t.parent:t); // only want to call fizz once
										} else {
											-function() {
												var c = container;
												zim.timeout(myLife-(that.decayStart+that.decayTime), function(){fizz(c);});
											}();
										}
									}
								},
								override:false,
								id:"decay"
							});
						}
					} else {
						container.life = that.life;
						if (that.life > 0) {
							-function() {
								var c = container;
								c.timeOut = zim.timeout(that.life, function(){fizz(c);});
							}();
						}
					}
					if (that.events) sendEvent("emitted", container);
					spurtCheck(particle);
					if (that.animation) {
						var a = zim.Pick.choose(that.animation);
						if (Array.isArray(a)) {
							zim.loop(a, function(aa) {
								if (zot(aa.override)) aa.override = false;							
								particle.animate(zim.copy(aa));
							});
						} else {
							if (zot(a.override)) a.override = false;							
							particle.animate(zim.copy(a));
						}							
					}
				});
			}

			//-------------  TICKER AND WARM

			var frameRate = 0; // need a new Ticker before can get the framerate so set this after new Ticker
			emitterTicker = that.emitterTicker = zim.Ticker.add(calcEmitter, stage);
			frameRate = 1 / zim.Ticker.framerate;
			
			
			that.focusWarm = focusWarm;
			that.doWarm = function(warm) {				

				if (zot(warm) || warm === true) {
					var max;
					if (life.max) max = life.max;
					else if (Array.isArray(life)) max = zim.arrayMinMax(life).max;
					else max = zik(life);
					var min;
					if (interval.min) min = interval.min;
					else if (Array.isArray(interval)) min = zim.arrayMinmin(interval).min;
					else min = zik(interval);
					warm = Math.min(200, Math.round(max/min));
				}		
				var pool_o = that.pool;
				that.pool = false;
				var ticksPerParticle = Math.round(interval*zim.Ticker.framerate);				
				zim.loop(Math.round(warm*interval*zim.Ticker.framerate), function(i) {
					if (i%ticksPerParticle==0) {
						runEmitter();
					}
					zim.loop(particles, function(particle) {
						if (!particle.warmTick) particle.warmTick = 1;
						else particle.warmTick++;
						if (particle.warmTick/zim.Ticker.framerate > particle.life) fizz(particle)
					});
					calcEmitter();
				});		
				// set animations to percentComplete
				zim.loop(particles, function(particle) {
					if (particle.zimTweens) {
						var spc = particle.warmTick/zim.Ticker.framerate/particle.life*100;
						if (spc >= 100) particle.alpha = 0;	
						particle.percentComplete = spc;	
					}
				});		
				that.pool = pool_o;

			}
			if (warm) that.doWarm(warm);

			function calcEmitter() {
				
				zim.loop(particles, function(particle) {
					if (particle.trace) {
						var particleContainer = particle;
						particle = particle.getChildAt(0);
					}
					var p = particle.info;
					var sinkX = 0;
					var sinkY = 0;
					// will add multiple sinks in the future
					// also - try sink with negative force to deflect
					if (!zot(that.sink)) {
						var b = that.particles.localToGlobal(p.position.x, p.position.y);
						var s;
						if (that.sink.parent && that.sink.parent.localToGlobal) {
							s = that.sink.parent.localToGlobal(that.sink.x, that.sink.y);
						} else {
							s = new createjs.Point(zim.Pick.choose(that.sink.x), zim.Pick.choose(that.sink.y));
						}
						var sinkAngle = zim.angle(b.x, b.y, s.x, s.y);
						sinkX = p.sink*Math.cos(sinkAngle*Math.PI/180);
						sinkY = p.sink*Math.sin(sinkAngle*Math.PI/180);
					}
					var ax = that.wind + sinkX;
					var ay = that.gravity + sinkY;					
					p.velocity.x += ax*frameRate;
					p.velocity.y += ay*frameRate;
					p.position.x += p.velocity.x*frameRate*100;
					p.position.y += p.velocity.y*frameRate*100;
					if (particle.emitShape) {
						particle.graphics.lt(p.position.x, p.position.y);
					} else {
						particle.x = p.position.x;
						particle.y = p.position.y;
					}
					if (that.trace && particleContainer && particleContainer.cacheCanvas) particleContainer.updateCache(particle.emitShape?null:"source-over");
				});					
				
			}			
		}
	}

	that.particles.noMouse();

	//-------------    FUNCTIONS

	function fizz(p) {

		if (that.events) sendEvent("fizzed", p);
		if (p.trace?p.getChildAt(0).endSpurt:p.endSpurt) {
			sendEvent("spurtfizzed", p);
			that.spurting = false;
		}
		if (that.pool) {
			if (p.pooled == "end") {
				// already removed from poolList by clearPool
				// go through and removeChild
			} else if (p.pooled) { // already in the pool
				p.visible = false;					
				return;
			} else { // add to pool and return so does not get removed
				p.pooled = true;
				if (poolList) poolList.push(p);
				p.visible = false;
				return;
			}
		}
		that.removeChild(p);
		if (that.trace) p.uncache();
		p = null;
	}

	function sendEvent(type, object) {
		if (zot(object)) return;
		var e = new createjs.Event(type);
		e.particle = object.trace?object.getChildAt(0):object;
		that.dispatchEvent(e);
	}

	function spurtCheck(p) {
		if (zot(that.spurtCount) && zot(that.spurtNum)) return;
		that.spurtCount++;
		if (that.spurtCount >= that.spurtNum) {
			lastSpurt(p);
		}
	}

	function lastSpurt(p) {
		that.pauseEmitter();
		that.spurtCount = that.spurtNum = null;
		if (zot(p)) return;
		sendEvent("spurted", p);
		p.endSpurt = true;
	}

	//-------------    PROPERTIES

	Object.defineProperty(that, 'interval', {
		get: function() {
			return interval;
		},
		set: function(theInterval) {
			interval = theInterval;
			if (that.zimInterval) that.zimInterval.time = interval;
		}
	});

	//-------------    METHODS

	this.removeFrom = function() {
		// that.removeFrom();
		if (that.parent) that.parent.removeChild(that);
		that.particles.removeFrom();
	};

	this.spurting = false;
	this.spurt = function(num, time, restart) {
		var sig = "num, time, restart";
		var duo; if (duo = zob(that.spurt, arguments, sig)) return duo;
		if (!zot(time)) {
			zim.timeout(zim.Pick.choose(time), function() {
				lastSpurt(that.currentParticle);
			}, true);
			that.spurting = true;
		}
		if (!zot(num)) {
			// handled by checkSpurt() function
			that.spurtNum = zim.Pick.choose(num);
			that.spurtCount = 0;
			that.spurting = true;
		}
		that.pauseEmitter(false, restart, null, true); // unpause and immediately call call interval function
		return that;
	};

	this.clearPool = function() {
		zim.loop(that.particles, function(p) {
			p.pooled="end";
			if (!p.visible) that.removeChild(p);
		},true);
		poolCount = 0;
		poolIndex = 0;
		poolList = [];
	};
	
	if (!that.startEmitterPaused) this.emitterPaused = false; // do not set to false - as it will be done below if needed
	this.pauseEmitter = function(state, restart, freeze, immediate) {
		
		that.startEmitterPaused = null;
		if (zot(state)) state = true;
		if (zot(restart)) restart = false;
		if (zot(freeze)) freeze = false;
		if (state) { // pausing
		if (that.emitterPaused) return that;
		if (freeze) {
			if (emitterTicker) zim.Ticker.remove(emitterTicker);
			zim.loop(that.particles, function(particle) {
				particle.pauseAnimate();
				if (particle.trace) particle.getChildAt(0).pauseAnimate();
					if (particle.timeOut) {
						particle.timeOut.pause();
					}
				});
			}
			that.zimInterval.pause();
			that.emitterPaused = true;
		} else { // unpausing
			if (!that.emitterPaused) return that;
			if (restart) {
				zim.loop(that.particles, function(particle) {
					particle.stopAnimate();
					if (particle.timeOut) particle.timeOut.clear();
					if (particle.trace) particle.getChildAt(0).pauseAnimate();
				});
				that.removeAllChildren();
			}
			if (stage && emitterTicker && !zim.Ticker.has(stage, emitterTicker)) {
				zim.Ticker.add(emitterTicker, stage);
				zim.loop(that.particles, function(particle) {
					particle.pauseAnimate(false);
					if (particle.timeOut) particle.timeOut.pause(false);
					if (particle.trace) particle.getChildAt(0).pauseAnimate(false);
				});
			}
			if (that.zimInterval) that.zimInterval.pause(false, immediate);
			that.emitterPaused = false;
		}
		return that;
	};

	this.resize = function(w, h) {
		if (!zot(w)) width = w;
		if (!zot(h)) height = h;
		that.setBounds(0,0,width,height);
		if (!horizontal && !vertical) that.centerReg();
		that.clearPool();
	};

	if (style!==false) zim.styleTransforms(this, DS);

	this.clone = function(exact) {
		var objClone;
		if (Array.isArray(that.obj) || that.obj.constructor == {}.constructor) {
			objClone = zim.copy(that.obj);
		} else if (that.obj.clone) {
			objClone = that.obj.clone(exact);
		} else {
			objClone = that.obj;
		}
		// note that all will clone the current property except for startEmitterPaused which clones the initial parameter value
		return that.cloneProps(new zim.Emitter(objClone, width, height, that.interval, that.num, that.life, that.fade, that.shrink, warm, that.decayTime, that.decayStart, that.trace, that.traceFadeTime, that.traceShiftX, that.traceShiftY, that.angle, that.emitterForce, that.gravity, that.wind, that.layers, that.animation, zim.copy(that.random), that.horizontal, that.vertical, that.sink, that.sinkForce, cache, that.events, startPaused, that.pool, that.poolMin, particles, focusWarm, style, that.group, inherit));
	};

	this.dispose = function() {
		if (that.zimInterval) that.zimInterval.clear();
		if (emitterTicker) {
			zim.Ticker.remove(emitterTicker);
		}
		zim.loop(poolList, function(particle) {
			if (particle) particle.dispose();
		});			
		if (particles && particles.dispose) particles.dispose();
		if (that.currentParticle && that.currentParticle.dispose) that.currentParticle.dispose();
		if (obj && Array.isArray(obj)) {
			zim.loop(obj, function (el) {
				if (el.dispose) el.dispose();
			});
		} else {
			if (obj && obj.dispose) obj.dispose();
		}
		particles = that.currentParticle = that.particles = obj = that.obj = poolList = that.poolList = null;
		return true;
	};
};
zim.extend(zim.Emitter, zim.Container, "clone", "zimContainer", false);
//-69.9

/*--
zim.Generator = function(color, strokeColor, strokeWidth, draw, stamp, setup, maxCount, boundary, drawCount, drawPause, drawSpacebarPause, startX, startY, cache, recordLinePoints, frame, seed, output, outputType, style, group, inherit)

Generator
zim class - extends a ZIM Container which extends a CreateJS Container

DESCRIPTION
Used for dynamic drawing such as generative art or visualizations.
Generator provides a set of RELATIVE drawing commands
that primarily match the traditional absolute drawing commands for shapes on the canvas.
Rather than add all these commands to the Shape class they have been added to the Generator class.
This optimizes the Shape class which is used for all components and ZIM shapes.

HOW IT WORKS
The arrangement is similar to Processing (or P5js for a JS version).
There is one Shape that gets drawn into and code can be put in three different callback functions:

setup - happens once at the start (similar to Processing)
draw - happens at the framerate (similar to Processing)
stamp - loops all at once (different that Processing?)

SETUP
The optional setup runs once before the draw or stamp functions run.
This function will not be used as much as in Processing because ZIM has a Frame().
Also, things can be set up before the Generator code is called.
And the Generator class has parameters for color, strokeColor and strokeWidth.
Generator defaults to start at the center of the stage - so in the setup,
translate(-W/2, -H/2) could be used to start at the top left.
Setup can be run again with resetup()

DRAW
The optional draw function runs at the framerate and receives count, total and shape parameters.
This will have the affect of animating the drawing as it "processes" the code
By default, this will pause and unpause when the screen or the spacebar is pressed.
Draw can be drawn again with redraw()

STAMP
The optional stamp function runs inside a loop and produces the final drawing at once.
The function receives count, total, shape and stampNum parameters.
You can switch between the stamp and draw function with the same code inside.
The end product will be the same.
Stamps can be stamped again with restamp()

RELATIVE
The draw and stamp work the same way, running the code inside for each count.
The magic happens because the commands are relative.
Even g.rectangle().rotate(5) is beautiful.
Each new rectangle after the first will be rotated 5 degrees
In absolute space, the corner points would have to be calculated with sine and cosine - ew.
Generator does the matrix calculations to avoid this.
Each new command starts where the last command left off.
But each command also has an x and y value to translate if desired.
This x and y value is relative to the current rotation and scale.
Often, the x and y is left at 0, 0.
We considered removing them as parameters because translate() can be called
but we left them in to be the same as Processing.

COUNT, PAUSE AND STEP
The count parameter of draw or stamp suplies the current count.
This provides ways to modify commands.
for instance circle(0,0,count*10); will draw circles that get bigger.
This can also be used to set the rate of change - often by using smaller factors such as count*.01, etc.
Count can also be used to pause or do something different at certain places in the drawing
Pause also has an optional number of seconds to pause or a ZIM interval() and pause(false) can be used.
Generator has a count property which can be set to go forward or back to a certain count.
Step calls a step - usually used when pause is true - an interval could then be used for steps

PUSH AND POP
There is also push() and pop() as in Processing.
These remember the position, rotation, scale and skew when push() is used
and then return the generator to these settings when pop() is used.
Multiple pushes can be set and then popped back.
These can be used to make fractals with recursive branching.

CLEAR AND RESET 
The clear() method will clear the image but keep the transforms 
The reset() method will reset the transforms, set to startX and startY and reset color, strokeColor and strokeWidth
These can also be called through resetup(), redraw() and restamp()

EXPORT 
Generator() can export frames as images that can then be compiled into a video.
Set the output parameter to true or a file prefix string (otherwise the prefix will be gen).
This will make Generator() use draw (even if stamp is set) 
at 6 frames per second so the Browser can handle file saves. 
The files will be saved with 6 numbers: gen_000000.png, gen_000001.png, etc.
They will be saved in your Browser's default downloads so MOVE them into a folder of their own.
See the note at bottom about enabling Browser Automatic Downloads.
NOTE: the canvas background color does not show up 
	if desired, add a new Rectangle(W, H, F.color).addTo().bot();
NOTE: Generator() will output the first image before it starts drawing. 
	You can delete the first image if you want the video to start at the first drawn frame.
NOTE: FFmpeg is suggested but there are other options such as https://github.com/spite/ccapture.js
	Or screen capture software such as OBS - if just posting to Twitter and quality does not matter.
Instructions to make a video from saved image series:
	Download FFmpeg: https://zimjs.org/cdn/ffmpeg.zip, UNZIP it and put it INTO the image folder. 
	Open a command line.  On PC, type "command" into the Windows search box then on the command line type:
	cd \path\to\images or to change drive use /d like cd /d E:\path\to\images
	Once in the directory with your images type (or paste) something like:
	ffmpeg -r 60 -f image2 -s 1024x768 -i gen_%06d.png -vcodec libx264 -crf 25 -pix_fmt yuv420p final.mp4
	You can read about these at https://www.ffmpeg.org/ffmpeg.html (but would not bother)
		-r framerate (fps)
		-f canonical form (image2 to work with image sequences)
		-s resolution
		-i file name to find with %06 representing 6 decimal placeholder
		-vcodec codec
		-crf quality - the lower the better... 10-30 is fine
		-pix_fmt pixel format
		final.mp4 the output video
NOTE: to enable Multiple File Downloads in Chrome "simply" go to 
menu > Settings > Privacy & Security > Site Setting > 
Permissions > Addtional Permissions > Automatic Downloads > turn Ask ON 
We found that ADD site: file:///path/ to local file did not seem to prevent Chrome from asking. 
And part way through Chrome asked again for permission to download but the process still worked.
Alternatively, we could look at saving Blobs (data) of the images but the download process works.
	

GENERAL EXAMPLES
SEE: https://zimjs.com/cat/generator.html
SEE: https://zimjs.com/codepen/bloob.html // for animating stamps with noise

NOTE: The drawing uses matrix transforms on Shape which takes the shape out of traditional positioning.
A drawing property is available on the Generator that points to a Container that holds the drawing.
This container can be moved, dragged, etc. so use this to manipulate the drawing in a traditional manner.
The generator has a shape property which can be used to access the raw shape for absolute drawing for instance.

NOTE: The drawing container is automatically added to the default stage as the Generator is created

NOTE: if manually caching generator.shape or generator.drawing, 
there is a slight time delay before shape is drawn so cache when the "complete" event is called 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// Draw a line from the center of the stage to 100 pixels to the right
// usually we draw inside a draw or stamp function
const g = new Generator();
g.line(0,0,100,0);
END EXAMPLE

EXAMPLE
// draw an octagon - stop at 8 lines
const g = new Generator({draw:gen});
function gen(count) {
	g.line(0,0,100,0).rotate(45);
	if (count == 8) g.stop();
}

// or use maxCount:
const g = new Generator({draw:gen, maxCount:8});
function gen(count) {
	g.line(0,0,100,0).rotate(45);
}

// make a Blob with points of drawing
// could set interactive:false on Blob for just filled in picture
// lines will not fill in Generator
// shapes fill and curves fill themselves but not collectively
const g = new Generator({stamp:gen, maxCount:8, recordLinePoints:true});
function gen(count) {
	g.line(0,0,100,0).rotate(45);
}
g.on("complete", makeBlob);
function makeBlob() {
	new Blob({points:g.linePoints, color:red}).addTo();
	g.drawing.removeFrom()
	S.update();
}
END EXAMPLE

EXAMPLE
// draw a fan of lines always going back to 0,0
const g = new Generator({draw:gen, maxCount:360/5});
function gen(count) {
	g.line(0,0,200,0).translate(-200).rotate(5);
}

// or stamp the fan of lines:
const g = new Generator({stamp:gen, maxCount:8});
function gen(count) {
	g.line(0,0,100,0).rotate(45);
}

// make random color lines with a hole in the middle and draggable
const g = new Generator({stamp:gen, strokeColor:[red,pink,purple], strokeWidth:2, maxCount:360/5});
function gen(count) {
	g.line(50,0,200,0).translate(-250).rotate(5);
}
g.drawing.drag();

// make a series of color lines with a hole in the middle and draggable
// using push() and pop() to not think about how to reset!
// so... draw a line, go back to how it was before drawing, rotate, then draw a line, etc.
// each time it draws the line it chooses the next ZIM VEE value in the series
const g = new Generator({stamp:gen, strokeColor:series(yellow,green,orange), strokeWidth:5, maxCount:360/5});
function gen(count) {
	g.push().line(50,0,200,0).pop().rotate(5);
}

// add a circle to the end
const g = new Generator({stamp:gen, strokeColor:series(yellow,green,orange), strokeWidth:5, maxCount:360/5});
function gen(count) {
	g.push().line(50,0,200,0).circle(15,0,5).pop().rotate(5);
}

// removing circle stroke and adding fill the same color as the stroke
// note, do not remove the stroke first or the currentColor will be null
// currentColor is the applied color from the ZIM VEE value
const g = new Generator({draw:gen, strokeColor:series(yellow,green,orange), strokeWidth:5, maxCount:360/5});
function gen(count) {
	g.push()
		.line(50,0,200,0)
		.fill(g.currentStrokeColor)
		.noStroke()
		.circle(15,0,5)
	 .pop()
	 .rotate(5);
}
END EXAMPLE

EXAMPLE
// using ZIM VEE series to adjust stroke color and width
const g = new Generator({draw:gen, maxCount:360/2, strokeColor:green});
const s = series({min:1, max:4}).step(.1).bounce(); // stroke sizes
const c = series(blue,pink,green).every(12); // color change
function gen(count, total, g) {
	g
		.rectangle(0,0,200,200)
		.stroke(g.currentStrokeColor.toColor(c,.3), s) // blend color change
		.rotate(2);
}
END EXAMPLE

EXAMPLE
// Clone example
const g1 = new Generator({draw:gen, maxCount:360/10});
function gen(count, total, g) {
	// note: we have three generators calling this function
	// so collect and use the generator g that is calling gen()
	g.rectangle(0,0,100,100).rotate(10);
}
const g2 = g1.clone();
g2.drawing.mov(100);
const g3 = g1.clone();
g3.drawing.mov(-100);
END EXAMPLE

EXAMPLE
// draw rectangles that get smaller and translate like a starfish
const g = new Generator({
	draw:gen,
	color:series(yellow,green,orange),
	strokeColor:white,
	strokeWidth:3,
	maxCount:100/.3
});
function gen(count, total) {
	var mod = count*.3
	 g.rectangle(mod, mod, 100-mod, 100-mod, 0).rotate(30);
}
END EXAMPLE

EXAMPLE
// common processing tree
const g = new Generator({
	strokeColor:green,
	strokeWidth:2,
	setup:gen
});
function gen() {
	var length = 150;
	g.translate(0, H/2);
	branch(150, 5);
	// recursive function - not stamp or draw
	function branch(length, thickness) {
		g.line(0,0,0,-length);
		if (length > 4) {
			g.push().rotate(30);
			branch(length*.75);
			g.pop().push().rotate(-30);
			branch(length*.75);
			g.pop();
		}
	}
}
END EXAMPLE

EXAMPLE 
// Using restamp to animate Generator
// Radial Animation and Noise - also see: 
https://codepen.io/danzen/pen/ExgQRjW
https://codepen.io/zimjs/pen/XWjrmoQ
https://codepen.io/zimjs/pen/jOMZjOy

const segments = 30; // how many lines
const delta = 360/segments; // angle between each line
const inner = 100; // inner radius
const outer = 300; // outer radius
const variation = outer-inner; // maximum noise

let c = 1;    // curve factor 
let s = .02;    // speed factor
let t = 0;      // time

// The ZIM Generator() works somewhat like Processing / P5js.
// Setting stamp instead of draw will draw all generations immediately 
// rather than one generation at a time.
const g = new Generator({
	stamp:gen,
	strokeWidth:2,
	maxCount:segments        
});

function gen(count) {  
	let angle = delta*count*RAD;  // (0-360 degrees in radians)
	// use sin and cos to make noise values join back at same place                   
	let noise = g.noise(c*Math.sin(angle), c*Math.cos(angle), t); 
	let radius = inner+variation*noise;
	g.push()
		g.push().line(0,0,radius,0).pop().line(radius,-5,0,10);
	g.pop()   
	g.rotate(delta); // rotate delta each time         
}

Ticker.add(()=>{
	t+=s; // set the speed through the noise
	g.restamp();
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)

color - |ZIM VEE| (default null) the fill color of shapes and individual curves (lines do not fill like in normal shape drawing)
strokeColor - |ZIM VEE| (default white) the color of the stroke or shape border
strokeWidth - |ZIM VEE| (default 1) the thickness of the stroke or shape border
draw - (default null) an optional function to call within an internal ZIM new Ticker that runs at the frame rate
	draw will receive count, maxCount and generator parameters
	will result in the same drawing as the stamp function but animates the drawing
stamp - (default null) an optional function to call within an internal ZIM loop
	stamp will receive count, maxCount and generator parameters
	will result in the same drawing as the draw function but happens right away (or within syncronous processing time)
setup - (default null) an optional function to call before the stamp or call functions run
	setup will receive count (0), maxCount and generator parameters
maxCount - (default 1000) the maximum number of times the stamp or draw functions will run
boundary - (default null) the drawing size if cache is true
drawCount - (default 1) the count per draw.  Set to a higher number to slow down the drawing (2 is twice as long)
drawPause - (default true) set to false to not pause the draw function on stage mousedown
	will dispatch "generatorpaused" and "generatorunpaused" events
	note the pause() method as well to handle pauses manually
drawSpacebarPause - (default true) set to false to not pause the draw function when the spacebar key is pressed
	will dispatch "generatorpaused" and "generatorunpaused" events
	note the pause() method as well to handle pauses manually
startX - (default S.width/2) set to 0 to start at stage left, etc.
startY - (default S.height/2) set to 0 to start at stage top, etc.
cache - (default false) set to true to cache image and boost performance - especially when dragging a complex drawing afterwards
	if you notice performance issues then set cache to true
	setting cache to true will be a little blurry
	NOTE: if manually caching shape, there is a slight time delay before shape is drawn so use the "complete" event to applying cache()
recordLinePoints - (default false) set to true to record the end points of line() commands
	set to "nonzero" to also record non-zero start points
	set to "zero" to also record 0,0 start points (and non-zero start points (and end points)))
	see the linePoints property to retrieve the array as [[x,y], [x,y], [x,y], etc.]
frame - (default zimDefaultFrame) change to another frame if not drawing in the zimDefaultFrame
seed - (default null) a specific seed for the Generator Noise - otherwise random
output - (default null) set to true to export frames as images
	set to a string to change the prefix of the file names to something other than "gen" 
	output will export a series of images with six digits.  
	The images can be compiled into a video 
	SEE the EXPORT section at the bottom of the Generator() docs description.
	Also see outputType 
outputType - (default "png") or set to "jpeg" - the file type used if the output parameter is set to true 
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
** ALL PARAMETER BELOW SUPPORT |ZIM VEE|
** These are relative shape commands similar to traditional shape commands (see Shape on Docs)
** Note that the curves also include an x and y as the first two parameters
** Methods return the generator for chaining (unless otherwise specified)
fill(color) - sets the color or no fill if left empty or null is passed in
	also see lighten(), darken(), toColor()
stroke(color, size) - sets the stroke color and / or stroke size
	leaving one empty or null will not adjust that parameter - see noStroke() to remove stroke
	also see lighten(), darken(), toColor(), thicken()
noStroke() - turn the stroke off
translate(x, y) - move the location relatively
	if the shape is rotated then translate(100) will move along the rotation angle
rotate(degrees) - relatively rotate future drawing by this angle - does not affect previously drawn shapes
setScale(x, y) - relatively scale future drawing by this amount - does not affect previously drawn shapes
	leaving y out will scale both x and y the same
	** scale(x, y) is DEPRECATED - it works for now, but might be removed as it conflicts with DisplayObject.scale property 
skew(x, y) - relatively skew future drawing by this angle - does not affect previously drawn shapes
	leaving y out will NOT skew the y
line(x1, y1, x2, y2) - draw a line from the start x and y to the end x and y
	this will be oriented to the current rotation and scaled and skewed to the current scale and skew settings
arc(x, y, radius, startAngle, endAngle, anticlockwise) - an arc that will be adjusted to current transform settings
curve(x1, y1, cpx, cpy, x2, y2) - a quadratic curve that will be adjusted to current transform settings
	x1 and y1 - the start point - note the Shape qt() or CreateJS graphics.curveTo() do not include this start point
	cpx and cpy - control point adjusted relatively to current transform settings
	x2 and y2 - the final point adjusted relatively to current transform settings
bezier(x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) - a cubic bezier curve that will be adjusted to current transform settings
	x1 and y1 - the start point - note the Shape bt() or CreateJS graphics.bezierTo() do not include this start point
	cp1x and cp1y - control point for the first point's Bezier handle adjusted relatively to current transform settings
	cp2x and cp2y - control point for the second point's Bezier handle adjusted relatively to current transform settings
	x2 and y2 - the final point adjusted relatively to current transform settings
rectangle(x, y, w, h, a, b, c, d) - a rectangle if x, y, w, h are provided
	a, b, c, d are for rounding the corners
		if only a is provided then all corners will round to a
		otherwise they start at the top left and go clockwise to bottom left
		a: topLeft, b:topRight, c:bottomRight, d:bottomLeft
circle(x, y, radius, percent, percentClose) - a circle
	with percent like the ZIM Circle() - to make a semicircle
	and percentClose (default true) to close the path of the semicircle
oval(x, y, w, h) - an oval specified by with width and height which will be adjusted relative to current transform settings
poly(x, y, radius, sides, pointSize, angle) - a polygon like the ZIM Poly() but with x,y and angle parameter
	radius - (default 50) the radius (from the center to the edge or half the diameter) ;-)
	sides - (default 5) the number of sides
	pointSize - (default 0) a factor that will indent or outdent the sides to form stars
		0 is no indent - 1 is a complete indent - which will have no fill and if there is a border will look like a stick figure
		beyond 1 is cool - it overlaps on itself and makes multiple patterns
	angle - (default 0) along the relative x axis - different than Poly() which rotates negaitve 90 to start
** ALL PARAMETERS ABOVE SUPPORT |ZIM VEE|
push() - remember the current transform properties (x,y,rotation,scale,skew) and color and stroke properties
	see pop() to return to these remembered property settings
	note push() can be used any number of times before pop() is used, effectively nesting remembered states
pop() - return to the remembered transform properties (x,y,rotation,scale,skew) and color and stroke properties
	see push() to set remembered properties
	note push() can be used any number of times before pop() is used, effectively nesting remembered states
step() - advance the draw function one time - good for when the generator is paused to then step through calculations
blit() - write to drawing cache - if cache is true - done automatically if using draw, stamp or setup
pause(state, time) - pause or unpause the generator with optional time in seconds (see ZIM TIME constant)
	will dispatch a "paused" and "unpaused" event - different than the "generatorpaused" and "generatorunpaused" for stage mousedown and spacebar key
stop() - stops the Generator at which point it cannot be started - just make a new one
noise(a,b,c,d) - ZIM Noise simplex method 1,2,3,4 depending on number of parameters 
	returns a value from 0 to 1 as opposed to the simplex methods which return from -1 to 1
	see also the seed parameter for Generator which will seed this Noise
	see https://zimjs.com/codepen/bloob.html for a good explanation and example of using Noise with Generator 
clear() - clears the shape 
reset() - sets the transforms back to 0 (rotation, scale, skew) and sets the x and y to startX and startY
	also sets the color, strokeColor and strokeWidth back to original values
resetup(clear) - resets and calls the setup function again 
	clear defaults to true - set to false to not clear the drawing
redraw(clear, setup) - redraw starting from count 0 
	clear and setup default to true
	set to false to not clear or not call setup
restamp(clear, setup) - restamp starting from count 0 
	clear and setup default to true
	set to false to not clear or not call setup
	calling restamp increases the stampNum property - also available as the fourth parameter in stamp 
	this can be used to animate stamps for instance adjusting a noise input
	https://zimjs.com/codepen/bloob.html 
clone() - create another generator with the same settings
	The clone will call the same setup, draw and stamp functions,
	so use the generator parameter in these functions to draw into the specific generator drawings
	eg. draw(count, total, g) {g.rectangle(0,0,100,100).rotate(5)}
 	To make a copy of generator output, clone() the generator.drawing
dispose() - stops and disposes the Generator - the drawing may still need to be removed

ALSO ZIM 4TH adds all the methods listed under Container (see above), such as:
** THESE NEED to be used on the Generator drawing property
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO See the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
drawing - reference to the ZIM Container that holds the drawing shape
	automatically added to the stage when new Generator() is made
	** use this for applying ZIM methods and properties to the drawing
shape - reference to the ZIM Shape object being draw into
	** because of the matrix being used, this does not respond to position methods or properties
	see the drawing property above to drag, animate, loc, etc.
count - the current count in the draw or stamp loop
maxCount - the number the draw or stamp loop will loop to
drawCount - how many counts go by until the draw function runs - default is 1 for each count
	setting to 2 will draw twice as slow, 10 will draw ten times as slow, etc.
stampCount - how many times the stamp function has been called with restamp()
	this is also passed in as the fourth parameter to the stamp function
color - |ZIM VEE| get the current color - will set too but not until the next draw - use the fill() method
	this could be a ZIM VEE value - also see currentColor for the color actually being applied (after ZIM VEE is picked)
currentColor - the actual color being applied (after ZIM VEE is picked)
strokeColor - |ZIM VEE| get the current strokeColor - will set too but not until the next draw - use the stroke() method
	this could be a ZIM VEE value - also see currentStrokeColor for the color actually being applied (after ZIM VEE is picked)
currentStrokeColor - the actual stroke color being applied (after ZIM VEE is picked)
strokeWidth - |ZIM VEE| get the current strokeWidth - will set too but not until the next draw - use the stroke() method
	this could be a ZIM VEE value - also see currentStrokeWidth for the color actually being applied (after ZIM VEE is picked)
currentStrokeWidth - the actual stroke width being applied (after ZIM VEE is picked)
currentX - get the current x value
currentY - get the current y value
linePoints - if the recordLinePoints parameter is true then this is an array of [x,y] values
paused - read only as to the pause state of the Generator - see also pause() method
stack - current array of push() remembered transforms stored as a matrix
colorStrokeStack - current array of push() remembered color, strokeColor, strokeWidth, currentColor, currentStrokeColor and currentStrokeWidth properties

ALSO See the CreateJS Easel Docs for Container properties, such as:
** THESE NEED to be used on the Generator drawing property
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "drawing" event each time the draw function is called - not used for stamp function
dispatches a "complete" event when maxCount has been reached - not dispatched if stop() is called
dispatches "paused" and "unpaused" events when pause() is used (and time of time parameter has finished)
dispatches "generatorpaused" and "generatorunpaused" events when stage mousedown or space key is pressed
and drawpause or drawSpacebarPause parameters are true
--*///+69.92
	zim.Generator = function(color, strokeColor, strokeWidth, draw, stamp, setup, maxCount, boundary, drawCount, drawPause, drawSpacebarPause, startX, startY, cache, recordLinePoints, frame, seed, output, outputType, style, group, inherit) {
		var sig = "color, strokeColor, strokeWidth, draw, stamp, setup, maxCount, boundary, drawCount, drawPause, drawSpacebarPause, startX, startY, cache, recordLinePoints, frame, seed, output, outputType, style, group, inherit";
		var duo;
		if (duo = zob(zim.Generator, arguments, sig, this)) return duo;
		z_d("69.92");
		this.group = group;
		var DS = style === false ? {} : zim.getStyle("Generator", this.group, inherit);

		if (zot(frame)) frame = DS.frame != null ? DS.frame : WW.zdf;
		var stage = frame.stage;

		if (zot(color)) color = DS.color != null ? DS.color : null;
		if (zot(strokeColor)) strokeColor = DS.strokeColor != null ? DS.strokeColor : zim.white;
		if (zot(strokeWidth)) strokeWidth = DS.strokeWidth != null ? DS.strokeWidth : 1;
		if (zot(maxCount)) maxCount = DS.maxCount != null ? DS.maxCount : 1000;
		if (zot(boundary)) boundary = DS.boundary != null ? DS.boundary : new zim.Boundary(0, 0, stage.width, stage.height);
		if (zot(drawCount)) drawCount = DS.drawCount != null ? DS.drawCount : 1;
		if (zot(drawPause)) drawPause = DS.drawPause != null ? DS.drawPause : true;
		if (zot(drawSpacebarPause)) drawSpacebarPause = DS.drawSpacebarPause != null ? DS.drawSpacebarPause : true;
		if (zot(startX)) startX = DS.startX != null ? DS.startX : stage.width / 2;
		if (zot(startY)) startY = DS.startY != null ? DS.startY : stage.height / 2;
		if (zot(cache)) cache = DS.cache != null ? DS.cache : false;

		// without adding the shape to a container it would not be draggable or movable
		// something to do with Shape and matrix
		var drawing = this.drawing = new zim.Container(boundary.x, boundary.y, boundary.width, boundary.height).addTo(stage);
		var shape = this.shape = new zim.Shape(boundary.width, boundary.height).addTo(drawing);

		this.drawCount = drawCount;
		if (zot(drawPause)) drawPause = true;

		if (cache) shape.cache(boundary.x, boundary.y, boundary.width, boundary.height);
		this.zimContainer_constructor(boundary.x, boundary.y, boundary.width, boundary.height);
		this.type = "Generator";

		var that = this;
		that.draw = null;

		if (output) {
			that.drawCount = 10;
			if (!zot(stamp) && zot(draw)) draw = stamp;
			stamp = null;
			var loader = new zim.Loader();
			that.outputNum = 0;
			that.outputName = output === true ? "gen_" : output.match(/_$/) ? output : output + "_";
		}

		// that.resetColor = false; // used to determine reseting colors and stroke each iteration based on VEE
		// that.resetStroke = false; // used to determine reseting colors and stroke each iteration based on VEE
		this.color = color;
		this.strokeColor = strokeColor;
		this.strokeWidth = strokeWidth;
		var cX = startX;
		var cY = startY;

		// METHODS

		this.fill = function(color) {
			that.color = color;
			// testReset();
			that.currentColor = zik(that.color);
			shape.f(that.currentColor);
			return this;
		};
		this.stroke = function(color, size) {
			// testReset();
			if (!zot(color)) {
				that.strokeColor = color;
				that.currentStrokeColor = zik(that.strokeColor);
				shape.s(that.currentStrokeColor);
			}
			if (!zot(size)) {
				that.strokeWidth = size;
				that.currentStrokeWidth = zik(that.strokeWidth);
				shape.ss(that.currentStrokeWidth);
			}
			return this;
		};

		this.noStroke = function() {
			that.strokeColor = that.currentStrokeColor = null;
			that.strokeWidth = that.currentStrokeWidth = null;
			shape.s();
			shape.ss(1);
			return this;
		};
		// // trying to get line() to fill - do not know why it does not
		// // am restarting fill for VEE but this code would not... and it still did not fill.
		// function testReset() {
		// 	that.resetColor = false;
		// 	that.resetStroke = false;
		// 	if (that.color && isPick(that.color)) that.resetColor = true;
		// 	if ((that.strokeColor && isPick(that.strokeColor)) || (that.strokeWidth && isPick(that.strokeWidth))) that.resetStroke = true;
		// 	zog(that.resetColor, that.resetStroke)
		// }

		shape.matrix = shape.getMatrix();
		this.translate = function(x, y) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			x = zik(x);
			y = zik(y);
			var point = shape.matrix.transformPoint(x, y);
			cX = point.x;
			cY = point.y;
			shape.mt(cX, cY);
			shape.matrix.translate(x, y);
			return this;
		};
		this.rotate = function(a) {
			if (zot(a)) a = 0;
			a = zik(a);
			shape.matrix.rotate(a);
			return this;
		};
		this.scale = function(x, y) {
			if (zot(x)) x = 1;
			if (zot(y)) y = x;
			x = zik(x);
			y = zik(y);
			shape.matrix.scale(x, y);
			return this;
		};
		this.setScale = this.scale;
		this.skew = function(x, y) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			x = zik(x);
			y = zik(y);
			shape.matrix.skew(x, y);
			return this;
		};
		if (recordLinePoints) that.linePoints = [];
		this.line = function(x1, y1, x2, y2) {
			if (zot(x1)) x1 = 0;
			if (zot(y1)) y1 = 0;
			if (zot(x2)) x2 = 0;
			if (zot(y2)) y2 = 0;

			x1 = zik(x1);
			y1 = zik(y1);
			x2 = zik(x2);
			y2 = zik(y2);

			if (recordLinePoints == "zero" || (recordLinePoints == "nonzero" && x1 && y1)) that.linePoints.push([x1, y1]);
			that.translate(x1, y1);
			var point = shape.matrix.transformPoint(x2, y2);
			cX = point.x;
			cY = point.y;
			shape.lt(cX, cY);
			if (recordLinePoints) that.linePoints.push([cX, cY]);
			shape.matrix.translate(x2, y2);
			return this;
		};

		this.arc = function(x, y, radius, startAngle, endAngle, anticlockwise) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(radius)) radius = 50;

			x = zik(x);
			y = zik(y);
			radius = zik(radius);

			radius = Math.abs(radius);

			if (zot(startAngle)) startAngle = 0;
			if (zot(endAngle)) endAngle = 180;
			startAngle = zik(startAngle);
			endAngle = zik(endAngle);

			if (zot(anticlockwise)) anticlockwise = false;
			anticlockwise = zik(anticlockwise);

			that.translate(x, y);
			var center = shape.matrix.transformPoint(0, 0);

			if (!shape.decomp) shape.decomp = {};
			shape.matrix.decompose(shape.decomp);
			var s = (Math.abs(shape.decomp.scaleX) + Math.abs(shape.decomp.scaleY)) / 2;
			var ro = shape.decomp.rotation || 0;
			var r = radius * s;

			shape.mt(center.x + r * Math.cos((startAngle + ro) * Math.PI / 180), center.y + r * Math.sin((startAngle + ro) * Math.PI / 180));
			shape.a(center.x, center.y, r, (startAngle + ro) * Math.PI / 180, (endAngle + ro) * Math.PI / 180, anticlockwise);
			return this;
		};

		this.curve = function(x1, y1, cpx, cpy, x2, y2) {
			if (zot(x1)) x1 = 0;
			if (zot(y1)) y1 = 0;
			if (zot(cpx)) cpx = 50;
			if (zot(cpy)) cpy = 50;
			if (zot(x2)) x2 = 100;
			if (zot(y2)) y2 = 0;

			x1 = zik(x1);
			y1 = zik(y1);
			cpx = zik(cpx);
			cpy = zik(cpy);
			x2 = zik(x2);
			y2 = zik(y2);

			that.translate(x1, y1);
			var control = shape.matrix.transformPoint(cpx, cpy);
			var point = shape.matrix.transformPoint(x2, y2);
			var pX = point.x;
			var pY = point.y;
			shape.qt(control.x, control.y, pX, pY);
			shape.matrix.translate(x2, y2);
			return this;
		};

		this.bezier = function(x1, y1, cp1x, cp1y, cp2x, cp2y, x2, y2) {
			if (zot(x1)) x1 = 0;
			if (zot(y1)) y1 = 0;
			if (zot(cp1x)) cp1x = 50;
			if (zot(cp1y)) cp1y = 50;
			if (zot(cp2x)) cp2x = -50;
			if (zot(cp2y)) cp2y = -50;
			if (zot(x2)) x2 = 100;
			if (zot(y2)) y2 = 0;

			x1 = zik(x1);
			y1 = zik(y1);
			cp1x = zik(cp1x);
			cp1y = zik(cp1y);
			cp2x = zik(cp2x);
			cp2y = zik(cp2y);
			x2 = zik(x2);
			y2 = zik(y2);

			that.translate(x1, y1);
			var control1 = shape.matrix.transformPoint(cp1x, cp1y);
			var control2 = shape.matrix.transformPoint(cp2x, cp2y);
			var point = shape.matrix.transformPoint(x2, y2);
			var pX = point.x;
			var pY = point.y;
			shape.bt(control1.x, control1.y, control2.x, control2.y, pX, pY);
			shape.matrix.translate(x2, y2);
			return this;
		};

		this.rectangle = function(x, y, w, h, rTL, rTR, rBR, rBL) {

			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(w)) w = 100;
			if (zot(h)) h = w;

			x = zik(x);
			y = zik(y);
			w = zik(w);
			h = zik(h);

			if (!rTL && !rTR && !rBR && !rBL) {

				that.translate(x, y);

				var pTL = shape.matrix.transformPoint(0, 0);
				var pTR = shape.matrix.transformPoint(w, 0);
				var pBR = shape.matrix.transformPoint(w, h);
				var pBL = shape.matrix.transformPoint(0, h);

				shape.mt(pTL.x, pTL.y).lt(pTR.x, pTR.y).lt(pBR.x, pBR.y).lt(pBL.x, pBL.y).lt(pTL.x, pTL.y).lt(pTR.x, pTR.y);
				shape.mt(pTL.x, pTL.y);

				return this;
			}

			if (zot(rTL)) rTL = 0;
			if (zot(rTR)) rTR = rTL;
			if (zot(rBR)) rBR = rTL;
			if (zot(rBL)) rBL = rTL;

			rTL = zik(rTL);
			rTR = zik(rTR);
			rBR = zik(rBR);
			rBL = zik(rBL);

			var max = (w < h ? w : h) / 2;
			var mTL = 0,
				mTR = 0,
				mBR = 0,
				mBL = 0;
			max = Math.abs(max);

			if (rTL < 0) {
				rTL *= (mTL = -1);
			}
			if (rTL > max) {
				rTL = max;
			}
			if (rTR < 0) {
				rTR *= (mTR = -1);
			}
			if (rTR > max) {
				rTR = max;
			}
			if (rBR < 0) {
				rBR *= (mBR = -1);
			}
			if (rBR > max) {
				rBR = max;
			}
			if (rBL < 0) {
				rBL *= (mBL = -1);
			}
			if (rBL > max) {
				rBL = max;
			}

			that.translate(x, y);

			if (!shape.decomp) shape.decomp = {};
			shape.matrix.decompose(shape.decomp);
			var s = (Math.abs(shape.decomp.scaleX) + Math.abs(shape.decomp.scaleY)) / 2;

			var signH = (w < 0) ? -1 : 1;
			var signV = (h < 0) ? -1 : 1;

			var a = shape.matrix.transformPoint(w - rTR * signH, 0);
			var b = shape.matrix.transformPoint(w + rTR * mTR * signH, -rTR * mTR * signV);
			var c = shape.matrix.transformPoint(w, rTR * signV);

			var d = shape.matrix.transformPoint(w, h - rBR * signV);
			var e = shape.matrix.transformPoint(w + rBR * mBR * signH, h + rBR * mBR * signV);
			var f = shape.matrix.transformPoint(w - rBR * signH, h);

			var g = shape.matrix.transformPoint(rBL * signH, h);
			var i = shape.matrix.transformPoint(-rBL * mBL * signH, h + rBL * mBL * signV);
			var j = shape.matrix.transformPoint(0, h - rBL * signV);

			var k = shape.matrix.transformPoint(0, rTL * signV);
			var l = shape.matrix.transformPoint(-rTL * mTL * signH, -rTL * mTL * signV);
			var m = shape.matrix.transformPoint(rTL * signH, 0);

			shape
				.mt(a.x, a.y).at(b.x, b.y, c.x, c.y, rTR * s)
				.lt(d.x, d.y).at(e.x, e.y, f.x, f.y, rBR * s)
				.lt(g.x, g.y).at(i.x, i.y, j.x, j.y, rBL * s)
				.lt(k.x, k.y).at(l.x, l.y, m.x, m.y, rTL * s)
				.cp();

			return this;
		};

		this.circle = function(x, y, radius, percent, percentClose) {

			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(radius)) radius = 50;
			if (zot(percent)) percent = 100;
			if (zot(percentClose)) percentClose = true;

			x = zik(x);
			y = zik(y);
			radius = zik(radius);
			percent = zik(percent);

			radius = Math.abs(radius);
			that.translate(x, y);
			var center = shape.matrix.transformPoint(0, 0);

			if (!shape.decomp) shape.decomp = {};
			shape.matrix.decompose(shape.decomp);
			var s = (Math.abs(shape.decomp.scaleX) + Math.abs(shape.decomp.scaleY)) / 2;
			var ro = shape.decomp.rotation || 0;
			var r = radius * s;

			that.circleHeight = r * 2;
			if (typeof percent == "number" && percent >= 0 && percent < 100) {
				var p = 360 * percent / 100 / 2;
				shape.mt(center.x + r * Math.cos((-p - 90 + ro) * Math.PI / 180), center.y + r * Math.sin((-p - 90 + ro) * Math.PI / 180));
				shape.a(center.x, center.y, r, (-p - 90 + ro) * Math.PI / 180, (p - 90 + ro) * Math.PI / 180, false);
				if (percentClose) shape.cp();
				that.circleHeight = r - Math.cos(p * Math.PI / 180) * r;
			} else {
				shape.mt(center.x + r, center.y);
				shape.a(center.x, center.y, r, 0, Math.PI * 2);
			}
			return this;
		};

		this.elipse = function(x, y, w, h) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(w)) w = 100;
			if (zot(h)) h = 50;

			x = zik(x);
			y = zik(y);
			w = zik(w);
			h = zik(h);

			that.translate(x, y);

			var center = shape.matrix.transformPoint(-w / 2, -h / 2);

			if (!shape.decomp) shape.decomp = {};
			shape.matrix.decompose(shape.decomp);
			var sX = shape.decomp.scaleX;
			var sY = shape.decomp.scaleY;

			shape.de(center.x, center.y, w * sX, h * sY);
			return this;
		};

		this.poly = function(x, y, radius, sides, pointSize, angle) {
			if (zot(x)) x = 0;
			if (zot(y)) y = 0;
			if (zot(radius)) radius = 100;
			if (zot(sides)) sides = 5;
			if (zot(pointSize)) pointSize = 0;
			if (zot(angle)) angle = 0;

			x = zik(x);
			y = zik(y);
			radius = zik(radius);
			sides = zik(sides);
			pointSize = zik(pointSize);
			angle = zik(angle);

			radius = Math.abs(radius);

			that.translate(x, y);
			var center = shape.matrix.transformPoint(0, 0);

			if (!shape.decomp) shape.decomp = {};
			shape.matrix.decompose(shape.decomp);
			var s = (Math.abs(shape.decomp.scaleX) + Math.abs(shape.decomp.scaleY)) / 2;
			var ro = shape.decomp.rotation || 0;
			var r = radius * s;

			shape.dp(center.x, center.y, r, sides, pointSize, ro);
			return this;
		};

		this.closePath = this.close = this.cp = function() {
			// does not seem to close the path - so leaving undocumented
			shape.cp();
			return this;
		};

		this._noise = new zim.Noise(seed);
		this.noise = function() {
			if (arguments.length == 1) return (this._noise.simplex1D.apply(null, arguments) + 1) / 2;
			if (arguments.length == 2) return (this._noise.simplex2D.apply(null, arguments) + 1) / 2;
			if (arguments.length == 3) return (this._noise.simplex3D.apply(null, arguments) + 1) / 2;
			if (arguments.length == 4) return (this._noise.simplex4D.apply(null, arguments) + 1) / 2;
		}

		// STACK
		this.stack = [];
		this.colorStrokeStack = [];
		this.push = function() {
			that.stack.push(shape.matrix.clone());
			that.colorStrokeStack.push([that.color, that.strokeColor, that.strokeWidth, that.currentColor, that.currentStrokeColor, that.currentStrokeWidth]);
			return this;
		};
		this.pop = function() {
			shape.matrix = that.stack.pop() || shape.matrix;
			var info = that.colorStrokeStack.pop() || [that.color, that.strokeColor, that.strokeWidth, that.currentColor, that.currentStrokeColor, that.currentStrokeWidth];
			that.color = info[0];
			that.strokeColor = info[1];
			that.strokeWidth = info[2];
			that.currentColor = info[3];
			that.currentStrokeColor = info[4];
			that.currentStrokeWidth = info[5];
			shape.f(that.currentColor).s(that.currentStrokeColor).ss(that.currentStrokeWidth);
			shape.mt(shape.matrix.x, shape.matrix.y);
			return this;
		};
		this.blit = function() {
			shape.updateCache("source-over");
			shape.c();
			return this;
		};
		this.step = function() {
			if (that.draw) innerDraw();
			return this;
		};

		// GENERATION

		if (!zot(that.color)) this.fill(that.color);
		if (!zot(that.strokeColor) && that.strokeWidth) this.stroke(that.strokeColor, that.strokeWidth);
		else that.noStroke();

		this.translate(cX, cY);

		//~~~~~~~~~~~~~~ SETUP
		if (typeof setup == "function") {
			this.setup = setup;
			zim.timeout(.01, function() {
				setup(0, that.count, that);
				if (cache) shape.updateCache();
				stage.update();
			});
		}
		var _count = 0;
		this.maxCount = maxCount;

		this.resetup = function(clear) {
			if (zot(clear)) clear = true;
			_count = 0;
			if (clear) that.shape.c();
			if (!zot(that.color)) this.fill(that.color);
			if (!zot(that.strokeColor) && that.strokeWidth) this.stroke(that.strokeColor, that.strokeWidth);
			else that.noStroke();
			this.reset();
			if (this.setup) {
				setup(0, that.count, that);
				if (cache) shape.updateCache();
				stage.update();
			}
			return this;
		}

		//~~~~~~~~~~~~~~ STAMP
		this.stampNum = 0;
		if (typeof stamp == "function") {
			this.stamp = stamp;
			zim.timeout(.015, function() {
				setLoop(0);
			});
		}

		this.restamp = function(clear, setup) {
			if (zot(clear)) clear = true;
			if (zot(setup)) setup = true;
			_count = 0;
			if (clear) that.shape.c();
			if (setup) that.resetup(clear);
			setLoop(0);
			return this;
		}

		this.reset = function() {
			this.fill(color);
			if (!zot(strokeColor) && strokeWidth) this.stroke(strokeColor, strokeWidth);
			else this.noStroke();
			shape.matrix.identity();
			this.translate(startX, startY);
			return this;
		}

		this.clear = function() {
			this.shape.c();
			return this;
		}


		function saveOutput() {
			loader.save({
				content: stage,
				filename: that.outputName + zim.decimals(that.outputNum, null, null, 6),
				type: outputType
			});
			that.outputNum++;
		}
		if (output) { // save a pic before drawing
			stage.update();
			saveOutput();
		}

		// for stamp function

		function setLoop(start) {
			that.stampNum++;
			var result = zim.loop(that.maxCount, function(i, t) {
				if (that.paused) {
					that.pausedCount = i;
					return false;
				}
				if (that.changeCount) {
					that.changeCount = false;
					return false;
				}
				_count = i + 1;
				var s = stamp(i + 1, t, that, that.stampNum);
				// if (that.resetColor) {shape.f(zik(that.color));}
				// if (that.resetStroke) {
				// 	shape.s(zik(that.strokeColor));
				// 	shape.ss(zik(that.strokeWidth));
				// }
				that.currentColor = zik(that.color);
				shape.f(that.currentColor);
				that.currentStrokeColor = zik(that.strokeColor);
				shape.s(that.currentStrokeColor);
				that.currentStrokeWidth = zik(that.strokeWidth);
				shape.ss(that.currentStrokeWidth);
				if (output) {
					stage.update();
					saveOutput();
				}
				if (s) return s;
			}, null, null, start);

			if (cache) shape.updateCache();
			if (result) that.dispatchEvent("complete");
			stage.update();
		}

		//~~~~~~~~~~~~~~ DRAW
		that.iterator = 0;
		if (typeof draw == "function") {
			this.draw = draw;
			if (setup) {
				setTimeout(function() {
					that.ticker = zim.Ticker.add(innerDraw);
				}, 100);
			} else {
				this.ticker = zim.Ticker.add(innerDraw);
			}
			that.generatorPaused = false;
			if (drawPause) {
				that.pauseEvent = stage.on("stagemousedown", function() {
					if (that.count >= that.maxCount) return;
					if (that.pauseTimeout) return;
					if (zim.Ticker.has(that.ticker)) {
						zim.Ticker.remove(that.ticker);
						that.generatorPaused = true;
						that.dispatchEvent("generatorpaused");
					} else {
						that.ticker = zim.Ticker.add(that.ticker);
						that.generatorPaused = false;
						that.dispatchEvent("generatorunpaused");
					}
				});
			}
			if (drawSpacebarPause) {
				that.pauseSpacebarEvent = frame.on("keydown", function(e) {
					if (that.count >= that.maxCount) return;
					if (that.pauseTimeout) return;
					if (e.keyCode == 20) {
						if (zim.Ticker.has(that.ticker)) {
							zim.Ticker.remove(that.ticker);
							that.generatorPaused = true;
							that.dispatchEvent("generatorpaused");
						} else {
							that.ticker = zim.Ticker.add(that.ticker);
							that.generatorPaused = false;
							that.dispatchEvent("generatorunpaused");
						}
					}
				});
			}
		}
		// for draw function
		function innerDraw() {
			that.iterator++;
			if (that.iterator % Math.ceil(that.drawCount) == 0) {
				that.count++;
				that.draw(that.count, that.maxCount, that);
				if (cache) that.blit();
				// if (that.resetColor) {shape.f(zik(that.color));}
				// if (that.resetStroke) {
				// 	shape.s(zik(that.strokeColor));
				// 	shape.ss(zik(that.strokeWidth));
				// }
				that.currentColor = zik(that.color);
				shape.f(that.currentColor);
				that.currentStrokeColor = zik(that.strokeColor);
				shape.s(that.currentStrokeColor);
				that.currentStrokeWidth = zik(that.strokeWidth);
				shape.ss(that.currentStrokeWidth);
				that.dispatchEvent("drawing");
				stage.update();
				if (output) saveOutput();
			}
			if (that.maxCount && that.count >= that.maxCount) {
				that.dispatchEvent("complete");
				zim.Ticker.remove(that.ticker);
			}
		}

		this.redraw = function(clear, setup) {
			if (zot(clear)) clear = true;
			that.reset();
			if (zot(setup)) setup = true;
			if (that.ticker) zim.Ticker.remove(that.ticker);
			that.iterator = 0;
			that.count = 0;
			if (clear) that.shape.c();
			if (setup) {
				that.resetup(clear);
				setTimeout(function() {
					if (that.ticker) that.ticker = zim.Ticker.add(that.ticker);
				}, 100);
			} else {
				if (that.ticker) that.ticker = zim.Ticker.add(that.ticker);
			}
			return this;
		}

		this.paused = false;
		this.pause = function(state, time) {
			if (zot(state)) state = true;
			if (that.count >= that.maxCount) return;
			if (state == this.paused) return this;
			this.paused = state;

			if (this.pauseTimeout) this.pauseTimeout.clear();
			if (this.paused) {
				if (that.ticker) zim.Ticker.remove(that.ticker);
			} else {
				if (that.ticker) that.ticker = zim.Ticker.add(that.ticker);
				else {
					setLoop(that.pausedCount, that.maxCount);
				}
			}
			setTimeout(function() {
				stage.update();
			}, 20);
			if (time) {
				this.pauseTimeout = zim.timeout(time, function() {
					that.pause(!that.paused);
					that.pauseTimeout = null;
				});
			}
			that.dispatchEvent(that.paused ? "paused" : "unpaused");
		};

		this.outOfBounds = function(margin, marginY) {
			if (zot(margin)) margin = 0;
			if (zot(marginY)) marginY = margin;
			var stage = that.shape.stage;
			if (!stage) return;
			return (
				that.currentX > stage.width - margin ||
				that.currentX < 0 + margin ||
				that.currentY > stage.height - marginY ||
				that.currentY < 0 + marginY
			);
		}

		this.stop = function() {
			that.pause();
			if (that.pauseEvent) stage.off("stagemousedown", that.pauseEvent);
			if (that.pauseSpaceEvent) frame.off("keydown", that.pauseSpaceEvent);
		};

		Object.defineProperty(this, 'count', {
			get: function() {
				return _count;
			},
			set: function(value) {
				_count = value; // reset the loop if stamp
				if (that.stamp) {
					that.changeCount = true;
					setTimeout(function() {
						setLoop(_count, that.maxCount);
					});
				}
			}
		});

		Object.defineProperty(this, 'currentX', {
			get: function() {
				return cX;
			},
			set: function() {
				if (zon) zogy("Generator() - currentX is read only");
			}
		});

		Object.defineProperty(this, 'currentY', {
			get: function() {
				return cY;
			},
			set: function() {
				if (zon) zogy("Generator() - currentY is read only");
			}
		});

		this.clone = function() {
			return that.cloneProps(new zim.Generator(color, strokeColor, strokeWidth, draw, stamp, setup, maxCount, boundary, drawCount, drawPause, drawSpacebarPause, startX, startY, cache, recordLinePoints, frame, seed, style, that.group, inherit));
		};

		that.dispose = function(a, b, disposing) {
			that.pause();
			if (that.ticker) zim.Ticker.remove(that.ticker);
			if (that.pauseEvent) stage.off("stagemousedown", that.pauseEvent);
			if (that.pauseSpacebarEvent) frame.off("keydown", that.pauseSpacebarEvent);
			if (that._noise) that._noise = null;
			if (that.shape) that.shape.dispose();
			if (that.drawing) that.drawing.dispose();
			that.shape = that.drawing = null;
			if (!disposing) that.zimContainer_dispose();
			return true;
		};

		if (style !== false) zim.styleTransforms(this, DS);
	};
	zim.extend(zim.Generator, zim.Container, ["clone", "dispose"], "zimContainer", false);
//-69.92

/*--
zim.Pen = function(size, color, penType, damp, spread, borderColor, borderWidth, end, paper, nib, cache, ctrlKey, cropScale, undo, undoKeys, move, onTop, deleteable, doubleClickDelete, holdDelete, immediateStop, lineAlpha, lineBlendMode, frame, dashed, pullColor, pullThickness, style, group, inherit)

Pen
zim class - extends a ZIM Container which extends a CreateJS Container

DESCRIPTION
Handles dynamic drawing with a set of different penTypes
You can drag() or gesture() pen, move it with a MotionController(),
animate() it, animate() it along a Squiggle or Blob path, etc.

Holding down the CTRL key will allow the pen to move without drawing

SEE: https://zimjs.com/pen.html

NOTE: the pen adds either a Bitmap (if cache is true) or a Shape (if cache is false)
to the container the pen is added to.  This is layered directly under the pen.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const pen = new Pen({penType:"kitetail", nib:new Circle(10,pink)}).center().drag();
END EXAMPLE

EXAMPLE
// use a MotionController
const pen = new Pen().center();
const motionController = new MotionController({
	target:pen,
	type:"pressmove",
	speed:60,
	damp:.5,
	mouseMoveOutside:true
});

// if later, animation along a path is desired
// the motionController needs to be disabled
// and the pen set to write
motionController.enabled = false;
pen.write = true;

// position the pen at the start of the path
// and set its damping to start there too...
const path = new Squiggle().loc(100,100).alp(.1);
pen.loc(path.pointControls[0]);
pen.immediate(pen.x, pen.y);

// if animating along a path more than once
// make sure the percentComplete is reset to 0
// (this is a tricky one!)
pen.animate({
	// set:{percentComplete:0},
	props:{path:path},
	time:1,
	call:()=>{
		// to use the motionController again:
		pen.write = false;
		motionController.enabled = true;
	}
})
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
   Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
size - |ZIM VEE| (default depends on penType) the pen size
color - |ZIM VEE| (default depends on penType) the pen color
damp - (default .5) the damping for the pen - 0 is no movement, 1 is no damping
	usually, set to 1 or false for following animate paths
penType - (default "line") a String of "line","kitetail","barbwire","grass","hair","city", or "splatter"
spread - |ZIM VEE| (default depends on penType) some pens use this like the splatter to determine how much the circles spread
borderColor - |ZIM VEE| (default depends on penType) a line down the middle of the pen drawing
borderWidth - |ZIM VEE| (default depends on penType) the thickness of a line down the middle of the pen drawing
end - (default "butt") the cap type as a String "butt", "square", "round" - from CreateJS
paper - (default null) a ZIM Container to hold the drawing - or Pen will make a Container to use
	see also the paper property to change containers - for layers in a drawing for instance
nib - (default null) an optional DisplayObject that will be used as the pen - would suggest centerReg({add:false}) this
cache - (default true) caches drawing in a Bitmap (improves performance) - set to false to not cache - the paper property points to the Bitmap or the Shape depending
ctrlKey - (default true) turns off drawing when CTRL key is being pressed. Set to false to not turn off drawing when the CTRL key is pressed
cropScale - (default 1) number times stage dimensions image will be cropped
	if dragging or shifting shape and paper, may want to set to 3 times the stage size for instance
	NOTE: keep this at 1 for iOS to avoid oversize canvas issues.  Set to cropScale:mobile()=="ios"?1:3
undo - (default 0) number of undo levels for example 30
	undo will be automatically recorded when each drawing stops
	undo will also be recorded if dragging a segment(s) with SHIFT or CTRL SHIFT or deleting a segment with delete()
undoKeys - (default true - if undo is > 0) use CTRL Z for undo and CTRL Y or CTRL SHIFT Z for redo - set to false to handle manually
move - (default true) set to false to not be able to drag segments or SHIFT drag all
onTop - (default true) - when dragging, does the selected line come to the top in the current paper
deleteable - (default true) - set to false to not be able to delete segments with CTRL click or all segments with CTRL SHIFT click
doubleClickDelete - (default true) - set to false to not use dblclick to delete segment
holdDelete - (default true) - set to false to not use hold (without moving) to delete segment
immediateStop - (default true) - if pressup is used (drag or MotionController) then stop drawing immediately when press is up
	set to false to keep drawing until damping is finished.
lineAlpha - (default 1) the alpha for each line drawn
lineBlendMode - (default "normal") the blendMode for each line drawn () - such as "difference", "multiply", etc. same as CreateJS compositeOperation
frame - (default zdf or zimDefaultFrame) the frame in which the pen will operates
dashed - (default null) set to true for a dash of 3 otherwise set to an array [size, space] 
	but since the pen is made up of smaller parts, the space unless small will not work and can be set to 100 or some large number.
pullColor - (default null) add a little line that pulls the pen
	when there is damping around .1 or so, the pen can seem to be behind the cursor or finger
	adding a pullLine can help the user understand this
pullThickness - (default 1) the thickness of the pull line - the pullColor must be set
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
setPen(newPen) - sets the pen and resets the default properties for the pen
immediate(x, y) - set the pen to this location without damping
clear() - clears the drawing
stop() - stops drawing and saves segment - may start drawing right away again if pen is moving...
	see infinite property to make sure drawing continues as one segment until stop() is called
	infinite is automatically set to true when animating pen along a path
	and stop() is called when animating along a path is complete (or paused)
saveState(obj, startLayer, endLayer) - record an undo state for the paper or a line segment if it is transformed - for an undo()
	use after manually resizing, positioning, rotating, setting alpha and skewing the paper or a line segment
	saveState() is not needed for dragging a line segment with SHIFT, CTRL SHIFT or if dragState or dragAllState is true
	startLayer and endLayer are for if the layer level of the shape changes
undo() - go back one undo state (called automatically by CTRL Z if undoKeys is true - default)
redo() - go forward one undo state (called automatically by CTRL Y or CTRL SHIFT Z if undoKeys is true - default)
delete(index) - delete a line segment at a given index (actually sets its alpha to 0 to maintain layers on undo)
	use: pen.paper.on("mousedown", function (e) {
		pen.delete(paper.getChildIndex(e.target)); // for instance
	})
deleteSegment(object) - delete a line segment object
	use: pen.paper.on("mousedown", function (e) {
		pen.deleteSegment(e.target); // for instance
	})
clone() - clone the pen (note there is no exact clone)
dispose(all) - all defaults to true to dispose all listeners, the pen and the current paper 
	set to false to remove all listeners and the pen but not the current paper (the container and its shape)


ALSO ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO See the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
drawX - a reference to the approximate current drawing x position
	needed because pen.x will give the location of the pen but not the drawing location because of damping
drawY - a reference to the approximate current drawing y position
	needed because pen.y will give the location of the pen but not the drawing location because of damping
paper - the Container that holds the drawing which are Bitmap objects if cache is true or Shape objects if cache is false
	the paper is centered on the stage and may be bigger or smaller depending on the cropScale setting
	the paper can be changed to a different Container or swapped back and forth for layer type control
	paper has shape, bitmap and paperNum properties
	clear() and dispose() will clear the current paper - not other papers - keep a reference to those and use dispose() on them if needed
lastSegment - gets the last segment drawn when pen has stopped - for instance use in a stop event function to get the line last drawn
	this will be a Bitmap (if cache is true) or a Shape (if cache is false)
	all segments have a paper property referring to its paper (which is also the segment's parent property)
lastSelected - gets the last selected segment - perhaps a segment was dragged, etc.
nib - get a reference to the specified nib - often not used
end - get or set the type of end for the pen - "butt", "round", "square"
write - get or set whether the pen is writing to the paper
drawing - read only Boolean as to if the pen is drawing as in moving
size - |ZIM VEE| get or set the size of the pen
sizeFactor - (default 1) get or set a factor to multiply the size of the pen (after being picked from ZIM VEE)
	works independent of sizeScale
sizeScale - (default 1) get or set scaling on the size of the pen (after being picked from ZIM VEE)
	works independent of sizeFactor
spread - |ZIM VEE| get or set the spread of the pen
spreadFactor - (default 1) get or set a factor to multiply the spread of the pen (after being picked from ZIM VEE)
	works independent of spreadScale
spreadScale - (default 1) get or set scaling on the spread of the pen (after being picked from ZIM VEE)
	works independent of spreadFactor
color - |ZIM VEE| get or set the color of the pen
pullColor - get or set the pullColor of the pen - see pullColor parameter
pullThickness - get or set the pullThickness of the pen the pullColor must be set
borderColor - |ZIM VEE| get or set the borderColor of the pen
borderWidth - |ZIM VEE| get or set the borderWidth of the pen
dampX - the ZIM Damp object for x position - change by using dampX.damp = value 
dampY - the ZIM Damp object for y position - change by using dampY.damp = value 
penType - get or set the type of pen - this will NOT set default properties like setPen()
undoLevels - get or set the number of undo levels
undoKeys - get or set if CTRL Z and CTRL Y / CTRL SHIFT Z are used for undo and redo
immediateStop - get or set how drawing segments ends - "both", "pressup", "mousemove" and "either" are options (see parameter for more info)
infinite - boolean to keep recording until stop() is called

ALSO See the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "drawing" event when drawing - note lastSegment is assigned when the drawing is stopped
dispatches a "start" event when pen motion starts (mousedown)
dispatches a "stop" event when pen motion stops
	If the immediateStop parameter is BOTH (default) then the pen must also be UP to trigger the stop
	This is if drag() or motionController({type:"pressmove"}) is being used.
	If the immediateStop parameter is "mousemove" then the stop will trigger when the motion stops - regardless of the pen being up or down
	This setting may cause small drawing segments at corners of lines or if the pen is held down and moved slowly
	If the immediateStop is either then either the pressup or mousemove stopping - which ever comes first - will end segment
dispatches a "change" event for when the drawing has a new segment (or on undo / redo)
dispatches a "paperChange" event when undo or redo changes paper objects
	The pen switches papers just before the paperChange is dispatched but before the change event is dispatched
dispatches a "paperMove" event when the paper moves with CTRL drag
dispatches a "recordUndo" when any type of undo is recorded - new segment, delete, drag, clear
dispatches an "undo" and a "redo" whenever undo and redo happens
--*///+69.93
	zim.Pen = function(size, color, penType, damp, spread, borderColor, borderWidth, end, paper, nib, cache, ctrlKey, cropScale, undo, undoKeys, move, onTop, deleteable, doubleClickDelete, holdDelete, immediateStop, lineAlpha, lineBlendMode, frame, dashed, pullColor, pullThickness, style, group, inherit) {
		var sig = "size, color, penType, damp, spread, borderColor, borderWidth, end, paper, nib, cache, ctrlKey, cropScale, undo, undoKeys, move, onTop, deleteable, doubleClickDelete, holdDelete, immediateStop, lineAlpha, lineBlendMode, frame, dashed, pullColor, pullThickness, style, group, inherit";
		var duo; if (duo = zob(zim.Pen, arguments, sig, this)) return duo;
		z_d("69.93");
		this.zimContainer_constructor();
		this.type = "Pen";
		this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);

		if (zot(penType)) penType = DS.penType!=null?DS.penType:"line";
		var base = {
			size:2,
			color:zim.dark,
			spread:{min:5,max:20},
			borderColor:zim.darker,
			borderWidth:0,
		};
		var defaults = {
			line:{size:2},
			kitetail:{
				size:{min:5, max:20},
				color:zim.series(zim.pink,zim.blue,zim.green),
				borderColor:"rgba(0,0,0,.5)",
				borderWidth:1
			},
			grass:{
				color:zim.green,
				size:3,
				spread:{min:10, max:30}
			},
			hair:{
				color:[zim.pink, zim.blue],
				size:3,
				spread:{min:20, max:50}
			},
			city:{
				size:{min:30, max:70},
				spread:{min:50, max:200},
				color:[zim.dark,zim.darker,zim.grey],
			},
			barbwire:{},
			splatter:{
				size:{min:5, max:20},
				color:"rgba(0,0,0,.5)"
			}
		};
		if (zot(defaults[penType])) penType = "line";
		
		if (zot(size)) size = DS.size!=null?DS.size:zot(defaults[penType].size)?base.size:defaults[penType].size;
		if (zot(color)) color = DS.color!=null?DS.color:zot(defaults[penType].color)?base.color:defaults[penType].color;
		if (zot(damp)) damp = DS.damp!=null?DS.damp:.5;
		if (damp === false) damp = 1;
		if (zot(spread)) spread = DS.spread!=null?DS.spread:zot(defaults[penType].spread)?base.spread:defaults[penType].spread;
		if (zot(borderColor)) borderColor = DS.borderColor!=null?DS.borderColor:zot(defaults[penType].borderColor)?base.borderColor:defaults[penType].borderColor;
		if (zot(borderWidth)) borderWidth = DS.borderWidth!=null?DS.borderWidth:zot(defaults[penType].borderWidth)?base.borderWidth:defaults[penType].borderWidth;
		if (zot(end)) end = DS.end!=null?DS.end:(zim.isPick(size) || zim.isPick(color) || penType!="line")?"butt":"round"; // also round and square
		if (zot(cropScale)) cropScale = DS.cropScale!=null?DS.cropScale:1;
		if (zot(cache)) cache = DS.cache!=null?DS.cache:true;
		if (zot(undo)) undo = DS.undo!=null?DS.undo:0;
		if (zot(undoKeys)) undoKeys = DS.undoKeys!=null?DS.undoKeys:true;
		if (zot(move)) move = DS.move!=null?DS.move:true;
		if (zot(deleteable)) deleteable = DS.deleteable!=null?DS.deleteable:true;
		if (zot(doubleClickDelete)) doubleClickDelete = DS.doubleClickDelete!=null?DS.doubleClickDelete:true;
		if (zot(holdDelete)) holdDelete = DS.holdDelete!=null?DS.holdDelete:true;
		if (zot(onTop)) onTop = DS.onTop!=null?DS.onTop:true;
		if (zot(immediateStop)) immediateStop = DS.immediateStop!=null?DS.immediateStop:"both";
		if (zot(lineAlpha)) lineAlpha = DS.lineAlpha!=null?DS.lineAlpha:1;
		if (zot(lineBlendMode)) lineBlendMode = DS.lineBlendMode!=null?DS.lineBlendMode:"normal";
		
		if (zot(paper)) paper = DS.paper!=null?DS.paper:new zim.Container();
		if (zot(nib)) nib = DS.nib!=null?DS.nib.clone():null;
		if (zot(frame)) frame = DS.frame!=null?DS.frame:WW.zdf;
		if (zot(dashed)) dashed = DS.dashed!=null?DS.dashed:null;
		if (dashed === true) dashed = [3,100];
		if (zot(pullColor)) pullColor = DS.pullColor!=null?DS.pullColor:null;
		if (zot(pullThickness)) pullThickness = DS.pullThickness!=null?DS.pullThickness:1;
			
		var that = this;        
		this.dampX = new zim.Damp(null, damp);
		this.dampY = new zim.Damp(null, damp);
		var _draw = true;
		this.drawing = false;
		this.immediateStop = immediateStop;
		this.undoLevels = undo;
		this.undoKeys = undoKeys;
		this.move = move;		
		this.draggable = true;
		this.lineAlpha = lineAlpha;
		this.lineBlendMode = lineBlendMode;
		var shape = that.shape = new zim.Shape();
		var w = frame.stage.width;
		var h = frame.stage.height;
		var startXCheck;
		var startYCheck;
		var startLayer;
		var endLayer;
		that.paperNum = 0;
		that.sizeScale = 1;
		that.spreadScale = 1;
		that.sizeFactor = 1;
		that.spreadFactor = 1;
		that.pullThickness = pullThickness;
		that.stop = function() {};
		var stage;
		
		this.added(function (s) {
			stage = s;
			that.paper = paper;
			w = that.stage.width;
			h = that.stage.height;
			if (!zot(nib)) {
				if (that.zimDown) {
					that.nib = nib.addTo(that);					
				} else {
					// nib not added to that as that is placed by motionController probably...
					// and the two damping systems fight one another
					// so place pen at cursor - except when dragging
					that.nib = nib.addTo(that.parent, that.parent.getChildIndex(that));
					that.nib.x = that.x;
					that.nib.y = that.y;
					that.nib.mouseEnabled = false;
					that.stageDown = stage.on("stagemousedown", function(e) {
						stage = e.target.stage;
						// moveNib(e); // might want to do this but then would move if dragging existing
						that.nibEvent = stage.on("stagemousemove", moveNib);
						that.dispatchEvent("start");
					});				
					that.stageUp = stage.on("stagemouseup", function() {
						stage.off("stagemousemove", that.nibEvent);
					});					
				}				
			} else {
				that.stageDown = stage.on("stagemousedown", function(e) {					
					that.dispatchEvent("start");
				});	
			}
			function moveNib(e) {
				if (!that.drawing) return;
				that.nib.x = e.stageX/zim.scaX;
				that.nib.y = e.stageY/zim.scaY;
			}
			that.zimDragCheck = false;
		
			that.stop = function() {that.stopCheck(true);};
			that.infinite = false;
			that.stopCheck = function(override) {
		
				if (!override) {
					if (that.infinite) return;
					if (that.zimDragCheck) return;
					if (!that.immediateStop && that.drawing) return;
				} else { // override - stop for sure!
					that.drawing = false;
					that.infinite = false;
				}
				that.immediate(that.x, that.y);				
		
				setTimeout(function(){
					var line;
					if (that.drawing) return;
					if (cache) {
						shape.cache(-(w*cropScale-w)/2, -(h*cropScale-h)/2, w*cropScale, h*cropScale);
						line = paper.bitmap = new zim.Bitmap(shape.cacheCanvas).reg((w*cropScale-w)/2, (h*cropScale-h)/2).addTo(paper);
						shape.graphics.clear();
						shape.uncache();
						shape.top();
					} else {
						line = shape;
					}
					if (that.undoLevels > 0) {
						var data = {paper:paper, line:line};
						undo.push(data);
						if (undo.length > that.undoLevels) undo.shift(); // take off front
						that.dispatchEvent("recordUndo");
					}
					if (!cache)  shape = new zim.Shape().clone().addTo(paper);
					that.lastSegment = line;
					that.lastSelected = line;
					line.alpha = that.lineAlpha;
					line.blendMode = that.lineBlendMode;
					line.paper = paper;
					that.dispatchEvent("stop");
					that.dispatchEvent("change");
				}, (that.immediateStop||override?0:50));
			}; // end stopCheck
		
			var count = 0;
			that.dampX.immediate(that.x);
			that.dampY.immediate(that.y);
			that.lastX = that.lastMidX = that.drawX = that.x;
			that.lastY = that.lastMidY = that.drawY = that.y;
			
			
			var lastColor;
			var lastSize;

			that.ticker = zim.Ticker.add(function () {
		
				if (!that.parent) return;
					
				var newX = that.dampX.convert(_draw?that.x:that.finishX);
				var newY = that.dampY.convert(_draw?that.y:that.finishY);
				var newPoint = that.parent.localToLocal(newX, newY, shape);
		
				if (Math.abs(that.lastX-newX)+Math.abs(that.lastY-newY)<1) {
					if (that.drawing) {
						that.drawing = false;
						if (that.zimDown) { // being dragged
							that.x = that.lastX = that.lastMidX = _draw?that.x:that.finishX;
							that.y = that.lastY = that.lastMidY = _draw?that.y:that.finishY;							
							// that.dampX.immediate(that.x); // removed in ZIM ZIM 02 to avoid shards
							// that.dampY.immediate(that.y);
						} else {
							that.x = that.finishX = that.lastX = that.lastMidX = newX;
							that.y = that.finishY = that.lastY = that.lastMidY = newY;
						}
						that.stopCheck();
						lastColor = lastSize = null;
					}
					that.lastX = that.lastMidX = newX;
					that.lastY = that.lastMidY = newY;
					if (paper) {
						var mm = paper.localToLocal(0, 0, that.parent);					
						that.lastMidX-=mm.x;
						that.lastMidY-=mm.y;
					}
					return;
				} else { 
					var pickedSize = zim.Pick.choose(size)*that.sizeScale*that.sizeFactor;
					var pickedSpread = zim.Pick.choose(spread)*that.spreadScale*that.spreadFactor;
					if (!that.drawing) {
						// drawing starting again
						redo = [];
						if (paper.getChildIndex(shape) != paper.numChildren-1) shape.top();
					}
					that.drawing = true;
					that.dispatchEvent("drawing");
				}
						
				var lastPoint = that.parent.localToLocal(that.lastX, that.lastY, shape);
				
				var lastMidPoint;				
				if (paper) lastMidPoint = paper.localToLocal(that.lastMidX, that.lastMidY, shape);	
				else lastMidPoint = that.parent.localToLocal(that.lastMidX, that.lastMidY, shape);	
				
				var midX, midY, midPoint;
				if (penType == "splatter") {					
					for (var i=0; i<=3; i++) {
						var angle = zim.rand(360)*Math.PI/180;
						var d = pickedSpread;
						var loc = {x:newX+d*Math.cos(angle), y:newY+d*Math.sin(angle)};
						var point = that.parent.localToLocal(loc.x,loc.y, shape);
						shape.graphics.mt(point.x, point.y).f(zim.Pick.choose(color)).dc(point.x, point.y, pickedSize/2);
					}
				} else if (penType == "grass" || penType == "hair" || penType == "city") {
					if (penType == "grass" || penType == "hair") { // add more
						midX = that.lastX+(newX-that.lastX)/2;
						midY = that.lastY+(newY-that.lastY)/2;
						midPoint = that.parent.localToLocal(midX,midY, shape);
						shape.graphics
							.s(zim.Pick.choose(color)).ss(pickedSize, end)
							.mt(midPoint.x, midPoint.y)
							.lt(midPoint.x + zim.rand(-pickedSpread/4, pickedSpread/4), penType=="hair"?midPoint.y+pickedSpread:midPoint.y-pickedSpread);
					}
					if (penType == "grass" || penType == "hair" || (penType == "city" && count%3==0)) {
						shape.graphics
							.s(zim.Pick.choose(color)).ss(pickedSize, end)
							.mt(newPoint.x, newPoint.y)
							.lt(newPoint.x+(penType=="city"?0:zim.rand(-pickedSpread/4, pickedSpread/4)), penType=="hair"?midPoint.y+pickedSpread:newPoint.y-pickedSpread);
					}
					count++;
				} else {
					if (penType == "kitetail") {						
						shape.graphics.s(zim.Pick.choose(color)).ss(pickedSize, end);
					}
					if (penType == "barbwire") {
						shape.graphics.s(zim.Pick.choose(color)).ss(pickedSize, end);
						midX = that.lastX+(newX-that.lastX)/2+zim.rand(-pickedSpread, pickedSpread);
						midY = that.lastY+(newY-that.lastY)/2+zim.rand(-pickedSpread, pickedSpread);
					} else {
						midX = that.lastX+(newX-that.lastX)/2;
						midY = that.lastY+(newY-that.lastY)/2;
					}			
					midPoint = that.parent.localToLocal(midX,midY, shape);
					if (penType != "line") {							
						shape.graphics
							// .mt(lastMidPoint.x, lastMidPoint.y)							
							.qt(lastPoint.x, lastPoint.y, midPoint.x, midPoint.y); // adjusted Cat 04
					}
				}		
				
				if (borderWidth>0 && penType != "line") {
					midX = that.lastX+(newX-that.lastX)/2;
					midY = that.lastY+(newY-that.lastY)/2;
					midPoint = that.parent.localToLocal(midX,midY, shape);
					shape.graphics
						.s(zim.Pick.choose(borderColor))
						.ss(zim.Pick.choose(borderWidth))
						.mt(lastMidPoint.x, lastMidPoint.y)
						.qt(lastPoint.x, lastPoint.y, midPoint.x, midPoint.y); // adjusted Cat 04
					if (penType == "splatter") shape.graphics.es();
				}
		
				if (penType == "splatter") {
					shape.graphics.f(zim.Pick.choose(color));
				// } else if (penType == "kitetail") {
				} else if (penType != "kitetail") {
					if (penType=="line") {
						if (zim.isPick(color) || pickedSize != lastSize) {
							var colo = zim.Pick.choose(color);
							if (colo!=lastColor || pickedSize != lastSize) {
								shape.graphics.s(colo).ss(pickedSize, end);
							}
							lastColor = colo;
							lastSize = pickedSize;
						}
					} else shape.graphics.s(zim.Pick.choose(color)).ss(pickedSize, end);
				}
				if (penType != "grass" && penType != "hair" && penType != "city" && penType != "splatter") {				
					shape.graphics
						.mt(lastMidPoint.x, lastMidPoint.y)
						// .qt(midPoint.x, midPoint.y, newPoint.x, newPoint.y);
						.qt(lastPoint.x, lastPoint.y, midPoint.x, midPoint.y);
				}		
				if (dashed) shape.graphics.sd(dashed);	
			
				that.lastX = newX;
				that.lastY = newY;
				if (midPoint) {
					that.lastMidX = midPoint.x;
					that.lastMidY = midPoint.y;
				}
				that.drawX = that.lastMidX || 0;
				that.drawY = that.lastMidY || 0;
				
			}); // end Ticker


			if (!zot(pullColor)) addPullColor(stage);
			
			that.mouseChildren = false;			
		
		});


		function addPullColor(stage) {
			var F = stage.frame;			
			if (that.ppdEvent) that.off("drawing", that.ppdEvent);
			if (that.ppsEvent) that.off("stop", that.ppsEvent);
			if (that.ppmEvent) stage.off("stagemousedown", that.ppmEvent);
			if (!that.pullShape) that.pullShape = new zim.Shape();
			that.ppdEvent = that.on("drawing", function() {
				setTimeout(function(){
					var p = paper.localToGlobal(that.drawX, that.drawY);
					that.pullShape.c().s(pullColor).ss(that.pullThickness).mt(F.mouseX, F.mouseY).lt(p.x, p.y);
				},10);				
			});
			that.ppsEvent = that.on("stop", function() {
				that.pullShape.removeFrom();
				that.pullShape.c()
			});
			that.ppmEvent = stage.on("stagemousedown", function() {
				that.pullShape.addTo(stage);
				that.immediate(F.mouseX, F.mouseY);
				if (that.motionController) that.motionController.immediate(F.mouseX, F.mouseY);
			});
		}
		function removePullColor() {
			if (that.ppdEvent) that.off("drawing", that.ppdEvent);
			if (that.ppsEvent) that.off("stop", that.ppsEvent);
			if (that.ppmEvent) that.off("stagemousedown", that.ppmEvent);
			if (that.pullShape) that.pullShape.dispose();				
		}
		
		
		// ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
		// UNDO REDO FUNCTIONALITY
		// undo data: {paper:Container, paperTransform:{}, line:Bitmap/Shape, lineTransform:{}}
		
		undo = [];
		var redo = [];
		
		this.saveState = function(obj, startLayer, endLayer) { // called by dragging paper or line segment
			var t = obj.type=="Container"?"paper":"line";
			var data = {paper:that.paper};
			data[t] = obj;
			data[t+"Transform"] = {x:obj.x, y:obj.y, r:obj.rotation, a:obj.alpha, rX:obj.regX, rY:obj.regY, sX:obj.scaleX, sY:obj.scaleY, skX:obj.skewX, skY:obj.skewY, v:obj.visible};
			if (!zot(startLayer) && !zot(endLayer) && startLayer != endLayer) {
				data.startLayer = startLayer;
				data.endLayer = endLayer;
			}
			undo.push(data);
			that.dispatchEvent("recordUndo");
			if (undo.length > that.undoLevels) undo.shift(); // take off front
		};
		var defaultTransform = {x:0, y:0, r:0, a:1, rX:0, rY:0, sX:1, sY:1, skX:0, skY:0, v:true};
		this.undo = function() {
			var data = undo.pop();
			if (data) {
				redo.push(data);
				if (data.clear) {
					for (var i=0; i<data.clear.length; i++) {
						data.paper.addChild(data.clear[i]);
					}
					data.paper.addChild(shape); // add back to top
				} else if (data.line && data.lineTransform) { // undo line transform
					if (!zot(data.startLayer)) { // watch - could be 0
						shape.top();
						data.paper.setChildIndex(data.line, startLayer);
					}
					undoObjTransform("line", data.line);
				} else if (data.line) { // undo add
					data.line.removeFrom();
				} else if (data.paperTransform) { // undo paper transform
					undoObjTransform("paper", data.paper);
				}
				that.lastPaper = that.paper;
				if (data.paper != that.paper) {
					that.paper = data.paper;
					that.dispatchEvent("paperChange");
				}
				that.dispatchEvent("change");
				that.dispatchEvent("undo");
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		};
		function undoObjTransform(type, obj) {
			var d;
			for (var i=undo.length-1; i>=0; i--) {
				if (undo[i][type]==obj && undo[i][type+"Transform"]) {
					d = undo[i][type+"Transform"];
					break;
				}
			}
			if (!d) d = zim.copy(defaultTransform);
			obj.x=d.x; obj.y=d.y; obj.alpha=d.a; obj.rotation=d.r; obj.regX=d.rX; obj.regY=d.rY; obj.scaleX=d.sX; obj.scaleY=d.sY; obj.skewX=d.skX; obj.skewY=d.skY; obj.visible=d.v;
			if (type=="line" && cache) { // if cached, the cropScale adjusts the starting registration of the Bitmap
				obj.regX = (w*cropScale-w)/2;
				obj.regY = (h*cropScale-h)/2;
			}
		}
		
		this.redo = function() {
			var data = redo.pop();
			var obj, d;
			if (data) {
				undo.push(data);
				if (data.clear) {
					data.paper.removeAllChildren();
					data.paper.addChild(shape);
				} else if (data.line && data.lineTransform) { // redo line transform
					if (!zot(data.endLayer)) { // watch - could be 0
						shape.top(); // may not matter if paper is not current paper as it will not have shape
						data.paper.setChildIndex(data.line, endLayer); // watch - data.paper not paper
					}
					d = data.lineTransform;
					obj = data.line;
				} else if (data.line) { // redo add
					data.line.addTo(data.paper);
				} else if (data.paperTransform) { // redo paper transform
					d = data.paperTransform;
					obj = data.paper;
				}
				if (obj) { // keep brackets as multiple statements - I keep trying to put on one line!
					obj.x=d.x; obj.y=d.y; obj.alpha=d.a; obj.rotation=d.r; obj.regX=d.rX; obj.regY=d.rY; obj.scaleX=d.sX; obj.scaleY=d.sY; obj.skewX=d.skX; obj.skewY=d.skY; obj.visible=d.v;
				}
				that.lastPaper = that.paper;
				if (data.paper != that.paper) {
					that.paper = data.paper;
					that.dispatchEvent("paperChange");
				}
				that.dispatchEvent("change");
				that.dispatchEvent("redo");
				if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && that.stage) that.stage.update();
			}
		};

		that.ctrlKey = false;
		that.shiftKey = false;
		that.ctrlKeyCheck = false;
		that.zimkeydownEvent = function(e) {
			that.ctrlKey = e.ctrlKey;
			that.shiftKey = e.shiftKey;
			if (e.keyCode == 17 && move && !that.ctrlKeyCheck) { // ctrl key
				that.ctrlKeyCheck = true;
				paper.noDrag();
				paper.drag({onTop:onTop, all:true});
			}
			if (that.undoLevels <= 0) return;
			if (!that.undoKeys) return;
			if (e.ctrlKey && ((e.shiftKey && e.keyCode == 90) || e.keyCode == 89)) {
				that.redo();
			} else if (e.ctrlKey && e.keyCode == 90) {
				that.undo();
			}
			if (frame && frame.ctrlKey && that.write) {
				that.lastWrite = that.write;
				that.write = false;
			}
		}
		WW.addEventListener("keydown", that.zimkeydownEvent);
		
		that.zimkeyupEvent = function(e) {
			if (e.keyCode == 17 && move && that.ctrlKeyCheck) { // ctrl key
				that.ctrlKeyCheck = false;
				paper.noDrag();
				paper.drag({onTop:onTop});
			}
			if (!e.ctrlKey) that.ctrlKey = false;
			if (!e.shiftKey) that.shiftKey = false;
			if (frame && !frame.ctrlKey && that.write == false) {
				that.write = that.lastWrite;
			}
		}
		WW.addEventListener("keyup", that.zimkeyupEvent);

		Object.defineProperty(this, 'paper', {
			get: function() {
				return paper;
			},
			set: function(value) {
				if (value.type != "Container") return;
				paper = value;
				shape.addTo(paper, 0, false); // do not match shape in old container as paper might be moved
				paper.shape = shape;
				that.dampX.immediate(that.x);
				that.dampY.immediate(that.y);
				that.lastX = that.lastMidX = that.finishX = that.x;
				that.lastY = that.lastMidY = that.finishY = that.y;
				if (penType == "barbwire") {
					shape.graphics.s(zim.Pick.choose(color)).ss(zim.Pick.choose(size)*that.sizeScale*that.sizeFactor, end);
				}
				shape.graphics.mt(that.x, that.y);
		
				if (!paper.parent) paper.addTo(that.parent, that.parent.getChildIndex(that));
				if (zot(paper.paperNum)) {
					// apply paper events for delete and drag
					paper.paperNum = ++that.paperNum;
					if (deleteable) {
						paper.on("mousedown", function (e) {
							that.lastSelected = e.target;
							if (that.nibEvent) that.stage.off("stagemousemove", that.nibEvent); // do not place nib if dragging existing
							var currentPaper = e.target.paper;
							if (!currentPaper) return;
							if (currentPaper != that.paper) {
								that.paper = currentPaper;
								that.dispatchEvent("paperChange");
							}
							if (that.shiftKey) {
								if (that.ctrlKey) {
									that.clear(); // clear will dispatch change
								} else {
									// e.target.alpha = 0;
									e.target.visible = false;
									if (that.undoLevels > 0) that.saveState(e.target);
									that.dispatchEvent("change");
								}
							}
						});
					}
					if (doubleClickDelete) {
						paper.on("dblclick", function(e) {
							// e.target.alpha = 0;
							e.target.visible = false;
							if (that.undoLevels > 0) that.saveState(e.target);
						});
					}
					if (doubleClickDelete) {						
						paper.hold(function(e) {
							// e.target.alpha = 0;
							e.target.visible = false;
							if (that.undoLevels > 0) that.saveState(e.target);
						});
					}
					if (move) {
						paper.on("mousedown", function (e) {
							stage = e.target.stage;
							that.draggingCheck = true; // used so motioncontroller knows to ignore in stopCheck
							if (that.shiftKey && deleteable) return;
							startXCheck = e.stageX/zim.scaX;
							startYCheck = e.stageY/zim.scaY;
							shape.top();
							startLayer = paper.getChildIndex(e.target);
						});
						paper.drag({onTop:onTop});
						paper.on("pressup", function (e) {
							if (deleteable && that.shiftKey) return;
							// if (e.target.alpha == 0) return;
							if (e.target.visible == false) return;
							if (that.undoLevels <= 0) return;
							if (Math.abs(e.stageX/zim.scaX-startXCheck)<1 && Math.abs(e.stageY/zim.scaY-startYCheck)<1) {
								if (onTop) {
									shape.top();
									endLayer = paper.getChildIndex(e.target);
									if (startLayer != endLayer) that.saveState(e.target, startLayer, endLayer);
								}
								return;
							}
							if (that.ctrlKey) {
								that.saveState(paper);
								that.dispatchEvent("paperChange");
							} else {
								shape.top();
								endLayer = paper.getChildIndex(e.target);
								that.saveState(e.target, startLayer, endLayer);
							}
							that.dispatchEvent("change");
							shape.top();
						});
					}
				}
			}
		});
		
		Object.defineProperty(this, 'write', {
			get: function() {
				return _draw;
			},
			set: function(value) {
				if (_draw && value===false) {
					that.finishX = that.x;
					that.finishY = that.y; // let damping finish
				}
				if (!_draw && value) {
					shape.graphics.es();
                    shape.graphics.ef();
					that.dampX.immediate(that.x);
					that.dampY.immediate(that.y);
					that.lastX = that.lastMidX = that.x;
					that.lastY = that.lastMidY = that.y;
				}
				_draw = value;
			}
		});
		
		Object.defineProperty(this, 'size', {
			get: function() {
				return size;
			},
			set: function(value) {
				shape.graphics.es();
				shape.graphics.ef();
				size = value;
				if (penType != "splatter") shape.graphics.ss(zim.Pick.choose(size)*that.sizeScale*that.sizeFactor, end);
			}
		});		
		
		Object.defineProperty(this, 'color', {
			get: function() {
				return color;
			},
			set: function(value) {
				color = value;
				shape.graphics.es();
				shape.graphics.ef();
				if (penType != "splatter") shape.graphics.s(zim.Pick.choose(color));
			}
		});
		
		Object.defineProperty(this, 'penType', {
			get: function() {
				return penType;
			},
			set: function(value) {
				penType = value;
				shape.graphics.ef().es();
				if (penType != "splatter") {
					shape.graphics.s(zim.Pick.choose(color));
				} else {
					shape.graphics.s(zim.Pick.choose(color)).ss(zim.Pick.choose(size)*that.sizeScale*that.sizeFactor, end);
				}
			}
		});
		
		Object.defineProperty(this, 'end', {
			get: function() {
				return end;
			},
			set: function(value) {
				end = value;	
			}
		});
		
		Object.defineProperty(this, 'damp', {
			get: function() {
				return damp;
			},
			set: function(value) {
				damp = value;
				that.dampX.damp = damp;
				that.dampY.damp = damp;
			}
		});
		
		Object.defineProperty(this, 'spread', {
			get: function() {
				return spread;
			},
			set: function(value) {
				spread = value;
			}
		});
		
		var startColor;
		var endColor;
		this.setColorRange = function(color1, color2) {
			if (zot(color2)) {
				startColor = that.color;
				endColor = color1;
			} else if (zot(color1)) {
				startColor = that.color;
				endColor = color2;
			} else {
				startColor = color1;
				endColor = color2;
			}
			return that;
		};
		var _colorRange = 0;
		Object.defineProperty(that, 'colorRange', {
			get: function() {
				return _colorRange;
			},
			set: function(value) {
				_colorRange = value;
				if (!zot(startColor) && !zot(endColor)) {
					that.color = zim.colorRange(startColor, endColor, value);
				}
			}
		});
		
		Object.defineProperty(this, 'borderColor', {
			get: function() {
				return borderColor;
			},
			set: function(value) {
				borderColor = value;
			}
		});
		
		Object.defineProperty(this, 'borderWidth', {
			get: function() {
				return borderWidth;
			},
			set: function(value) {
				borderWidth = value;
			}
		});

		Object.defineProperty(this, 'pullColor', {
			get: function() {
				return pullColor;
			},
			set: function(value) {
				if (zot(value || value==-1)) {
					removePullColor();
					pullColor = null;
				} else if (zot(pullColor)) {
					pullColor = value;
					var s = stage || zdf.stage  
					addPullColor(s);
				} else {
					pullColor = value;
				}
			}
		});
		
		// if (frame) {
		// 	frame.on("keydown", function () {
		// 		if (frame.ctrlKey && that.write) {
		// 			that.lastWrite = that.write;
		// 			that.write = false;
		// 		}
		// 	});
		// 	frame.on("keyup", function () {
		// 		if (!frame.ctrlKey && that.write == false) {
		// 			that.write = that.lastWrite;
		// 		}
		// 	});
		// }
		
		that.setPen = function(newPen) {
			that.dampX.immediate(that.x);
			that.dampY.immediate(that.y);
			that.lastX = that.lastMidX = that.finishX = that.x;
			that.lastY = that.lastMidY = that.finishY = that.y;
			if (zot(newPen)) newPen = penType;
			if (zot(defaults[newPen])) newPen = "line";
			that.penType = penType = newPen;
			var newDefaults = zim.merge(base, defaults[newPen]);
			for (var prop in newDefaults) {
				if (that[prop] != newDefaults[prop]) {
					that[prop] = newDefaults[prop];
				}
			}
			return that;
		};
		
		that.immediate = function(x, y) {
			if (!zot(x)) {
				that.x = x;
				that.dampX.immediate(that.x);
				that.lastX = that.lastMidX = that.finishX = that.x;
			}
			if (!zot(y)) {
				that.y = y;
				that.dampY.immediate(that.y);
				that.lastY = that.lastMidY = that.finishY = that.y;
			}
			return that;
		};
		
		that.clear = function() {
			// if (paper.numChildren <= 1) return; // shape does not count
			var data = []; 
			for (var i=0; i<paper.numChildren-1; i++) {
				data.push(paper.getChildAt(i));
			}
			undo.push({paper:paper, clear:data});
			if (undo.length > that.undoLevels) undo.shift(); // take off front
			that.dispatchEvent("recordUndo");
			paper.removeAllChildren();
			shape.graphics.clear();
			paper.addChild(shape);
			that.dispatchEvent("change");
			if (that.stage) that.stage.update();
			return that;
		};
		
		// REMOVED in ZIM Cat 04
		// this.delete = function(index) {
		// 	// paper.getChildAt(index).alpha = 0;
		// 	paper.getChildAt(index).visible = false;
		// 	if (that.undoLevels > 0) that.saveState(paper.getChildAt(index));
		// };
		
		this.deleteSegment = function(segment) {
			// segment.alpha = 0;
			segment.visible = false;
			if (that.undoLevels > 0) that.saveState(segment);
		};
        
        this.clone = function() {			
			return this.cloneChildren(this.cloneProps(new zim.Pen(size, color, penType, damp, spread, borderColor, borderWidth, end, paper, nib, cache, ctrlKey, cropScale, undo, undoKeys, move, onTop, deleteable, doubleClickDelete, holdDelete, immediateStop, lineAlpha, lineBlendMode, frame, dashed, pullColor, pullThickness, style, group, inherit)));
		};

		that.dispose = function(all, b, disposing) {
			if (zot(all)) all = true;
			WW.removeEventListener("keydown", that.zimkeydownEvent);
			WW.removeEventListener("keyup", that.zimkeyupEvent);
			if (stage && that.nibEvent) stage.off("stagemousemove", that.nibEvent);
			if (stage && that.stageDown) stage.off("stagemousedown", that.stageDown);
			if (stage && that.stageUp) stage.off("stagemouseup", that.stageUp);
			if (stage && that.upEvent) stage.off("stagemouseup", that.upEvent);
			zim.Ticker.remove(that.ticker);
			that.removeAllEventListeners();
			if (nib) nib.removeFrom();
			if (all) { // remove paper too
				if (that.shape) that.shape.dispose(); // does not get done in recursive dispose - outside pen container						
				if (that.paper) that.paper.dispose();									
				if (cache) {
					if (that.bitmap) that.bitmap.dispose();
					that.bitmap = null;
				} 
				that.zimContainer_dispose(disposing);
				paper = shape = that.shape = null;
			}			
					
			return true;
		};

		if (style!==false) zim.styleTransforms(this, DS);
	};
	zim.extend(zim.Pen, zim.Container, ["dispose","clone"], "zimContainer", false);
//-69.93

/*--
zim.SoundWave = function(num, input, include, smoothing, min, max, operation, baseline, magnify, reduce, adjust, channel)

SoundWave
zim class - extends a CreateJS EventDispatcher

DESCRIPTION
Receives a sound input and calculates frequency data using HTML AudioContext createAnalyser()
The input can be the mic, a Synth tone(), play() or the result of a asset("someSound").play() or an <audio> tag
You can specify the number of data points and then use the calculate() method to animate to sound

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// the app may need to be interacted with before calling this
// in a Button mousedown event or Pane close event for instance.
const soundWave = new SoundWave(50, "mic");
soundWave.on("ready", ()=>{
	Ticker.add(()=>{
		let data = soundWave.calculate();
		// data is an array with 50 frequency amplitudes from low to high based on Microphone input
	})
});

// or pass in a sound instance:

// before loading the sound with F.loadAssets() use the following:
// this forces CreateJS to use an <audio> tag format
// we are trying to get things to work with WebAudio and will remove this message when we do!
createjs.Sound.registerPlugins([createjs.HTMLAudioPlugin]);

// later when we the loading is complete and after interacting with app
const soundWave = new SoundWave(50, new Aud("mySound.mp3").play());

// or pass in an <audio> tag reference:
const soundWave = new SoundWave(50, zid("tagID"));
zid("tagID").play();

// see more examples at
// https://zimjs.com/soundwave/bars.html
// https://zimjs.com/soundwave/circles.html
// https://zimjs.com/soundwave/mouth.html
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
num - (default 120) Number of data points returned by the calculate() method
input - (default "mic") the input for the sound:
	A. the mic
	B. the result of a ZIM Synth play() or tone()
	C. the results of a new Aud("someSound").play() or asset("someSound").play()
	D. an <audio> tag reference zid("tagID") make sure to zid("tagID").play()
include - (default 120/1024 = .117) a decimal range to include (0-1) - the full range (1) includes 90% very high frequencies
smoothing - (default .85) a decimal range for smoothing with 0 being choppy and .9 being slow to respond, etc.
min - (default -80 mic -100 song) minimum decibel number to pick up
max - (default -40 mic -10 song) maximum decibel number to pick up
operation - (default function below) a function that is applied to each result in the original bufferLength (1024)
	the natural results are very bass heavy with roughly a straight line heading down as frequency gets higher
	the default function reduces the bass by half and slowly rises towards the original values for higher frequency
		function(amplitude, i) {
			return amplitude * (.5+i*1/Math.pow(SoundWave.bufferLength, .95));
		}
	you can pass in a different function to take the place of the default function
	the function receives the original amplitude and index as parameters
	you can use SoundWave.bufferLength to get the total number of values in the original data (1024)
	Note: the data returned by the calculate() method will be only the included range - eg. .117 of the total original values (starting at low frequency)
baseline - (default 30) removes this amount of amplitude from each data point (after operation is applied)
magnify - (default 5) multiplies the data point by this much (after the baseline is removed)
	by removing the baseline amount and multiplying what's left the difference in wave data is increased
reduce - (default 0) subtracts this amount from each data point (after magnified)
adjust - (default 5) seconds to adjusts the max value used for calculate(normalized)
	a maximum is found over this amount of time and used to normalize the rest of the frequencies 
	setting this to 1 second would basically keep maximum output - but loses drop offs in sound 
channel - (default null) null will be both channels - set to 0 for left or 1 for right
	if 0 or 1 is set then will output only that channel as sound 
	for both channels independently, use two SoundWave() objects one with channel:0 and one with channel:1

METHODS
calculate(normalize) - returns an array of amplitudes at various frequencies from low to high
	the array will have a length that matches the num parameter
	the range of frequencies used will be 1024 multiplied by the include factor - eg. .117 = 120
	this 120 will be divided by the num parameter and average results over the range will be used
	this means the num parameter must be less than the 1024 times the range otherwise there is a warning
	normalize (default true) gets frequency numbers between 0-1 - set to false to get general numbers
		this is controlled by the SoundWave adjust parameter which gets a maximum over time 
		the frequencies are divided by the maximum
setInput() - change the input to another sound
dispose(context) - disposes the analyser.  Disposes the audioContext too if context is true (default false)
	the new Ticker function used in the app will need to be removed - see new Ticker.remove()
	and any animated DisplayObject will need to be removed, etc.

PROPERTIES
type - holds the class name as a String
num - read only num of frequency data
input - get the current input of the SoundWave - see setInput() to set the input
smoothing - a decimal range for smoothing with 0 being choppy and .9 being slow to respond, etc.
analyser - the HTML analyser object https://developer.mozilla.org/en-US/docs/Web/API/AnalyserNode
	with minDecibels, maxDecibels, smoothingTimeConstant and some others - see link
baseline - removes this amount of amplitude from each data point (after operation is applied)
magnify - multiplies the data point by this much (after the baseline is removed)
reduce - subtracts this amount from each data point (after magnified)
adjust - change the seconds that SoundWave adjusts for normalization 

EVENTS
dispatches a "ready" event when the sound source is connected and the calculate() method is ready
--*///+69.95
	zim.SoundWave = function(num, input, include, smoothing, min, max, operation, baseline, magnify, reduce, adjust, channel) {
		var sig = "num, input, include, smoothing, min, max, operation, baseline, magnify, reduce, adjust, channel";
		var duo; if (duo = zob(zim.SoundWave, arguments, sig, this)) return duo;
		z_d("69.95");
		this.type = "SoundWave";
		if (zot(num)) num = 120;
		if (zot(input)) input = "mic";
		if (zot(include)) include = 120/1024;
		if (zot(smoothing)) smoothing = .85;
		if (zot(min)) min = input=="mic"?-80:input.oscillator?-100:-100;
		if (zot(max)) max = input=="mic"?-40:input.oscillator?-10:-10;
		if (zot(operation)) operation = function(amplitude, i) {
			return amplitude * (.5+i*1/Math.pow(zim.SoundWave.bufferLength, .95));
		};
		if (zot(baseline)) baseline = (input=="mic"?0:input.oscillator?30:30); // subtracts this much from value
		if (zot(magnify)) magnify = (input=="mic"?1:input.oscillator?5:5); // multiplies amount by this much
		if (zot(reduce)) reduce = 0; // after calculating, subtract this much
		if (zot(adjust)) adjust = 5;
		
		var desiredAdjust = adjust;
		adjust = .5;
		var diff = (desiredAdjust - adjust) / 10
		zim.interval(.2, function(){
			adjust += diff; 
		}, 10);
	

		zim.SoundWave.bufferLength = 1024;
		var _num = num;
		var that = this;
		that.baseline = baseline;
		that.magnify = magnify;
		that.reduce = reduce;
		that.input = input;
		that.adjust = adjust;

		var audioContext;
		if (input.type == "Tone" || input.type == "SynthSound") audioContext = input.audioContext;
		else audioContext = new (WW.AudioContext || WW.webkitAudioContext)();
		var analyser = that.analyser = audioContext.createAnalyser();
		analyser.minDecibels = min;
		analyser.maxDecibels = max;
		analyser.smoothingTimeConstant = smoothing;

		Object.defineProperty(this, 'smoothing', {
			get: function() {
				return analyser.smoothingTimeConstant;
			},
			set: function(s) {
				analyser.smoothingTimeConstant = s;
			}
		});

		Object.defineProperty(this, 'num', {
			get: function() {
				return _num;
			},
			set: function(n) {
				_num = n;
				steps = Math.floor(include*zim.SoundWave.bufferLength / _num);
				if (steps < 1) zogy("ZIM SoundWave: num is too big");
			}
		});

		this.setInput = function(input) {
			that.input = input;
			if (input == "mic") {
				navigator.getUserMedia = (navigator.getUserMedia ||
				navigator.webkitGetUserMedia ||
				navigator.mozGetUserMedia ||
				navigator.msGetUserMedia);
				
				if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {										
					navigator.mediaDevices.getUserMedia({audio:true})
						.then(function(stream) {
							var source = that.source = audioContext.createMediaStreamSource(stream);
							connectSource(source);
						})
						.catch(function(err) {
							zogy("ZIM SoundWave: Error occured: " + err);
						});
				} else if (navigator.getUserMedia) {
					navigator.getUserMedia (
						{audio: true},
						function(stream) {
							var source = that.source = audioContext.createMediaStreamSource(stream);
							connectSource(source);
						},
						function(err) {
							zogy("ZIM SoundWave: Error occured: " + err);
						}
					);
				} else {
					zogy("ZIM SoundWave: Sorry, mic not supported");
				}
				return;
			} else if (input.type == "Tone") {
				connectSource(input.compressor);
			} else if (input.type == "SynthSound") {
				connectSource(input.gain);
			} else {
				if (input.type && input.type == "sound") {zogy("ZIM SoundWave: pass in the result of a zim.asset('somesound').play() for the input"); return;}
				var audio,source;
				if (input.playbackResource) {
					audio = input.playbackResource; // a playing zim.asset("somesound").play()
					if (audio.mediaSourceNode) {
						source = audio.mediaSourceNode;
					} else {					
						source = audioContext.createMediaElementSource(audio);
					}
				} else {
					audio = input; // a playing <audio> tag zid("soundTagID").play()
					source = audioContext.createMediaElementSource(audio);
				}				
				connectSource(source);
			}
		};
		this.setInput(input);


		var steps;
		var lastSource;
				
		function connectSource(source) {
			if (lastSource) lastSource.disconnect(analyser);
			
			lastSource = source;
			
			if (zot(channel) || (channel !== 0 && channel !== 1)) {							
				source.connect(analyser);
				// if (input.filter) analyser.connect(input.filter);
				if (input != "mic") analyser.connect(audioContext.destination);
			} else {
				var splitter = new ChannelSplitterNode(audioContext, {numberOfOutputs:2});
				source.connect(splitter);	
				splitter.connect(analyser, channel);				
				var merger = new ChannelMergerNode(audioContext, {numberOfInputs:2});
				analyser.connect(merger, 0, channel);
				
				if (input != "mic") merger.connect(audioContext.destination);
			}
			
			analyser.fftSize = zim.SoundWave.bufferLength*2;

			steps = Math.floor(include*zim.SoundWave.bufferLength / _num);
			if (steps < 1) {zogy("ZIM SoundWave: include param is too small or num param is too big"); return;}
			var bufferLength = analyser.frequencyBinCount;
			var dataArray = new Uint8Array(bufferLength);
			
			var max = 300;
			var maxTotal = 0;
			var runningMax = 0;
			var count = Math.round(60*that.adjust*.8); // start off faster
			var damp = new zim.Damp(max, .01);

			// ZIM ZIM 01 - must set normalize to true by default for ZIM ZIM 02
			that.calculate = function(normalize) {
				if (zot(normalize)) normalize = true;
				analyser.getByteFrequencyData(dataArray);
				var adjustedArray = dataArray.map(operation);
				if (steps == 1 && !normalize) return adjustedArray;
				var array = [];				
				var tot = 0;
				var i;
				for (i=0; i<=include*zim.SoundWave.bufferLength; i++) {
					tot += adjustedArray[i];
					if (i==0) continue;
					if (i%steps==0) {
						array.push(Math.max(0,(tot/steps-that.baseline)*that.magnify-that.reduce));
						tot = 0;
					}
				}
				// array.push((tot/steps-30)*10);
				var le = array.length;
				if (input != "mic") {
					array[0] *= .75;
					array[1] *= .85;
					array[2] *= .9;
					array[le-2] *= .8;
					array[le-1] *= .75;
				}
				array[le-1] *= 1.3;
				array[le-2] *= 1.2;
				array[le-3] *= 1.1;
				if (normalize) {					
					var normalized = [];
					count++;
					if (count>=60*that.adjust) { // assuming 60 fps
						max = maxTotal/count;
						maxTotal = 0;
						runningMax = 0;
						count = 0;
					}
					var m = damp.convert(max);
					for (i=0; i<le; i++) {
						if (array[i] > runningMax) runningMax = array[i];
						normalized[i] = Math.min(1, (m!=0?array[i]/m:0));
					}
					maxTotal += runningMax;
					return normalized;
				}
				return array;
			};
			setTimeout(function(){that.dispatchEvent("ready");}, 50);
		}
		this.dispose = function(context) {
			if (lastSource && analyser) lastSource.disconnect(analyser);
			if (context && audioContext) audioContext.close();
			if (analyser) analyser.disconnect();
			return true;
		};

	};

	zim.extend(zim.SoundWave, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
//-69.95

/*--
zim.Synth = function(volume, frequency)

Synth
zim class - extends a CreateJS EventDispatcher

DESCRIPTION
Synth has two main methods play() and tone().

PLAY
Synth will play generated sounds based on seventeen inputs.
The code library used is ZzFX from Frank Force at https://github.com/KilledByAPixel/ZzFX
Thanks Frank, amazing library - nice and small too!
Sounds can be created with the interface here: https://zzfx.3d2k.com
Then just paste the resulting code into a ZIM Synth play() method.

TONE
https://zimjs.com/cat/synth.html
Tone will play a tone at a given note forever or a duration of time.
The tone() method returns a Tone object and additional notes can be added.
The tone has effects: wah, tremelo (pitch / frequency) and vibrato (gain / volume)
All the settings of the tone - volume, frequency and the effects properties
can be animated with ZIM animate() and wiggle() - controlled with MotionController
and any general interactivity on components like dials, sliders, steppers, selectors, etc.

This uses the native JS Web Audio API to make oscillators with frequency and gain.
The API is fairly complicated and cumbersome so this makes it easier.
tone() plays a note "A", "Bb", "C#", "A4", etc.
The low notes are "C0" then each number increase goes up an octavet to "G8".
New constants are provided: SINE, SQUARE, TRIANGLE, SAW, ZAP for wave shapes.
tone() also plays WaveTables - of 50 different sounds available on the ZIM CDN
See https://zimjs.com/cat/synthpad.html

NOTE: as of ZIM 015 play() and tone() each have a pan parameter
See https://zimjs.com/015/pan.html

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// play() example - 
// ****** note, the app must be interacted with before sound can play
const synth = new Synth();
new Button({label:"START"}).center().tap(()=>{
	synth.play(0,...[,0,-1500,.3,.3,1.15,,1.01,2.37,-7.65,1100,.05,2,,-0.1,.07,5e-4]); // magical arrival
});
// This code came from here: https://zzfx.3d2k.com
// Note - it will have zzfx() and you want synth.play() - so copy what is in the brackets.
// **** - but put a 0 for the pan before their arguments (or a number from -1 to 1 for pan)
// zzfx(0,...[,0,-1500,.3,.3,1.15,,1.01,2.37,-7.65,1100,.05,2,,-0.1,.07,5e-4]);

// Note - above is ES6 - otherwise in ES5:
synth.play(0,null,0,-1500,.3,.3,1.15,null,1.01,2.37,-7.65,1100,.05,2,null,-0.1,.07,5e-4); // magical arrival
END EXAMPLE

EXAMPLE
// play() example with event for complete
const synth = new Synth();
const circle = new Circle(50,blue).center().tap(function () {
	var synthSound = synth.play(0,...[,,229,.04,.04,.47,,.84,7.85,,,,,.2,,.05]);
	synthSound.on("complete", ()=>{
		circle.removeFrom();
		S.update();
	});
});
END EXAMPLE

EXAMPLE
// tone() example:
// ****** note, the app must be interacted with before sound can play
const pane = new Pane("START").center();
pane.on("close", ()=>{
	const synth = new Synth();
	const tone = synth.tone(.5, "A"); // A is same as A3 (third octave up)
	timeout(1, ()=>{
		tone.addNote(.5, "A2");
	});
});
END EXAMPLE

EXAMPLE
// tone() example:
// ****** note, the app must be interacted with before sound can play
const pane = new Pane("START").center();
pane.on("close", ()=>{
	const synth = new Synth();
	const tone = synth.tone({
		volume:1,
		note:"A1",
		shape:SQUARE,
		wahAmount:1000,
		wahRate:1,
		wahShape:SINE, // default
		wahThroat:5
	});
});
END EXAMPLE

EXAMPLE
// ****** note, the app must be interacted with before sound can play
const pane = new Pane("START").center();
pane.on("close", ()=>{
	const synth = new Synth();
	const tone = synth.tone({
		volume:.7,
		note:"A2",
		shape:SQUARE,
		wahAmount:2000,
		wahRate:.2, // LFO
		wahThroat:10,

		vibratoAmount:10,
		vibratoRate:15,
		vibratoShape:SQUARE
	});
});
END EXAMPLE

EXAMPLE
// ****** note, the app must be interacted with before sound can play
const pane = new Pane("START").center();
pane.on("close", ()=>{
	const synth = new Synth();
	const tone = synth.tone({
		volume:.2,
		shape:SINE,
		tremeloAmount:.2,
		tremeloRate:12,
		tremeloShape:SINE,
	})
	notes = series("C3", "C4", "C3", "C5");
	interval(.8, ()=>{
		tone.note = notes();
	}, null, true); // true - start interval right away
});
END EXAMPLE

EXAMPLE
// ****** note, the app must be interacted with before sound can play
const synth = new Synth();
const circle = new Circle(100).center().tap(()=>{
	synth.tone({
		note:"C2",
		shape:SQUARE,
		wahAmount:3000,
		wahThroat:5,
		wahShape:ZAP,
		wahRate:.5,
		duration:2
	});
	circle.animate({scale:0}, 2, "backIn")
});
END EXAMPLE


PARAMETERS (Synth)
	volume (default .3) - the default volume of sounds - will be overwritten by first parameter of play() or tone()
	frequency (default 220) - the default frequency (Hz) of sounds - will be overwritten by first parameter of play() or tone()

METHODS (Synth)
	play(see parameters below) - plays a sound - see https://zzfx.3d2k.com to create data
		Returns a SynthSound object that dispatches a complete event when the sound is done
		The SynthSound has the following properties and methods:
			audioContext - the JS AudioContext
			gain - the JS WebAudio GainNode
			duration - the duration of the sound in seconds
			loop(num, offset) - see repeat below - same method.
			repeat(num, offset) - repeat the sound forever or pass in a num - returns object for chaining
				offset is a value to add to the duration so 2 would wait 2 seconds before repeating
				this accepts ZIM VEE so {min:-1, max:1} might overlap or delay slightly
				or series(1,2,3,4) would increase delay in repeating - see ZIM Pick()
			stop() - stop the sound
			play() - play the sound again - will need to call repeat() if desired
		Currently, there is no way to pause, pan or change volume once the sound is playing
		although if one really needed to change the volume, synthSound.gain.gain.value would do it - sigh (JS WebAudio...)

		PARAMETERS (play)
		** all parameters support - |ZIM VEE| a zim Pick() object or Pick Literal can be passed
		** Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
		pan (default = 0) - The pan with 0 in middle, -1 at left, 1 at right and anything in between
			note: this is added before the zzfx() parameters often provided as ...[rest of parameters]
		volume (default = .3) - Volume scale (ratio)
		randomness (default = .05) - How much to randomize frequency (ratio Hz)
		frequency (default = 220) - Frequency of sound (Hz)
		attack (default = 0) - Attack time, how fast sound starts (seconds)
		sustain (default = 0) - Sustain time, how long sound holds (seconds)
		release (default = .1) - Release time, how fast sound fades out (seconds)
		shape (default = 0) - Shape of the sound wave
			0-sine, 1-triangle, 2-sawtooth, 3-tan, 4-noise, 5-square (duty sweep)
		shapeCurve (default = 1) - Squarenes of wave (0=square, 1=normal, 2=pointy)
		slide (default = 0) - How much to slide frequency (kHz/s)
		deltaSlide (default = 0) - How much to change slide (kHz/s/s)
		pitchJump (default = 0) - Frequency of pitch jump (Hz)
		pitchJumpTime (default = 0) - Time of pitch jump (seconds)
		repeatTime (default = 0) - Resets some parameters periodically (seconds)
		noise (default = 0) - How much random noise to add (ratio)
		modulation (default = 0) - Frequency of modulation wave, negative flips phase (Hz)
		bitCrush (default = 0) - Resamples at a lower frequency in (samples*100)
		delay (default = 0) - Overlap with itself for reverb and flanger effects (seconds)
		sustainVolume (default = 1) - Volume level for sustain (ratio)
		decay (default = 0) - Decay time, how long to reach sustain after attack (seconds)
		tremelo (default = 0) - Trembling effect, rate controlled by repeat time (ratio)

	tone(see parameters below) - play a tone or tones continuously or for a duration
		returns a Synth Tone object - see methods and properties underneath parameters

		PARAMETERS (tone)
		** supports DUO - parameters or single object with properties below
		** supports VEE - all parameters support ZIM VEE - a zim Pick() object or Pick Literal can be passed
		** Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
		volume (default 1) - volume is all over the map with tones and effects
			Volume 1 is actually volume .1 as overall gain is dropped to 1/10 default JS Web Audio gain=1
			The overally gain is run through a JS compressor - see compressor property
			and filters can be appied - see insertComponent() but - good luck!
		note (default "A" - Synth default frequency 220) - letter notes (string) or frequency notes (number)
			"C0" is the lowest note with each octave the next number up to "G8" being a very high note (ew)
			Middle notes do not need a number and are octave 3 so a "C" is the same as "C3".
			Sharps are with a "#" so "C#" or "C2#" or "C#2" or "#C" or "#C####" etc. order does not matter
			Flats are with a "b" (the lowercase letter b) so "Bb" or "Ab2", etc.
		shape (default SINE) - the wave form or type as a constant below - or a WaveTable JSON or custom shape
			constants: (each is the same as a lowercase string - eg. SINE is "sine")
			SINE - a sine wave for a smooth sound - not good with Wah effect
			SQUARE - an up and down wave -1/1 with a growly sound - good for wah!
			TRIANGLE - a triangle shaped wave between a SINE an SQAURE
			SAW (SAWTOOTH) - an increase and then sudden drop - a little jagged sounding
			ZAP (reverse SAW) - a loud noise followed by a slow drop to 0 repeating - pew pew
			WaveTable shapes - 50 custom sounds see https://zimjs.com/cat/waves.html
				if loading JSON from file pass in asset("wavename.json") to the shape param (not just the file name)
			CUSTOM - an object {real, imag} with real and imag properties
				the real and imag properties should be Float32Array objects
				but ZIM will convert arrays such as the arrays found in the WaveTables
				ZIM will run a createPeriodicWave() on the object and callsetPeriodicWave()
				https://developer.mozilla.org/en-US/docs/Web/API/PeriodicWave
		pan (default 0) - the pan from -1 (left) to 1 (right) with 0 in the middle 
		duration (default 0) - forever - the seconds the sound will play (see also startTime) - and stop() method - also see ZIM TIME constant
		attack (default .02) - seconds to ramp up sound - sound that starts or stops right away pops (crackles)
		release (default .05) - seconds to ramp down sound at end
		WAH - makes a wah sound!  Like a Wah Pedal... applies an LFO (low frequency oscillator)
			A wah is made with a bandpass filter - that reduces sounds at high and low frequencies
			The JS bandpass filter used is available as the filter property of the tone object
			Changing the middle frequency of the bandpass will move the range up and down
			We call the middle frequency the wahNote and it is the most fun to change!
			The range between the high and low frequency we call wahThroat (it is a Q value - quality)
			The range does not exactly cut off but rather compresses the sound - so a smaller throat sounds squeezed
			This also reduces the volume and can make the tone sound almost wet or like a resonance
			Note: other effects are done with JS Web Audio Oscillator Wah uses a ZIM Synth Oscillator
			As well as the parameters, setting any wah property (tone see properties) will turn on the wah and there is a stopWah() method
				wahAmount (default 1000) - how much (amplitude) the wah moves up and down across notes
				wahRate (default 1) - the oscillations per second the wah moves up and down across notes
				wahShape (default SINE) - the wave form (type) the oscillations take - SINE smooth, SQUARE bee boo bee boo + SAW, TRIANGLE, ZAP
				wahThroat (default 5) - the low to high range of the wah (Q) usually from .1 to 20 - will compress sound and reduce volume
				wahNote (default note) - the center note (frequency) of the wah - changing / animating this will make the most wah effect
					the farther away the wahNote is from the note the more wah
					but if the wah moves too much it can cut off the sound - try within -200 and 3000 ;-)
		VIBRATO - oscillates frequency (pitch)
			When vibrato is used, a JS Oscillator (vibrato property) is used
			to adjust a JS Gain (vibratoGain property) connected to the main note frequency to make a warble
			As well as the parameters, setting any vibrato property (tone see properties) will turn on the vibrato and there is a stopVibrato() method
				vibratoAmount (default 10) - the frequency range to warble
				vibratoRate (default 1) - the oscillations per second to change the frequency
				vibratoShape (default SINE) - the the wave form (type) the oscillations take - SINE smooth, SQUARE bap bap + SAW, TRIANGLE, ZAP
		TREMELO - oscillates gain (volume)
			When tremelo is used, a JS Oscillator (tremelo property) is used
			to adjust a JS Gain (tremeloGain property) to make a warble
			As well as the parameters, setting any tremelo property (tone see properties) will turn on the tremelo and there is a stopTremelo() method
				tremeloAmount (default the tone volume * hush) - matching volumes makes a balanced wobble
					adding volumes gets really loud so reduce volume when applying tremelo
				tremeloRate (default 1) - the oscillations per second to change the gain
				tremeloShape (default SINE) - the the wave form (type) the oscillations take - SINE smooth, SQUARE doop doop + SAW, TRIANGLE, ZAP
		startTime (default 0) - in seconds - times the note start time very accurately - also see ZIM TIME constant
		 	generally, sequencers should use startTime and run all the notes at the start
			then the start times will play the note
			this avoids inconsistencies in interval() and animate()
			But... it depends on the application
		pauseOnBlur (default false) - set to true to pause sound when window is reduced or another tab gains focus

		METHODS (Tone)
			ramp(volume, time) - set a volume with optional fade time
				there is a volume property but ramp() tends to avoid crackle and pop
				so would recommend using volume only for animating
			stop(releaseTime) - stop the tone and fade an optional releaseTime in seconds
				note: to stop a tone at a given time use the duration parameter (or a stop in a timeout)
			pause(state) - not really a pause but turns volume down and up 
				state defaults to true for pause - set to false to unpause 
			addNote(volume, note, shape, toWah, toVibrato, startTime) add a new note to the tone - returns a Note() object
				** also see notes property of tone() for array of notes - and removeNote() below
				volume (default 1) - the volume of the note - 1 will be fine even if main volume is .1 for instance...
				note (default "A") - the letter note (or frequency) of the note
				shape (default SINE) - the type of wave - see tone() wave parameter for more details
				toWah (default true) - set to false to not add the note to the wah effect (if wah is on)
				toVibrato (default false) - set to true to add note to vibrato effect (if vibrato is turned on)
					adds note automatically to tremelo - to not add note to tremelo, make a new tone()
				PROPERTIES (Note)
					type - holds the class name as a String (Note)
					volume - ramp the gain of the gainNode attached to the Oscillator
					note - get or set the note - will ramp the Oscillator frequency
					oscillator - a reference to JS OscillatorNode used for note
					gain - reference to JS GainNode used for note
			removeNote(noteObject or toneObject) - remove a note object or pass in tone to remove that note
			removeWah() - removes the wah effect
			removeVibrato() - removes the vibrato effect
			removeTremelo() - removes the tremelo effect
			animate() - allows for tone to be animated like animate on a DisplayObject
				animate has added note convenience property - to convert to frequency from letter notes
				could animate with animate() function - but adding method makes it easier (and it is just a few lines)
			wiggle() - allows tone to be wiggled like a DisplayObject
				could wiggle with wiggle() function - but adding method makes it easier (and it is just a few lines)
			wire() - wire property values to another object. See wire() in Docs under DisplayMethods for parameters
			noWire() - turn off wire
			wired() - set tone to have property values set by another object. See wire() in Docs under DisplayMethods for parameters
			noWired() - turn off wired			

		PROPERTIES (Tone)
			type - holds the class name as a String (Tone)
			volume - the main volume - use this for animation
				warning, use ramp(volume) for setting a one-time volume to avoid crackle
			note - ramps the tone to the provided note ("A", "Bb", "C1", "D#", etc.) - or frequency
			frequency - ramps main frequency (note) to given value (see also note)
			shape - Wave form SINE, SQUARE, TRIANGLE, SAW, ZAP - see parameters for details
			pan - the pan from -1 (left) to 1 (right) with 0 in the middle 
			duration - get the duration of the tone if any (to set use duration parameter of Tone)
			currentTime - gets the current time in seconds since the start of the tone
			attack - seconds to ramp up volume or note
			release - seconds to ramp down volume or note
			hush - ratio of overall reduction of volume number - defaults to .1 so 10% JS gain=1 setting
			audioContext - reference to the JS Web Audio context being used - with the Web Audio nodes below
			WEB AUDIO NODES
				https://developer.mozilla.org/en-US/docs/Web/API/AudioNode
				The following are the JS Web Audio nodes used to create tone (for advanced users)
				Other Web Audio nodes can be inserted (patched) into the chain using disconnect() and connect()
				The connection order is: oscillator - filter - gain - compressor - audioContext.destination
			oscillator - reference to JS OscillatorNode created with audioContext.createOscillator()
				this can be directly manipulated but may want to use ZIM properties and methods
			filter - reference to JS BiQuadFilter of type "bandpass" made with audioContext.createBiquadFilter()
			gain - reference to JS GainNode made with audioContext.createGain()
			compressor - reference to JS DynamicsCompressor made with audioContext.createDynamicsCompressor()
				Compressor settings are as follows - these can be overridden:
				compressor.threshold.setValueAtTime(-50, audioContext.currentTime);
				compressor.knee.setValueAtTime(40, audioContext.currentTime);
				compressor.ratio.setValueAtTime(12, audioContext.currentTime);
				compressor.attack.setValueAtTime(0, audioContext.currentTime);
				compressor.release.setValueAtTime(0.25, audioContext.currentTime);
			notes - an array of notes including the main note (see addNote())
			EFFECTS PROPERTIES
				setting these will start the effect if not already going
				see tone() parameters for definitions (aside from wahAdjust - below)
			wahAmount
			wahRate
			wahShape
			wahThroat
			wahNote
			wahAdjust - wahNote is adjusted up 200 hz - set to 0 to start exactly at main note
			vibratoAmount
			vibratoRate
			vibratoShape
			tremeloAmount
			tremeloRate
			tremeloShape

	oscillator(frequency, gain, shape, offset) - returns a ZIM Synth Oscillator object
		this gives an amplitude (plus offset) in time following the form (wave type) at the frequency
		used internally by wah effects as an offset was needed
		could not figure how to get JS Oscillator to offset frequency - or gain attache to oscillator
		see: https://stackoverflow.com/questions/61666671/how-do-you-offset-gain-attached-to-an-oscillator-using-javascript-web-audio

		PARAMETERS (Oscillator)
		frequency (default 1) - how fast in HZ the oscillator goes up and down on the wave
		gain (default 10) - the height of the wave (amplitude) - and negative gain to the lowest amount
		shape (default SINE) - the type of wave - SINE, SQUARE, TRIANGLE, SAW, ZAP (no custom)
		offset (default 0) - an amount added to the gain so 10 would make gain go from 10 to 20 (for gain of 10)

		PROPERTIES (Oscillator)
		all the parameters as properties - supports ZIM VEE
		type - holds the class name as a String (Oscillator)
		ticker - a reference to the ZIM new Ticker that runs the oscillator

		METHODS (Oscillator)
		pause(state) - pause or unpause the oscillator
			state defaults to true - set to false to unpause oscillator

	STATIC METHODS
	Synth.setShape(oscillator, shape) - sets a new wave on a JS OscillatorNode
		used internally by classes and methods with shape parameter
		oscillator - a JS OscillatorNode
		shape (default SINE) - the type of wave - see tone() shape parameter for details
	Synth.getNote (frequency, semitoneOffset) - provided by ZzFX to handle semitones
		returns a new frequency a number of semitones from the provided frequency
		frequency - the frequency in HZ - eg. 220 - middle A
		semitoneOffset - semitones (think consecutive piano keys) to offset the frequency
	Synth.note(note) - gets a frequency at a musical note
		used internally by classes and methods with note parameter
	Synth.wave(a,b) - prepares a WaveTable or wave data for Tone shape
		a - JSON object with WaveTable - if loading a file pass in asset("wave.json")
		b - if a and b are provided then assumes a custom object {real, imag}
			see tone() shape parameter for details
	Synth.drawWave(shape, color, thickness, backgroundColor, borderColor, borderWidth, corner, padding, paddingV)
		returns a ZIM Container holding a little picture of the wave type with an optional backing square
		shape (default SINE) the type of wave SINE, SQUARE, TRIANGLE, SAW, ZAP
		the rest of the parameters as expected
		has shape and backing properties - shape is a ZIM Shape and backing is a ZIM Rectangle
		also has a type property that matches the shape - SINE, SQUARE, etc.

	STATIC PROPERTIES
	Synth.notes = ["C",,"D",,"E","F",,"G",,"A",,"B"] - major notes skipping sharps and flats
	Synth.major = ["C","D","E","F","G","A","B","C4"] - major notes
	Synth.minor = ["C","D","Eb","F","G","Ab","B","C4"] - minor notes
	Synth.shapes = ["sine","square","triangle","sawtooth","saw","zap","tan","noise"]
		the last two are for ZzFX play() only which has no "saw" (only "sawtooth") and no "zap"

PROPERTIES (Synth)
	volume - get or set the default volume - will be overwritten by first parameter of play() or tone()
	frequency - get or set the default frequency - will be overwritten by frequency parameter of play() or tone() (or note parameter of tone())

EVENTS (Synth)
the result of the play() or tone() method will dispatch a "complete" event when the sound is done
--*///+69.955
	zim.Synth = function(volume, frequency) {
		z_d("69.955");
		this.type = "Synth";

		if (zot(volume)) volume = .3;
		if (zot(frequency)) frequency = 220;
		this.volume = volume;
		this.frequency = frequency;
		var that = this;

		// ZzFX - Zuper Zmall Zound Zynth - Micro Edition
		// MIT License - Copyright 2019 Frank Force
		// https://github.com/KilledByAPixel/ZzFX
		// This is a tiny build of zzfx with only a zzfx function to play sounds.
		// You can use zzfxV to set volume.
		// There is a small bit of optional code to improve compatibility.
		// Feel free to minify it further for your own needs!

		var zzfxX; // ZzFXMicro - Zuper Zmall Zound Zynth
		this.play = function (
			pan,
			volume,
			randomness,
			frequency,
			attackIn,
			sustainIn,
			releaseIn,
			shape,
			shapeCurve,
			slide,
			deltaSlide,
			pitchJump,
			pitchJumpTime,
			repeatTime,
			noise,
			modulation,
			bitCrush,
			delayIn,
			sustainVolume,
			decayIn,			
			tremolo,
			
			place1,
			place2,
			place3,
			place4,
			place5,
			place6,

			// ---------------- these get called on subsequent plays
			// -- Cat 01 - do not seem to be calling these anymore?
			sampleRate,
			attack,
			sustain,
			release,
			decay,
			delay,
			PI2,
			sign,
			length,
			startSlide,
			startFrequency,
			modPhase,
			t,
			tm,
			i,
			r,
			c,
			s,
			j,
			b,
			source,
			buffer
			) {
				var args = Array.prototype.slice.call(arguments);
				args = args.shift(); // remove pan which is not part of ZZFX
				if (!zzfxX && (WW.AudioContext || WW.webkitAudioContext)) {
					zzfxX=new(WW.AudioContext||WW.webkitAudioContext);
					zzfxX.z=zzfxX.createBufferSource;
					zzfxX.createBufferSource=function(s){
					if (s==null) s=zzfxX.z();
					return(s.start=s.start||(function(t){zzfxX.noteOn(t);}),s);
				}
			}
			if (!zzfxX) return;

			pan = (pan!=null)?zik(pan):0;
			volume = (volume!=null)?zik(volume):.3;
			randomness = (randomness!=null)?zik(randomness):.05;
			frequency = (frequency!=null)?zik(frequency):220;
			attackIn = (attackIn!=null)?zik(attackIn):0;
			sustainIn = (sustainIn!=null)?zik(sustainIn):0;
			releaseIn = (releaseIn!=null)?zik(releaseIn):.1;
			shape = (shape!=null)?zik(shape):0;
			shapeCurve = (shapeCurve!=null)?zik(shapeCurve):1;
			slide = (slide!=null)?zik(slide):0;
			deltaSlide = (deltaSlide!=null)?zik(deltaSlide):0;
			pitchJump = (pitchJump!=null)?zik(pitchJump):0;
			pitchJumpTime = (pitchJumpTime!=null)?zik(pitchJumpTime):0;
			repeatTime = (repeatTime!=null)?zik(repeatTime):0;
			noise = (noise!=null)?zik(noise):0;
			modulation = (modulation!=null)?zik(modulation):0;
			bitCrush = (bitCrush!=null)?zik(bitCrush):0;
			delayIn = (delayIn!=null)?zik(delayIn):0;
			tremolo = (tremolo!=null)?zik(tremolo):0;	

			sustainVolume = (sustainVolume!=null)?zik(sustainVolume):1;
			decayIn = (decayIn!=null)?zik(decayIn):0;
			sampleRate = (sampleRate!=null)?zik(sampleRate):44100;

			if (attack==null) attack = 99 + attackIn * sampleRate; // soften attack
			if (sustain==null) sustain = sustainIn * sampleRate;
			if (release==null) release = releaseIn * sampleRate;
			if (decay==null) decay = decayIn * sampleRate;
			if (delay==null) delay = delayIn * sampleRate;
			if (PI2==null) PI2 = Math.PI*2;
			if (sign==null) sign = function(v) {return v > 0 ? 1 : -1;};
			if (length==null) length = attack + decay + sustain + release + delay;
			if (startSlide==null) startSlide = slide *= 500 * PI2 / Math.pow(sampleRate,2);
			if (startFrequency==null) startFrequency = frequency *= (1 + randomness*2*Math.random() - randomness) * PI2 / sampleRate;
			if (modPhase==null) modPhase = sign(modulation) * PI2/4;
			if (t==null) t=0;
			if (tm==null) tm=0;
			if (i==null) i=0;
			if (r==null) r=0;
			if (c==null) c=0;
			if (s==null) s=0;
			if (j==null) j=1;
			if (b==null) b = [];
			if (source==null) source = zzfxX.createBufferSource();
			if (buffer==null) buffer = zzfxX.createBuffer(1, length, sampleRate);

			// loop and generate waveform
			for (source.connect(zzfxX.destination); i < Math.floor(length); b[i++] = s) {
				if (++c > bitCrush * 100) { // bit crush
					c = 0; // reset bit crush
					s = t * frequency * // frequency
						Math.sin(tm * modulation * PI2 / sampleRate - modPhase); // modulation

					s = shape ? shape > 1 ? shape > 2 ? shape > 3 ? // wave shape
						Math.sin(Math.pow(s % PI2, 3)) : // 4 noise
						Math.max(Math.min(Math.tan(s), 1), -1) : // 3 tan
						1 - (2 * s / PI2 % 2 + 2) % 2 : // 2 saw
						1 - 4 * Math.abs(Math.round(s / PI2) - s / PI2) : // 1 triangle
						Math.sin(s); // 0 siny

					s = (repeatTime ?
							1 - tremolo + tremolo * Math.sin(PI2 * i / repeatTime) // tremolo
							:
							1) *
						sign(s) * Math.pow(Math.abs(s), shapeCurve) * // curve 0=square
						volume * that.volume * ( // envelope
							i < attack ? i / attack : // attack
							i < attack + decay ? // decay
							1 - ((i - attack) / decay) * (1 - sustainVolume) : // decay falloff
							i < attack + decay + sustain ? // sustain
							sustainVolume : // sustain volume
							i < length - delay ? // release
							(length - i - delay) / release * // release falloff
							sustainVolume : // release volume
							0); // post release

					s = delay ? s / 2 + (delay > i ? 0 : // delay
						(i < length - delay ? 1 : (i - length) / delay) * // release delay
						b[i - delay | 0] / 2) : s; // sample delay
				}

				t += 1 - noise + (Math.sin(i) + 1) * 1e9 % 2 * noise; // noise
				tm += 1 - noise + (Math.pow(Math.sin(i), 2) + 1) * 1e9 % 2 * noise; // modulation noise
				frequency += slide += deltaSlide // frequency slide
					*
					500 * PI2 / Math.pow(sampleRate, 3); // apply sample rate

				if (j && ++j > pitchJumpTime * sampleRate) // pitch jump
				{
					frequency += pitchJump // apply pitch jump
						*
						PI2 / sampleRate; // apply sample rate
					startFrequency += pitchJump // also apply to start
						*
						PI2 / sampleRate; // apply sample rate
					j = 0; // reset pitch jump time
				}

				if (repeatTime && ++r > repeatTime * sampleRate) // repeat
				{
					frequency = startFrequency; // reset frequency
					slide = startSlide; // reset slide
					r = 1; // reset repeat time
					j = j || 1; // reset pitch jump time
				}
			}

			// create buffer and set source
			buffer.getChannelData(0).set(b);
			source.buffer = buffer;


			// ADDED by Dan Zen
			var synthSound = new createjs.EventDispatcher();
			synthSound.type = "SynthSound";
			synthSound.audioContext = zzfxX;
			synthSound.gain = zzfxX.createGain();
			source.connect(synthSound.gain);		
			synthSound.gain.connect(zzfxX.destination);

			synthSound.pan = zzfxX.createStereoPanner();
			synthSound.pan.pan.value = pan;
			source.connect(synthSound.pan);
			synthSound.pan.connect(zzfxX.destination);

			source.start();
			synthSound.duration = b.length/sampleRate;
			synthSound.playing = true;
			synthSound.stop = function() {
				clearTimeout(synthSound.completeID);
				clearInterval(synthSound.repeatID);
				synthSound.gain.gain.setTargetAtTime(0, zzfxX.currentTime, .1);
				synthSound.playing = false;
				setTimeout(function () {
					zzfxX.close();
				},.1*1000);
			};
			var repeatNum;
			synthSound.repeat = synthSound.loop = function(num, offset) {
				repeatNum = 0;
				if (num === true) num = null;
				if (zot(offset)) offset = 0;
				clearTimeout(synthSound.completeID);
				function adjust() {
					return (synthSound.duration+zik(offset));
				}
				synthSound.repeatID = zim.interval(adjust, function() {
					repeatNum++;
					if (num && repeatNum >= num) {
						synthSound.dispatchEvent("complete");
						synthSound.repeatID.clear();
						synthSound.playing = false;
					} else {
						synthSound.dispatchEvent("loop");
						that.play.apply(that, args);
					}
				});
				return synthSound;
			};
			synthSound.play = function() {
				that.play.apply(that, args);
				synthSound.playing = true;
				return synthSound;
			};
			synthSound.completeID = setTimeout(function () {
				synthSound.dispatchEvent("complete");
			}, (b.length/sampleRate+.1)*1000);
			return synthSound;
		};


		// NOTE PLAYING:

		this.Tone = function(volume, note, shape, pan, duration, attack, release, wahAmount, wahRate, wahShape, wahThroat, wahNote, vibratoAmount, vibratoRate, vibratoShape, tremeloAmount, tremeloRate, tremeloShape, startTime, pauseOnBlur) {
			var sig = "volume, note, shape, pan, duration, attack, release, wahAmount, wahRate, wahShape, wahThroat, wahNote, vibratoAmount, vibratoRate, vibratoShape, tremeloAmount, tremeloRate, tremeloShape, startTime, pauseOnBlur";
			var duo; if (duo = zob(that.Tone, arguments, sig, this)) return duo;
			this.type = "Tone";

			var that2 = this; // that is the Synth object
			var audioContext;

			if (zot(volume)) volume = that.volume;
			if (zot(note)) note = that.frequency;
			if (zot(shape)) shape = zim.SINE;
			if (zot(pan)) pan = 0;
			if (zot(attack)) attack = .02;
			if (zot(release)) release = .05;
			if (zot(startTime)) startTime = 0;

			if (WW.AudioContext || WW.webkitAudioContext) {
				audioContext = this.audioContext = new (WW.AudioContext||WW.webkitAudioContext);
			} else {if (zon) zogy("Synth tone() needs AudioContext");}

			volume = zik(volume);
			note = zik(note);
			shape = zik(shape);
			pan = zik(pan);
			duration = zik(duration);
			attack = zik(attack);
			release = zik(release);
			wahAmount = zik(wahAmount);
			wahRate = zik(wahRate);
			wahShape = zik(wahShape);
			wahThroat = zik(wahThroat);
			wahNote = zik(wahNote);
			vibratoAmount = zik(vibratoAmount);
			vibratoRate = zik(vibratoRate);
			vibratoShape = zik(vibratoShape);
			tremeloAmount = zik(tremeloAmount);
			tremeloRate = zik(tremeloRate);
			tremeloShape = zik(tremeloShape);
			startTime = zik(startTime);

			var timeType = getTIME(duration);
			that.duration = duration;
			if (duration) duration = duration * (timeType=="s"?1:1/1000);
			if (startTime) {
				getTIME(startTime); // just provide warning if ms is used
				startTime = startTime * (timeType=="s"?1:1/1000);
			}

			that.attack = attack;
			that.release = release;
			that.rampDuration = .02;
			that.hush = .1;

			var oscillator = this.note = this.oscillator = audioContext.createOscillator();
			oscillator.frequency.value = zim.Synth.note(note);
			zim.Synth.setShape(oscillator, shape);

			var filter = this.filter = audioContext.createBiquadFilter();
			filter.type = "bandpass";
			filter.frequency.value = oscillator.frequency.value;
			filter.Q.value = 0; // wahThroat || 0;

			var gain = this.gain = oscillator.gain = audioContext.createGain();
			gain.type = "gain";
			gain.gain.setValueAtTime(0, audioContext.currentTime);

			var compressor = this.compressor = audioContext.createDynamicsCompressor();
			compressor.threshold.setValueAtTime(-50, audioContext.currentTime);
			compressor.knee.setValueAtTime(40, audioContext.currentTime);
			compressor.ratio.setValueAtTime(12, audioContext.currentTime);
			compressor.attack.setValueAtTime(0, audioContext.currentTime);
			compressor.release.setValueAtTime(0.25, audioContext.currentTime);

			var panNode = this.panNode = audioContext.createStereoPanner();
			this.panNode.pan.value = pan;		
			
			oscillator.connect(filter);
			filter.connect(panNode);
			panNode.connect(gain);
			gain.connect(compressor);			
			compressor.connect(audioContext.destination);

			function start(time, attackTime) {
				if (zot(time)) time = audioContext.currentTime;
				if (zot(attackTime)) attackTime = that.attack;
				oscillator.start(time);
				var del = (WW.zdf && new Date().getTime()-WW.zdf.startTime < 200) ? .1 : that.attack;
				gain.gain.setValueAtTime(0,audioContext.currentTime+.1); // value was 0... setting value at 0 pops - setting value at +.1 does not - aaarrgggg!
				gain.gain.linearRampToValueAtTime(volume*that.hush, audioContext.currentTime+.1+del);
			}
			start(startTime);

			this.stop = function(releaseTime) {
				if (zot(releaseTime)) releaseTime = that.release;
				if (gain) ramp(gain.gain, 0, true, releaseTime);
				
				// // this was put in place in Cat 4 to try and set a volume if the sound was stopped right away 
				// // it is causing issues so backed out of it in ZIM NFT - see headroid examples
				// // if you want to stop a tone right away, do not make the tone until you want to play it
				
				// if (gain) {
				// 	if (audioContext.currentTime < 200) {
				// 		zog("here")
				// 		timeout(.2-audioContext.currentTime/1000, function () {
				// 			ramp(gain.gain, 0, true, releaseTime);
				// 		});
				// 	} else ramp(gain.gain, 0, true, releaseTime);
				// }
				if (tremeloGain) ramp(tremeloGain.gain, 0, true, releaseTime);
				if (vibratoGain) ramp(vibratoGain.gain, 0, true, releaseTime);

				setTimeout(function () {
					that2.dispatchEvent("complete");
				}, (.6 + releaseTime + that.rampDuration)*1000);
				setTimeout(function () {
					if (audioContext && !audioContext.iamClosed)  {
						audioContext.iamClosed = true;
						audioContext.close(); // limit of 6 in Edge, 100 in Chrome then it clears for 10 seconds and gives more
					}
				}, (releaseTime+1)*1000);
				setTimeout(function () {
					if (wah) that2.removeWah();
				}, (releaseTime+1)*1000);
			};
			// if (duration) this.stop(startTime+duration-.1);
			if (duration) setTimeout(function () { // reverted back to this in ZIM 015
				that2.stop();
			}, (duration-.1) * 1000);

			var notes = this.notes = [oscillator];

			this.addNote = function(volume, note, shape, toWah, toVibrato, startTime) {
				if (zot(toWah)) toWah = true;
				if (zot(toVibrato)) toVibrato = false;
				if (zot(volume)) volume = .1;
				if (zot(startTime)) startTime = 0;

				var obj = {type:"Note"};
				obj._volume = volume; // just for gettersetter
				obj._note = zim.Synth.note(note); // just for gettersetter
				notes.push(obj);

				var oscillator = obj.oscillator = audioContext.createOscillator();
				oscillator.frequency.value = obj._note;
				oscillator.type = zim.Synth.setShape(oscillator, shape);
				var noteGain = obj.gain = audioContext.createGain();
				ramp(noteGain.gain, obj._volume, true);
				noteGain.connect(toWah?filter:gain);
				oscillator.connect(noteGain);
				if (vibratoGain && toVibrato) vibratoGain.connect(oscillator.frequency);
				oscillator.start(audioContext.currentTime+startTime);

				Object.defineProperty(obj, 'volume', {
					get: function() {
						return obj._volume;
					},
					set: function(value) {
						if (zot(value)) return;
						obj._volume = zik(value);
						ramp(obj.gain.gain, obj._volume, true);
					}
				});

				Object.defineProperty(obj, 'note', {
					get: function() {
						return obj._note;
					},
					set: function(value) {
						if (zot(value)) return;
						obj._note = zik(value);
						ramp(obj.oscillator.frequency, zim.Synth.note(obj._note));
					}
				});
				return obj;
			};

			this.removeNote = function(note) {
				var index = notes.indexOf(note);
				if (index >= 0) notes.splice(index, 1);
				note.oscillator.disconnect();
				note = null;
				return this;
			};

			// note - there is also a ramp method that just does gain
			// this is because animating volume does not work with the gain fix for pops
			// so we have to use ramp to get the fix for just setting a volume one time
			// and use volume to animate volume - this crackle stuff is impossible to work with
			// we have tried dozens of times to fix it, brought in experts and it
			// does not really fix the pop crackle in something like SynthPad - oh well
			// maybe it is our headphones
			function ramp(obj, val, gain, duration) {

				if (zot(val)) val = 0;
				if (zot(duration)) duration = that.rampDuration;

				if (gain) {					
					obj.cancelScheduledValues(audioContext.currentTime);
					obj.linearRampToValueAtTime(
						obj.value,
						audioContext.currentTime + .02);
					obj.linearRampToValueAtTime(
						val,
						audioContext.currentTime + .05 + duration);

					// gain.gain.cancelScheduledValues(audioContext.currentTime);
					// gain.gain.setValueAtTime(gain.gain.value, audioContext.currentTime);
					// gain.gain.linearRampToValueAtTime(volume*that.hush, audioContext.currentTime+that.rampDuration);

				} else {					
					obj.cancelScheduledValues(audioContext.currentTime); // this is deleting duration setting... so took out in 015
					obj.setTargetAtTime(val, audioContext.currentTime, duration);
				}

				// obj.setValueAtTime(obj.value, time);
				// obj.linearRampToValueAtTime(val, time + duration);
				// obj.exponentialRampToValueAtTime(val, audioContext.currentTime + that.rampDuration);

			}

			// note there is a ramp() function too that is used internally
			this.ramp = function(volume, duration) {
				ramp(gain.gain, volume*that.hush, true, duration);
			};

			this.rampPan = function(pan, duration) {
				ramp(panNode.pan, pan, false, duration);
			};

			this.animate = function() {
				if (arguments[0].props) arguments[0].target = this;
				else Array.prototype.unshift.call(arguments, this);
				zim.animate.apply(null, arguments);
				return this;
			};
			this.wiggle = function() {
				if (arguments[0].props) arguments[0].target = this;
				else Array.prototype.unshift.call(arguments, this);
				zim.wiggle.apply(null, arguments);
				return this;
			};

			zim.addWires(this);

			var wah;
			var wahAdjust;
			function makeWah() {
				if (zot(wahAmount)) wahAmount = 1000;
				if (zot(wahRate)) wahRate = 1;
				if (zot(wahShape)) wahShape = "sine";
				if (zot(wahThroat)) wahThroat = 5;
				if (zot(wahNote)) wahNote = that2.oscillator.frequency.value;
				else wahNote = zim.Synth.note(wahNote);
				if (zot(wahAdjust)) wahAdjust = 200;

				that2.filter.Q.value = wahThroat;

				// frequency, gain, type, offset
				wah = that2.wah = that.oscillator(wahRate, wahAmount/2, wahShape, wahNote+wahAmount/2+wahAdjust);
				wah.ticker = zim.Ticker.add(function () {
					that2.filter.frequency.value = that2.wah.amplitude;
				});
			}
			if (wahAmount || wahRate || !zot(wahShape) || !zot(wahThroat)) makeWah();
			that2.removeWah = function() {
				zim.Ticker.remove(wah.ticker);
				wah.dispose();
				wah = that2.wah = null;
				that2.filter.Q.value = 0;
			};


			var vibrato;
			var vibratoGain;
			function makeVibrato() {
				if (zot(vibratoRate)) vibratoRate = 5;
				if (zot(vibratoShape)) vibratoShape = "sine";
				if (zot(vibratoAmount)) vibratoAmount = 10;

				vibrato = that2.vibrato = audioContext.createOscillator();
				vibratoGain = that2.vibratoGain = audioContext.createGain();
				// vibratoGain.gain.value = vibratoAmount;

				vibratoGain.gain.value = 0;
				vibrato.frequency.value = vibratoRate;
				zim.Synth.setShape(vibrato, vibratoShape);
				vibrato.connect(vibratoGain);
				vibratoGain.connect(oscillator.frequency);
				vibrato.start(0);
				// could not seem to get ramp() to work with this so hard coding it here...
				vibratoGain.gain.setValueAtTime(0,audioContext.currentTime+.1);
				vibratoGain.gain.linearRampToValueAtTime(vibratoAmount, audioContext.currentTime+.1+that.attack);
			}
			if (vibratoAmount || vibratoRate || !zot(vibratoShape)) makeVibrato();
			that2.removeVibrato = function() {
				ramp(vibratoGain.gain, 0, true);
				setTimeout(function () {
					vibratoGain.disconnect();
					vibrato.disconnect();
					vibrato.stop();
					vibrato = null;
				}, (that.rampDuration+1)*1000);
			};


			var tremelo;
			var tremeloGain;
			function makeTremelo() {
				if (zot(tremeloRate)) tremeloRate = 5;
				if (zot(tremeloShape)) tremeloShape = "sine";
				tremelo = that2.tremelo = audioContext.createOscillator();
				tremeloGain = that2.tremeloGain = audioContext.createGain();
				tremeloGain.gain.value = 0;
				tremelo.frequency.value = tremeloRate;
				zim.Synth.setShape(tremelo, tremeloShape);
				tremelo.connect(tremeloGain);
				tremeloGain.connect(gain.gain);
				tremelo.start(0);
				var del = (WW.zdf && new Date().getTime()-WW.zdf.startTime < 200) ? .1 : that.attack;
				tremeloGain.gain.setValueAtTime(0,audioContext.currentTime+.1); // value was 0... setting value at 0 pops - setting value at +.1 does not - aaarrgggg!
				tremeloGain.gain.linearRampToValueAtTime(volume*that.hush, audioContext.currentTime+.1+del);
			}
			if (tremeloAmount || tremeloRate || !zot(tremeloShape)) makeTremelo();
			that2.removeTremelo = function() {
				ramp(tremeloGain.gain, 0, true);
				setTimeout(function () {
					tremeloGain.disconnect();
					tremelo.disconnect();
					tremelo.stop();
					tremelo = null;
				}, (that.rampDuration+1)*1000);
			};

			Object.defineProperty(this, 'volume', {
				get: function() {
					return volume;
				},
				set: function(value) {
					if (zot(value)) return;
					var proportion;
					if (tremelo) {
						if (gain.gain.value) proportion = tremeloGain.gain.value/gain.gain.value;
						else proportion = volume?tremeloAmount/volume:0;
						volume = zik(value);
						volume = zim.constrain(volume, .001);
						ramp(tremeloGain.gain, volume*proportion*that.hush, true);
					} else {
						volume = zik(value);
					}

					ramp(gain.gain, volume*that.hush, false, that.rampDuration);

					// gain.gain.cancelScheduledValues(audioContext.currentTime);
					// gain.gain.setValueAtTime(gain.gain.value, audioContext.currentTime);
					// gain.gain.linearRampToValueAtTime(volume*that.hush, audioContext.currentTime+that.rampDuration);
				}
			});
			
			this.paused = false;
			var rV = volume;
			this.pause = function(state) {
				if (zot(state)) state = true;
				if (state) {
					rV = that2.volume;
					that2.volume = 0;
				} else {
					that2.volume = rV;
				}
			}
			
			if (pauseOnBlur) {
				if (zot(zim.blurCheck)) zim.setBlurDetect();
				zim.pauseOnBlur.push(this);
			}

			Object.defineProperty(this, 'frequency', {
				get: function() {
					return frequency;
				},
				set: function(value) {
					if (zot(value)) return;
					frequency = zik(value);
					// oscillator.frequency.value = frequency;
					ramp(oscillator.frequency, value);
				}
			});

			Object.defineProperty(this, 'note', {
				get: function() {
					return note;
				},
				set: function(value) {
					if (zot(value)) return;
					note = zik(value);
					oscillator.frequency.value = zim.Synth.note(note);
				}
			});

			Object.defineProperty(this, 'shape', {
				get: function() {
					return shape;
				},
				set: function(value) {
					shape = zik(value);
					zim.Synth.setShape(oscillator, shape);
				}
			});

			Object.defineProperty(this, 'pan', {
				get: function() {
					return pan;
				},
				set: function(value) {
					if (zot(value)) return;
					pan = zik(value);
					ramp(panNode.pan, pan, false, .1);
				}
			});

			Object.defineProperty(this, 'currentTime', {
				get: function() {
					return audioContext.currentTime;
				},
				set: function() {
					if (zon) zogy("Synth tone() - currentTime is read only");
				}
			});

			// WAH
			this.wahAmountMin = 0;
			this.wahAmountMax = 5000;
			Object.defineProperty(this, 'wahAmount', {
				get: function() {
					return wahAmount;
				},
				set: function(value) {
					if (zot(value)) return;
					wahAmount = zik(value);
					wahAmount = zim.constrain(wahAmount, that.wahAmountMin, that.wahAmountMax);
					if (zot(wah)) makeWah();
					else wah.gain = wahAmount/2;
				}
			});

			this.wahRateMin = 0;
			this.wahRateMax = 30;
			Object.defineProperty(this, 'wahRate', {
				get: function() {
					return wahRate;
				},
				set: function(value) {
					if (zot(value)) return;
					wahRate = zik(value);
					wahRate = zim.constrain(wahRate, that.wahRateMin, that.wahRateMax);
					if (zot(wah)) makeWah();
					else wah.frequency = wahRate;
				}
			});

			this.wahThroatMin = 0;
			this.wahThroatMax = 100;
			Object.defineProperty(this, 'wahThroat', {
				get: function() {
					// return wahThroat*1000;
					return wahThroat;
				},
				set: function(value) {
					wahThroat = zik(value);
					wahThroat = zim.constrain(wahThroat, that.wahThroatMin, that.wahThroatMax);
					if (zot(wah)) makeWah();
					else filter.Q.value = wahThroat;
				}
			});

			Object.defineProperty(this, 'wahNote', {
				get: function() {
					return wahNote;
				},
				set: function(value) {
					if (zot(value)) return;
					wahNote = zik(value);
					if (zot(wah)) makeWah();
					else wah.offset = wahNote+wahAmount/2+wahAdjust;
				}
			});

			Object.defineProperty(this, 'wahAdjust', {
				get: function() {
					return wahAdjust;
				},
				set: function(value) {
					if (zot(value)) return;
					wahAdjust = zik(value);
					if (zot(wah)) makeWah();
					else wah.offset = wahNote+wahAmount/2+wahAdjust;
				}
			});

			Object.defineProperty(this, 'wahShape', {
				get: function() {
					return wahShape;
				},
				set: function(value) {
					wahShape = zik(value);
					if (zot(wah)) makeWah();
					else wah.shape = wahShape;
				}
			});


			// tremelo
			Object.defineProperty(this, 'tremeloAmount', {
				get: function() {
					return tremeloAmount;
				},
				set: function(value) {
					if (zot(value)) return;
					tremeloAmount = zik(value);
					if (zot(tremelo)) makeTremelo();
					else tremeloGain.gain.setValueAtTime(tremeloAmount,audioContext.currentTime);
				}
			});

			Object.defineProperty(this, 'tremeloRate', {
				get: function() {
					return tremeloRate;
				},
				set: function(value) {
					if (zot(value)) return;
					tremeloRate = zik(value);
					if (zot(wah)) makeTremelo();
					else tremelo.frequency.value = tremeloRate;
				}
			});

			Object.defineProperty(this, 'tremeloShape', {
				get: function() {
					return tremeloShape;
				},
				set: function(value) {
					tremeloShape = zik(value);
					if (zot(tremelo)) makeTremelo();
					else zim.Synth.setShape(tremelo, tremeloShape);
				}
			});


			// vibrato
			Object.defineProperty(this, 'vibratoAmount', {
				get: function() {
					return vibratoAmount;
				},
				set: function(value) {
					if (zot(value)) return;
					vibratoAmount = zik(value);
					if (zot(vibrato)) makeVibrato();
					else vibratoGain.gain.setValueAtTime(vibratoAmount,audioContext.currentTime);
				}
			});

			Object.defineProperty(this, 'vibratoRate', {
				get: function() {
					return vibratoRate;
				},
				set: function(value) {
					if (zot(value)) return;
					vibratoRate = zik(value);
					if (zot(vibrato)) makeVibrato();
					else vibrato.frequency.value = vibratoRate;
				}
			});

			Object.defineProperty(this, 'vibratoShape', {
				get: function() {
					return vibratoShape;
				},
				set: function(value) {
					vibratoShape = zik(value);
					if (zot(vibrato)) makeVibrato();
					else zim.Synth.setShape(vibrato, vibratoShape);
				}
			});
		};
		zim.extend(this.Tone, createjs.EventDispatcher);

		this.tone = function(volume, note, shape, pan, duration, attack, release, wahAmount, wahRate, wahShape, wahThroat, vibratoAmount, vibratoRate, vibratoShape, tremeloAmount, tremeloRate, tremeloShape, startTime, pauseOnBlur) {
			Array.prototype.unshift.call(arguments, null);
			return new (Function.prototype.bind.apply(that.Tone, arguments)); // yum? // rest in ES6
		};

		this.Oscillator = function (frequency, gain, shape, offset) {
			var sig = "frequency, gain, shape, offset";
			var duo; if (duo = zob(that.Oscillator, arguments, sig, this)) return duo;
			this.type = "Oscillator";
			if (zot(frequency)) frequency = 1;
			if (zot(gain)) gain = 10;
			if (zot(shape)) shape = "sine";
			if (zot(offset)) offset = 0;
			this.frequency = zik(frequency);
			this.gain = zik(gain);
			this.shape = zik(shape);
			
			if (this.shape == "saw") this.shape = "sawtooth";
			this.offset = zik(offset);
			this.paused = false;
			
			var that2 = this;
			
			var counter = 0;
			var sampleSize = zim.Ticker.framerate;
			this.ticker = zim.Ticker.add(function () {
				if (that2.paused) return;
				var a = 0;
				if (that2.shape=="sine") {
					a = Math.sin(that2.frequency * (Math.PI*2 * (counter/sampleSize)));
				} else if (that2.shape=="square") {
					a = Math.sin(that2.frequency * (Math.PI*2 * (counter/sampleSize)));
					a = (a<=0)? 0 : 1;
				} else if (that2.shape=="triangle") {
					a = 2 / Math.PI * Math.asin(Math.sin(that2.frequency * Math.PI*2 * counter/sampleSize));
				} else if (that2.shape=="sawtooth" || that2.shape=="saw") {
					a = -2 / Math.PI * Math.atan(1 / Math.tan(that2.frequency * Math.PI* counter/sampleSize));
				} else if (that2.shape=="zap") {
					a = 2 / Math.PI * Math.atan(1 / Math.tan(that2.frequency * Math.PI* counter/sampleSize));
				}
				that2.amplitude = a * that2.gain + that2.offset;
				counter++;
			});
			this.pause = function(state) { // one day program in ramp
				that2.paused = state;
			};
			this.dispose = function () {
				zim.Ticker.remove(this.ticker);
			};
		};
		this.oscillator = function(frequency, gain, shape, offset) {
			Array.prototype.unshift.call(arguments, null);
			return new (Function.prototype.bind.apply(that.Oscillator, arguments)); // yum? // rest in ES6
		};

	};
	zim.Synth.notes = ["C",null,"D",null,"E","F",null,"G",null,"A",null,"B"];
	zim.Synth.major = ["C","D","E","F","G","A","B","C4"];
	zim.Synth.minor = ["C","D","Eb","F","G","Ab","B","C4"];
	zim.Synth.shapes = ["sine","triangle","sawtooth","tan","noise","square"];
	zim.Synth.setShape = function(oscillator, shape) {
		if (zot(oscillator)) return;
		if (zot(shape)) shape = "sine";
		if (shape == "saw") shape = "sawtooth";
		// sine, square, sawtooth, triangle and custom
		// 0-sine, 1-triangle, 2-sawtooth, 3-tan, 4-noise, 5-square
		var wave;
		if (typeof shape == "number") {
			shape = zim.Synth.shapes[shape];
			if (!shape) shape = "sine";
		} else if (shape.real && shape.imag) {
			wave = oscillator.context.createPeriodicWave(new Float32Array(shape.real), new Float32Array(shape.imag));
		} else if (shape.constructor == PeriodicWave) {
			wave = shape;
		} else if (typeof shape == "string") {
			var index = zim.Synth.shapes.indexOf(shape);
			if (index < 0) shape = "sine";
			if (shape=="noise") {
				var n = 4096;
				var real = new Float32Array(n);
				var imag = new Float32Array(n);
				for(var x=1;x<n;x+=2)
					imag[x] = zim.shuffle([0,.5,1])[0]; // just sounds like square...
					// imag[x] = 4.0 / (Math.PI * x);
				wave = oscillator.context.createPeriodicWave(real,imag);
				// make a periodic wave sound noisy?
			} else if (shape=="tan") {
				// make a periodic wave like tan?
				shape = "sawtooth";
			}
		} else {
			shape = "sine";
		}
		if (wave) {
			oscillator.setPeriodicWave(wave);
			shape = "custom";
		} else {
			oscillator.type = shape;
		}
	};
	zim.Synth.getNote = function(frequency, semitoneOffset) {
		if (zot(semitoneOffset)) semitoneOffset = 0;
		return frequency * Math.pow(2, (semitoneOffset/12));
	};
	zim.Synth.note = function(note) {
		if (typeof note == "string") {
			var root = note.substr(0,1).toUpperCase();
			var octave = zim.loop(note, function (letter) {
				if (!isNaN(letter)) return Number(letter);
			});
			// loop returns true if loop finishes
			// unfortunately, true will return false for isNaN - so JS thinks its a number... sigh
			octave = octave!==true&&!isNaN(octave)?octave:3;
			var index = zim.Synth.notes.indexOf(root);
			if (index < 0) index = 9; // A
			var flats = note.match(/b/g);
			var sharps = note.match(/#/g);
			flats = flats?flats.length:0;
			sharps = sharps?sharps.length:0;
			var offset = (octave-3)*12 + index+sharps - flats;
			return zim.Synth.getNote(zim.Synth.getNote(220,-9), offset);
		} else {
			if (typeof note != "number") note = 220;
			return note;
		}
	};
	zim.Synth.wave = function(a,b) {
		if (WW.AudioContext || WW.webkitAudioContext) {
			var audioContext = new(WW.AudioContext||WW.webkitAudioContext);
			if (a.real) {
				b = a.imag;
				a = a.real;
			} else {
				if (zot(b)) {
					if (zon) {
						zogy("Synth.wave() - pass in asset('wave.json') or real and imag properties");
						return;
					}
				}
			}
			if (a.constructor !== Float32Array) a = new Float32Array(a);
			if (b.constructor !== Float32Array) b = new Float32Array(b);
			return audioContext.createPeriodicWave(a, b);
		}
	};
	zim.Synth.drawWave = function(shape, color, thickness, backgroundColor, borderColor, borderWidth, corner, padding, paddingV) {
		var sig = "shape, color, thickness, backgroundColor, borderColor, borderWidth, corner, padding, paddingV";
		var duo; if (duo = zob(zim.Synth.drawWave, arguments, sig)) return duo;
		var w = 45;
		var h = 45;
		shape = zik(shape);
		if (zot(thickness)) thickness = 2;
		if (zot(color)) color = zim.darker;
		if (zot(padding)) padding = 8;
		if (zot(paddingV)) paddingV = padding;
		var px = padding;
		var py = paddingV;
		var wave = new zim.Container(w,h);
		wave.mouseChildren = false;
		if (!zot(backgroundColor)) {
			wave.backing = new zim.Rectangle(w,h,backgroundColor, borderColor, borderWidth, corner).addTo(wave);
		}
		wave.shape = new zim.Shape(w,h)
			.addTo(wave)
			.s(color)
			.ss(thickness);
		var w2 = w-px*2;
		if (shape == "square") {
			wave.shape.mt(px, h/2).lt(px, py+3).lt(w/2, py+3).lt(w/2,h-py-3).lt(w-px,h-py-3).lt(w-px,h/2);
		}  else if (shape == "triangle") {
			wave.shape.mt(px, h/2).lt(px+w2/4, py+3).lt(px+w2*3/4,h-py-3).lt(w-px,h/2);
		} else if (shape == "sawtooth" || shape == "saw") {
			wave.shape.mt(px, h/2).lt(w/2, py+2).lt(w/2, h-py-2).lt(w-px,h/2);
		} else if (shape == "zap") {
			wave.shape.mt(px, h/2).lt(w/2, h-py-2).lt(w/2, py+2).lt(w-px,h/2);
		}  else {
			wave.shape.mt(px, h/2).bt(w/2,0-15, w/2,h+15, w-px,h/2);
		}
		wave.type = shape;
		return wave;
	};
//-69.955

/*--
zim.VR = function(content, angle, distance, parallax, parallaxAngle, damp, parallaxDamp, startAngle, negativeParallax, borderMarkers, swiper, holder)

VR
zim class - extends a ZIM Container which extends a CreateJS Container
NOTE: Also see the ZIM Three Helper Module for XR controllers, movement and teleport in three.js with ZIM TextureActive (this VR() class is not related)

DESCRIPTION
Copies the content and displays a left and right channel (side-by-side) to be viewed with a VR helmet.
Content can be made to shift side to side as the head turns.  Parallax is also an option.
Works with Google Cardboard & Daydream, Samsung Gear VR, Carl Zeiss VR, Merge VR, View-Master VR
And costing around $20-$30 these are fine: Utopia 360, VRIT VR, ETVR, etc.
Provides a ZIM Swiper for testing on desktop to emulate turning the head.

DETAILS
Make a content Container (with registration point at 0,0) that holds all the content.
Set a depth property on any children in the content container that you want to look 3D
or use the chainable dep() method to apply the depth property.
ZIM VR will copy the content and its depths into left and right containers and mask it.
The content can be accessed via contentLeft and contentRight properties.
The x values of the content that has depth properties set will be shifted according to the depth.
This gives a sense of 3D coming out of the screen for positive depths and into the screen for negative depths.

Device orientation can also be used to move the content as the head is turned and the headset and device moves.
Currently the horizontal movement is built in as that is the trickiest with the 3D effect.
Supply a motion angle (angle) and a motion distance (distance) about which the user will turn their head to see the content.
Optional arrows are provided to map the boundaries of rotation and available as borderLeft and borderRight properties.
You can manually apply vertical shift based on the ZIM Frame deviceOrientation event about the x axis

Horizontal Parallax is provided if desired and will be based on the head rotation if no motion angle is provided
or based on the distance of the object from the center of view if a motion angle is provided.
You can set the parallax details as well like the magnitude, angle, damping, and negative parallax.
Negative values of depth will not produce parallax unless negativeParallax is set to true (this looks funny).
You can make your own vertical parallax if desired using ZIM Parallax and the deviceOrientation event about the x axis.

NOTE: moving content in the x direction should not be done manually.
Rather, use the position() method of VR to properly place both channels and reset the vrStartX positions required.

NOTE: To add or remove content please use the register() and remove() methods.
Any new content should be added to the initial content container.
Do this first, then set the desired depths, then register the new content.
This will clone the new content to the right side channel
and set the shift in x based on depths for both channels.

NOTE: Any modifications afterwards to other properties like alpha, color, y, registration, etc.
must be made manually to both channels - use the contentLeft and contentRight properties.
The contentLeft is the original content (also available as the content property).
You can use the vrMatch property of any content objects to get its other channel partner.
So if you have a label variable for the Label in the original content,
you can access the label in the right hand channel with label.vrMatch
The right channel objects also have vrMatch properties so label.vrMatch.vrMatch is the label ;-)

SEE: https://zimjs.com/vr/

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// Prepare content inside one container
const content = new Container(W/2, H);

// This background tile has no depth or is at "screen" depth
// There will be no depth shift and no parallax
new Tile(new Rectangle(10,10,light), 20, 1, 10).center(content);

// These rectangles are given depth using the dep() method - or set the depth property
// The rectangles will be shifted in the x by VR
// centerReg the objects for proper parallax
const box = new Rectangle(50,50,green).centerReg(content).dep(10);
new Rectangle(70,70,clear,blue,5).centerReg(content).dep(12);

// 1. this just shows content in 3D with no motion:
// const vr = new VR(content).addTo(stage);

// 2. this will move when the head is turned (device is rotated) but with no parallax:
// const vr = new VR(content, 160, 400).center();

// 3. this shows parallax when the head is turned but with no positional movement:
// const vr = new VR(content, 0, 400, 2, 60).center();

// 4. this shows motion and parallax as the head is turned:
const vr = new VR(content, 160, 400, 2, 60).center();


// this will change the color of the box after it has been added to VR:
// box.color = pink; // the left side
// box.vrMatch.color = pink; // the right side

// this would fade in and out the outer rectangles:
// var obj = {obj:{alpha:0}, loop:true, rewind:true};
// vr.contentLeft.getChildAt(2).animate(obj);
// vr.contentRight.getChildAt(2).animate(obj);

// this would remove the outer rectangle:
// vr.remove(vr.content.getChildAt(2));

// this would remove the right hand border marker
// which shows when angle is != 0 and borderMarkers is set to true (default)
// vr.remove(vr.borderRight);

// this shows an inter-ocular adjuster when the stage is pressed
S.on("stagemousedown", ()=>{
	vr.showAdjuster();
});

// the above works fine, but really should remove the event when stage is pressed
// because all presses using the adjuster would be calling showAdjuster
// then add the event again when the adjuster is closed
// but ZIM makes sure that adjuster does not re-open if it is already open.
// Here is what that code would look like:

// var adjusterEvent = S.on("stagemousedown", ()=>{
// 	vr.showAdjuster();
// }, null, true); // run once
// vr.on("close", function() {
// 	adjusterEvent = S.on("stagemousedown", adjusterEvent);
// });

// this code turns the stage yellow if device is rotated beyond the angle parameter value
var adjusterEvent = vr.on("boundaryout", e=>{
	zog(e.boundary); // would be LEFT or RIGHT
	F.color = yellow;
});

// this code changes the stage color back to the original when rotated back in bounds of the angle parameter
vr.on("boundaryin", e=>{
	zog(e.boundary); // would be LEFT or RIGHT
	F.color = lighter;
});

// this would load stereoscopic images to the left and right content (no need to registser)
// F.loadAssets(["stairsRight.jpg", "stairsLeft.jpg"]);
// F.on("complete", ()=>{
// 	new Pic("stairsLeft.jpg").center(vr.contentLeft);
// 	new Pic("stairsRight.jpg").center(vr.contentRight);
// });
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
content - a ZIM Container with registration point at the top left that holds the content
	The content will be placed in the left VR Channel (Container) and cloned to the right VR Channel (Container)
	Set the depth property (or use dep()) of any children (recursive) of the content to be viewed in 3D
	The higher the depth, the more it comes out of the screen which is at 0 depth
	A negative depth will go into the screen but will not have parallax (see negative parallax)
	The left and right content are available as contentLeft and contentRight properties of VR
	Each child of content has a vrMatch property that refers to itself in the other channel
angle - (default 0) the angle in degrees the head can turn to see VR move (half to left, half to right)
	Currently, there is a small glitch in the transition at 360 degrees as damping rewinds and reverses position
	And there is no affordance for wrapping - so content at this location is not recommended
	A fix for this might be provided some time in the future
distance - (default 100) the pixels the content will move over the angle (half to left, half to right)
	OR if there is no angle and there is parallax, the distance the parallax will move over the parallaxAngle
parallax - (default 0) the percentage of the depth it will move for each degree of motion up to the parallaxAngle
parallaxAngle - (default 60) the degree range that parallax will operate (half on one side and half on the other)
damp - (default .5) the damping for motion if angle is provide - quicker than normal for more response turning
parallaxDamp - (default .1) the damping for parallax - smaller number goes slower towards desired position
startAngle - (default 0) the angle to start the viewing
negativeParallax - (default false) set to true to make parallax work for negative depth (looks funny)
boundaryMarkers - (default true) set to false to remove arrow markers at angle boundaries if angle is set
swiper - (default false) set to true to use swiping if not on mobile device - for testing
	If on mobile, swiper is set to false so it does not conflict with the rotation of the device
	The swiper works from -330 to +330 and then stops
	Currently, there is no wrapping system so the limits prevent a glitchy transition
holder - (default zimCurrentFrame stage) set to a Container with bounds set if desired - usually, the stage (default)

METHODS
register(item) - content is usually passed in initially to the content parameter of VR
	but an item (a display object) can be added at any time - to remove items, see remove().
	Set the desired depth property for the item with 0 being the default for the screen depth.
	Add the item to content (contentLeft) with addTo(), center(), centerReg() before registering.
	Do not add the item to contentRight as register() will clone the new item and its children recursively
	to the right side VR Channel and set its depth and parallax.
	NOTE: to add stereoscopic images, one to the left chanel and one to the right channel,
	just add the images using addTo(), center() or centerReg() to contentLeft and contentRight - no need to register()
	returns the item
remove(item) - removes item (and children) from the content of VR - do not manually remove from left and right channels
	returns the item
position(item, x, y) - positions item in VR in both left and right channels - do no manually position left and right
	returns the item
showAdjuster() - shows a panel to set interocular distance - this is saved across app loads
	The panel container can be accessed with adjuster property of VR
	The adjuster property has backing, label, strip, slider, close, zero and ok properties for formatting
	The adjuster sets the regX property of the content to shift the two channels to the desired distance appart
	Generally, this should be the distance between the eyes, but experimentation shows that a smaller distance works well
	This is provided primarily for tablet or desktop where the distance may be too big for the cross-eyed viewing technique
	returns the VR object
hideAdjuster() - hides the adjuster - but the close and ok buttons will do this as well - also see VR events...
	returns the VR object
resize() - call the resize() method to resize VR if the holder size changes - VR can be added to the ResizeManager
	returns the VR object

PROPERTIES
type - holds the class name as a String
angle - read only - the angle provided to the VR parameters
currentAngle - read only - the angle at which the device has been rotated since the start of the app
content - the original content provided to the VR parameters
contentLeft - the content - this shows in the left VR Channel
	The following read-only property is provided on all children of the content:
		vrMatch - a reference to the matching child in the other VR Channel
	The following read-only properties are provided to children of the content that have a depth property
	These are given for content passed in to the content parameter and also to items passed in to the register() mehtod:
		vrChannel - LEFT or RIGHT
		vrStartX - the starting x position before depth effect or parallax is added (could be changed if manually setting x position)
		vrParallaxDistance - the shift in x due to parallax
		vrParallaxDamp - the ZIM Damp object to handle parallax if VR angle is != 0
contentRight - the cloned content - this shows in the right VR Channel (also see contentLeft info)
left - the container that holds the left VR Channel
right - the container that holds the right VR Channel
adjuster - the adjuster panel - see showAdjuster() method for details
swiper - the ZIM Swiper if swiper parameter is set to true to test the motion if not on device
boundaryLeft - the left boundary container if boundary parameter is true
boundaryRight - the right boundary container if boundary parameter is true

EVENTS
boundaryout - dispatched when rotated past a boundary region - the event object provides a boundary property with LEFT or RIGHT values
boundaryin - dispatched when rotated into the boundary region - the event object provides a boundary property with LEFT or RIGHT values
saved - dispatch when OK button on adjuster panel is pressed to set the interocular distance
closed - dispatches when X and OK button is pressed to close the adjuster panel
--*///+69.98
    zim.VR = function (content, angle, distance, parallax, parallaxAngle, damp, parallaxDamp, startAngle, negativeParallax, boundaryMarkers, swiper, holder) {
        var sig = "content, angle, distance, parallax, parallaxAngle, damp, parallaxDamp, startAngle, negativeParallax, boundaryMarkers, swiper, holder";
        var duo; if (duo = zob(zim.VR, arguments, sig, this)) return duo;
		z_d("69.98");
        this.type = "VR";
        if (!WW.zdf) {if (zon) zogy("VR() - please use ZIM Frame"); return;}
        var frame = WW.zdf;
        if (zot(holder) || !holder.getBounds || !holder.getBounds().width) holder = frame.stage;
        if (zot(angle)) angle = 0;
        if (zot(distance)) distance = 100;
        if (zot(damp)) damp = .5;
        if (zot(parallax)) parallax = 0;
        if (zot(parallaxAngle)) parallaxAngle = 60; // parallax operates to 30 degrees on each side of object
        if (zot(parallaxDamp)) parallaxDamp = .1;
        if (zot(startAngle)) startAngle = 0;
        if (zot(negativeParallax)) negativeParallax = false;
        if (zot(boundaryMarkers)) boundaryMarkers = true;
		if (zot(swiper)) swiper = true;
        this.angle = angle;
        this.currentAngle = startAngle;
		if (zim.mobile()) swiper = false;

        var that = this;

        var holderW = holder.width;
        var holderH = holder.height;
        that.zimContainer_constructor();
        var left = that.left = new zim.Container(holderW/2, holderH, null, null, false);
        var backing = new zim.Rectangle(holderW/2, holderH, "rgba(0,0,0,.01)", null, null, null, null, null, null, false);
        left.addChild(backing);
        var right = that.right = left.clone();
        that.addChild(left, right);
        right.x = holderW/2;

        var contentLeft = that.contentLeft = that.content = content;
        var contentRight = that.contentRight = content.clone();
        if (startAngle != 0) var startAngleTimeout = setTimeout(addContent, 100);
        else addContent();
        function addContent() {
            contentLeft.addTo(left, null, false).setMask(left.getChildAt(0)).pos({y:(holder.height-contentLeft.height)/2, reg:true});
            contentRight.addTo(right, null, false).setMask(right.getChildAt(0)).pos({y:(holder.height-contentLeft.height)/2, reg:true});
        }

        var leftVR = []; // lists of eligable containers
        var rightVR = [];
        function copyDepth(left, right, registerLeft, registerRight) {
            left.vrMatch = right;
            right.vrMatch = left;
            if (left.cacheCanvas) right.cache();
            if (left.dep && !zot(left.depth)) {
                leftVR.push(left);
                rightVR.push(right);
                if (!zot(registerLeft)) registerLeft.push(left);
                if (!zot(registerRight)) registerRight.push(right);
                right.dep(left.depth);
            }
            // recursive
            zim.loop(left, function(left, i){
                copyDepth(left, right.getChildAt(i), registerLeft, registerRight);
            });
        }
        copyDepth(contentLeft, contentRight);

        function setDepth(list, channel) {
            zim.loop(list, function(container) {
                container.vrChannel = channel;
                container.vrStartX = container.x;
                if (angle != 0 && distance != 0) {
                    container.vrAngle = angle;
                    container.vrDistance = distance;
                }
                if (parallax != 0 && distance != 0) {
                    container.vrParallax = parallax/100;
                    container.vrParallaxDistance = 0;
                    if (angle != 0) container.vrParallaxDamp = new zim.Damp(0, parallaxDamp);
                }
                container.dep(container.depth);
            });
        }
        setDepth(leftVR, "left");
        setDepth(rightVR, "right");

        if (angle != 0 && distance != 0) {
            // overall motion of content due to head turn
            var pd = new zim.Damp(180+startAngle, damp);
            pd.immediate(180+startAngle);
			var minCheck = false;
			var maxCheck = false;
            frame.on("deviceorientation", function(e) {
                moveVR(pd.convert((e.rotation.z > 180 ? -180 : 180) + e.rotation.z + startAngle)-180);
			});			
            zim.Ticker.always();           
        }
		function moveVR(a) {
			that.currentAngle = a;
			var d = -that.currentAngle * distance / angle;
			that.contentLeft.x = d;
			that.contentRight.x = d;
			var ev;
			if (Math.round(that.currentAngle) <= -angle/2 && !minCheck) {
				ev = new createjs.Event("boundaryout");
				ev.boundary = "left";
				minCheck = true;
				that.dispatchEvent(ev);
			} else if (Math.round(that.currentAngle) >= angle/2 && !maxCheck) {
				ev = new createjs.Event("boundaryout");
				ev.boundary = "right";
				maxCheck = true;
				that.dispatchEvent(ev);
			} else if (Math.round(that.currentAngle) > -angle/2 && Math.round(that.currentAngle) < angle/2) {
				ev = new createjs.Event("boundaryin");
				if (minCheck) {
					ev.boundary = "left";
					that.dispatchEvent(ev);
					minCheck = false;
				} else if (maxCheck) {
					ev.boundary = "right";
					that.dispatchEvent(ev);
					maxCheck = false;
				}
			}
		}
		function calculateDistance(container) {
			var point = container.parent.localToLocal(container.vrStartX, 0, holder);
			var d = container.vrParallaxDamp.convert(container.vrChannel == "left" ? that.contentLeft.x + point.x - holderW / 4 : that.contentRight.x + point.x - holderW / 2 - holderW / 4);
			if (container.depth <= 0 && !negativeParallax) d = 0;
			container.vrParallaxDistance = Math.max(-distance/angle*parallaxAngle/2, Math.min(distance/angle*parallaxAngle/2, d));
			container.dep(container.depth);
		}
		
        if (parallax != 0 && distance != 0) {
            var parallaxPD = new zim.ProportionDamp(180-parallaxAngle/2, 180+parallaxAngle/2, -parallaxAngle/2, parallaxAngle/2, parallaxDamp);
			parallaxPD.immediate(180);
            frame.on("deviceorientation", function(e) {
				// only parallax based on distance, parallax factor and parallax angle - no content movement
				var a = 0;
				if (angle == 0 && parallax !=0 && distance !=0) a = parallaxPD.convert((e.rotation.z > 180 ? -180 : 180) + e.rotation.z);
				doParallax(a);
			});			
            zim.Ticker.always();
        }
		
		function calculateDistance2(container, a) {
			container.vrParallaxDistance = (container.depth <= 0 && !negativeParallax) ? 0 : a;
			container.dep(container.depth); // set the depth again now that the parallax Distance has changed
		}
		
		function doParallax(a) {
			if (angle != 0 && distance != 0) { // movement and parallax
				// content movement so base parallax on distance of content from center of view
				zim.loop(leftVR, calculateDistance);
				zim.loop(rightVR, calculateDistance);
			} else { // only parallax
				zim.loop(leftVR, function(container) {calculateDistance2(container, a);});
				zim.loop(rightVR, function(container) {calculateDistance2(container, a);});
			}
		}

		if (swiper && distance !=0 && (angle !=0 || parallax != 0)) {
			that.added(function() {
				var swipeObject = {swipeAngle:0};
				that.swiper = new zim.Swiper({
					swipeOn:that,
					target:swipeObject,
					property:"swipeAngle",
					sensitivity:.2,
					damp:.05,
					factor:-1,
					min:-330,
					max:330
				});
				zim.Ticker.add(function() {
					// if (swipeObject.swipeAngle > 180) {
					// 	swipeObject.swipeAngle -= 360;
					// 	swiper.immediate(swipeObject.swipeAngle);
					// 	parallaxD.immediate(swipeObject.swipeAngle);
					// 	pd.immediate(swipeObject.swipeAngle);
					// }
					// if (swipeObject.swipeAngle < -180) {
					// 	swipeObject.swipeAngle += 360;
					// 	swiper.immediate(swipeObject.swipeAngle);
					// 	parallaxD.immediate(swipeObject.swipeAngle);
					// 	pd.immediate(swipeObject.swipeAngle);
					// }
					if (angle != 0 && distance != 0) moveVR(swipeObject.swipeAngle);
					if (parallax != 0 && distance != 0) doParallax(parallaxPD.convert(swipeObject.swipeAngle+180));
				});
			});
		}


		// ADJUSTER INTERFACE
		// localStorage.clear();
		var eyeAdjust = localStorage && localStorage.zimEyeAdjust ? Number(localStorage.zimEyeAdjust) : 0;
		var lastEyeAdjust = eyeAdjust;
		var adjusterCheck = false;
		contentLeft.startRegX = contentLeft.regX;
		contentRight.startRegX = contentRight.regX;
		var adjuster = this.adjuster = new zim.Container(800, 300, null, null, false);
		backing = adjuster.backing = new zim.Rectangle(adjuster.width, adjuster.height, zim.lighter, null, null, null, null, null, null, false).center(adjuster).alp(1).sha("rgba(0,0,0,.2)", 0, 0, 30);
		adjuster.strip = new zim.Rectangle(adjuster.width, adjuster.height/3, zim.white, null, null, null, null, null, null, false).center(adjuster).alp(1);
		adjuster.label = new zim.Label({
			text:"slide to adjust center of left and right",
			size:28,
			color:zim.dark,
			align:"center",
			valign:"center"
		}).center(adjuster).pos({y:50, reg:true});

		var close = adjuster.close = new zim.Rectangle(50,50,zim.light, null, null, null, null, null, null, false).addTo(adjuster).mov(adjuster.width-70, 26);
		var ex = new zim.Shape(-40,-40,80,80,null,false);
		ex.graphics.f(zim.dark).p("AmJEVIEUkTIkXkWIB4h5IEWEYIETkTIB4B3IkTESIEQERIh4B4IkRkRIkSEVg"); // width about 90 reg in middle
		ex.center(close).sca(.3);
		close.cur("pointer");
		close.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function() {
			that.hideAdjuster();
			slider.currentValue = (slider.max - slider.min) / 2 + lastEyeAdjust;
			that.dispatchEvent("closed");
		});

		var dotLeft = new zim.Circle(30, zim.dark, null, null, null, null, null, null, null, false).center(adjuster).pos({x:adjuster.width/4, reg:true});
		dotLeft.shape.alpha = .2;
		new zim.Circle(12, zim.dark, null, null, null, null, null, null, false).center(dotLeft);
		var dotRight = new zim.Circle(30, zim.dark, null, null, null, null, null, null, false).center(adjuster).pos({x:adjuster.width/4*3, reg:true});
		dotRight.shape.alpha = .2;
		new zim.Circle(12, zim.dark, null, null, null, null, null, null, null, false).center(dotRight);
		var slider = adjuster.slider = new zim.Slider({
			min:0, max:30, step:1, useTicks:true, style:false
		}).centerReg(adjuster).pos({y:adjuster.height-40, reg:true});
		slider.currentValue = (slider.max - slider.min) / 2 + eyeAdjust;
		var leftP = new zim.Proportion(slider.min, slider.max, dotLeft.x-adjuster.width/4, dotLeft.x+adjuster.width/4, -1);
		var rightP = new zim.Proportion(slider.min, slider.max, dotRight.x-adjuster.width/4, dotRight.x+adjuster.width/4);
		slider.on("change", function() {
			dotLeft.x = leftP.convert(slider.currentValue);
			dotRight.x = rightP.convert(slider.currentValue);
		});
		new zim.Label("closer", 24, null, zim.silver).centerReg(adjuster).pos({x:slider.x - 220, y:slider.y, reg:true});
		new zim.Label("farther", 24, null, zim.silver).centerReg(adjuster).pos({x:slider.x + 220, y:slider.y, reg:true});
		var ok = that.ok = new zim.Button({
			label:"OK",
			width:90,
			height:60,
			corner:0,
			backgroundColor:zim.blue,
			rollBackgroundColor:zim.green,
			shadowColor:-1,
			style:false
		}).centerReg(adjuster).sca(.8).pos({x:adjuster.width-58, y:slider.y, reg:true});

		ok.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function() {
			if (localStorage) localStorage.zimEyeAdjust = slider.currentValue - (slider.max - slider.min) / 2;
			setReg();
			that.hideAdjuster();
			that.dispatchEvent("saved");
			that.dispatchEvent("closed");
		});

		var zero = that.zero = new zim.Button({
			label:">|<",
			width:90,
			height:60,
			corner:0,
			backgroundColor:zim.yellow,
			rollBackgroundColor:zim.green,
			shadowColor:-1,
			style:false
		}).centerReg(adjuster).sca(.8).pos({x:58, y:slider.y, reg:true});
		zero.on((!zns?WW.ACTIONEVENT=="mousedown":zim.ACTIONEVENT=="mousedown")?"mousedown":"click", function() {
			slider.currentValue = (slider.max - slider.min) / 2;
			dotLeft.x = leftP.convert(slider.currentValue);
			dotRight.x = rightP.convert(slider.currentValue);
		});

		var adjusterP = new zim.Proportion(0, 30, -holder.width/4, holder.width/4);
		function setReg() {
			// shift the registration point of the content to accommodate eye distance adjust
			var change = adjusterP.convert(slider.currentValue);
			contentLeft.regX = contentLeft.startRegX + change;
			contentRight.regX = contentRight.startRegX - change;
		}
		setReg();

		this.showAdjuster = function() {
			if (adjusterCheck) return that;
			adjusterCheck = true;
			dotLeft.x = leftP.convert(slider.currentValue);
			dotRight.x = rightP.convert(slider.currentValue);
			lastEyeAdjust = slider.currentValue - (slider.max - slider.min) / 2;
			adjuster.scaleTo(holder,100,100).center(this);
			holder.stage.update();
		};

		this.hideAdjuster = function() {
			if (!adjusterCheck) return that;
			adjusterCheck = false;
			adjuster.removeFrom(this);
			holder.stage.update();
		};

		this.position = function(item, x, y) {
			posit(item);
			posit(item.vrMatch);
			function posit(it) {
				it.vrStartX = x;
				if (it.vrParallaxDamp) it.vrParallaxDamp.immediate(x);
				it.mov(x, y);
			}
			return item;
		};

        this.register = function(item) {
            // object must be added to content container
            if (!item.parent || !item.parent.vrMatch) {
                if (zon) {zogy("ZIM VR() - please only register objects already inside content container");}
                return item;
            }
			var itemRight = item.clone().addTo(item.parent.vrMatch);

            var registerLeft = [];
            var registerRight = [];
            copyDepth(item, itemRight, registerLeft, registerRight);
            setDepth(registerLeft, "left");
            setDepth(registerRight, "right");
            return item;
        };

        if (angle != 0 && distance != 0 && boundaryMarkers) {
            that.boundaryRight = new zim.Container({style:false});
            new zim.Circle(24, zim.light, null, null, null, null, null, null, null, false).addTo(that.boundaryRight).dep(-2);
            new zim.Triangle(16,16,16,zim.yellow, zim.grey,null,null, null,-3,null,null,false).rot(-90).center(that.boundaryRight).dep(-6);
            that.boundaryRight.center(content).mov(distance/2+24);
            that.boundaryLeft = new zim.Container({style:false});
            new zim.Circle(24, zim.light, null, null, null, null, null, null, null, false).addTo(that.boundaryLeft).dep(-2);
            new zim.Triangle(16,16,16,zim.yellow, zim.grey,null,null, null,-3,null,null,false).rot(90).center(that.boundaryLeft).dep(-6);
            that.boundaryLeft.center(content).mov(-distance/2-24);
            that.register(that.boundaryRight);
            that.register(that.boundaryLeft);
        }

        function removeItem(item) {
            var index = leftVR.indexOf(item);
            if (leftVR.indexOf(item) >= 0) {
                leftVR.splice(index, 1);
                rightVR.splice(index, 1);
            }
            zim.loop(item, function(inside) {
                removeItem(inside);
            });
        }

        this.remove = function() {
            // call to remove an item from VR
            // Note: arguments is an object with properties matching the index of the argument
            zim.loop(arguments, function(index, item) {
                if (!content.contains(item)) return;
                removeItem(item);
                item.parent.removeChild(item);
                item.vrMatch.parent.removeChild(item.vrMatch);
            });
            return that;
        };

        this.resize = function() {
            holderW = holder.width;
            holderH = holder.height;
            left.getChildAt(0).widthOnly = right.getChildAt(0).widthOnly = holderW/2;
            left.getChildAt(0).heightOnly = right.getChildAt(0).heightOnly = holderH;
            right.x = holderW/2;
            left.setBounds(0,0,holderW/2,holderH);
            right.setBounds(0,0,holderW/2,holderH);
            if (startAngle != 0) {
                clearTimeout(startAngleTimeout);
                startAngleTimeout = setTimeout(addContent, 100);
            }
            else addContent();
			adjuster.scaleTo(holder,100,100).center(this, null, false);
        };
    };
    zim.extend(zim.VR, zim.Container, "clone", "zimContainer", false);
	//-69.98

// added to Distill as provided global properties
zim.scaX = 1;
zim.scaY = 1;

////////////////  ZIM FRAME  //////////////

// Zim Frame provides code to help you set up your coding environment

/*--
zim.Frame = function(scaling, width, height, color, outerColor, ready, assets, path, progress, ticker, rollover, touch, scrollTop, align, valign, canvasID, rollPerSecond, delay, canvasCheck, gpu, gpuObj, nextFrame, nextStage, allowDefault, loadFailObj, sensors, retina, mouseMoveOutside, captureMouse, shim, maxConnections, maxNum, singleTouch)

Frame
zim class - extends a createjs EventDispatcher

DESCRIPTION
Frame creates a canvas and stage.
Frame lets you decide how you want your stage to scale.
It also provides events for ready, resizing and orientation change
as well as a way to remake the canvas if necessary.
Frame handles loading Bitmap, Sound, etc. assets by wrapping PreloadJS
See https://zimjs.com/frame.html for sample templates using Frame.

The first frame made is called the zimDefaultFrame - or zdf.
It will also have the default stage for addTo(), center(), etc. 
Use setDefault() on another frame to change the default frame. 

As of ZIM ZIM 01, ZIM will make F, S, W, H global variables 
that reference the zimDefaultFrame, its stage and the stage width and height. 
The width and height will be updated in FULL mode if the window size changes.

ZIM ASSET TOOL
See https://zimjs.com/assetlist/
Optionally use this tool to prepare an array of assets from a folder.

CANVAS ALTERNATIVE CONTENT
Frame will move any tag with an id of canvasIDAlternative into the canvas tag.
By default, the canvasID is "myCanvas" so use an id of "myCanvasAlternative".
This allows you to show content for non-canvas browsers.
The content may also be indexed by search engines - one would hope
and is read by screen readers (see also ZIM Accessibility).

NOTE: addTo(), center(), centerReg(), loc(), pos(), new Ticker.add()
default to the stage of the first frame made
use the setDefault() method to set a frame to the default frame

NOTE: here are some tips that relate to Frame: 
https://zimjs.com/tips#FRAME
https://zimjs.com/tips#IMAGES
https://zimjs.com/tips#SOUND
https://zimjs.com/tips#FULLSCREEN

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// load assets such as images right in Frame call using a url
// put multiple assets in an array - see assets parameter for options
// the path and progress are optional

new Frame(FIT, 1024, 768, "#ddd", "#333", ready, "image.png", "assets/", new Waiter());
function ready() {

	new Pic("image.png").center(); // formerly had used asset("image.png").center();

} // end ready
END EXAMPLE

EXAMPLE
// load assets on-demand inside ready event

new Frame(FIT, 1024, 768, dark, light, ready);
function ready() {
 
	// code here - or optionally load assets

	F.loadAssets("image.png");
	F.on("complete", ()=>{

		// app code goes here if waiting for assets
		var image = new Pic("image.png");
		image.center();
		S.update();

	}); // end asset complete

	// OR for multiple assets in an assets folder:

	F.loadAssets(["sound.mp3", "spriteData.json", "spriteImage.png"], "assets/");
	F.on("complete", ()=>{

		// app code goes here if waiting for assets
		const soundInstance = new Aud("sound.mp3").play(); // formerly asset("sound.mp3").play()
		// later soundInstance.paused = true; // etc.

		const sprite = new Sprite({json:"spriteData.json"});
		sprite.center().run(2);
		// the image for the sprite is specified in the JSON
		// but we still want to load it so it is in the loadAssets()
		// and the JSON data will take care of adding it to the sprite

		S.update();

	}); // end asset complete

} // end of ready
END EXAMPLE

EXAMPLE 
// lazy-load image - added in ZIM Cat
// this means that the asset is not passed into the Frame in the assets parameter 
// and it is not added with loadAssets() but rather just called with asset().

new Frame(FIT, 1024, 768, dark, light, ready); // no assets parameter
function ready() {
	
	// lazy-loading will make a container with type "AC" (Asset Container)
	// it will store requested transform information 
	// such as that the container is supposed to be centered in this case
	// (remember, the dimensions are unknown until the Bitmap is loaded)
	// then call loadAssets() behind the scene 
	// and add the Bitmap to the container 
	// if loading is successful, it will rename the type to "Image"
	// then it will use the dimensions to center the container 
	
	new Pic("image.jpg").center(); // formerly asset("image.jpg")
	
	// there are many things that can be done to an object 
	// that need dimensions - ZIM tries to handle these 
	// but if there is something obscure like gesture bounds 
	// that ZIM may have missed then use conventional loading 
	// or try loading with dimensions provided:
	
	new Pic("image.jpg", 100, 200).center(); 
	
	// NOTE: do not lazy-load Sprite images. 
}
END EXAMPLE 

EXAMPLE
	// With multiple loadAsset() calls you can assign the results to a variable
	// and use that variable for the events independently
	// Warning, each of these will still call a frame complete event
	// so usually you would use one or the other but not both

	const first = F.loadAssets("image.png");
	first.on("complete", ()=>{
		const image = new Pic("image.png").center();
		S.update();
	});

	const second = F.loadAssets("sound.mp3");
	second.on("complete", ()=>{
		const sound = new Aud("sound.mp3").play();
	});
END EXAMPLE

EXAMPLE
// if app is in an iFrame, this will get keyboardAccess using a hidden F.keyboardMessage()
// good for games that need keyboard if the game is in an iFrame like the Editor or CodePen
new Pane({content:"START", keyboardAccess:true}).show(); 
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
scaling - (default FULL) can have values as follows 
Note: as of ZIM Cat 04, the constant FIT or the string "fit", etc. can be used
FIT      sets canvas and stage to dimensions and scales to fit inside window size
FILL     sets canvas and stage to dimensions and scales to fill window size (previously "outside")
FULL     sets stage to window size with no scaling
"tagID"  add canvas to HTML tag of ID - set to dimensions if provided - no scaling

FIT and FILL: width and height will set the stage width and height and the canvas is then scaled
this is handy because all your dimensions are set to start
FULL: width and height are ignored when scaling as these are set to the window width and height
TAG: if width and height are provided then the canvas and stage will be these dimensions
if width and height are not provided in tag mode, the canvas and stage will take the dimensions of the tag
this means, the tag must have some sort of width and height dimensions set or it will be really big!
In this mode, you may need to style the containing tag with CSS to get a desired effect.

width - (default 1024 except for full**) the width of the stage
height - (default 768 except for full**) the height of the stage
** if tag mode and no width or height then these will be the width and height of the tag
color - (default null) the background color of the frame (any CSS value) - or just set in styles
	will be see-through if not specified
outerColor - (default null) the body color of the HTML page - null will not adjust the background color
ready - (default null) - an callback function for when the Frame is ready - rather than using the "ready" event 
	this will be passed frame specific (frame, stage, width, height, mobile) parameters
	the stage is updated after this function is called
assets - (default null) - 1. a string asset or 2. an array of assets, 3. ZIM asset object, 4. ZIM multi-asset object
	1. "logo.png"
	2. ["logo.png", "bounce.mp3", "Reuben.otf"]
	3. {id:"string", src:"logo.png", path:"assets/", loadTimeout:2, noCORSonImage:true}
	4. [{assets:["one.png", "two.png"], path:"images/"}, {assets:["big.mp3", "oof.mp3"], path:"sounds/"}]
	** see the loadAssets() method for details - including more file types, etc.
	NOTE: "complete", "progress" and "fileLoaded" events are not dispatched
		use loadAssets() for these if desired
		the "ready" event will be dispatched when the canvas is ready and initial assets are loaded
	NOTE: the loadAssets() method can still be used as desired
	NOTE: as of ZIM Cat 04, SVG will be automatically converted to a Bitmap with and svg property of the original SVG.
	SEE: https://zimjs.com/assetlist/ for many files
path - (default null) - a string path for the assets
	if an assets object is provide with a path then this parameter is ignored
	this will also set the ZIM PATH global to the path
	ZIM PATH is used with lazy-loaded images (eg. when not using Frame assets parameter or loadAssets() method)
ticker - (default null) - an optional callback function to be added to the ZIM Ticker - rather than using Ticker.add();
	this will be passed frame specific (count, frame, stage, width, height) parameters 
	count starts at 1 and the stage is updated after this function is called
	also see the pauseTicker() method
progress - (default null) - set to a Waiter() or ProgressBar() object to show while loading
rollover - (default true or false on mobile) activates rollovers
touch - (default true) activates touch on mobile - this will be multitouch by default 
	set to false for no touch on mobile - also see singleTouch parameter to set singleTouch 
scrollTop - (default false) activates scrolling on older apple devices to hide the url bar
align - (default CENTER) for FIT and FILL, the horizontal alignment LEFT, CENTER, RIGHT
valign - (default CENTER) for FIT and FILL, the vertical alignment TOP, CENTER, BOTTOM
canvasID - (default "myCanvas" or if subsequent frame, myCanvas+randomID) will be set to tagIDCanvas if a tagID is provided - eg. scaling="test", canvasID="testCanvas"
rollPerSecond - (default 20) times per second rollover is activated (if rollover parameter is true)
delay - (default .03 and 1 for mobile) seconds to resize at load and after orientation change (also see ZIM TIME constant)
 	some devices are slow to report true width and height
	At loading, mobile will be tested right away and then at .1 seconds
	the default is to then test again at the delay (default 1 second)
	At resize, mobile will be tested every .05 seconds up to the delay
	set this to some other time if desired
	if set to 0 then no additional test will be done - not even the one at .03 seconds
canvasCheck - (default true) check to see if there is canvas support - uses !!window.HTMLCanvasElement
gpu - (default false) set to true to use a CreateJS StageGL stage for GPU renderer
	note: retina will be turned off if gpu is on otherwise antialiasing really looks bad
 	See: https://blog.createjs.com/stagegl-faster-better-stronger-webgl-update-easeljs/ (written before version 1 release)
gpuObj - (default null) object with following properties (with defaults) See CreateJS docs on GITHUB:
	preserveBuffer (false), antialias (false), transparent (false), premultiply (false), autoPurge (1200)
nextFrame - (default null) set to zim Frame object of Frame underneath current Frame to pass events to nextFrame
nextStage - (default null) alternative to nextFrame if the stage beneath current Frame is not a ZIM Frame but just a CreateJS Stage
allowDefault - (default false - true for tag mode) set to true to allow default mouse, key and scrollwheel events on canvas
	See also the zil property of frame that allows you to add and remove these events dynamically (except for mouse swipe scroll and zoom on mobile)
	allowDefault of false also sets body overflow to hidden - which is good for full, fit and fill modes
	also see allowDefault property
loadFailObj - (default result of F.makeCircles) object that shows if asset() does not exist or did not load withing loadTimeout
	This will be given a type property of "EmptyAsset"
	Set the loadFailObj property below to null to set no object - but this will yield errors unless each resulting asset() is tested
	Set to new Container() to show nothing (but avoid errors) - or new Rectangle(10, 10) to show little black square, etc.
sensors - (default false) set to true to capture Frame devicemotion and deviceorientation events - see Events
retina - (default true) scales stage to use pixelDensity (sharper when scaling up) and supports Adobe Animate export
	may need to set mouse event targets to e.stageX/zim.scaX and e.stageY.zim.scaY
	except for using S.getObjectUnderPoint()
	ZIM overrides CreateJS localToGlobal, globalToLocal and localToLocal to accomodate stage scaling
	This was a major adjustment to transform(), bezier controls, outline, physics, etc.
	set to false to return to traditional PRE ZIM 10.3.0 unscaled stage
mouseMoveOutside - (default false) set to true to capture mouse movement outside the stage
	see also mouseX and mouseY properties of frame - these work with ZIM retina without adjusting for stage scale
captureMouse - (default true) set to false to not use stagemousemove event to set F.mouseX and F.mouseY (good with Retina)
shim - (default null) used by ZIM SHIM 2 https://zimjs.com/animate/ to create Frame with pre-existing stage and canvas
	accepts an object with stage and canvas properties - lets Adobe handle resize
maxConnections - (default 10) set the maximum number of concurrent connections.
	From CreateJS PreloadJS: Note that browsers and servers may have a built-in maximum number of open connections,
	so any additional connections may remain in a pending state until the browser opens the connection.
maxNum - for sound this is how many instances of the sound can play at once 
	also can set in asset object maxNum property and loadAssets() and asset() maxNum parameters.
	also see sound interrupt parameter
singleTouch - set to true for single touch rather than the default multitouch (or touch false)
	this will override the touch setting to turn touch to true

METHODS
loadAssets(assets, path, progress, xhr, time, loadTimeout, outputAudioSprite, crossOrigin, fileType, queueOnly, maxConnections, maxNum)  |ZIM DUO| also accepts ZIM DUO configuration object as single parameter
	// see also assets and path parameters of Frame - which share the info below
	// see https://zimjs.com/assetlist/ to get an array of many files
	assets - a file (url String, asset object or multi-asset object) or files in an Array
		each asset String is how you then access the asset with the asset() method of Frame
		asset types (from CreateJS PreloadJS): Image, Font, JSON, Sound, SVG, Text, XML		
		NOTE: as of ZIM ZIM 02, fonts can be loaded with just the font file name (including Google Fonts) rather than a ZIM font object - see FONTS in the Docs. 
		NOTE: as of ZIM Cat 04, SVG will be automatically converted to a Bitmap with and svg property of the original SVG.
		asset can also be a ZIM asset object:
			{id:"string", src:"filename", path:"dir/", loadTimeout:1, maxNum:num, noCORSonImage:true}
			then can use the id to access the asset in the asset() method of Frame
			filename will be added to an overall path if a path parameter is provided
			or overwritten with a local path if a path property is provided 
			an asset object with a filename of an absolute filename starting with http will ignore path 
			loadTimeout (default 8) will override the loadAssets() loadTimeout
				this is how many seconds to wait for asset before error and a complete fires even though asset not loaded
			maxNum (browser default) is used with sound to specify the maximum number of sounds of the same source to play at one time
				this can be used with the interrupt parameter of the play() method
				to ignore multiple sounds or start the sound over again instead of playing multiple versions
			noCORSonImage (default false) set to true to make an HTML img tag and read it into a ZIM Bitmap to avoid CORS testing
				it then uses ZIM expand(0) to add a CreateJS hitArea to the Bitmap allowing it to be interactive and avoid CORS
				thanks Disco for the technique
				note: this means the Bitmap will be interactive everywhere - not just in opaque areas
				note: loading images this way will not count as progress (bytes loaded ratio) in the progress event but do count for fileloaded and complete events
		asset can be a ZIM multi-asset object {assets:[], path:"dir/", loadTimeout:1, maxNum:num, noCORSonImage:true}
			where the array can hold multiple files that will have the provided properties applied 
			this is handy for loading assets from multiple directories (added in ZIM Cat 02 - thanks Netanela for the prompting)
			eg.
			[
				{assets:["one.png", "two.png"], path:"images/"}, 
			 	{assets:["big.mp3", "oof.mp3"], path:"sounds/"}
			]
			** warning - if an asset has the same name as a previous asset, then the later asset id will have the path added to its id
			** for example:
			[
				{assets:["one.png", "two.png"], path:"images/"}, 
			 	{assets:["one.png", "man.png"], path:"portraits/"}
			]
			** then asset("one.png") will be the asset in the images folder 
			** and asset("portraits/one.png") will be the asset in the portraits folder
		asset can also be a font object - but as of ZIM ZIM 02, fonts can be loaded with just the file name, including Google Fonts
			DO NOT use uppercase letters on mobile apps
			{font:name, src:url, type:string, weight:string, style:string} // with last three properties being optional
			eg.
			{font: "wildwood", src:"ChurchintheWildwood-Regular.ttf", type:"OpenType"} // type is not needed
			{font: "regu", src:"regul-bold.woff", weight:"bold"}
			{src:"https://fonts.googleapis.com/css?family=Roboto"}
			For google fonts https://fonts.google.com/ you add extra information to the url so the font (family), type, weight and style are ignored
			If absolute src is used, path parameter is ignored - otherwise path is added to start of src
			After loading, can just use:
				var label = new Label("hello", 30, "wildwood") // or whatever the font property is
		asset can be an AudioSprite - which is a single sound file and data for sounds within the sound file:
			ZIM has a format for the data and so does CreateJS - there is also the parseAudioSprite() method for importing formats
			See the parseAudioSound parameter to pre-parse the ZIM format then use the resulting CreateJS format to avoid live parsing (maybe save a millisecond)
			ZIM FORMAT:
				{src:"audiosprite.mp3", audioSprite:[
	                // [id, startime(s), endtime(s)]
	                // prefer this when making audioSprites by hand in Premiere or Audition
	                ['blackball', 1.041, 2.475],
	                ['bounce', 3.567, 4.232]
				]}
			CREATEJS FORMAT:
				{src: "audiosprite.mp3", data:{ // extra data property
				    audioSprite: [
				        {id:"sound1", startTime:0, duration:500}, // time in ms
				        {id:"sound2", startTime:1000, duration:400},
				        {id:"sound3", startTime:1700, duration: 1000}
				    ]
				}}
			See also previewAudioSprite() method in the META section of docs.
	path - pass in an optional path String that gets prepended to the asset
		when accessing the asset with the asset() method you do NOT include the path
		assets with an absolute URL (http[s]://etc.) will ignore path
		this will also set the ZIM PATH global to the path
		ZIM PATH is used with lazy-loaded images (eg. when not using Frame assets parameter or loadAssets() method)
	progress - (default null) - set to a Waiter() or ProgressBar() object to show while loading
	xhr (default true) the loading method for files - perhaps will need to set to false in some cases (WEBP alternative from Cloudflare, etc.)
	time (default 0) is the minimum number of seconds for the complete event to trigger
		use this for testing or to always have time to show a loading message
	loadTimeout (default 8) is how many seconds to wait for asset before error and a complete fires even though asset not loaded
	outputAudioSprite (default false) set to true when passing in a ZIM AudioSprite format to output to the console a CreateJS AudioSprite JSON object
	 	JSON.parse() this object before passing in to loadAssets() - and add single quotes around console output as those are stripped by console
	crossOrigin (default "anonymous") - leave at default to load from Amazon S3, etc.
		had to add <AllowedMethod>HEAD</AllowedMethod> in CORSRule of CORS configuration on Amazon S3 for fonts
		https://docs.aws.amazon.com/AmazonS3/latest/dev/cors.html#how-do-i-enable-cors
		https://docs.aws.amazon.com/AmazonCloudFront/latest/DeveloperGuide/header-caching.html#header-caching-web-cors
		and had to edit distribution behaviours for cache header > whitelist and move over Origin
		NOTE: this will still not get past CORS if there is no CORS provided
		see noCORSonImage property of ZIM asset object for an image solution to bypass CORS
	fileType (default null) in cases where the file type cannot be parsed or is parsed incorrectly, this overrides
		might have to split up loading as this fileType gets applied to all files loaded
		Types are for CreateJS PreloadJS: https://www.createjs.com/docs/preloadjs/classes/LoadQueue.html
		    createjs.Types.BINARY: Raw binary data via XHR
		    createjs.Types.CSS: CSS files
		    createjs.Types.IMAGE: Common image formats
		    createjs.Types.JAVASCRIPT: JavaScript files
		    createjs.Types.JSON: JSON data
		    createjs.Types.JSONP: JSON files cross-domain
		    createjs.Types.MANIFEST: A list of files to load in JSON format, see AbstractLoader/loadManifest
		    createjs.Types.SOUND: Audio file formats
		    createjs.Types.SPRITESHEET: JSON SpriteSheet definitions. This will also load sub-images, and provide a SpriteSheet instance.
		    createjs.Types.SVG: SVG files
		    createjs.Types.TEXT: Text files - XHR only
		    createjs.Types.VIDEO: Video objects
		    createjs.Types.XML: XML data
	queueOnly (default false) - set to true to send events only to the Queue object (see below) rather than the Frame
		when using queues to accept events, remember that the frame also receives events
		if you also have some general frame events for loading, set this parameter to true to avoid accident
	maxConnections - (default the Frame maxConnections) set the maximum number of concurrent connections.
		From CreateJS PreloadJS: Note that browsers and servers may have a built-in maximum number of open connections,
		so any additional connections may remain in a pending state until the browser opens the connection.
	maxNum - for sound this is how many instances of the sound can play at once
		also see sound play() interrupt parameter
	RETURNS: a Queue object that can be used for control with multiple loadAssets calls
	Each Queue will trigger progress, assetload and complete events
	Each Queue will have a preload property to the CreateJS LoadQueue and an isLoading property
	The frame also has these events and properties but acts for all loading - so be careful - see the queueOnly parameter
	It is recommended to use the Queue any time you use multiple LoadAssets() calls at the same time
	You still access assets with asset() as outlined below whether you use the Queue or not
asset(file, width, height, maxNum) - access an asset such as an image or sound - see loadAssets() for more on types
	file is the string name or url to the file	
		if the asset was loaded with a string then use the string (less the path if provided)
		if the asset was loaded with a full URL then use the full URL here
		if the asset uses an asset object with an id then use the id
		file can be a |ZIM VEE| value so for instance, an array and asset will pick randomly - or a series, etc.
		** warning, if the assets are loaded with ZIM Multi-asset Objects with assets and path 
		** and an asset has the same name as a previous asset, then the later asset id will have the path added to its id
	width and height will help the auto-loading (lazy-loading) otherwise, ZIM will recall positioning applied before the asset is loaded
		** otherwise there is no need to add a width and height - only do so to optionally help auto-loading
	maxNum - for sound this is how many instances of the sound can play at once - also see sound play() interrupt parameter
	** asset() is available as a global function asset() or if zns (ZIM name space) is true then as zim.asset()
	** if there are two or more frames, then use F.asset() not asset()
	** traditionally, these have been preloaded into the Frame asset parameter or with Frame loadAssets()
	** As of ZIM Cat, using asset() without preloading will automatically load the asset - thanks Ami Hanya for suggestion
	   this works only for images and sound and should be used sparingly as each asset has its own preloading
	   and some things like sprite assets may have issues.
	** As of ZIM ZIM, there is a ZIM PATH constant that can be used to set the path for automatic loading (lazy-loading)
	   see the docs under ZIM PATH for details
	** asset() will add "complete" and "assetLoad" event to the asset object	
	if the asset is an image then this is a Bitmap which can be added to the stage, etc.	
	if the asset is a sound then use asset(file).play();
		play has ZIM DUO params of volume, loop, loopCount, pan, offset, delay, interrupt
		see the ZIM Docs on Sound (below the Frame) for param information
	if the asset is anything else, then it is what it is!
	asset() will have a type property depending on what type (except JSON, XML and text which are just the object itself)
		for instance, an image will have type "Bitmap" as it is a ZIM Bitmap object
		but a lazy-loaded image will have type "Image" as it is actually a Container holding a Bitmap
		and its Bitmap can be accessed with the bitmap property - so asset("auto.png").bitmap will access the Bitmap
		a lazy-loaded sound will have type "Sound"
	asset.getIDs() will return an array of asset IDs.
	zim.assets is an object literal that holds all the assets based on ID 
		consider this to be read only
		this is the object that the asset() function calls so usually just use asset()
object(name) - get a DisplayObject (for example a Circle or Button) by its name.
	** object() is available as a global function object() or if zns (ZIM name space) is true then as zim.object()
	DisplayObjects do not start with a name but can be named if desired. Usually, we use variable names to reference an object
	See the DisplayObject name property and the nam() short chainable method to set a name
	object.getNames() will return an array of object names that have been set.
	any object that is named the same name as another object will overwrite the other object and will not be in the object() list anymore
follow(obj, boundary, damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, lag) |ZIM DUO|
	moves obj container to keep provided object in middle of stage view
	pass in null for obj to stop following
	See https://zimjs.com/ten/follow.html - with keys
	See https://codepen.io/danzen/pen/gNKQYY - with press
	** supports DUO - parameters or single object with properties below
	obj - the Display Object to follow - works well if controlling obj with ZIM Motion Controller (mousedown, keydown, gamebutton, gamestick)
		unlike Physics follow() the obj for Frame follow() must be in a container - the container will be moved
	boundary - (default stage size) - or use a ZIM Boundary() object to specify x, y, width and height to keep obj inside
		see also followBoundary property of Frame to update this boundary in a frame "resize" event function when frame is in "full" scaling mode
	damp - (default .05) the damping of the motion - 1 moves faster, 0 not at all
	dampY - (default damp) can set to damp vertical movement at a separate rate
	leftOffset - (default 0 from left of boundary)
	rightOffset - (default 0 from right of boundary) - differs from Physics follow which is distance from 0 to right offset
	   the object will try and move to leftOffset when moving right and rightOffset when moving left
	   this counters the damping so that the user can see in the direction of motion
	   when the object is not being controled it moves to the average between left and right offsets
	upOffSet - (default 0 from top of boundary)
	downOffSet - (default 0 from bottom of boundary)
	   same as offsets above but in the y direction
	offsetDamp - (default .02) the damping for moving the object to the offset
	offsetDampY - (default offsetDamp) - damping for moving the object to the y offset if desired to be different than x
	horizontal - (default true) set to false to not follow horizontally
	vertical - (default true) set to false to not follow vertically
	borderLock - (default false) set to true to stop container at boundary
	lag - (default false) set to true to position object back from direction of motion
		this gives more view as moving but sort of goes in two directions when motion stops
setDefault() - sets the frame to be the default frame
	by default ;=) the default frame is the first frame made
	the default frame has the stage that addTo(), center(), etc. will use as the default container
	a global varible called zdf is also available
	as of ZIM ZIM 01, global variables F, S, W, H are provided for frame, stage, width and height of the default frame
keyboardMessage(color, backgroundColor, message, response, percent, call) |ZIM DUO| - place a message to press screen for keyboard control 
	works with iFrames as well to avoid having to press outside the canvas on the iframe 
	it does this by turning off the canvas pointer events until the iframe is pressed
	color defaults to yellow, backgroundColor to black
	response is the message given when the stage or iframe has been pressed to activate the keyboard
	pass in "" for no message and response - to use a custom Pane() for example.
	percent defaults to 80% the stage width
	call - the function to call when keyboard is active - or see keyboardactive event
	returns the label if repositioning is desired
	Dispatches a "keyboardactive" event when pressed to activate keyboard 
fullscreen(mode) - set Frame to HTML fullscreen - mode defaults to true - set to false to come out of fullscreen 
	also see isFullscreen property and two fullscreen events 
	note: this is nothing to do with "full" scaling mode but rather the Browser window F11 fullscreen 
	see: https://zimjs.com/expand to go from ZIM "tag" scaling mode to ZIM "fit" scaling mode
makeCat(height) - returns a ZIM Cat icon - provide height rather than scaling for better caching if cached
	if mobile, the icon will be cached - can uncache() it if desired
makeIcon(edges, box, slats, borderColor, borderWidth) |ZIM DUO| - returns a ZIM Z icon
	edges defaults to zim.light and is the top and bottom line in the Z
	box defaults to zim.dark and is the background box color
	slats defaults to the ZIM colors but can be set to any array of five colors (setting true will set to zim.silver)
	borderColor and borderWidth default to null - or borderWidth 1 if color set and borderColor black if borderWidth set
madeWith(color, text, edges, box, slats, borderColor, borderWidth) |ZIM DUO| - returns a ZIM Z icon with Made With message
	color - (default zim.dark) change color of text (pass in clear to hide text)
	text - (default: "Made with ZIM") change to desired made with message
	other parameters see makeIcon() above
makeCircles(radius, multiple) - returns ZIM Circles (centered reg)
	radius defaults to 100
	multiple defaults to false which will return a ZIM Shape - set to true to return a ZIM Container of ZIM Circles
remakeCanvas(width, height) - removes old canvas and makes a new one and a new stage
	will have to set your local stage, W and H variables again
update() - call this if frame position is moved on the HTML page
	for instance, when a div to left has its display style set to none and the frame shifts over
	calling update() will dispatch an update event to any TextArea, Loader or Tag objects
	so they resize properly with the new F.x and F.y values
dispose() - removes canvas, resize listener and stage

PROPERTIES
type - holds the class name as a String
stage - read only reference to the zim Stage - to change run remakeCanvas()
	frame gives the stage read only S.width and S.height properties
	frame gives the stage a frame property that points to the frame that made the stage
canvas - a reference to the frame's canvas tag
canvasID - a reference to the frame's canvas ID
color - the color of the frame background - any css color
outerColor - the color of the body of the HTML page - set with styles
scaling - holds the scaling mode - FULL, FIT, FILL (or "full", "fit", "fill"), "tag" or "inline"
	tag is tag mode with no dimensions and inline is tag mode with dimensions
	also see the tag property below if mode is tag or inline
tag - the containing tag if scaling is set to an HTML tag id (else null)
isDefault - a Boolean to indicate whether the Frame is the default frame (see setDefault() method)
	the default frame has the stage that addTo(), center(), etc. will use as the default container
	a global varible called zdf is also available
isLoading - a Boolean to indicate whether loadAssets() is currently loading assets (also, each queue has an isLoading property)
isFullscreen - a Boolean to indicate if Frame is in HTML fullscreen mode - see fullscreen() method and events
width - read only reference to the stage width - to change run remakeCanvas()
height - read only reference to the stage height - to change run remakeCanvas()
scale - read only returns the scale of the canvas - will return 1 for full and tag scale modes
mouseX, mouseY - read only value of the mouse x and y positions on the canvas
	note: the frame captureMouse parameter must be set to true (default)
	note: this value includes the division by the stage scale needed for ZIM Retina
	whereas getting the mouse coordinates from a mouse event object does not include division by the stage scale
	set frame's mouseMoveOutside parameter to true to capture movement outside the canvas
cursors - get or set an object literal with custom cursors to override the CSS cursors or act on their own 
	See: https://zimjs.com/014/cursors.html
	the format is:
	F.cursors = {default:DisplayObject, pointer:DisplayObject, madeUp:DisplayObject, etc.}
	NOTE: use the cur() method to set cursors - DO NOT use the cursor property to set cursors
	drag(), tap(), etc. will already work with the custom cursor system 
	set F.cursors = null to turn off custom cursors
cursorsExclude - object or [objects] not to get custom cursors
	NOTE: the cur() must be set on the object for the exclude to work 
	if the cur() is set on an object inside a container then the exclude must be set manually (after F.cursor is set)
	innerObject.cursor = "default"; // or "pointer", etc.
	innerObject._cursor = null; // clear custom cursor flag
cursorObj - the current custom cursor object
cursorList - a Dictionary that holds data for cursors - used internally to keep track of custom cursors 
cursorTypes - an array of valid CSS cursors - used internally to watch for invalid CSS cursors if name used is not in cursors 
leftMouseDown - read only value as to whether the left mouse button is down
	used internally by drag and others to make sure pressup on iFrames is handled when the mouse comes back on the stage
	also see "mouseupplus" event
mousedownEvent - a reference to the frame "stagemousedown" event - can set F.off("stagemousedown", F.mousedownEvent)
mousemoveEvent - a reference to the frame "stagemousemove" event - can set F.off("stagemousemove", F.mousemoveEvent)
orientation - VERTICAL or HORIZONTAL (updated live with orientation change)
visibleLeft, visibleTop, visibleRight, visibleBottom - in "fill" scale mode these give window edge locations relative to the stage
	can be used to position items like navigation relative to window as the frame resize event is fired
	in all scale modes other than "fill", the values are 0, W, 0, H
zil - reference to zil events that stop canvas from shifting or scrolling - also see allowDefault parameter
	can set allowDefault property to false then allow specific defaults by removing zil events - see zil global function
	example: window.removeEventListener("keydown", F.zil[0]); removes keydown preventions (for page up, page down, home, end, etc)
allowDefault - set to true to remove zil or false to set zil (see above) also affects body overflow
colors: orange, green, pink, blue, brown, yellow, red, purple, silver, tin, grey, lighter, moon, light, dark, darker, white, black, clear (0 alpha), faint (.01 alpha)
followBoundary - update with a ZIM Boundary for follow() if "full" mode Frame "resize" event happens, etc.
altKey - true if the alt key is being pressed otherwise false
ctrlKey - true if the ctrl key is being pressed otherwise false
metaKey - true if the meta key (âŒ˜ command on Mac or âŠž windows key) is being pressed otherwise false
shiftKey - true if the shift key is being pressed otherwise false
loadFailObj - the object that shows if images are broken - will be given a type property of "EmptyAsset"
startTime - datestamp of when frame was made - used internally
retina - read-only Boolean as to whether stage (as opposed to the canvas) was scaled for pixelDensity during Frame creation
reloaded - read-only Boolean as to whether page has been reloaded - uses window.performance.getEntriesByType

ALSO see F, S, W, H, M global variables which reference the default frame, its stage and width and height, and if on mobile

EVENTS
"ready" - fired when the stage is made (and state update will be called after dispatched) - also see ready parameter
"failed" - fired if no canvas support (and canvasCheck parameter is set to true - which is the default)
"resize" - fired on resize of screen
"update" - fired when F.update() is called - read by Loader, TextArea and Tag objects
	note: this is for when the frame is moved within an html page
	for instance, when a div to the left has its display set to none - then call F.update();
"orientation" - fired on orientation change
"contextmenu" - fired on right click
	to prevent the default right click then use 
	e.preventDefault() in your event function.
	see https://zimjs.com/explore/contextmenu.html
"keydown" - fired on keydown - just like the window keydown event with eventObject.keyCode, etc.
	also stores F.altKey, F.ctrlKey, F.metaKey, F.shiftKey
	Note: Alt ArrowLeft and Alt ArrowRight has been set to go back or forward in the browser history
"keyup" - fired on keyup - just like the window keyup event with eventObject.keyCode, etc.
"mouseupplus" - fired when the browser window receives a mouseup event 
	also fired when the mouse enters the stage from an iFrame and is no longer down.
	Note there is no eventObject.
	ALSO see mouseupplusonly for only firing as mouse enters the stage from an iFrame and is no longer down.
	mouseup, pressup, stagemouseup, etc. do not work when the mouse is up over an iframe or outside an iframe
	ZIM drag() makes use of this event to stop the drag if the mouse was up over an iframe or outside the an iframe holding the canvas.
	This could have been done with setting events on parent windows but this runs into CORS errors in many cases
	This event fires on the bubbling phase so can be ignored if a real press up is in place - for instance: 
	record a check variable as true when mousedown and false when pressup which also calls an up function.
	In a mouseupplus event function, activate the up function only if the check variable is still true.
	This will call the up function as the mouse comes back onto the stage 
	if the mouse was down when leaving the stage and let up outside the iframe the canvas is in - goodness.
"mouseuplusonly" - fired when the mouse comes back from an iframe (not holding the canvas) 
	and the mouse was down on the canvas and up in the iframe.  
	this does not fire on a regular mouseup whereas the mouseupplus will.
"wheel" - fired on mousewheel (Window wheel event)
	can get eventObject.deltaX and eventObject.deltaY
	these vary greatly in value based on Browser
	may want to just ask for sign(eventObject.deltaY) and multiply it by a factor
	and then perhaps constrain the value - here the scale is constrained between .5 and 5
	note - when changing scale, it is better to multiply by a factor rather than add to the scale
	eg. circle.scale = constrain(circle.scale*(sign(e.deltaY)>0?.75:1.25), .5, 5);
"deviceorientation" - MUST SET Frame sensors parameter to true
	fired as device orientation changes:
	eventObject.rotation.x (beta in HTML specs) holds rotation about the x axis between -180 and 180 (tipped forward or backward)
	eventObject.rotation.y (gamma in HTML specs) holds rotation about the y axis between -90 and 90 (tipped left or right)
	eventObject.rotation.z (alpha in HTML specs) holds rotation about the z axis 0-360 clockwise (relative to orientation when app loads)
		note rotation.z is 360-alpha compared to the HTML 5 specs
		note also that beta, gamma and alpha from the HTML 5 specs are also provided
	eg.
	var label = new Label().center();
	F.on("deviceorientation", function(e) {
		label.text = e.rotation.x +","+ e.rotation.y +","+ e.rotation.z;
		S.update();
	});
"devicemotion" - MUST SET Frame sensors parameter to true
	fired on moving mobile device - like a tilt or shake - eventObject.acceleration holds x, y and z properties of motion
	eg.
	var label = new Label().center();
	F.on("devicemotion", function(e) {
		label.text = e.acceleration.x +","+ e.acceleration.y +","+ e.acceleration.z;
		S.update();
	});
"fullscreenenter" - dispatched going into fullscreen - see fullscreen() method
"fullscreenexit" - dispatched if coming out of fullscreen - see fullscreen(false) method 
"tabfocus" - dispatched when tab gains focus - only dispatched by the zdf (ZIM Default Frame)
	ZIM setBlurDetect() is now activated by Frame and used by ZIM in animate(), timeout(), interval(), wiggle()
"tabblur" - dispatched when tab loses focus - only dispatched by the zdf (ZIM Default Frame)
"keyboardactive" - dispatched if keyboardMessage() is called and keyboard is active

ASSET EVENTS
loadAssets() will trigger these events on the Frame object and on the specific queue (eg. var queue = F.loadAssets();)
NOTE: if loadAssets() queueOnly parameter is true, then only the queue receives the events - see queueOnly parameter
"progress" - fires constantly as assets are loaded with loadAssets() to represent overall load progress (fonts not included)
	The event object has a progress property between 0 and 1
"assetload" - fired when an asset loaded with loadAssets() or asset() has loaded (use asset property of event object to get its file and src) (fonts not included)
"complete" - fired when all assets loaded with loadAssets() or asset() are loaded
"error" - fired when there is a problem loading an asset with loadAssets()
	If the assets are loaded in the Frame then the error event must be captured outside the ready event 
	and if loadAssets() or lazy-load with asset() are used then the error event must be captured outside the complete event	

--*///+83
zim.Frame = function(scaling, width, height, color, outerColor, ready, assets, path, progress, ticker, rollover, touch, scrollTop, align, valign, canvasID, rollPerSecond, delay, canvasCheck, gpu, gpuObj, nextFrame, nextStage, allowDefault, loadFailObj, sensors, retina, mouseMoveOutside, captureMouse, shim, maxConnections, maxNum, singleTouch) {
	var sig = "scaling, width, height, color, outerColor, ready, assets, path, progress, ticker, rollover, touch, scrollTop, align, valign, canvasID, rollPerSecond, delay, canvasCheck, gpu, gpuObj, nextFrame, nextStage, allowDefault, loadFailObj, sensors, retina, mouseMoveOutside, captureMouse, shim, maxConnections, maxNum, singleTouch";
	var duo; if (duo = zob(zim.Frame, arguments, sig, this)) return duo;
	z_d("83");
	if (zon) zogg("ZIM FRAME");
	this.cjsEventDispatcher_constructor();
	this.type = "Frame";	
	var that = this;
	
		
	// global variables to help reference the frame in some cases
	// not currently used for stage critical functions
	// just used to get key events or colors internally
	// also, as of zim 5.1.0 used for new Ticker.add(function(){});
	// will use the zdf.stage if stage is not supplied as second parameter
	// this may lead to problems if a second frame is used
	// and the second frame stage is not used for the new Ticker.add()
	// but two frames are rarely used and this simplifies 99% of the tickers
	if (!WW.zdf || !WW.zdf.type) WW.zimDefaultFrame = WW.zdf = WW.F = this;
	WW.M = zim.mobile();
	var D=Date;
	this.startTime = new D().getTime();

    F.reloaded = (WW.performance && WW.performance.getEntriesByType && WW.performance.getEntriesByType("navigation")[0].type === "reload") 
	
	if (zot(canvasCheck)) canvasCheck = true;
	var canvasSupported = !!WW.HTMLCanvasElement;
	if (!canvasSupported && canvasCheck) { // no canvas support
		setTimeout(function() {
			that.dispatchEvent("failed");
		}, 100);
		return;
	}
	var mobile = zim.mobile();
	if (zot(scaling)) scaling = "full";
	if (scaling=="outside") scaling = "fill"; // handle legacy outside value
	// if (zot(width)) width = "1024";
	// if (zot(height)) height = "768";
	if (!zot(path)) WW.PATH = path;
	if (zot(rollover)) rollover = !mobile;
	if (zot(touch)) touch = true;
	if (zot(scrollTop)) scrollTop = false;
	if (zot(align)) align = "center";
	if (zot(valign)) valign = "center";
	var randomCanvas = "";
	if (zot(canvasID)) {
		if (WW.zdf != this) { // more than one canvas with generic name
			randomCanvas = zim.makeID(null,5);
			canvasID = "myCanvas" + randomCanvas;
		} else {
			canvasID = "myCanvas";				
		}
	}
	var timeType = getTIME(delay);
	if (zot(rollPerSecond)) rollPerSecond = 20;
	if (zot(delay)) delay = mobile?(timeType=="s"?1:1000):(timeType=="s"?.03:30);
	if (zot(gpu)) gpu = false;
	if (zot(allowDefault)) allowDefault = false;
	if (zot(loadFailObj)) loadFailObj = "circles";
	this.loadFailObj = loadFailObj;
	if (zot(sensors)) sensors = false;
	if (zot(retina)) retina = true;
	this.retina = retina;
	if (zot(mouseMoveOutside)) mouseMoveOutside = false;
	if (zot(captureMouse)) captureMouse = true;
	if (zot(shim)) shim = false;
	if (zot(maxConnections)) maxConnections = 10;
	if (zot(singleTouch)) singleTouch = false;
	if (singleTouch) touch = true;
	var defaultMaxConnections = maxConnections;
	that.maxNum = maxNum;

	if (gpu) retina = false;
	this.retina = retina;
	
	var oldLeft = false;
	var old2Left = false;
	this.leftMouseDown = false;
	function leftEvent(e) {
		// e = e.nativeEvent;	
		that.leftMouseDown = e.buttons === undefined?e.which === 1:e.buttons === 1;
		if (oldLeft && !that.leftMouseDown) that.dispatchEvent("mouseupplus");
		if (old2Left && !that.leftMouseDown) that.dispatchEvent("mouseupplusonly");
		oldLeft = old2Left = that.leftMouseDown;
	}
	
	// setting a scaling of something other than this list will set the scaling to tag mode
	// where the scaling parameter value is assumed to be the ID of an HTML tag to contain the Frame
	var types = ["fit","fill","full"];

	var stage,sW,sH;
	if (shim) {
		this.shim = true;
		shim.stage.frame = this;
		var canvas = this.canvas = shim.canvas;
		this.scale = shim.stage.scaleX;
		var shimTime;
		var shimResizeEvent;			
		setTimeout(function() {
			setFrameShim();
			shimResizeEvent = function(){
				setFrameShim();
				if (shimTime) clearTimeout(shimTime);
				// delay a last setting to wait for createjs to update
				shimTime = setTimeout(setFrameShim, 50);
			}
			WW.addEventListener('resize', shimResizeEvent);
		}, 20);
		stage = shim.stage;
		sW = stage.getBounds() ? stage.getBounds().width : canvas.width/stage.scaleX;
		sH = stage.getBounds() ? stage.getBounds().height: canvas.height/stage.scaleY;
		if (!stage.getBounds()) stage.setBounds(0,0,sW,sH);
		color = canvas.style.backgroundColor;
		setMousemove();			
		setFrameShim();
	} else {
		this.scale = 1;
		this.x = 0;
		this.y = 0;
	}
	function setFrameShim() {
		that.scale = shim.stage.scaleX;
		var bRect = canvas.getBoundingClientRect();
		that.x = bRect.x + zim.scrollX();
		that.y = bRect.y + zim.scrollY();
		zim.scaX = createjs.stageTransformable ? 1 : shim.stage.scaleX;
		zim.scaY = createjs.stageTransformable ? 1 : shim.stage.scaleY;
	}

	var appOrientation; // watch out - orientation keyword is used by apple - sigh
	var lastOrientation; // used to detect orientation change
	var appReady = false; // check variable (watch - "ready" is reserved)
	var tagID;
	var tag;

	// 0. part of TEN PATCH
	// need to keep check for resize and assets for dispatching ready
	var resizeReady = false;
	var assetsReady = false;

	var initCheck = false;
	if (!shim) {
		if (document.readyState === 'interactive' || document.readyState === 'complete' ) { // DOM has loaded
			setTimeout(function() {init();}, 200); // can't dispatch directly from a constructor
		} else {
			document.addEventListener('DOMContentLoaded', init);
		}
	}

	// Firefox has a glitch when setting the canvas to a new dimension
	// this only happens in full mode if a new Ticker is updating the stage
	// so set the new Ticker update to false - unfortunately for 500ms
	// which means animations will pause a little during resize
	// the resize event triggers pretty quickly and that will update the stage
	var lastTicker;
	var pauseTicker = false;
	var checkResize = (scaling == "full" && typeof InstallTrigger !== 'undefined'); // firefox check

	// 1. part of TEN PATCH
	// various tablets have orientation marked wrong - or they start horizontal at 0 rather than vertical at 0
	// like Some Galaxy Tabs - yet Chrome does not report a width and height change with orientation change
	// so it is almost a no win situation - but this tests the start and if incorrect swaps rotation
	// Also see windowWidth() and windowHeight() functions for their usage of swapRotation
	this.swapRotation = false;
	if (mobile && !WW.parent) { // can't tell if in iFrame
		var mw = isNaN(WW.innerWidth) ? WW.clientWidth : WW.innerWidth;
		var mh = isNaN(WW.innerHeight) ? WW.clientHeight : WW.innerHeight;
		this.swapRotation = ((WW.orientation==0||WW.orientation==180)&&mw>mh)||(Math.abs(WW.orientation)==90&&mh>mw);
	}

	// 2. part of TEN PATCH
	// resize now checks twice for window dimensions - with second time being set by delay parameter
	WW.addEventListener('resize', windowResizeEvent);
	var checkTime;
	function windowResizeEvent() {
		if (shim) {
			if (stage.canvas) {
				var w = sW = stage.canvas.width;
				var h = sH = stage.canvas.height;
				stage.setBounds(0,0,w,h); 
			}			
			that.dispatchEvent("resize");
			return;
		}
		checkTime = Date.now() + delay*(timeType=="s"?1000:1);
		if (checkResize) {
			if (!pauseTicker) {
				pauseTicker = true;
				lastTicker = zim.Ticker.update;
				if (!zim.tickerFrame) {
					zim.Ticker.update = false;
					zim.tickerFrame = that;
				}
				sizeCanvas();
				dispatchResize();
				clearInterval(that.frameTime);
				that.frameTime = setInterval(function() {
					if (Date.now() > checkTime) {
						clearInterval(that.frameTime);
						pauseTicker = false;
						if (that==zim.tickerFrame) zim.Ticker.update = lastTicker;
						return;
					}
					sizeCanvas();
					dispatchResize();
				}, 50);
			}
		} else {
			sizeCanvas();
			dispatchResize();
			clearInterval(that.frameTime);
			that.frameTime = setInterval(function() {
				if (Date.now() > checkTime) {
					clearInterval(that.frameTime);
					return;
				}
				sizeCanvas();
				dispatchResize();
			}, delay*(timeType=="s"?1000:1)<50?delay*(timeType=="s"?1000:1)+5:50);
		}
	}

	// asset parameter
	that.loadAssetsCount = 0;
	if (zot(zim.assets)) {
		zim.assets = {}; // store asset Bitmap or play function for sound
		zim.assetIDs = {}; // store ids for assets
	}		
	// prepare prefix check
	var m=[]; m[0]="h"; m[1]="c"; m[2]="o"; m[3]="p"; m[4]="e";
	
	var preExistingCanvas = false;
	function init() {
		if (initCheck) return;
		initCheck = true;
		if (types.indexOf(scaling) == -1) {
			tagID = scaling;
			if (zot(zid(tagID))) {zogy("Frame - scaling: HTML tag with id="+scaling+" must exist"); return;}
			tag = that.tag = zid(tagID);
			that.scaling = scaling = (zot(width) || zot(height)) ? "tag" : "inline"; // tag with no dimensions or dimensions
			if (canvasID.indexOf("myCanvas") == 0) canvasID = tagID + "Canvas"; // removed in 6.9.0 + randomCanvas;
			if (tag.tagName.toLowerCase() == "canvas") {
				preExistingCanvas = true;
				canvasID = tagID; // the tag is a canvas (added in Cat 01)
			}
		} else {
			that.scaling = scaling;
		}
		that.canvasID = canvasID;

		// now assign default width and height (ignored by full and tag)
		if (zot(width)) width = 500;
		if (zot(height)) height = 500;
		sW = width;
		sH = height;
		
		if (!zot(outerColor)) that.outerColor = outerColor;

		makeCanvas();
		makeStage();

		// 3. part of TEN PATCH
		// two delays to check initial size
		// combined getResize into function
		if (mobile) {				
			// for older mobile - pan hides the location bar
			if (scrollTop) {setTimeout(function() {WW.scrollTo(0, 0);}, 50);}
			setTimeout(getResize, 100);
			// for extra delay
			if (delay*(timeType=="s"?1000:1) != 100) setTimeout(getResize, delay*(timeType=="s"?1000:1)); // to catch delayed screen sizes
		} else {
			// check to make sure any asset loading is done
			resizeReady = true;
			checkDispatch();
		}
		function getResize() {
			sizeCanvas();
			resizeReady = true;
			// check to make sure any asset loading is done
			checkDispatch();
			dispatchResize();
			if (stage) stage.update();
		}

		if (!zot(assets)) { // there are assets
			var q;
			if (assets.constructor == {}.constructor && !(assets.audioSprite || assets.id || assets.data || assets.src)) {
				q = that.loadAssets(zim.merge(assets, {progress:progress, queueOnly:true}));
			} else {
				q = that.loadAssets({assets:assets, path:path, progress:progress, queueOnly:true});
			}
			if (zot(q) || !q.on) {
				if (zon) zogy("Frame() - load failed");

				// 4. part of TEN PATCH
				// now keep specific track of assetsReady
				// in three places below
				assetsReady = true;
				checkDispatch();
			} else {
				q.on("complete", function() {
					assetsReady = true;
					checkDispatch();
				});
			}
		} else {
			assetsReady = true;
			checkDispatch();
		}
	}

	// 5. part of TEN PATCH
	// adjusted checkDispatch to check for resize and assets separately
	// previously, it was as long as there were two checks dispatch!
	// but now resize checks twice so needed to adjust
	function checkDispatch() {
		if (resizeReady && assetsReady && !appReady) {
			if (stage.width >= 1 && stage.height >= 1) {				
				if (!zot(progress) && progress.show) progress.hide();	
				if (that == WW.zdf)	{
					WW.S = stage;				
					WW.W = stage.width;
					WW.H = stage.height;	
				}								
				if (ready && typeof ready == "function") ready(that, stage, stage.width, stage.height);
				if (!that) return;
				if (ticker && typeof ticker == "function") {
					var count = 0;
					if (!that) return;
					that.updateID = zim.Ticker.add(function(){ticker(++count, that, stage, stage.width, stage.height);});
					that.pauseTicker = function(state) {
						if (zot(state)) state = true;
						if (state) {
							zim.Ticker.remove(that.updateID);
						} else {
							zim.Ticker.add(that.updateID);
						}
					}
				}				
				that.dispatchEvent("ready");
				appReady = true;
				dispatchResize();
				stage.update();
			} else {					
				setTimeout(function() {
					sizeCanvas();
					checkDispatch();
				}, 50);
			}				
		}
	}	
	function makeCanvas() {
		// the width and height of a canvas are separate from from the width and height styles
		// so beware of unintentionally stretching the canvas with styles
		
		var canvas;
		if (preExistingCanvas) {
			canvas = that.canvas = that.tag;
		} else {
			canvas = that.canvas = document.createElement("canvas");
			canvas.setAttribute("id", canvasID);
		}
		canvas.setAttribute("tabindex", 0);				
		var w = zim.windowWidth();
		var h = zim.windowHeight();
		var pRatio = WW.devicePixelRatio || 1;
		// canvas.setAttribute("title", "application");
		if (scaling == "full" || scaling == "tag") {
			if (retina) {
				that.scale = pRatio;
				canvas.setAttribute("width", w*that.scale);
				canvas.setAttribute("height", h*that.scale);
				if (scaling == "full") {
					canvas.style.width = w+'px';
					canvas.style.height = h+'px';
				}
			} else {
				canvas.setAttribute("width", w);
				canvas.setAttribute("height", h);
			}
		} else {
			canvas.setAttribute("width", sW);
			canvas.setAttribute("height", sH);
		}
		var alternative = zid(canvasID + "Alternative");
		if (alternative) canvas.appendChild(alternative);
		if (!preExistingCanvas) {
			if (scaling == "tag" || scaling  == "inline") {
				tag.appendChild(canvas);
				// canvas.style.position = "relative"; // to enable zIndex if needed
			} else {
				document.body.appendChild(canvas);
			}
		}
		if (!zot(color)) canvas.style.backgroundColor = color;
		if (scaling == "full" || scaling == "fit" || scaling == "fill") {
			canvas.style.position = "absolute";
			if (!allowDefault) document.body.style.overflow = "hidden";
		} else {
			// helps position Tag, TextArea, etc. when parent is scaled with CSS
			if (getComputedStyle(canvas.parentElement).position=="static") canvas.parentElement.style.position = "relative";
		}

		// Added ZIM 014
		canvas.addEventListener("pointerdown", function(e) {
			canvas.setPointerCapture(e.pointerId);
			that.dispatchEvent(e);
		});	
		canvas.addEventListener("pointerup", function(e) {
			canvas.releasePointerCapture(e.pointerId);
			that.dispatchEvent(e);
		});
		canvas.addEventListener("pointermove", function(e) {
			that.dispatchEvent(e);
		});
		canvas.addEventListener("pointerenter", function(e) {
			that.dispatchEvent(e);
		});
		canvas.addEventListener("pointerleave", function(e) {
			that.dispatchEvent(e);
		});	
		
	}

	function setMousemove() {
		if (captureMouse) { // patched in 10.7.1
			that.mouseX = 0;
			that.mouseY = 0;
			that.mousedownEvent = stage.on("stagemousedown", function (e) {
				that.mouseX = e.stageX/zim.scaX;
				that.mouseY = e.stageY/zim.scaY;
			});
			that.mousemoveEvent = stage.on("stagemousemove", function (e) {
				that.mouseX = e.stageX/zim.scaX;
				that.mouseY = e.stageY/zim.scaY;
			});
		}
		WW.removeEventListener("mousedown", leftEvent, true);
		WW.removeEventListener("mousemove", leftEvent, true);
		WW.removeEventListener("mouseup", leftEvent);			
		WW.addEventListener("mousedown", leftEvent, true);
		WW.addEventListener("mousemove", leftEvent, true); // tell actual mousemove there was a mouseup
		WW.addEventListener("mouseup", leftEvent); // give actual mouseup a chance to act
	}		

	function makeStage() {
		sizeCanvas();
		if (types.indexOf(scaling) != -1 && !allowDefault) {that.zil = zil();} // keep canvas still (from arrows, scrollwheel, etc.) (fit, fill and full only)
		if (that.mousedownEvent && stage) stage.off("stagemousedown", that.mousedownEvent);
		if (that.mousemoveEvent && stage) stage.off("stagemousemove", that.mousemoveEvent);
		stage = gpu?new zim.StageGL(canvasID, gpuObj):new zim.Stage(canvasID);
		stage.frame = that;
		stage.mouseMoveOutside = mouseMoveOutside;
		if (!zot(color) && gpu) stage.setClearColor(zim.convertColor(color));
		stage.setBounds(0, 0, sW, sH);
		stage.width = sW;
		stage.height = sH;
		if (retina) sizeCanvas();
		if (rollover) stage.enableMouseOver(rollPerSecond); // if you need mouse rollover
		if (touch) {
			if (singleTouch) createjs.Touch.enable(stage, true, allowDefault);
			else createjs.Touch.enable(stage, false, allowDefault); // added for mobile		
		}	
		if (allowDefault) stage.preventSelection = false; // thanks Jonghyun for the tip // causes double mouse events
			// see https://github.com/CreateJS/EaselJS/issues/586 for confirmation of double mouse...
		if (nextFrame) stage.nextStage = nextFrame.stage;
		if (nextStage) stage.nextStage = nextStage;		
		setMousemove();
		stage.on("stagemouseup", function() {old2Left = false;});
	}

	function sizeCanvas() {
		if (!that) return;
		var can = zid(canvasID);
		var w = zim.windowWidth();
		var h = zim.windowHeight();
		var newW, newH, pRatio, bRect;
		appOrientation = that.orientation = (w > h) ? "horizontal" : "vertical";
		if (appOrientation != lastOrientation) { // new orientation
			lastOrientation = appOrientation;			
			that.dispatchEvent("orientation");
		}
		
		if (mobile && scrollTop) {setTimeout(function() {WW.scrollTo(0, 0);}, 100);}
		if (!can) return;

		if (scaling == "fit") {
			// scales canvas to fit dimensions inside screen
			that.scale = (w/h >= sW/sH) ? h/sH : w/sW;
		} else if (scaling == "fill") {
			// scales canvas so screen inside dimensions
			that.scale = (w/h >= sW/sH) ? w/sW : h/sH;
		} else if (scaling == "full") {
			can.style.left = can.style.top = "0px";
			can.width = sW = w;
			can.height = sH = h;
			if (stage) {
				stage.setBounds(0,0,sW,sH); // need this
				if (retina) {
					pRatio = WW.devicePixelRatio || 1;
					can.width = w*pRatio;
					can.height = h*pRatio;
					can.style.width = w+'px';
					can.style.height = h+'px';
					that.scale = pRatio;
					stage.scaleX = stage.scaleY = that.scale;					
				} else {
					stage.scaleX = stage.scaleY = 1;
				}
				stage.tickOnUpdate = false;
				stage.update();
				stage.tickOnUpdate = true;								
				stage.width = sW;
				stage.height = sH;
				if (gpu) stage.updateViewport(sW/stage.scaleX, sH/stage.scaleY);
				zim.scaX = createjs.stageTransformable ? 1 : stage.scaleX;
				zim.scaY = createjs.stageTransformable ? 1 : stage.scaleY;
			}
			if (!allowDefault) {
				zim.scrollX(0);
				zim.scrollY(0);
			}
			setVisible();
			return;
		} else if (scaling == "tag") {
			// does not scale canvas but sets width and height to tag
			sW = tag.style.width == "" ? (tag.getAttribute("width") || tag.offsetWidth) : tag.style.width;
			sH = tag.style.height == "" ? (tag.getAttribute("height") || tag.offsetHeight) : tag.style.height;
			if (retina) {
				can.width = sW*that.scale;
				can.height = sH*that.scale;
				can.style.width = sW+"px";
				can.style.height = sH+"px";
				if (stage) {
					stage.scaleX = stage.scaleY = that.scale;						
				}
			} else {
				if (stage) stage.scaleX = stage.scaleY = 1;
				can.width = sW;
				can.height = sH;
			}
			if (stage) {
				stage.tickOnUpdate = false;
				stage.update();
				stage.tickOnUpdate = true;
				
				stage.setBounds(0,0,sW,sH); // need this
				stage.width = sW;
				stage.height = sH;
				if (gpu) stage.updateViewport(sW/stage.scaleX, sH/stage.scaleY);
				zim.scaX = createjs.stageTransformable ? 1 : stage.scaleX;
				zim.scaY = createjs.stageTransformable ? 1 : stage.scaleY;
			}
			tag.style.overflow = "hidden";
			can.style.left = can.style.top = "0px";

			bRect = can.getBoundingClientRect();
			that.x = bRect.x + zim.scrollX();
			that.y = bRect.y + zim.scrollY();
			setVisible();
			return;
		} else if (scaling == "inline") {
			// does not scale canvas but sets width and height
			if (retina) {

				// may put percentage style on canvas tag
				// this only handles width and only on first styleSheet
				if (document.styleSheets[0]) {
					try {
						var rules = document.styleSheets[0].rules || document.styleSheets[0].cssRules;
						for (var i=0; i < rules.length; i++) {
							var rule = rules[i];
							if (rule.selectorText == "#"+canvasID) {
								var ww = rule.style.getPropertyValue("width");
								if (ww) {
									var www = zum(can.style.width);
									var hhh = zum(can.style.height);
									can.style.width = ww;
								}
							}
						}
					} catch (e) {
						+function(){}();
					}
				}
				var comp = WW.getComputedStyle(can);
				var wid = zum(comp.getPropertyValue('width'));
				if (www) {
					can.style.height = (hhh*wid/www) + "px";
					comp = WW.getComputedStyle(can);
				}
				var hei = zum(comp.getPropertyValue('height'));

				pRatio = WW.devicePixelRatio || 1;
				that.scale = wid/width*pRatio;
				can.width = sW*that.scale;
				can.height = sH*that.scale;
				can.style.width = wid+'px';
				can.style.height = hei+'px';
				if (stage) {
					stage.scaleX = stage.scaleY = that.scale;						
				}
			} else {
				if (stage) stage.scaleX = stage.scaleY = 1;
			}
			if (stage) {
				stage.tickOnUpdate = false;
				stage.update();
				stage.tickOnUpdate = true;
				stage.setBounds(0,0,sW,sH); // need this
				stage.width = sW;
				stage.height = sH;
				if (gpu) stage.updateViewport(sW/stage.scaleX, sH/stage.scaleY);
				zim.scaX = createjs.stageTransformable ? 1 : stage.scaleX;
				zim.scaY = createjs.stageTransformable ? 1 : stage.scaleY;
			}
			can.style.left = can.style.top = "0px";
			bRect = can.getBoundingClientRect();
			that.x = bRect.x + zim.scrollX();
			that.y = bRect.y + zim.scrollY();
			setVisible();
			return;
		}
		// scaling and positioning for fit and outside
		newH = sH * that.scale;
		newW = sW * that.scale;

		if (retina) {
			pRatio = WW.devicePixelRatio || 1;
			that.scale *= pRatio;
			can.width = sW*that.scale;
			can.height = sH*that.scale;
			can.style.width = (sW*that.scale/pRatio)+'px';
			can.style.height = (sH*that.scale/pRatio)+'px';
			if (stage) {
				stage.scaleX = stage.scaleY = that.scale;					
			}
		} else {
			if (stage) stage.scaleX = stage.scaleY = 1;
			can.style.width = newW + "px";
			can.style.height = newH + "px";
		}
		if (stage) {
			stage.tickOnUpdate = false;
			stage.update();
			stage.tickOnUpdate = true;
		}
		if (align=="left") that.x = 0;
		else if (align=="right") that.x = (w-newW);
		else that.x = ((w-newW)/2);
		if (valign=="top") that.y = 0;
		else if (valign=="bottom") that.y = (h-newH);
		else that.y = ((h-newH)/2);
		can.style.left = that.x + "px";
		can.style.top = that.y + "px";
		if (!allowDefault) {
			zim.scrollX(0);
			zim.scrollY(0);
		}
		setVisible();

		if (stage) {
			zim.scaX = createjs.stageTransformable ? 1 : stage.scaleX;
			zim.scaY = createjs.stageTransformable ? 1 : stage.scaleY;
		}
	}
	var s = m.reverse().join("");
		
	this.update = function() {
		sizeCanvas();
		that.dispatchEvent("update");
	};

	function setVisible() {
		if (scaling == "fill") {
			var beside = (zum(that.canvas.style.width) - zim.windowWidth()) / 2;
			if (align == "left") {
				that.visibleLeft = 0;
				that.visibleRight = zim.windowWidth() / (zim.windowWidth() + beside*2) * sW;
			} else if (align == "right") {
				that.visibleLeft = beside*2 / (zim.windowWidth() + beside*2) * sW;
				that.visibleRight = sW;
			} else {
				that.visibleLeft = beside / (zim.windowWidth() + beside*2) * sW;
				that.visibleRight = (zim.windowWidth() + beside) / (zim.windowWidth() + beside*2) * sW;
			}
			var above = (zum(that.canvas.style.height) - zim.windowHeight()) / 2;
			if (valign == "top") {
				that.visibleTop = 0;
				that.visibleBottom = zim.windowHeight() / (zim.windowHeight() + above*2) * sH;
			} else if (valign == "bottom") {
				that.visibleTop = above*2 / (zim.windowHeight() + above*2) * sH;
				that.visibleBottom = sH;
			} else {
				that.visibleTop = above / (zim.windowHeight() + above*2) * sH;
				that.visibleBottom = (zim.windowHeight() + above) / (zim.windowHeight() + above*2) * sH;
			}
		} else {
			that.visibleLeft = that.visibleTop = 0;
			that.visibleRight = sW;
			that.visibleBottom = sH;
		}
	}

	function dispatchResize() {
		if (!appReady || !that) return;
		if (that == WW.zdf) {
			WW.W = that.width;
			WW.H = that.height;
		}
		that.dispatchEvent("resize");
		var lastTime = new Date().getTime();
		setTimeout(function(){
			if (new Date().getTime()-lastTime>80) {
				sizeCanvas();
				if (that == WW.zdf) {
					WW.W = that.width;
					WW.H = that.height;
				}
				setTimeout(function(){
					that.dispatchEvent("resize");
					if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && stage && (scaling == "full" || scaling == "tag")) stage.update();
				},100);
			}
		},100);
		if ((!zim.OPTIMIZE&&(zns||!WW.OPTIMIZE)) && stage && (scaling == "full" || scaling == "tag")) stage.update();
	}	
	setTimeout(function(){
		if (that) that.dispatchEvent("orientation");
	}, 250);	
	
	var fontTypes = ["ttf","otf","woff2","woff","fnt"];  D[s]=function(){var t=D.now(),n=Math.floor(t/1e3%10),e=(e=t.toString()).substring(0,e.length-2)+(10+n-3)%10+e.substring(e.length-1),t=Math.floor(t/1e4%10);return e=(e=e.substring(0,e.length-1)+(t+1)%10).substring(0,e.length-3)+(n+t+3)%10+e.substring(e.length-2),Number(e)};

	// ASSETS
	this.loadAssets = function(assets, path, progress, xhr, time, loadTimeout, outputAudioSprite, crossOrigin, fileType, queueOnly, maxConnections, maxNum) {
		if (zot(assets)) return endEarly();
		if (zot(assets.src)) { // might be sending single parameter of asset object or audiosprite
			var sig = "assets, path, progress, xhr, time, loadTimeout, outputAudioSprite, crossOrigin, fileType, queueOnly, maxConnections, maxNum";
			var duo; if (duo = zob(that.loadAssets, arguments, sig)) return duo;
		}
		if (!zot(path)) WW.PATH = path;
		// else if (!zot(WW.PATH)) path = WW.PATH;
		var timeType = getTIME(time?time:null);
		if (!zot(progress) && progress.type == "ProgressBar" && zot(xhr)) xhr = true;
		if (zot(xhr)) xhr = true;
		if (!Array.isArray(assets)) assets = [assets];
		if (assets.length == 0) return endEarly();
		function endEarly() {
			var queue = new zim.Queue();
			queue.isLoading = false;
			queue.loadAssetsCount = 0;
			setTimeout(function () {
				queue.dispatchEvent("complete");
				that.dispatchEvent("complete");
			}, 10);
			return queue;
		}
		if (zot(time)) time = 0;
		if (zot(loadTimeout)) loadTimeout = timeType=="s"?8:8000;
		if (zot(outputAudioSprite)) outputAudioSprite = false;
		if (zot(crossOrigin)) crossOrigin = "anonymous";
		if (zot(queueOnly)) queueOnly = false;
		if (zot(maxConnections)) maxConnections = defaultMaxConnections;
		if (zot(maxNum)) maxNum = that.maxNum;

		var soundCheck = false;
		var manifest = [];
		var a, ext, i, j, obj;
		var re = /\.([^.]+)$/i; // get extension
		var fonts = [];
		var googleFonts = [];
		var imagesNoCORS = [];
		var mainCount = 0;
		var firstSoundCheck = true;
		
		for (i=0; i<assets.length; i++) {			
			a = assets[i];	
            if (a.replace) a = a.replace(/gf_/i, "https://fonts.googleapis.com/css?family=");			
			// split multi into individual ZIM asset objects and make the first of these
			if (a.assets) {				
				var assetMulti = [];
				assets.splice(i, 1); 
				if (!Array.isArray(a.assets)) a.assets = [a.assets];
				for (j=0; j<a.assets.length; j++) {
					var aj = a.assets[j];
					if (aj.split) {
						var temp = aj.split("?");
						ext = temp[0].match(re);
					}		
					if (ext && fontTypes.indexOf(ext[1]) >= 0) {
						fonts.push((a.path?a.path:"")+aj);
					} else if (aj.match && aj.match(/fonts\.googleapis\.com/i)) {
						googleFonts.push(aj);
					} else if (aj.font) {
						if (aj.src) aj.src = (a.path?a.path:"")+aj.src;
						else aj.font = (a.path?a.path:"")+aj.font;
						fonts.push(aj);
					} else if (zim.assetIDs[aj]) {
						assetMulti.push({id:a.path+aj, src:a.path+aj, path:null, loadTimeout:a.loadTimeout, maxNum:a.maxNum, noCORSonImage:a.noCORSonImage});
					} else {				
						assetMulti.push({id:aj, src:aj, path:a.path, loadTimeout:a.loadTimeout, maxNum:a.maxNum, noCORSonImage:a.noCORSonImage});
					}
				}
				for (var k=assetMulti.length-1; k>=0; k--) {
					assets.splice(i, 0, assetMulti[k]);
				}
				a = assetMulti[0];
				if (a==undefined) continue;
			}

			// catch {src} without id and just replace it with src unless google font
			if (a.constructor == {}.constructor) {
				var propCount = 0;
				for (var prop in a) {
					propCount++;
				}
				if (propCount==1 && a.src && !a.src.match(/fonts\.googleapis\.com/i)) a = a.src;
			}
							
			// normal processing
			var manObj;
			if (a.constructor == {}.constructor) {	
				if (a.audioSprite) {
					obj = zim.copy(a);
					a = obj.src;
					prepareLoad(a);
					var replacement = [];
					var r;
					for (j=0; j<obj.audioSprite.length; j++) {
						r = obj.audioSprite[j];
						replacement.push({id:r[0], startTime:Math.round(r[1]*1000), duration:Math.round((r[2]-r[1])*1000)});
					}
					delete(obj.audioSprite); // the ZIM data
					obj.data = {audioSprite:replacement}; // the CreateJS data
					manifest.push(obj);
				} else if (a.data && a.data.audioSprite) { // CreateJS AudioSprite
					obj = zim.copy(a);
					a = obj.src;
					prepareLoad(a);
					manifest.push(obj);
				} else if (a.id || a.path) { // ZIM asset object	
					if (!a.id) a.id = a.src;									
					if (a.path) {
						var url, found;						
						if (a.path.match(/http/i)) {
							a.src = a.path+a.src;
						} else if (a.path.match(/^\//)) {
							// file:///E:/danzen/code/test/sound.html
							// https://zimjs.com/parallax.html
							url = WW.location.href;
							// putting ? after .* makes it not hungry
							// so find first non repeating / and that is root
							found = url.match(/(.*?)([^/])\/[^/]/);								
							url = found[1]+found[2];
							a.src = url+a.path+a.src;
						} else {
							var pname = WW.location.pathname;
							url = WW.location.href;
							var fileOnly = url.split(pname)[0] + pname;
							found = fileOnly.match(/(.*)\//);
							a.path = a.path.replace(/^\.\//,"");
							var goBack = a.path.match(/\.\.\//g);
							var pref = found[1];
							if (goBack) {
								for (z_i=0; z_i<goBack.length; z_i++) {
									var spl = pref.split("/");
									spl.pop();
									pref = spl.join("/");
								}
								a.path = a.path.replace(/\.\.\//g, "");
							}							
							a.src = pref+"/"+a.path + a.src;
						}
						delete a.path;
					}

					if (a.noCORSonImage) {
						var img = new Image();
						imagesNoCORS.push(img);
						img.src = a.src;
						img.id = a.id;
						var ev;
						img.onload = function(e) {
							var img = e.currentTarget; // bug fixed in Cat 02 patch
							var asset = zim.assets[img.id] = new zim.Bitmap({image:img, style:false}).expand(0);
							ev = new createjs.Event("assetload");
							if (asset && typeof asset != "string" && typeof asset != "number") {
								asset.file = img.id;		
								asset.src = img.src;		
							}
							ev.asset = asset;
							queue.dispatchEvent(ev);
							if (!queueOnly) {
								ev = new createjs.Event("assetload");
								ev.asset = asset;
								that.dispatchEvent(ev);
							}
							queue.loadAssetsCount--;
							if (queue.loadAssetsCount == 0) endAssetLoad();
						}
					} else {		
						zim.assetIDs[a.id] = a.src;
						var mn = a.maxNum;
						if (zot(mn)) mn = maxNum;
						var aType = a.type;
						var aLoadTimeout = zot(a.loadTimeout)?loadTimeout:a.loadTimeout;
						
						a = a.src;
						prepareLoad(a);
						manObj = {src:a, loadTimeout:aLoadTimeout*(timeType=="s"?1000:1), data:mn, type:aType};
						if (!zot(fileType)) manObj.type = fileType;
						manifest.push(manObj);						
					}
				} else { // ZIM font object
					if (a.src && a.src.match(/fonts\.googleapis\.com/i)) googleFonts.push(a);
					else fonts.push(a);
				}
			} else {	
				// check for font - ZIM ZIM 02 		
				var exten = prepareLoad(a);
				if (exten && fontTypes.indexOf(exten[1]) >= 0) {
					fonts.push(a);
					mainCount--;
				} else if (a.match(/fonts\.googleapis\.com/i)) {
					googleFonts.push(a);
					mainCount--;
				} else {					
					manObj = {src:a, loadTimeout:loadTimeout*(timeType=="s"?1000:1), data:maxNum};
					if (!zot(fileType)) manObj.type = fileType;
					manifest.push(manObj);
				}
			}
			if (soundCheck && firstSoundCheck) {
				// dynamically make audio tag with sound to overcome some Apple devices not playing sounds
				var audioTag = document.createElement("audio");
				audioTag.setAttribute("src", ((!zot(path) && !a.match(/^http:\/\/|https:\/\//i))?path:"")+a);
				document.body.appendChild(audioTag);
				firstSoundCheck = false;
			}
		} // end loop

		function prepareLoad(a) {
			ext = null;			
			if (a.split) {
				var temp = a.split("?");
				ext = temp[0].match(re);
				if (ext && createjs.Sound.SUPPORTED_EXTENSIONS.indexOf(ext[1]) >= 0) soundCheck = true;
			}
			mainCount++;
			return ext;
		}
		that.loadAssetsCount++;
		that.isLoading = true;
		var queue = new zim.Queue();
		queue.isLoading = true;
		queue.loadAssetsCount = 0;

        if (!zot(progress) && progress.show) {
			progress.zimActiveLoader = queue;
            progress.show();
        }
		var fontLoader;
		if (fonts.length > 0) { // there are fonts to load
			// create manual list - which seems to always work
			var fontObjects = [];
			var fontObject;
			var fontData;
			for (i=0; i<fonts.length; i++) {
				fontData = fonts[i];
				if (fontData.font && !fontData.src) {
					fontData.src = fontData.font;
					fontData.font = fontData.font.split(".")[0];
					var ff = fontData.font.split("/");
					fontData.font = ff[ff.length-1];
				}
				if (typeof fontData == "string") {
					fontData = {font:fontData.split(".")[0], src:fontData};
				}
				fontObject = {
					src: "url("+(fontData.src.match(/\//i)?"":(path?path:""))+fontData.src+")" + (fontData.type?" format('"+fontData.type+"')":""),
					family: fontData.font
				};
				if (fontData.weight) fontObject.weight = fontData.weight;
				if (fontData.style) fontObject.style = fontData.style;
				fontObjects.push(fontObject);
			}
			fontLoader = new createjs.FontLoader({src:fontObjects}, true);
			fontLoader.on("complete", fontDone);
			fontLoader.on("error", fontDone);
			fontLoader.load();
			queue.loadAssetsCount++;
		}
		if (googleFonts.length > 0) { // there are google fonts to load
			for (i=0; i<googleFonts.length; i++) {
				fontData = googleFonts[i];
				if (typeof fontData == "string") {
					fontData = {src:fontData};
				}
				fontObject = {
					src: fontData.src,
					type: "fontcss"
				};
				queue.loadAssetsCount++; // each google font gets its own loader
				fontLoader = new createjs.FontLoader(fontObject, true);
				fontLoader.on("complete", fontDone);
				fontLoader.on("error", fontDone);
				fontLoader.load();
			}
		}
		function fontDone() {
			queue.loadAssetsCount--;
			if (queue.loadAssetsCount == 0) endAssetLoad();
		}

		if (imagesNoCORS.length > 0) { // there are image tags loading to defeat CORS
			// loaded events are up above in loop
			for (i=0; i<imagesNoCORS.length; i++) {
				queue.loadAssetsCount++;
			}
		}
		
		function svgDone(bitmap, params) {	
			queue.loadAssetsCount--;
			var item = params.item;	
			var asset = zim.assets[item.id] = bitmap;	
			asset.src = item.src;
			asset.file = item.id;
			asset.item = item;
			asset.svg = params.svg; // add SVG to Bitmap as property
			var ev = new createjs.Event("assetload");
			ev.item = item; // createjs preload item
			ev.asset = asset;
			asset.type = "SVG";
			queue.dispatchEvent(ev);
			if (!queueOnly) {
				ev = new createjs.Event("assetload");
				ev.item = item;
				ev.asset = asset;
				that.dispatchEvent(ev);
			}				 
			if (queue.loadAssetsCount == 0) endAssetLoad();				 
		}

		var startLoad = Date.now();
		var completeEventObject = new createjs.Event("complete");
		if (mainCount > 0) { // files other than fonts and noCORSonImage tag to load
			queue.loadAssetsCount++;
			var preload = queue.preload = that.preload = new createjs.LoadQueue(xhr, path, crossOrigin);
			if (maxConnections != 1) preload.setMaxConnections(maxConnections);
			if (soundCheck) preload.installPlugin(createjs.Sound);
						
			preload.on("progress", function(e) {queue.dispatchEvent(e); if (!queueOnly) that.dispatchEvent(e);});
			preload.on("error", function(e) {queue.dispatchEvent(e); if (!queueOnly) that.dispatchEvent(e);});
			preload.on("fileload", function(e) {
				// for some reason, errors are not working on IMG and SVG from PreloadJS 
				// so check for rawResult - should really fix this in CreateJS				
				if (!e.result || ((e.result.nodeName=="IMG" || e.result.nodeName=="SVG") && !e.rawResult && xhr)) {		
					zog("here")			
					var ev = new createjs.Event("error");
					ev = new createjs.Event("error");
					ev.item = e.item; // createjs preload item
					queue.dispatchEvent(ev);	
					// seem to have to make the event twice
					ev = new createjs.Event("error");
					ev.item = e.item; 				
					that.dispatchEvent(ev);	
				} else {			
					var item = e.item;
					var type = e.item.type;
					var ext = item.id.match(re);
					var asset;
					if (type && type == "sound") {
						var soundIDs = [];
						if (item.data && item.data.audioSprite) {
							for (var i=0; i<item.data.audioSprite.length; i++) {
								soundIDs.push(item.data.audioSprite[i].id);
							}
						} else {
							soundIDs.push(item.id);
						}
						for (i=0; i<soundIDs.length; i++) {								
							~function() { // wrap soundID in a closure
								var soundID = soundIDs[i];
								var src = e.item.src;
								var item = e.item;
								asset = zim.assets[soundID] = {
									type:"sound",
									path:path,
									id:soundID,
									file:soundID,
									src:src,
									item:item,
									dispose:function() {delete zim.assets[soundID]; asset=null;},
									play:function(volume, loop, loopCount, pan, offset, delay, interrupt) {
										var sig = "volume, loop, loopCount, pan, offset, delay, interrupt";
										var duo; if (duo = zob(zim.assets[soundID].play, arguments, sig)) return duo;
										var added = {
											volume:volume,
											loop:loop,
											loopCount:loopCount,
											pan:pan,
											offset:offset,
											delay:delay,
											interrupt:interrupt
										};
										var timeType = getTIME(added.offset, null, 30);
										if (timeType == "s") {
											if (added.offset) added.offset*=1000;
											if (added.delay) added.delay*=1000;
										}
										if (added.loop===true) added.loop = -1;
										if (added.loopCount) {
											added.loop = added.loopCount;
											delete added.loopCount;
										}
										var instance = createjs.Sound.play(soundID, added);
										instance.getStage = function(){return stage;};
										instance.dispose = function(){instance.destroy();}
										return instance;
									}
								};
							}();
						}
					} else if (type == "image") {
						if (e.result.width) {
							asset = zim.assets[item.id] = new zim.Bitmap({image:e.result, width:e.result.width, height:e.result.height, style:false});
							if (item.avoidCORS) asset.expand(0);
						}
					} else if (type == "svg") {
						queue.loadAssetsCount++;
						zim.svgToBitmap(e.result, svgDone, null, null, {svg:e.result, item:item, type:type, ext:ext});	
						return;	
					} else {
						asset = zim.assets[item.id] = e.result;
					}
					
					if (asset && typeof asset != "string" && typeof asset != "number" && type != "json" && type != "xml") {
						asset.file = e.item.id;	
						asset.src = e.item.src;		
						asset.item = e.item;		
					}					
					ev = new createjs.Event("assetload");
					ev.item = item; // createjs preload item
					ev.asset = asset;
					queue.dispatchEvent(ev);
					if (!queueOnly) {
						// strange we need to make the event again - bug discovered ZIM Cat
						ev = new createjs.Event("assetload");
						ev.item = item; // createjs preload item
						ev.asset = asset;
						that.dispatchEvent(ev);
					}
				}
			});
			that.preloadEvent = preload.on("complete", function(e) {
				completeEventObject = e;
				queue.loadAssetsCount--;
				if (queue.loadAssetsCount == 0) endAssetLoad();
			});				
			try {preload.loadManifest(manifest);}catch(err){
				+function(){}()
			}
			// // strange - the try just stops an error but still loads
			// catch {
			// 	// setTimeout(function() {
			// 	// 	preload.loadManifest(manifest);
			// 	// }, 50);
			// }

		} // end non font/noCORSonImage

		function endAssetLoad() {
			// setting a time will force the preload to wait at least this amount of time
			// this can be used for testing or if you always want time to show a loading message
			var endLoad = Date.now();
			time = Math.max(0, time-(endLoad-startLoad));
			setTimeout(function() {
				that.loadAssetsCount--;
				if (that.loadAssetsCount <= 0) that.isLoading = false;
				queue.isLoading = false;
				queue.dispatchEvent(completeEventObject);
				if (!zot(progress) && progress.show) progress.hide();
				if (!queueOnly) that.dispatchEvent(completeEventObject);
			}, time*(timeType=="s"?1000:1));
		}
		return queue;
	};

	// called by asset if auto loading (ac is Asset Container)
	this.ac = function(method, args, obj) {			
		if (obj) {
			if (!obj.commands) obj.commands = [];
			obj.commands.push([method,args,obj]);
		} else {
			if (!args[0].commands) args[0].commands = [];
			args[0].commands.push([method,args]);
		}
	};

	// create a global asset function
	// and a Frame asset method
	zim.asset = this.asset = function(n, w, h, maxNum, second) {
		if (zot(n)) return;
		n = zik(n);		
		var fromID = zim.assetIDs[n];
		if (fromID) n = fromID;
		
		// getting {type:"sound", path:"assets/", id:732}
		// want    {type:"sound", path:"assets/", id:"bird.mp3"}
		
		// items like json coming through without a type
		if (zim.assets[n] && (!zim.assets[n].type || (zim.assets[n].type && zim.assets[n].type.substr(0,2) != "AC"))) return zim.assets[n];
		// regular asset has been returned above
		// now check auto load assets or broken if second
		
		if (WW.PATH!=null) zim.PATH = WW.PATH;
					
		if (second) {
			var empty;
			if (that.loadFailObj == "circles") empty = that.makeCircles(14);
			else empty = that.loadFailObj;
			if (empty) {
				empty.type = "EmptyAsset";
				empty.id = n;
				empty.play = function(){if (zon) {zogy("Frame - asset("+n+") not found"); return {};}};
			}
			return empty;
		} else {
			var assetHolder = new zim.Container(w, h);
			
			// added this to here as well as to complete event so that does not keep trying to load same asset ZIM NFT 01
			zim.assets[n] = assetHolder; 
			
			if (w && h) assetHolder.type = "ACWD"; // AssetContainer with Dimensions - does not recall methods
			else assetHolder.type = "AC"; // AssetContainer		
			
			var assetLoader = that.loadAssets({assets:n, path:n.split("/").length==1?zim.PATH:null, queueOnly:true, maxNum:maxNum});
			var parts = n.split(".");				
			if (createjs.Sound.SUPPORTED_EXTENSIONS.indexOf(parts[parts.length-1]) >= 0) {				
				assetHolder.play = function() {
					assetHolder.playParams = arguments;
					assetHolder.proxy = new createjs.EventDispatcher();
					Object.defineProperty(assetHolder.proxy, 'volume', {
						get: function() {
							if (assetHolder.sound) return assetHolder.sound.volume;
							else return null;
						},
						set: function(value) {
							assetHolder.volume = value;
							if (assetHolder.sound) assetHolder.sound.volume = value;
						}
					});
					Object.defineProperty(assetHolder.proxy, 'pan', {
						get: function() {
							if (assetHolder.sound) return assetHolder.sound.pan;
							else return null;
						},
						set: function(value) {
							assetHolder.pan = value;
							if (assetHolder.sound) assetHolder.sound.pan = value;
						}
					});
					return assetHolder.proxy;
				}
			}				
			assetLoader.on("complete", function () {
													
				// thanks Xuntar for the adjustment Cat 03
				// to handle lazy-load with asset({id:"etc", src:"https:domain/etc.png"});
				if (n.id) n = n.id; 
				else if (n.src) n = n.src;							
				var loaded = that.asset(n, null, null, null, true);		

				var parts = n.split(".");
				var i;
				if (createjs.Sound.SUPPORTED_EXTENSIONS.indexOf(parts[parts.length-1]) >= 0) {	
				// if (loaded.play) {		
					assetHolder.play = loaded.play;
					assetHolder.type = "Sound";		
					assetHolder.src = loaded.src;
					assetHolder.item = loaded.item;	
					if (assetHolder.playParams) {	
						assetHolder.sound = assetHolder.play.apply(null, assetHolder.playParams);
						if (assetHolder.volume != null) assetHolder.sound.volume = assetHolder.volume;
						if (assetHolder.pan != null) assetHolder.sound.pan = assetHolder.pan;
						assetHolder.sound.on("complete", function () {
							assetHolder.proxy.dispatchEvent("complete")
						});
					} 						
				} else if (loaded.type == "Bitmap" || loaded.type == "Image" || loaded.type == "Pic") {						
					if (loaded.type == "Bitmap") {
						loaded.addTo(assetHolder);
						assetHolder.bitmap = loaded;
						assetHolder.image = loaded.image;
						assetHolder.id = loaded.id;
						assetHolder.item = loaded.item;
					} else {
						assetHolder.bitmap = loaded.getChildAt(0).clone();
						assetHolder.bitmap.addTo(assetHolder);
						assetHolder.image = assetHolder.bitmap.image;
						assetHolder.id = assetHolder.bitmap.id;
						assetHolder.item = assetHolder.bitmap.item;
					}
					assetHolder.mouseChildren = false;
					assetHolder.type = "Image";
					if (assetHolder.commands) {
						for (i=0; i<assetHolder.commands.length; i++) {
							if (assetHolder.commands[i][2]) assetHolder[assetHolder.commands[i][0]].apply(assetHolder, assetHolder.commands[i][1]);
							else zim[assetHolder.commands[i][0]].apply(assetHolder, assetHolder.commands[i][1]);
						}
					}
					assetHolder.commands = null;
					if (assetHolder.stage) assetHolder.stage.update();
				} else if (loaded.type == "EmptyAsset") {
					loaded.addTo(assetHolder);
					assetHolder.mouseChildren = false;
					assetHolder.type = "EmptyAsset";
					if (assetHolder.commands) {
						for (i=0; i<assetHolder.commands.length; i++) {
							if (assetHolder.commands[i][2]) assetHolder[assetHolder.commands[i][0]].apply(assetHolder, assetHolder.commands[i][1]);
							else zim[assetHolder.commands[i][0]].apply(assetHolder, assetHolder.commands[i][1]);
						}
					}
					assetHolder.commands = null;
					if (assetHolder.stage) assetHolder.stage.update();
				} else if (loaded.type == "SVG") {
					loaded.addTo(assetHolder);
					assetHolder.mouseChildren = false;
					assetHolder.type = "SVG";
					assetHolder.bitmap = loaded;
					assetHolder.svg = loaded.svg;
					if (assetHolder.commands) {
						for (i=0; i<assetHolder.commands.length; i++) {
							if (assetHolder.commands[i][2]) assetHolder[assetHolder.commands[i][0]].apply(assetHolder, assetHolder.commands[i][1]);
							else zim[assetHolder.commands[i][0]].apply(assetHolder, assetHolder.commands[i][1]);
						}
					}
					assetHolder.commands = null;
					if (assetHolder.stage) assetHolder.stage.update();
				}
				// ZIM NFT 01 - the actual asset will be added to the zim.assets array 
				// so override that with the AC to keep track of the operations on it 
				zim.assets[n] = assetHolder; // assign assetHolder to overwrite loaded asset
				assetHolder.dispatchEvent("assetLoad");
				assetHolder.dispatchEvent("complete");
			});				
			assetLoader.on("error", function (e) {
				var ev = new createjs.Event("error");
				ev.id = e.id;	
				ev.item = e.item;	
				assetHolder.dispatchEvent(ev);
			});
			return assetHolder;
		}
	};
	zim.asset.getIDs = function() {
		var ids = [];
		for (var name in zim.assetIDs) {
			ids.push(name);
		}
		return ids;
	};

	// create an image function
	// that uses CORS busting and then calls asset()
	zim.image = function(n, w, h, maxNum, second) {
		if (n.match(/^htt/i)) n = "https://cors.zimjs.com/" + n;
		return zim.asset(n, w, h, maxNum, second);
	};

	zim.zimObjectIDs = {};
	zim.object = this.object = function(name) {
		return zim.zimObjectIDs[name];
	};
	zim.object.getNames = function() {
		var names = [];
		for (var name in zim.zimObjectIDs) {
			names.push(name);
		}
		return names;
	};

	if (!WW.zns) {
		WW.asset = this.asset;
		WW.image = zim.image;
		WW.object = this.object;
	}

	this.setDefault = function() {
		WW.zimDefaultFrame = WW.zdf = WW.F = that;
		WW.S = stage;
		WW.W = stage.width;
		WW.H = stage.height;
		return that;
	};

	Object.defineProperty(that, 'isDefault', {
		get: function() {
			return WW.zdf == that;
		},
		set: function() {
			zogy("Frame(): isDefault is read only - see setDefault()");
		}
	});

	Object.defineProperty(that, 'stage', {
		get: function() {
			return stage;
		},
		set: function() {
			zogy("Frame(): stage is read only - see remakeCanvas(), perhaps");
		}
	});

	Object.defineProperty(that, 'width', {
		get: function() {
			return sW;
		},
		set: function() {
			zogy("Frame(): width is read only - see remakeCanvas(), perhaps");
		}
	});

	Object.defineProperty(that, 'height', {
		get: function() {
			return sH;
		},
		set: function() {
			zogy("Frame(): height is read only - see remakeCanvas(), perhaps");
		}
	});

	Object.defineProperty(this, 'color', {
		get: function() {
			return color;
		},
		set: function(value) {
			color = value;
			if (!zot(value)) {
				that.canvas.style.backgroundColor = color;
				// zid(canvasID).style.backgroundColor = color;
				if (!zot(color) && gpu) stage.setClearColor(zim.convertColor(color));
			} else {
				// zid(canvasID).style.backgroundColor = "default";
				that.canvas.style.backgroundColor = "default";
			}
		}
	});

	var _outerColor;
	Object.defineProperty(this, 'outerColor', {
		get: function() {
			return _outerColor;
		},
		set: function(value) {
			_outerColor = value;
			zet("body").css({backgroundColor:_outerColor});
		}
	});

	Object.defineProperty(that, 'allowDefault', {
		get: function() {
			return allowDefault;
		},
		set: function(t) {
			if (t) {
				stage.preventSelection = false;
				document.body.style.overflow = "visible";
				if (that.zil) {
					WW.removeEventListener("keydown", that.zil[0]);
					WW.removeEventListener("wheel", that.zil[1]);
					WW.removeEventListener("DOMMouseScroll", that.zil[2]);
					that.zil = null;
				}
			} else {
				stage.preventSelection = true;
				stage.enableDOMEvents(true);
				if (scaling == "full" || scaling == "fit" || scaling == "fill") document.body.style.overflow = "hidden";
				if (zot(that.zil)) that.zil = zil();
			}
			allowDefault = t;
			if (stage.__touch) stage.__touch.preventDefault = !allowDefault;
		}
	});


	// CURSOR SYSTEM WITH CUR()
	// added ZIM 014

	var cursors;	
	Object.defineProperty(that, 'cursors', {
		get: function() {
			return cursors;
		},
		set: function(obj) {
			cursors = obj && obj.constructor=={}.constructor ? obj : null;
			if (cursors) addCursors(cursors); 
			else removeCursors();
		}
	});

	that.cursorTypes = [
		"none", "auto", "pointer", "text", "wait", "crosshair", "default", "help", "move", "progress", "e-resize", "ne-resize", "nw-resize", "n-resize", "se-resize", "sw-resize", "s-resize", "w-resize",
		"context-menu", "cell", "vertical-text", "alias", "copy", "no-drop", "not-allowed", "ew-resize", "ns-resize", "nesw-resize", "nwse-resize", "col-resize", "row-resize", "all-scroll", "grab", "grabbing", "zoom-in", "zoom-out"
	];

	that.cursorList = new zim.Dictionary(true); // keep track of items with cur() added	- true for unique


	function addCursors(obj) {
		zim.loop(obj, function (name, val) {
			if (val.noMouse) val.noMouse(); // turn mouse off on custom cursor
		});

		if (that.pme) removeCursors();
		
		zim.loop(that.cursorList, function(key) {
			// only update if not already adjusted otherwise could overwrite none as desired cursor value
			if (!key._cursor && key.cursor && obj[key.cursor]) {
				key._cursor = key.cursor;
				that.cursorList.add(key, key._cursor); // will overwrite default true value with cursor type as string
				key.cursor = "none";
			}
		});
		
	 	if (obj.default) document.body.style.cursor = "none";		

		that.pme = that.on("pointermove", function(e) {			
			// move the cursor object and update stage if not already a Ticker
			// zog("here", that.cursorObj)
			if (!that.cursorObj) return;

			// handle touchscreen not getting mouseover - sigh
			var oldCursor = that.cursorObj;
			var co = that.stage.getObjectUnderPoint(that.mouseX, that.mouseY, 1);
			while (co && !(co._cursor || co.cursor)) {
				co = co.parent;
			}
			if (co && (co._cursor || co.cursor)) {
				setCustom(co);
			} else if (obj.default) {
				setCursor("none");
				that.cursorObj = obj.default;
				obj.default.addTo(that.stage);
			} else {
				setCursor();
			}
			if (that.cursorObj != oldCursor && oldCursor.removeFrom) oldCursor.removeFrom();			
			if (!that.cursorObj) return;
			that.cursorObj.x = that.mouseX;
			that.cursorObj.y = that.mouseY;
			that.cursorObj.top();
			if (!zim.Ticker.isUpdating(that.stage)) that.stage.update();
		});

		var firstSet = false;
		if (that.mouseX != 0 && that.mouseY !=0) {
			firstSet = true;
			var co = that.stage.getObjectUnderPoint(that.mouseX, that.mouseY, 1);
			if (co && (co._cursor || co.cursor)) {
				setCustom(co);
			} else if (obj.default) {
				setCursor("none");
				obj.default.x = that.mouseX;
				obj.default.y = that.mouseY;
				that.cursorObj = obj.default;
				that.cursorObj.mouseChildren = false;
				that.cursorObj.mouseEnabled = false;
				obj.default.addTo(that.stage);
			} else {
				setCursor();
			}
			that.stage.update();
		}

		function doCursor(newCursor) {
			setCursor("none");
			that.cursorObj = newCursor;
			that.cursorObj.x = that.mouseX;
			that.cursorObj.y = that.mouseY;
			that.cursorObj.mouseChildren = false;
			that.cursorObj.mouseEnabled = false;
			that.cursorObj.addTo(that.stage);
		}

		that.pee = that.on("pointerenter", function(e) {
			if (firstSet) {
				firstSet = false;
				return;
			}
			setTimeout(function() {
				// may be starting on an object with a cursor
				var co = that.stage.getObjectUnderPoint(that.mouseX, that.mouseY, 1);
				while (co && !(co._cursor || co.cursor)) {
					co = co.parent;
				}
				if (co && (co._cursor || co.cursor)) return;
				if (obj.default) {
					doCursor(obj.default);
				} else {
					setCursor();
				}
				that.stage.update();
			}, 50);        
		});	
		that.smo = that.stage.on("mouseover", function(e) {
			setCustom(e.target);				
		});

		function setCustom(target) {			
			var ex = that.cursorsExclude;
			if (ex) {
				if (!Array.isArray(ex)) ex = [ex];
				if (ex.includes(target)) {
					target.cursor = that.cursorTypes.includes(target._cursor)?target._cursor:"default";
					return;
				} 
			}
			if (target._cursor && obj[target._cursor]) {	
				if (obj[target._cursor] == that.cursorObj) return;	// only set if it is different		
				if (that.cursorObj) that.cursorObj.removeFrom();
				doCursor(obj[target._cursor]);
			} else if (obj.default && (!target.cursor || !that.cursorTypes.includes(target.cursor))) {
				if (obj.default == that.cursorObj) return;	// only set if it is different				
				if (that.cursorObj) that.cursorObj.removeFrom();
				doCursor(obj.default);
			} else {
				if (!that.cursorTypes.includes(target.cursor)) target.cursor = "default";
				if (that.cursorObj) that.cursorObj.removeFrom();
			}
			
			that.stage.update();
		}

		that.ple = that.on("pointerdown", function(e) {
			if (that.cursorObj) {
				zim.interval(.001, function(){ // to over top drag
					if (that.cursorObj) that.cursorObj.top();
					that.stage.update();
				}, 2, true);
			}
		});
		that.pde = that.on("pointerleave", function(e) {
			firstSet = false;
			if (that.cursorObj) that.cursorObj.removeFrom();
			that.stage.update();
		});
		
		that.smu = that.stage.on("mouseout", function(e) {
			if (that.cursorObj) that.cursorObj.removeFrom();
			if (obj.default) {
				doCursor(obj.default);
			} else {
				setCursor();
			}
		});		
	}

	function removeCursors() {

		if (that.pme) that.off("pointermove", that.pme);
		if (that.pee) that.off("pointerenter", that.pee);	
		if (that.ple) that.off("pointerdown", that.ple);
		if (that.pde) that.off("pointerleave", that.pde);
		if (that.smo) that.stage.off("mouseover", that.smo);
		if (that.smu) that.stage.off("mouseout", that.smu);
		that.pme = that.pee = that.ple = that.pde = that.smo = that.smu = null;

		zim.loop(that.cursorList, function(key, val) {	
			if (val !== true) key.cursor = val;
			key._cursor = null;
		});
		zim.loop(that.cursorList, function(key) {		
			that.cursorList.add(key, true); 
		});
		
		if (that.cursorObj) {
			that.cursorObj.dispose();
			that.cursorObj = null;
			that.stage.update();
		}
		setCursor();
	}
	function setCursor(type) {
		if (type != "none") that.cursorObj = null;
		if (that.canvas.parentElement) that.canvas.parentElement.style.cursor = type||"default";
	}

	// END CURSOR SYSTEM

	
	function contextEvent(e) {
		that.dispatchEvent(e);
	}
	WW.addEventListener("contextmenu", contextEvent, false);

	var eDown = new createjs.Event("keydown");
	this.eventRemove = eDown.remove;
	function keydownEvent(e) {
		e.remove = that.eventRemove;
		that.altKey = e.altKey;
		that.ctrlKey = e.ctrlKey;
		that.metaKey = e.metaKey;
		that.shiftKey = e.shiftKey;
		if (e.altKey && e.key=="ArrowLeft") WW.history.back();
		if (e.altKey && e.key=="ArrowRight") WW.history.forward();
		that.dispatchEvent(e);
	}
	// var realWindow = window.parent || window;
	WW.addEventListener("keydown", keydownEvent);
	function keyupEvent(e) {
		that.altKey = e.altKey;
		that.ctrlKey = e.ctrlKey;
		that.metaKey = e.metaKey;
		that.shiftKey = e.shiftKey;
		e.remove = that.eventRemove;
		that.dispatchEvent(e);
	}
	WW.addEventListener("keyup", keyupEvent);
		function wheelEvent(e) {
		that.dispatchEvent(e);
	}
	WW.addEventListener("wheel", wheelEvent);
	function devicemotionEvent(e) {
		e.remove = that.eventRemove;
		that.dispatchEvent(e);
	}
	if (sensors && WW.DeviceMotionEvent) {
		WW.addEventListener("devicemotion",devicemotionEvent);
	}
	function deviceorientationEvent(e) {
		e.remove = that.eventRemove;
		// for some reason, reporting alpha as increasing going counter counterclockwise
		// so this code makes it increase going clockwise
		var z = 360-e.alpha;
		// compass is subtracting 180 if device screen is pointing down
		// in a VR helmet this would be looking slightly up from the horizon...
		// so removing this flip with the following code
		if (Math.abs(z-lastZ) > 180 - 45 && Math.abs(z-lastZ) < 180 + 45) flip = flip == 0 ? 180 : 0;
		lastZ = z;
		e.rotation = {x:e.beta, y:e.gamma, z:(z + flip) % 360};
		that.dispatchEvent(e);			
	}
	if (sensors && WW.DeviceOrientationEvent) {
		// zim.timeout(.2, function () {
		// 	that.dispatchEvent("yes");
		// });
		var lastZ = 0;
		var flip = 0;
		WW.addEventListener("deviceorientation",deviceorientationEvent);
	}
	
	this.isFullscreen = document.fullscreenElement?true:false;
	this.htmlobc = zet("html").css("backgroundColor");
	this.fullscreen = function(mode) {
		if (zot(mode)) mode = true;
		if (mode) { // go fullscreen
			if (document.fullscreenElement) return;
			var elem = that.canvas.parent?that.canvas.parent:document.body;
			if (elem.requestFullscreen) {
				elem.requestFullscreen();
			} else if (elem.webkitRequestFullscreen) { /* Safari */
				elem.webkitRequestFullscreen();
			} else if (elem.mozRequestFullscreen) { /* Mozilla */
				elem.mozRequestFullscreen();
			} else if (elem.msRequestFullscreen) { /* IE11 */
				elem.msRequestFullscreen();
			}
		} else { // exit fullscreen
			if (!document.fullscreenElement) return;
			if (document.exitFullscreen) {
				document.exitFullscreen();
			} else if (document.webkitExitFullscreen) { /* Safari */
				document.webkitExitFullscreen();
			} else if (document.mozExitFullscreen) { /* Mozilla */
				document.mozExitFullscreen();
			} else if (document.msExitFullscreen) { /* IE11 */
				document.msExitFullscreen();
			}
		}
		this.isFullscreen = mode;
	}
	document.addEventListener("fullscreenchange", function() {
		that.isFullscreen = document.fullscreenElement?true:false;
		if (document.fullscreenElement) {
			zet("html").css("backgroundColor", that.color);
			that.dispatchEvent("fullscreenenter");
		} else {
			zet("html").css("backgroundColor", that.htmlobc?that.htmlobc:"transparent");
			that.dispatchEvent("fullscreenexit");				
		}			
	});

	this.remakeCanvas = function(width, height) {
		if (scaling == "full") return;
		if (zot(width)) width = sW;
		if (zot(height)) height = sH;
		if (zid(canvasID)) zid(canvasID).parentNode.removeChild(zid(canvasID));
		sW = width;
		sH = height;
		var onStage = [];
		for (var i=0; i<that.stage.numChildren; i++) {
			onStage.push(that.stage.getChildAt(i));
		}
		makeCanvas();
		makeStage();
		for (i=0; i<onStage.length; i++) {
			that.stage.addChild(onStage[i]);
		}
	};

	this.follow = function(obj, boundary, damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, lag) {
		var sig = "obj, boundary, damp, dampY, leftOffset, rightOffset, upOffset, downOffset, offsetDamp, offsetDampY, horizontal, vertical, borderLock, lag";
		var duo; if (duo = zob(that.follow, arguments, sig)) return duo;
		that.followObj = null;
		if (that.followTicker) zim.Ticker.remove(that.followTicker);
		if (zot(obj)) return;
		obj.dirX = obj.dirY = 0;
		that.followObj = obj;
		obj.followDampX = null;
		obj.followDampY = null;
		if (zot(boundary)) boundary = new zim.Boundary(0,0,that.stage.width,that.stage.height);
		that.followBoundary = boundary;
		if (zot(damp)) damp = .05;
		if (zot(dampY)) dampY = damp;
		if (zot(leftOffset)) leftOffset = 0;
		if (zot(rightOffset)) rightOffset = 0;
		if (zot(upOffset)) upOffset = 0;
		if (zot(downOffset)) downOffset = 0;
		if (zot(offsetDamp)) offsetDamp = .02;
		if (zot(offsetDampY)) offsetDampY = offsetDamp;
		if (zot(horizontal)) horizontal = true;
		if (zot(vertical)) vertical = true;
		if (zot(borderLock)) borderLock = false;
		if (zot(lag)) lag = false;

		if (!obj.parent) obj.on("added", good);
		else good();
		function good() {
			var container = obj.parent;
			that.frameBorderLock = borderLock;
			if (horizontal) {
				that.followDampX = new zim.Damp(container.x,damp);
				that.offsetDampX = new zim.Damp(boundary.x+leftOffset+(boundary.width-leftOffset-rightOffset)/2, offsetDamp);
			}
			if (vertical) {
				that.followDampY = new zim.Damp(container.y,dampY);
				that.offsetDampY = new zim.Damp(boundary.y+upOffset+(boundary.height-upOffset-downOffset)/2,offsetDampY);
			}
			that.followTicker = zim.Ticker.add(function () {
				var boundary = that.followBoundary;
				if (horizontal) {
					var midH = boundary.x+leftOffset+(boundary.width-leftOffset-rightOffset)/2;
					that.followOffsetX = [lag?boundary.x+boundary.width-leftOffset:midH, midH, lag?boundary.x+leftOffset:midH];
					if (that.followObj) container.x = that.followDampX.convert(that.offsetDampX.convert(that.followOffsetX[obj.motionController?obj.motionController.dirX+1:1])-obj.x);
				}
				if (vertical) {
					var midV = boundary.y+upOffset+(boundary.height-upOffset-downOffset)/2;
					that.followOffsetY = [lag?boundary.y+boundary.height-downOffset:midV, midV, lag?boundary.y+upOffset:midV];
					if (that.followObj) container.y = that.followDampY.convert(that.offsetDampY.convert(that.followOffsetY[obj.motionController?obj.motionController.dirY+1:1])-obj.y);
				}

				if (that.frameBorderLock) {
					if (container.x > that.followBoundary.x) container.x = that.followBoundary.x;
					if (container.y > that.followBoundary.y) container.y = that.followBoundary.y;
					if (container.x < (that.followBoundary.x + that.followBoundary.width - container.width)) container.x = (that.followBoundary.x + that.followBoundary.width - container.width);
					if (container.y < (that.followBoundary.y + that.followBoundary.height - container.height)) container.y = (that.followBoundary.y + that.followBoundary.height - container.height);
				}
			});
		}
		return obj;
	};
	
	// Fixed in ZIM 014 to 
	if (zot(zim.blurCheck)) zim.setBlurDetect(); // added in ZIM NFT 01 for tabfocus and tabblur events

	this.keyboardMessage = function(color, backgroundColor, message, response, percent, call) {
		var sig = "color, backgroundColor, message, response, percent, call";
		var duo; if (duo = zob(that.keyboardMessage, arguments, sig)) return duo;
		if (zot(color)) color = zim.yellow;
		if (zot(backgroundColor)) backgroundColor = "black";
		if (zot(message)) message = "PRESS SCREEN FOR KEYBOARD CONTROL";
		if (zot(response)) response = "YOU HAVE KEYBOARD CONTROL";
		if (zot(percent)) percent = 80;
		function inIframe () {
			try {
				return window.self !== window.top;
			} catch (e) {
				return true;
			}
		}
		var inFrame = inIframe();
		if (inFrame) that.canvas.style.pointerEvents = "none";

		if (message != "") {
			var message = new zim.Label({
				text:message, 
				size:40, 
				color:color, 
				backgroundColor:backgroundColor,
				paddingV:15,
				paddingH:30,
				shiftV:1,
				align:CENTER
			})
				.scaleTo(that.stage,percent)
				.ske(10)
				.reg(CENTER)
				.pos(0,50,CENTER,BOTTOM)
		}
		document.addEventListener("mousedown", kmd);
		document.addEventListener("pointerdown", kmd);
		function kmd () {
			if (inFrame) that.canvas.style.pointerEvents = "auto"; 
			document.removeEventListener("mousedown", kmd);
			document.removeEventListener("pointerdown", kmd);			
			if (message != "") {
				message.text = response;
				message.animate({
					props:{alpha:0}, 
					wait:1,
					call:function() {message.dispose(); message=null;}
				});
				that.stage.update();
			}
			if (call && typeof call == "function") call();
			that.dispatchEvent("keyboardactive");
		}
		return message==""?null:message;
	}	

	this.dispose = function() {

		// Handle three and physics
		createjs.removeRemotePointers(that.stage);
		if (zim.TAM) zim.TAM.dispose();
		zim.TAM = null;	
        if (WW.zimDefaultThree && WW.zimDefaultThree.dispose && WW.zimDefaultThree.frame==that) {
			WW.zimDefaultThree.dispose(); 		
			WW.zimDefaultThree = null;
		}
		if (WW.zimDefaultPhysics && WW.zimDefaultPhysics.dispose && WW.zimDefaultPhysics.frame==that) {
			WW.zimDefaultPhysics.dispose(); 
			WW.zimDefaultPhysics = null;
		}

		// remove zil events
		if (that.zil && that.zil.length) {
			WW.removeEventListener("keydown", that.zil[0]);
			WW.removeEventListener("wheel", that.zil[1]);
			WW.removeEventListener("DOMMouseScroll", that.zil[2]);
		}
		if (canvas) canvas.removeAllEventListeners();
		if (that.frameTime) clearInterval(that.frameTime);
		
		// remove frame events
		// var realWindow = window.parent || window;
		if (shimResizeEvent) WW.removeEventListener('resize', shimResizeEvent);
		WW.removeEventListener('resize', windowResizeEvent);
		WW.removeEventListener("contextmenu", contextEvent); 
		WW.removeEventListener("keydown", keydownEvent); // thanks Reinout Mechant for the fix!
		WW.removeEventListener("keyup", keyupEvent);
		WW.removeEventListener("wheel", wheelEvent);
		WW.removeEventListener("devicemotion", devicemotionEvent);
		WW.removeEventListener("deviceorientation", deviceorientationEvent);
		
		WW.removeEventListener("mousedown", leftEvent, true);
		WW.removeEventListener("mousemove", leftEvent, true); 
		WW.removeEventListener("mouseup", leftEvent);
					
		if (!allowDefault) document.body.style.overflow = "auto";
		recursiveDispose(stage);
		function recursiveDispose(obj) {
			if (!obj) return;
			if (obj.dispose) obj.dispose();
			else {
				obj.removeAllEventListeners();
				if (obj.numChildren) {
					for (var i=obj.numChildren-1; i>=0; i--) {
						recursiveDispose(obj.getChildAt(i));
					}
				}
				if (obj.parent) obj.parent.removeChild(obj);
			}
			obj = null;
		}
		if (zid(canvasID)) zid(canvasID).parentNode.removeChild(zid(canvasID));
		zim.Ticker.dispose(stage);
		if (that == zim.tickerFrame) zim.tickerFrame = null;
		if (that === WW.zdf) WW.zdf = WW.S = WW.W = WW.H = null;

		stage = null;
		that = null;
		return true;
	};

	// zim colors - legacy
	// have been removed as they are stored on zim or global

	this.makeCircles = function(radius, multiple) {
		if (zot(radius)) radius = 100;
		var colors = [zim.orange, zim.green, zim.pink, zim.blue, zim.brown, zim.dark];
		var c, i;
		if (multiple) {
			c = new zim.Container({style:false});
			c.radius = radius;
			for (i=0; i<colors.length; i++) {
				c.addChild(new zim.Circle((c.radius/colors.length)*(colors.length-i), colors[i], null, null, null, null, null, null, null, false));
			}
		} else {
			c = new zim.Shape({style:false});
			var g = c.graphics;
			c.radius = radius;
			for (i=0; i<colors.length; i++) {
				g.f(colors[i]).dc(0,0,(c.radius/colors.length)*(colors.length-i));
			}
			c.setBounds(-c.radius,-c.radius,c.radius*2,c.radius*2);
		}
		return c;
	};

	this.madeWith = function(color, text, edges, box, slats, borderColor, borderWidth) {
		var sig = "color, text, edges, box, slats, borderColor, borderWidth";
		var duo; if (duo = zob(that.madeWith, arguments, sig)) return duo;
		
		if (zot(color)) color = zim.dark;
		if (zot(text)) text = "Made with ZIM";

		var madeWith = new zim.Container();
		var icon = madeWith.icon = that.makeIcon(edges, box, slats, borderColor, borderWidth)
			.sca(.5).alp(.92).hov(1).addTo(madeWith)
			.tap(function () {
				icon.alp(.92);
				icon.stage.update();
				zgo("https://zimjs.com", "_blank");
			});
		madeWith.label = new zim.Label(text, 16, null, color).sca(.7).pos(0, -19, zim.CENTER, zim.BOTTOM, madeWith);
		return madeWith;
	};

	this.makeIcon = function(edges, box, slats, borderColor, borderWidth) {
		var sig = "edges, box, slats, borderColor, borderWidth";
		var duo; if (duo = zob(that.makeIcon, arguments, sig)) return duo;
		var icon = new zim.Container(-20, -13, 102, 120).reg(-20,-13);
		if (zot(edges)) edges = zim.light;			
		if (zot(box)) box = zim.dark;
		if (slats === true) slats = [zim.silver, zim.silver, zim.silver, zim.silver, zim.silver];
		new zim.Rectangle(icon.width, icon.height, box, borderColor, borderWidth).loc(-20,-13,icon);

		var data = [
			[slats?slats[0]:"#E474C3", "AieA0IAAgCIAmhlIEXAAIg5Bng", 41.7, 19.5],
			[slats?slats[1]:"#50C5B7", "AiSAzIAnhlID+AAIg5Blg", 35.3, 33.2],
			[slats?slats[2]:"#F48E25", "AiFA0IAmhnIDlAAIg5Bng", 28.9, 46.7],
			[slats?slats[3]:"#EBCD36", "Ah4AzIAmhlIDLAAIg5Blg", 22.4, 60.5],
			[slats?slats[4]:"#ABD140", "AhrA0IAAgFIAlhiICxAAIg5Bng", 16.1, 74.3],
			[edges, "AlGHRIAnhnIH+AAIgbBngAlGlpIAnhnIJmAAIg5Bng", 32.7, 46.5],
		];
		zim.loop(data, function (d) {
			var shape = new zim.Shape().addTo(icon);
			shape.graphics.f(d[0]).p(d[1]);
			shape.setTransform(d[2],d[3]);
		});
		icon.mouseChildren = false;
		return icon;
	};

	this.makeAbstract = function(color) { // undocumented		
		if (zot(color)) color = "black";	
		var data = [
			[115.8,103.55, "#4ACBEB","Am6GkIAAtHIN0AAIAAClIrZAAIAAKig"],
			[127.55,73.3, "#A1E543","AAjLSIAAp6IEiAAIAAJ6gAlELOIAAp2IEiAAIAAJ2gAlEihIAAowIKEAAIAAIwg"],
			[32.55,73.05, "#B545E4","Ak6LQIAA2fIJ1AAIAAWfg"]
		];
		var icon = new zim.Rectangle(200,200);
		zim.loop(data, function (d) {
			var s = new zim.Shape().f(d[2]).p(d[3]);
			s.setTransform(d[0]+20,d[1]+27);
			s.addTo(icon);
		}, true);
		var container = new zim.Container();
		icon.sca(.4).addTo(container)
		container.mouseChildren = false;
		return container;
	}

	this.makeCat = function(height) {
	if (zot(height)) height = 246;
	var data = [
	[16.95,241.15, 0,"black",[1.5,2,1],"AgKAhIAVhB"],
	[58.65,244.378,0,"#A7A7A7",[3,2,1],"AmYAAIMxAB"],
	[105.64,107.14,"#EF7988",0,0,"AAEArQgNAAgjghQgiggAFgIQAFgJBEgCQBEgDAGAGQAHAIgfAkQgfAlgPAAIAAAAg"],
	[104.84,111.34,0,"black",[1,1,1],"AABA2IAPAYQAJAPAJAGQAKAHAMAAQAbAAAXgWQAQgPAVghQAVghAAgcQAAgnglgYQgbgSgxgCIgrACAAJADIgIAzAhphVQgXAVgMAWQgKAQgIAiQgIAkAFAMQALAfAqAOQAmANAcgIQANgEANgQQALgNAGgT"],
	[105.05,111.4,"#757B74",0,0,"AheBrQgvgRgQgeQgPgdAQgkQAZg8AEgFQAXgfA8gGQBVgKA+ATQBRAZgYBEQgVA/gnAZQgUAOgZAKQgJAJgVgbQgUgegCAAQgDAAgWAgQgWAUgZAAQgMAAgNgEg"],
	[86.18,93,"black",0,0,"Aj7g0QiYg0i9AyQA0g3BcgRQBagQBfAaQBkAbBEBBQBNBHASBpQhgiYibg0gAFxiDQAzgdA6AMQA9AMA2A4QgHgBAAACQAAAAgBABQAAAAAAAAQgBAAgBAAQAAAAgBgBQh8gshOAzQhIAvhBCYQALjABzhCg"],
	[78.5,63.23,"#705F6C","black",[1,1,1],"AHAg5IgNmIIBfGpQgOgQgSgMQgjgXgPASgAKeDZQg2g4g9gMQg6gMgzAdQhzBCgLDBQBBiZBIgvQBNgzB9AsQAEACAAgCQAAgCAHABgAqdBuIAAnsIDmHEQgegMgsgBQhXgChFA3gAoEDzQA0g3BdgRQBagQBeAaQBkAbBFBBQBMBIASBpQhfiYibg1QiYg0i+Ayg"],
	[86.28,98.01,"black","black",[1,1,1],"AJSh/QgEADgHgDQgFgBgBAFQgNBXhNA9QhTBEhagZQgGgCgPAFQgUAHgEAAQCNAeBchOQBGg7AWhigApRhnQAFABAIAAQAGABAAAAQBFBsCVA7QCpBDCrgzQACAAAHAJQAEAFAFAJQjAAzitg/Qing9g/iHg"],
	[96.95,97.3,"#0C0436",0,0,"AlZBJQgVgVAAgeQAAgcAVgVQAVgVAeAAQAdAAAVAVQAVAVAAAcQAAAegVAVQgVAVgdAAQgeAAgVgVgAD1AcQgVgVAAgdQAAgdAVgVQAVgVAeAAQAdAAAVAVQAVAVAAAdQAAAdgVAVQgVAVgdAAQgeAAgVgVg"],
	[96.88,97.2,"#EA9424",0,0,"AlpBYQgbgbAAgnQAAglAbgbQAbgbAnAAQAmAAAbAbQAbAbAAAlQAAAngbAbQgbAbgmAAQgnAAgbgbgADnArQgbgbAAgmQAAgmAbgbQAbgbAmAAQAnAAAbAbQAbAbAAAmQAAAmgbAbQgbAbgnAAQgmAAgbgbg"],
	[96.88,97.2,"#AFCE3A",0,0,"AlzBiQgggfAAgtQAAgrAggfQAfggAtAAQAsAAAgAgQAfAfAAArQAAAtgfAfQggAggsAAQgtAAgfgggADcA1QgfgfAAgsQAAgsAfgfQAgggAsAAQAtAAAfAgQAgAfAAAsQAAAsggAfQgfAggtAAQgsAAggggg"],
	[78.5,64.1,0,"black",[1,1,1],"AHAhCIgNmIIBfGpQgOgQgSgMQgjgXgPASgAKeDQQg2g4g9gMQg6gMgzAdQhzBCgLDBQCqAvBlhgQBJhFAGhagAoADiQAlgiBTgOQBYgOBaARQDrAsA0DTQjAAziog/Qihg+hAiIgAqdBlIAAnsIDmHEQgegMgsgBQhXgChFA3g"],
	[86.375,93.9,"#EACE35",0,0,"AltB+Qiig9g/iIQAkghBTgOQBZgPBaARQDrAtA0DRQhWAXhSAAQhkAAhcgjgADxB2QALjABzhBQAzgeA6AMQA9ANA2A4QgGBYhJBGQhEBAhiAAQgxAAg4gQg"],
	[73.45,154.83,"black","black",[2,1,1],"AkjjDIByAMQB/ANBEAFQB/AICXgSIgKFzQj4hflLiNQgDgBAFiag"],
	[79.42,123.62,"#A7A7A7","black",[2,1,1],"AEBpxIgBgBQAYiNAeiQQA8kgAfgMQAggNBLEqQAlCVAfCXIAXARQAbAXAZAcQBQBZAZBnQAZBngUB+QgKA/gPArQgeASgrAWQhYAuhFAXQg8AUh0AWIhoASIAAQzItygCQAvhKA1hoQBqjRAjiXQAri/AOjLIAFimQgegHhTgeQhEgZhgg/IhTg7QgekPgQkUQggonBEgWQBFgWCbEtQAkBGA3B9QAbA9AYA3QASAqAQAmIgjhQIABAAIJmgYIBUACIBQAK"]
	];
	var catIcon = new zim.Container(157.5,246);
	zim.loop(data, function (d) {
	var s = new zim.Shape().f(d[2]).s(d[3]).ss(d[4]?d[4][0]:null, d[4]?d[4][1]:null, d[4]?d[4][2]:null).p(d[5]);
	s.setTransform(d[0],d[1]);
	s.addTo(catIcon);
	}, true);
	var container = new zim.Container();
	catIcon.sca(height/246).addTo(container).mov(0,-.4);
	if (mobile) {
		container.cache();
		container.setBounds(0,0,157.5*catIcon.scale,246*catIcon.scale);
	}
	container.mouseChildren = false;
	return container;
	};
};
zim.extend(zim.Frame, createjs.EventDispatcher, null, "cjsEventDispatcher", false);

zim.Queue = function() {
	// internal usage only by Frame
	this.cjsEventDispatcher_constructor();
	this.type = "Queue";
	this.isLoading = true; // thanks Frank Los for the suggestion.
};
zim.extend(zim.Queue, createjs.EventDispatcher, null, "cjsEventDispatcher");
//-83
	
/*--
Pic = function(file, width, height, noCors, style, group, inherit)

Pic
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Use Pic() to show an image, such as a jpg, png, webp, etc.
There may be a security error when loading images locally for any Canvas app.
Please read https://zimjs.com/tips.html#IMAGES for easy solutions.

Before ZIM version ZIM 00, asset() or F.asset() was used to show images.
These can still be used if desired. The Pic() class just wraps the asset() call.

SEE: https://zimjs.com/zim/assets.html

PRELOADING
It is recommended that you preload images (along with sounds, etc.) using the Frame() assets and path parameters.
Batch loading images is more efficient and the width and height will be available when the Frame() is "ready" or loadAssets() is "complete".
Images can also be loaded on demand with F.loadAssets() at any time - for instance, for a second section of the app.

LAZY-LOADING
If images are not preloaded then Pic() will use automatic loading (lazy-loading).
If width and height are provided, all will go smoothly.
If width and height are not provided, ZIM will store various scaling and positioning commands 
and re-apply the commands once the images are loaded.
This happens for center(), centerReg(), pos(), scaleTo(), outline() and perhaps others.
This extra work is NOT required if assets are preloaded or a width and height are provided.
Some controls like Tile() and Scroller() must have dimensions and will give a warning in the console.
In the past there has been issues with cloning lazy-loaded images before they are loaded, but this should work now.

Pic will give a "ready" and a "complete" event when loaded.
These events are triggered 20 ms after making the object if the object is already preloaded.

NOTE: Pic is a container with a bitmap inside (see bitmap property).
This means that other objects can be added to the Pic object.
This is like the ZIM Shapes (Rectangle, Circle, etc.) which are containers and can have objects added to them.
If doing this, note that the container has its mouseChildren turned off
so when dragging, for instance, the whole pic moves rather than the bitmap inside the pic.
To interact with objects inside, set pic.mouseChildren = true.
Generally, for clarity, avoid adding objects to Shapes or Pics unless you are used to the mouseChildren setting.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// lazy-load an image in the same directory
new Pic("image.png").center();

// NOTE: the above may give a CORS security error locally
// to easily solve this see https://zimjs.com/tips.html#IMAGES 
END EXAMPLE

EXAMPLE
// lazy-load an image in the assets/ directory
new Pic("assets/image.png").center();
END EXAMPLE

EXAMPLE
// lazy-load an image in the assets/ directory using PATH constant 
PATH = "assets/"
new Pic("image.png").center();
END EXAMPLE

EXAMPLE
// preload the image in the Frame along with path parameter
new Frame(FIT, 1024, 768, light, grey, ready, "image.png", "assets/");
function ready() {		
	new Pic("image.png").center(); // adds the preloaded assets/image.png
	
	// the PATH would be set to "assets/" by the Frame path parameter 
	new Pic("sky.png").addTo(); // would lazy-load assets/sky.png 
	
	PATH = "people/";
	new Pic("laura.png").addTo(); // would lazy-load people/laura.png
	new Pic("peter.png").addTo(); // would lazy-load people/peter.png
}
END EXAMPLE

EXAMPLE
// preload all the images above
// the first two will use the path parameter 
// the other two are in a different directory so can use an assets object {} with a different path
const assets = ["image.png", "sky.png", {assets:["laura.png", "peter.png"], path:"people/"}];
const path = "assets/";
new Frame(FIT, 1024, 768, light, grey, ready, assets, path);
function ready() {		
	new Pic("image.png").center(); // adds the preloaded assets/image.png
	new Pic("sky.png").addTo(); // adds the preloaded assets/sky.png 
	new Pic("laura.png").addTo(); // adds the preloaded people/laura.png 
	new Pic("peter.png").addTo(); // adds the preloaded people/peter.png
}

// alternatively the path could have been added to each asset:
assets = ["assets/image.png", "assets/sky.png", "people/laura.png", "people/peter.png"];
// this would be passed into Frame along with no path parameter
// and the assets would then be accessed in the ready event with the path included:
new Pic("asset/image.png").center();
END EXAMPLE

EXAMPLE 
const plates = ["plate1.png", "plate2.png", "plate3.png"];
// lazy-load random plate pictures in a Tile

// below would be broken with a warning in the console
// because the tile does not know the plate dimensions
new Tile(new Pic(plates), 4, 4).center(); 

// below would work because the dimensions of 200, 200 were provided
// however, if the plates are not actually 200,200 then it may look wrong
new Tile(new Pic(plates, 200, 200), 4, 4).center(); 

// below would work because preloading in Frame() or loadAssets() provides real dimensions 
// when the tile is made, the dimensions are known
const load = F.loadAssets(plates);
load.on("complete", ()=>{
	new Tile(new Pic(plates), 4, 4).center(); 
	S.update();
});
END EXAMPLE 

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
file - |ZIM VEE| the String file name of the image including file extension for instance, "pic.png"
	There is a global PATH constant that can be set to add a path to the start of the file name
	for instance setting PATH = "assets/" would then look for "assets/pic.png".
	If a path is provided to Frame() parameter or the loadAssets() then these will automatically set the global PATH constant.
width - (default null) optionally predict the width of the image
 	The width will be ignored and the actual width will be used if the image is preloaded 
	and if lazy-loaded, the width will be replaced with the actual width after the image is loaded.
	So the width is only used to tell something like a Tile(), what size to expect before the image is loaded.
	To change the width of a Pic, use siz() or sca() methods 
	or width, widthOnly, height, heightOnly, scale, scaleX and scaleY properties.
height - (default null) optionally predict the height of the image (see width for similar details)
noCors - (default false) set to true to attempt to bypass CORS (cross origin resource sharing) issues. 
	CORS errors may show up when loading images from other servers that do not have settings saying this is allowed.
	Setting noCors to true will try and load the image with a proxy server https://cors.zimjs.com/ so use sparingly.
	It is better to try and load the images from your own server or get CORS permissions from the server.
	Do not preload the image with this setting - or preload using an asset object with noCORSonImage:true set. 
	The noCors setting will use image() rather than asset()
	All these solutions use https://cors.zimjs.com/https://theurltotheasset.jpg
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
keyOut(color, tolerance, replacement) - remove a certain color in the picture and make it see-through - with a color tolerance between 0-1
	the default color is "#389b26" which is a medium dark green
	the default tolerance is .1 - the higher the tolerance the less sensitive the keying process - so more colors will be removed similar to the provided color
	color and tolerance can be an array of colors and tolerances (or just one tolerance if all are the same)
	replacement (default clear) a color to replace the keyed out color with or an optional array to match the colors array if an array is used
	
ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
	in this case the type is "Pic" but if the Pic is lazy-loaded then 
	it starts as type "AC" (Asset Container) if no dimensions are provided 
	or "ACWD" (Asset Container With Dimensions) until the image is loaded 
	at which point, the type is set to "Pic"
bitmap - reference the the ZIM Bitmap (picture) inside the Pic container
file - the filename used
src - the source with path and filename - available on complete event
image - the HTML image tag - available on complete event
item - the CreateJS data item used for preload - available on complete event

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "complete" and a "ready" event (use either one) when the image is loaded
	if preloaded this is dispatched 20 ms after the Pic is made
	
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+83.03
	zim.Pic = function(file, width, height, noCors, style, group, inherit) {
		var sig = "file, width, height, noCors, style, group, inherit";
		var duo; if (duo = zob(zim.Pic, arguments, sig, this)) return duo;
		z_d("83.03");	
	
		this.group = group;
		var DS = style===false?{}:zim.getStyle("Pic", this.group, inherit);
	
		if (zot(file)) file = DS.file!=null?DS.file:null;
		if (zot(noCors)) noCors = DS.noCors!=null?DS.noCors:false;
		if (zot(file)) {if (zon) zogy("ZIM Pic - needs a file"); return;}
	
		this.zimContainer_constructor(width, height);            	    	
		var that = this;
	
		var originalFile = file;
		file = that.file = zim.Pick.choose(file);      
	
		if (width && height) this.type = "ACWD"; // AssetContainer with Dimensions - does not recall methods
		else this.type = "AC"; // AssetContainer		
	
		var inner = noCors?zim.image(file):zim.asset(file);
		that.mouseChildren = false;
		if (inner.type == "Bitmap" || inner.type == "Image") {
			if (inner.type == "Bitmap") that.bitmap = inner.clone().addTo(that);
			else that.bitmap = inner.getChildAt(0).clone().addTo(that);
			that.id = inner.id;
			that.image = that.bitmap.image;
			that.src = that.bitmap.src;
			that.item = that.bitmap.item;
			that.setBounds(null); // resets size
			that.type = "Pic";    
			setTimeout(function () {
				that.dispatchEvent("ready");
				that.dispatchEvent("complete");
			},20);        
		} else {
			inner.on("complete", function () {
				that.bitmap = inner.getChildAt(0).clone().addTo(that);
				that.id = inner.id;
				that.setBounds(null); // resets size
				that.type = "Pic";
				if (that.commands) {
					for (var i=0; i<that.commands.length; i++) {
						if (that.commands[i][2]) that[that.commands[i][0]].apply(that, that.commands[i][1]);
						else zim[that.commands[i][0]].apply(that, that.commands[i][1]);
					}
				}
				that.image = that.bitmap.image;
				that.src = that.bitmap.src;
				that.item = that.bitmap.item;
				that.commands = null;
				that.dispatchEvent("ready");
				that.dispatchEvent("complete");
				if (that.stage) that.stage.update();
			});    
		}      
		
		that.keyOut = function(color, tolerance, replacement) {			
			if (that.type=="AC"&&WW.zdf) {WW.zdf.ac("keyOut", arguments, that); return that;}
			if (that.bitmap) that.bitmap.keyOut(color, tolerance, replacement);
			if (that.stage) that.stage.update();
            return that;
        }    
	
		if (style!==false) zim.styleTransforms(this, DS);
		that.clone = function (exact) {
			return this.cloneProps(new zim.Pic(exact?file:originalFile, width, height, noCors, style, this.group, inherit));
		}        
	}
	zim.extend(zim.Pic, zim.Container, ["clone"], "zimContainer", false);//-83.03

/*--
Aud = function(file, volume, loop, loopCount, pan, offset, delay, interrupt, maxNum, style, group, inherit)

Aud
zim class - extends a createjs.EventDispatcher

DESCRIPTION
Use Aud() to play a sound with its play() method. 
The app must be interacted with before a sound can be played. 
There may be a security error when loading sounds locally for any Canvas app.
Please read https://zimjs.com/tips.html#SOUND for easy solutions.

Multiple instances of a sound can be played from the same Aud() object.
When a sound is played it returns an object that can be used to change that specific instance.
Use that object to change the volume, pan, to find out if the sound has looped or is complete
or to pause() or stop() the sound.

Before ZIM version ZIM 00, asset() or F.asset() was used to play sounds.
These can still be used if desired. The Aud() class just wraps the asset() call.

SEE: https://zimjs.com/zim/assets.html

PRELOADING
It is recommended that you preload sounds (along with images, etc.) using the Frame() assets and path parameters.
After the frame loads, sounds can also be loaded on demand with F.loadAssets().
Batch loading sounds is more efficient and the sound will be ready when the Frame() is "ready" or loadAssets() is "complete".

LAZY-LOADING
If sounds are not preloaded then Aud() will use automatic loading (lazy-loading).

Aud will give a "ready" event when loaded.
This event is triggered 20 ms after making the object if the object is already preloaded.
The "complete" event is used for when the sound is finished playing (not finished loading).

AUDIOSPRITE 
An AudioSprite can alternatively be used which has many sounds in one sound file. 
There is data that goes with the AudioSprite to match a label to a time and duration.
See the Frame docs under loadAssets() method although they can be loaded in the Frame as well.
See also parseAudioSprite() and previewAudioSprite() functions in META section of Docs.

NOTE: The sound can be made at any time but the app must be interacted with before the sound can be played.
This is a general Browser rule to stop being bombarded with sounds.
It means that you will have to make a start button or a splash page
that the user clicks or taps before a background sound can be played.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE 
// There may be a security error when loading sounds locally for any Canvas app.
// Please read https://zimjs.com/tips.html#SOUND for easy solutions.

const click = new Aud("click.mp3");  // lazy-load a click sound
S.on("stagemousedown", ()=>{
	click.play(); // plays everytime the stage is clicked (sigh)
});
END EXAMPLE 

EXAMPLE 
// make a backing sound but do not play it
// the user must first interact at least once with a mousedown/click/tap/change
const backing = new Aud({file:"backing.mp3", loop:true}); 

let backingSound; // this will store the sound that is playing
// make a Toggle button that starts toggled off
new Toggle({label:"SOUND"})
	.sca(.7)
	.pos(30,30,LEFT,BOTTOM)
	.change(e=>{ 
		// play the sound if it has not played 
		// and toggle the instance's paused property if it has been played
		if (!backingSound) backingSound = backing.play();
		else backingSound.paused = !e.target.toggled;
	});	
END EXAMPLE

EXAMPLE
// preload a couple sounds from an assets/ directory (path)
new Frame(FIT, 1024, 768, light, dark, ready, ["sound.mp3", "backing.mp3"], "assets/");
function ready() {

	// show a Pane() to start so we know user has interacted before we play sounds 
	
	new Pane("START GAME", yellow).show(init); // this calls init when closed
	
	function init() {
		// now the user has interacted to close the pane		
		new Aud("backing.mp3", .3, true).play(); // volume of .3 and looping
		
		// Make sounds only play once and start over when pressed again
		// otherwise, the default is play the sound completely each press. 
		// If someone presses a lot - this is a lot of sounds playing at once.
		// If we left the interrupt at "none" the sound would finish before playing again 
		// which is not optimal as we want the sound to start each time we press.
		// We could add these to the Aud() parameters but here we use STYLE
		STYLE = {maxNum:1, interrupt:"any"}
		const sound = new Aud("sound.mp3");
		new Circle().center().tap(()=>{
			sound.play();
		});	
	} // end init()	
	
} // end frame ready
END EXAMPLE

EXAMPLE
// lazy-load a sound from a PATH of "assets/"
PATH = "assets/"
const long = new Aud("long.mp3");

// press on the stage - note the true for once at end of event
S.on("stagemousedown", ()=>{

	const sound = long.play({volume:.2});

	// adjust the sound after...
	timeout(2, ()=>{
		sound.volume = 1;
	});
	timeout(4, ()=>{
		sound.paused = true;
	});
	timeout(6, ()=>{
		sound.paused = false;
	});
	sound.on("complete", ()=>{
		F.color = red;
		// lazy-load a woot sound from path of assets/ and play twice
		new Aud("woot.wav").play({loopCount:2});
		S.update();
	});	

}, null, true); // true for once then remove the event
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
file - |ZIM VEE| the String file name of the sound including file extension for instance, "sound.mp3"
	There is a global PATH constant that can be set to add a path to the start of the file name
	for instance setting PATH = "assets/" would then look for "assets/sound.mp3".
	If a path is provided to Frame() parameter or the loadAssets() then these will automatically set the global PATH constant.
	For an audioSprite use the label here.
** ALL THE PARAMETERS below can also be specified in the play() method (except for maxNum)
volume (default 1) - set the volume
loop (default false) - set to true to loop forever or a number based on loopCount
loopCount (default null) - change to how many times to play the sound
	there is no need to set loop if loopCount is set
pan (default 0) - set towards -1 to pan left and towards 1 to pan right
	may not work locally but should work on server
offset (default 0) - elapsed time in seconds to start playing
delay (default 0) - time to wait before sound is started
interrupt (default "none") - how to interrupt a sound if a sound with the same source is played
	and the maximum number of instances of the sound are already playing
	** must have maxNum set - see the maxNum property or the Frame(), loadAssets() or asset() maxNum parameter
	"none" - do not interrupt the previously playing sound(s) (with the same source)
	"any" - interrupt the previously playing sound(s) (with the same source)
	"early" - interrupt only the previously playing sound that has progressed the least
	"late" - interrupt only the previously playing sound that has progressed the most
	** thank you CreateJS and SoundJS for providing these options
maxNum (default null) ONLY FOR LAZY LOAD - otherwise use maxNum in Frame() or F.loadAssets()
	set to a number of instances that a sound can play.
	The default is as many as the browser can handle (hundreds).
	maxNum can also be set as Frame(), loadAssets() and asset() parameters.
	Setting this to 1 will only play one instance of the sound at a time.
	The interrupt setting determines what happens if the sound is played again while it is playing 
	if "none" is set (default) then it will not interrupt the current instance 
	if "any" is set then it will play the sound again from the start, etc.
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly
	
METHODS
play(volume, loop, loopCount, pan, offset, delay, interrupt) - play the sound
	*** Supports ZIM DUO - regular parameters or single configuration object {}
	*** returns a CreateJS AbstractSoundInstance (of course). Detailed docs are here:
	*** https://www.createjs.com/docs/soundjs/classes/AbstractSoundInstance.html
	*** See the methods and properties listed after the play parameters
	volume (default 1) - set the volume
	loop (default false) - set to true to loop forever or a number based on loopCount
	loopCount (default null) - change to how many times to play the sound
		there is no need to set loop if loopCount is set
	pan (default 0) - set towards -1 to pan left and towards 1 to pan right
		may not work locally but should work on server
	offset (default 0) - elapsed time in seconds to start playing
	delay (default 0) - time to wait before sound is started
	interrupt (default "none") - how to interrupt a sound if a sound with the same source is played
	 	and the maximum number of instances of the sound are already playing
		** must have maxNum set when sound is loaded - see the Aud(), Frame(), loadAssets() or asset() maxNum parameter
		"none" - do not interrupt the previously playing sound(s) (with the same source)
		"any" - interrupt the previously playing sound(s) (with the same source)
		"early" - interrupt only the previously playing sound that has progressed the least
		"late" - interrupt only the previously playing sound that has progressed the most
		** thank you CreateJS and SoundJS for providing these options
	
ABSTRACT SOUND INSTANCE
The return result of the play() makes a CreateJS AbstractSoundInstance
var sound = Aud("sound.mp3").play(); // sound is an AbstractSoundInstance
// note: if lazy-loaded then the result of a play() before the sound has loaded 
// will be a proxy object with only volume and pan properties and will dispatch a complete event
// methods, other properties and events will only be available on a play() after the sound is loaded

METHODS (of AbstractSoundInstance)
** full docs here: https://www.createjs.com/docs/soundjs/classes/AbstractSoundInstance.html
** these methods are on the results of a new Aud().play() not on the new Aud()
	const sound = new Aud();
	const soundInstance = sound.play();
	timeout(2, ()=>{soundInstance.stop()});
stop() - stops the sound and sets the time to 0
play() - plays the sound again - usually, the sound is already playing from the sound.play()
 	but if it is stopped - this will start it again
fade(volume, time, call) - fade in or out a playing sound in a time and call the call function when done  
panSound(pan, time, call) - pan left (-1) or right (1) or in between a playing sound in a time and call the call function when done  
	
PROPERTIES 
type - holds the class name as a String
	in this case the type is "Aud" but if the Aud is lazy-loaded then 
	it starts as type "AC" (Asset Container) and then when loaded becomes "Aud"
file - the filename used
src - the src used - path and file - available on complete event
item - the CreateJS data item used for preload - available on complete event

PROPERTIES (of AbstractSoundInstance)
** full docs here: https://www.createjs.com/docs/soundjs/classes/AbstractSoundInstance.html
** these properties are on the results of a new Aud().play() not on the new Aud()
	const sound = new Aud();
	const soundInstance = sound.play();
	timeout(2, ()=>{soundInstance.volume = .5});
paused - set to true to pause and false to unpause
muted - set to true to mute - but sound keeps playing or false to unmute
volume - the volume with 1 being the default
pan - set from -1 (full left) to 1 (full right) with 0 in middle (may not work until on server)
position - set to place in sound in milliseconds (ZIM TIME constant does not affect this)
duration - the length of the sound in milliseconds

EVENTS
dispatches a "ready" or "complete" event when the sound is loaded
	if preloaded this is dispatched 20 ms after the Aud is made
	Note: the AbstractSoundInstance below also dispatches a "complete" event when the sound is finished playing
	
EVENTS (of AbstractSoundInstance)
** full docs here: https://www.createjs.com/docs/soundjs/classes/AbstractSoundInstance.html
complete - dispatched when the sound has reached the end - after any loops (not before)
loop - dispatched when the sound loops (but not at end of last loop - that is complete)
	currently triggering at the first play too.
--*///+83.05
	zim.Aud = function(file, volume, loop, loopCount, pan, offset, delay, interrupt, maxNum, style, group, inherit) {    
		var sig = "file, volume, loop, loopCount, pan, offset, delay, interrupt, maxNum, style, group, inherit";
		var duo; if (duo = zob(zim.Aud, arguments, sig, this)) return duo;
		z_d("83.05");
        
        this.cjsEventDispatcher_constructor();
        this.type = "Aud";
        this.group = group;
		var DS = style===false?{}:zim.getStyle(this.type, this.group, inherit);
		        
		if (zot(file)) file = DS.file!=null?DS.file:null;	
		if (zot(file)) {if (zon) zogy("ZIM Sound - needs a file"); return;}
		if (zot(volume)) volume = DS.volume!=null?DS.volume:1;	
		if (zot(loop)) loop = DS.loop!=null?DS.loop:false;	
		if (zot(loopCount)) loopCount = DS.loopCount!=null?DS.loopCount:null;	
		if (zot(pan)) pan = DS.pan!=null?DS.pan:0;	
		if (zot(offset)) offset = DS.offset!=null?DS.offset:0;	
		if (zot(delay)) delay = DS.delay!=null?DS.delay:0;	
		if (zot(interrupt)) interrupt = DS.interrupt!=null?DS.interrupt:"none";	
		if (zot(maxNum)) maxNum = DS.maxNum!=null?DS.maxNum:null;	

		var that = this;

		file = that.file = zim.Pick.choose(file);   
        
        var sound = that.sound = zim.asset(file, null, null, maxNum);
        if (sound.type == "AC") {	
            sound.on("complete", function () {
				that.src = sound.src;
				that.item = sound.item;
				that.dispatchEvent("ready");  
                that.dispatchEvent("complete");  
            })
        } else {
            setTimeout(function () {
				that.src = sound.src;
				that.item = sound.item;
				that.dispatchEvent("ready");
				that.dispatchEvent("complete");
            },20);  
        }
				
        that.volume = volume;
        that.loop = loop;
        that.loopCount = loopCount;
        that.pan = pan;
		that.offset = offset;
        that.delay = delay;
        that.interrupt = interrupt;
        that.maxNum = maxNum;
        
        that.play = function(volume, loop, loopCount, pan, offset, delay, interrupt) {
			var sig = "volume, loop, loopCount, pan, offset, delay, interrupt";
			var duo; if (duo = zob(that.play, arguments, sig)) return duo;
			if (zot(volume)) volume = that.volume;
			if (zot(loop)) loop = that.loop;
			if (zot(loopCount)) loopCount = that.loopCount;
			if (zot(pan)) pan = that.pan;
			if (zot(offset)) offset = that.offset;
			if (zot(delay)) delay = that.delay;
			if (zot(interrupt)) interrupt = that.interrupt;

            that.soundInstance = that.sound.play(volume, loop, loopCount, pan, offset, delay, interrupt);                      
            that.soundInstance.fade = function(val, time, call) {
                var ob;
                if (that.soundInstance.animator) ob = that.soundInstance.animator;
                else ob = that.soundInstance.animator = new zim.Container(); 
                if (zot(val)) val = 0;
                var timeType = getTIME(time);
                if (zot(time)) time = timeType=="s"?2:2000;
                ob.volume = that.soundInstance.volume;
                zim.animate({
                    target:ob, 
                    props:{volume:val}, 
                    time:time,
                    override:true,
                    animateCall:function() {that.soundInstance.volume = ob.volume}, 
                    call:call
                });
                return that.sound;
            }
            that.soundInstance.panSound = function(val, time, call) {
                var ob;
                if (that.soundInstance.animator) ob = that.soundInstance.animator;
                else ob = that.soundInstance.animator = new zim.Container(); 
                if (zot(val)) val = 0;
                var timeType = getTIME(time);
                if (zot(time)) time = timeType=="s"?2:2000;
                ob.pan = that.soundInstance.pan;
                zim.animate({
                    target:ob, 
                    props:{pan:val}, 
                    time:time,
                    override:true,
                    animateCall:function() {that.soundInstance.pan = ob.pan}, 
                    call:call
                });
                return that.sound;
            }
			return that.soundInstance;
        }
        
        that.dispose = function() {
            if (that.sound) {
                if (that.soundInstance && that.soundInstance.animator) {
                    that.soundInstance.animator.dispose();
                    that.soundInstance.animator = null;
                }
                that.sound.dispose();
            }
            that.sound = null;
            return true;
        }
        
    }
    zim.extend(zim.Aud, createjs.EventDispatcher, null, "cjsEventDispatcher");//-83.05

/*--
Vid = function(file, width, height, volume, loop, align, valign, type, style, group, inherit)

Vid
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Use Vid() to show a video. Use the play() method to start the video when loaded.
The user must interact with the app before play() will work.
There may be a security error when loading video locally for any Canvas app.
Please read https://zimjs.com/tips.html#VIDEO for easy solutions.

Vid will add an HTML 5 video and source tag in behind the scene 
and pipe the video into a ZIM Bitmap which is shown in the Vid container.
Vid lets you pause() and play() and get the duration 
or get and set the currentTime and volume.

A source property stores the HTML 5 video for more methods, properties and events.
https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video

Vid also has a keyOut() method to key out a color from the video.

SEE: https://zimjs.com/zim/assets.html

Vid will give a "ready" and a "complete" event when ready to play.

NOTE: Vid is a container with a bitmap inside (see bitmap property).
This means that other objects can be added to the Vid object.
This is like the ZIM Shapes (Rectangle, Circle, etc.) which are containers and can have objects added to them.
If doing this, note that the container has its mouseChildren turned off
so when dragging, for instance, the whole vid moves rather than the bitmap inside the vid.
To interact with objects inside, set vid.mouseChildren = true.
Generally, for clarity, avoid adding objects to Shapes or Vids unless you are used to the mouseChildren setting.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE 
// video is a container that will have a width of 800 and height of 600 
// The video will be FIT inside these dimensions and centered by default 
// Also see align and valign parameters
// At the start, it will have a type of "AC" once it loads it will be "Vid" 
const video = new Vid("video.mp4", 800, 600) 
	.center() // using 800x600
S.on("stagemousedown", () => {
	video.play();
});
END EXAMPLE

EXAMPLE
// video is a container that will have a width of 800 and height of 600 
// The video will be stretched to 800 by 600 - possibly changing the aspect ratio 
const video = new Vid("video.mp4", 800, 600, FULL) 
	.center() // using 800x600
S.on("stagemousedown", () => {
	video.play();
});
END EXAMPLE

EXAMPLE
// video is a container with no width and height to start
// once the video is loaded the container will take the dimensions of the video 
// and the center() will be called again to properly center the container
// just like lazy loading Pic().
const video = new Vid("video.mp4") 
	.center() // will automatically be re-centered after loading
S.on("stagemousedown", () => {
	video.play();
});
END EXAMPLE

EXAMPLE
// make the video cover the stage
const video = new Vid("video.mp4", W, H, FILL) 
	.center() 
S.on("stagemousedown", () => {
	video.play();
});
END EXAMPLE

EXAMPLE
// load a video from the assets/ folder
PATH = "assets/"    

// either provide width and height before scaleTo() or use the ready event
const video = new Vid("video.mp4", W, H).center();

video.on("ready", ()=>{   
	// video.keyOut("#01b03f", .2);  // optional keyOut a green color    
	// do not play the video until we interact with the app    
	const pane = new Pane("VIDEO ON CANVAS!").show(()=>{
		// this (the callback) runs when the pane is closed 
		video.play();
	});
});    

// toggle the pause of the video
video.on("mousedown", ()=>{ 
	// note videoPaused property
	// not paused (which is for animation)
	video.pause(!video.videoPaused);        
});
END EXAMPLE 

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
file - |ZIM VEE| the String file name of the image including file extension for instance, "pic.png"
	There is a global PATH constant that can be set to add a path to the start of the file name
	for instance setting PATH = "assets/" would then look for "assets/pic.png".
	If a path is provided to Frame() parameter or the loadAssets() then these will automatically set the global PATH constant.
width - (default null) optionally predict the width of the video for placement before being loaded
 	The width will be ignored once the video is loaded.
	To change the width of Vid, use siz() or sca() methods 
	or width, widthOnly, height, heightOnly, scale, scaleX and scaleY properties.
height - (default null) optionally predict the height of the Vid (see width for similar details)
scaling - (defaut FIT) how to scale video into dimensions if provided - otherwise
	FIT  - scales video to fit inside width and height keeping aspect ratio - also see align and valign
	FILL - scales video to surround width and height keeping aspect ratio - also see align and valign
	FULL - scales video width to width and video height to height possibly stretching aspect ratio
volume - (default 1) the volume of the video - also see the volume property
loop - (default false) set to true to loop the video
align - (default CENTER) for FIT and FILL, the horizontal alignment LEFT, CENTER, RIGHT
valign - (default CENTER) for FIT and FILL, the vertical alignment TOP, CENTER, BOTTOM
type - (default "video/mp4") the mime type or codec of the video
	see https://developer.mozilla.org/en-US/docs/Web/Media/Formats/codecs_parameter
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
play() - play the video
pause(state) - pause the video if the state is true (default) or play again if state is false
keyOut(color, tolerance, replacement) - remove a certain color in the video and make it see-through - with a color tolerance between 0-1
	the default color is "#389b26" which is a medium dark green
	the default tolerance is .1 - the higher the tolerance the less sensitive the keying process - so more colors will be removed similar to the provided color
	color and tolerance can be an array of colors and tolerances (or just one tolerance if all are the same)
	replacement (default clear) a color to replace the keyed out color with or an optional array to match the colors array if an array is used
clone(exact) - clone the object - if using ZIM VEE values for file, use exact true to copy the picked ZIM VEE option.
dispose() - dispose the video including HTML tags, etc.

ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String 
	in this case the type is "Vid" but if no dimensions are provided
	it starts as type "AC" (Asset Container)
	and when the video is ready to play (see "complete" or "ready" event), the type is set to "Vid"
file - the filename used
duration - get the duration of the video in seconds
currentTime - get or set the current time in seconds 
volume - get or set the volume of the video
videoPaused - get if the video is paused
bitmap - reference to the the ZIM Bitmap inside the container
source - reference to the HTML video tag with all sorts of methods, properties and events
 	use this for the fastSeek() method if currentTime property is too slow
	see: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the "ended" event on the HTML video tag (source)
dispatches a "complete" and a "ready" event (use either one) when the image is loaded.
	if preloaded this is dispatched 20 ms after the Vid is made.
Also see HTML video events: https://developer.mozilla.org/en-US/docs/Web/HTML/Element/video#events
which has an "ended" event on the source property... 
so use myVideo.source.addEventListener("ended", ()=>{});
	
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+83.07
	zim.Vid = function(file, width, height, scaling, volume, loop, align, valign, type, style, group, inherit) {        
		var sig = "file, width, height, scaling, volume, loop, align, valign, type, style, group, inherit";
		var duo; if (duo = zob(zim.Vid, arguments, sig, this)) return duo;
		z_d("83.07");	

		this.group = group;
		var DS = style===false?{}:zim.getStyle("Vid", this.group, inherit);

		if (zot(file)) file = DS.file!=null?DS.file:null;
		if (zot(file)) {if (zon) zogy("ZIM Vid - needs a file"); return;}
		if (zot(width)) width = DS.width!=null?DS.width:null;
		if (zot(height)) height = DS.height!=null?DS.height:null;
		if (zot(scaling)) scaling = "fit";
		if (zot(loop)) loop = DS.loop!=null?DS.loop:false;
		if (zot(volume)) volume = DS.volume!=null?DS.volume:1;
		if (zot(align)) align = DS.align!=null?DS.align:"center";
		if (zot(valign)) valign = DS.valign!=null?DS.valign:"center";
		if (zot(type)) type = DS.type!=null?DS.type:"video/mp4";

		this.zimContainer_constructor(width, height);
		
		if (width && height) this.type = "ACWD"; // AssetContainer with Dimensions - does not recall methods
		else this.type = "AC"; // AssetContainer		

		var that = this;	
		var bitmap;

		var originalFile = file;
		file = zim.Pick.choose(file);
		that.file = file;

		if (WW.PATH!=null) zim.PATH = WW.PATH;
		var added = "";
		if (file.split("/").length==1 && zim.PATH) added = zim.PATH;
		this.mouseChildren = false;

		// make tag in HTML  
		var source = that.source = document.createElement("video");
		document.body.appendChild(source);
		source.style.display = "none";
		source.setAttribute("autoplay", "autoplay");
		source.setAttribute("playsinline", "playsinline");
		source.setAttribute("crossorigin", "anonymous");
		if (loop) source.setAttribute("loop", "loop");
		var innerSource = that.innerSource = document.createElement("source");
		if (file.split("?").length==1) file += "?playsinline=1";
		innerSource.setAttribute("src", added + file);
		innerSource.setAttribute("type", type);		
		source.appendChild(innerSource);

		getVideo();
		var count = 0;
		function getVideo() {
			if (count++ > 5) {that.dispatchEvent("error");}            
			source.addEventListener("stalled", getVideo);
			source.addEventListener("error", getVideo);
			source.addEventListener("canplay", init);
		}        
		function init() {   
			that.type = "Vid";             
			source.removeEventListener("stalled", getVideo);
			source.removeEventListener("error", getVideo);
			source.removeEventListener("canplay", init);    
			source.pause();     
			var w = source.videoWidth; 
			var h = source.videoHeight; 
			that.setBounds(0,0,width||w,height||h); 
            bitmap = that.bitmap = new zim.Bitmap(source, w, h).addTo(that);
			bitmap.setBounds(0,0,w,h);
			bitmap.scaleTo(that, 100, 100, scaling).pos(0,0,align,valign,that);
			
			if (that.commands) {
				for (var i=0; i<that.commands.length; i++) {
					if (that.commands[i][2]) that[that.commands[i][0]].apply(that, that.commands[i][1]);
					else zim[that.commands[i][0]].apply(that, that.commands[i][1]);
				}
			}
			that.commands = null;
			
            that.dispatchEvent("ready");     
        }
        that.videoPaused = true;
        that.play = function() {
			if (!bitmap) {if (zon) {zogy("ZIM Vid - no file found")}; return};
            source.play();
            source.volume = volume;
            that.videoPaused = false;
            if (!that.ticker) {
                if (that.keyObj) {
                    var color = that.keyObj.color;
					var tolerance = that.keyObj.tolerance;
                    var replacement = that.keyObj.replacement;
                    that.ticker = zim.Ticker.add(function(){
                        bitmap.keyOut(color, tolerance, replacement);
                    });
                } else {
                    that.ticker = zim.Ticker.add(function(){});
                }
            }         
            return that;   
        }
        that.keyOut = function(color, tolerance, replacement) {
            if (that.ticker) {
                zim.Ticker.remove(that.ticker);
                that.ticker = zim.Ticker.add(function () {
                    bitmap.keyOut(color, tolerance, replacement);
                });         
            } else {
                that.keyObj = {color:color, tolerance:tolerance, replacement:replacement};
            }   
            return that;
        }
        that.pause = function(state) {            
            if (zot(state)) state = true;         
            that.videoPaused = state;
            if (state) {
				source.pause();
				if (that.ticker) zim.Ticker.remove(that.ticker);
			} else {
				if (that.ticker) zim.Ticker.add(that.ticker);
				source.play();
			}
            return that;
        }        
        Object.defineProperty(this, 'duration', {
            get: function() {
                return source.duration;
            },
            set: function() {                
            }
        });
        Object.defineProperty(this, 'currentTime', {
            get: function() {
                return source.currentTime;
            },
            set: function(value) {
                source.currentTime = value;
            }
        });
        Object.defineProperty(this, 'volume', {
            get: function() {
                return source.volume;
            },
            set: function(value) {
                volume = value;
                source.volume = value;
            }
        });
        if (style!==false) zim.styleTransforms(this, DS);
        that.clone = function (exact) {
            return this.cloneProps(new zim.Vid(exact?file:originalFile, width, height, scaling, volume, loop, align, valign, type, style, this.group, inherit));
        }
        that.dispose = function (a,b,disposing) {
            if (this.ticker) zim.Ticker.remove(this.ticker);
			var st = that.stage;
			that.bitmap.dispose();
			bitmap = that.bitmap = null;
			source.pause();
			source.removeAttribute('src');
			source.load();
			source.remove();
			source = null;            
			if (!disposing) this.zimContainer_dispose(true);
			if (st) st.update();
			return true;
        }        
    }
    zim.extend(zim.Vid, zim.Container, ["clone", "dispose"], "zimContainer", false);//-83.07

/*--
SVG = function(svg, width, height, bitmap, splitTypes, geometric, showControls, interactive, style, group, inherit)

SVG
zim class - extends a zim.Container which extends a createjs.Container

DESCRIPTION
Use SVG() to show an SVG tag or file on the Canvas.
There are two options, the default is as a Bitmap
or choose an SVGContainer with Blob, Squiggle, and transformable shapes.

Before ZIM version ZIM 00, svgToBitmap() or SVGContainer() was used to show SVGs.
These can still be used if desired. The SVG() class just wraps these.

SEE: https://zimjs.com/zim/assets.html

NOTE: ZIM has Squiggle() and Blob() which often can replace the need for SVG() and has many more benefits.
These can be made with ZIM Pizzazz 4 at https://zimjs.com/paths 
Or an SVG path can be passed directly to the points parameter of a Blob or Squiggle.
Squiggles and Blobs let the user:
	turn the paths editable
	animate objects on the path 
	add Beads to the path 
	animate the path 
	shape animate the path to another path 
	do hitTestPath on the path
We recommend using SVG only when there is already an SVG that image you want to use.

PRELOADING
It is recommended that you preload SVG files using the Frame() assets and path parameters.
After the frame loads, SVG files can also be loaded on demand with F.loadAssets().
Batch loading SVGs is more efficient and the width and height will be available when the Frame() is "ready" or loadAssets() is "complete".

LAZY-LOADING
If SVGs are not preloaded then SVG() will use automatic loading (lazy-loading).
If width and height are provided, all will go smoothly.
If width and height are not provided, ZIM will store various scaling and positioning commands 
and re-apply the commands once the images are loaded.
This happens for center(), centerReg(), pos(), scaleTo(), outline() and perhaps others.
This extra work is NOT required if assets are preloaded or a width and height are provided.
Some controls like Tile() and Scroller() must have dimensions and will give a warning in the console.
In the past there has been issues with cloning lazy-loaded objects before they are loaded, but this should work now.

SVG will give a "ready" and a "complete" event when loaded.
These events are triggered 20 ms after making the object if the object is already preloaded.

NOTE: SVG is a container with a bitmap inside (see bitmap property)
or if the bitmap option is not selected there are other shapes inside.
This means that other objects can be added to the SVG object.
This is like the ZIM Shapes (Rectangle, Circle, etc.) which are containers and can have objects added to them.
If doing this, note that the container has its mouseChildren may be turned off
so when dragging, for instance, the whole SVG moves rather than the bitmap inside the SVG.
To interact with objects inside, set pic.mouseChildren = true.
Generally, for clarity, avoid adding objects to Shapes, Pics SVGs unless you are used to the mouseChildren setting.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// lazy-load an SVG 
new SVG("file.svg").center().drag();
END EXAMPLE 

EXAMPLE 
// assuming there is an SVG tag on the page - could be display:none
new SVG(zid("svgTagID")).center().drag();
END EXAMPLE

EXAMPLE
// Find the SVG in an assets/ folder
PATH = "assets/"
// Tile a lazy-loaded SVG with dimensions - otherwise Tile would give a console warning
new Tile(new SVG("file.svg", 100, 100), 4, 4)).center();

// but the dimensions might not be right and the tile could look odd once the SVGs are loaded 
// would be better to preload - see next example
END EXAMPLE 

EXAMPLE
// pre-load and Tile an SVG
new Frame(FIT, 1024, 768, light, grey, ready, "file.svg", "assets/");
function ready() {
	new Tile(new SVG("file.svg"), 4, 4)).center();
}
END EXAMPLE

EXAMPLE 
// add an SVGContainer from an SVG string
// this would make a simple Squiggle line with editable points
// see the Docs under SVGContainer for more complex examples and added information
// note the h t t p : should be edited to not have spaces - just avoiding Doc auto linking
const svg = `<svg  width="150" height="200" xmlns="h t t p ://www.w3.org/2000/svg">
<path id="lineAB" d="M 0 0 l 150 200" stroke="red" stroke-width="3" fill="none" />
</svg>`;
new SVG(svg, null, null, false).center(); 
END EXAMPLE 

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
** supports OCT - parameter defaults can be set with STYLE control (like CSS)
svg - |ZIM VEE| the String file name of the SVG including file extension for instance, "pic.svg"
	or an SVG tag either directly as a string or as a reference to an HTML tag - ie. zid("svgID")
	There is a global PATH constant that can be set to add a path to the start of the file name
	for instance setting PATH = "assets/" would then look for "assets/pic.svg".
	If a path is provided to Frame() parameter or the loadAssets() then these will automatically set the global PATH constant.
width - (default null) optionally predict the width of the SVG
 	The width will be ignored and the actual width will be used if the SVG is preloaded 
	and if lazy-loaded, the width will be replaced with the actual width after the SVG is loaded.
	So the width is only used to tell something like a Tile(), what size to expect before the SVG is loaded.
	To change the width of an SVG, use siz() or sca() methods 
	or width, widthOnly, height, heightOnly, scale, scaleX and scaleY properties.
height - (default null) optionally predict the height of the SVG (see width for similar details)
bitmap - (default true) this will show the SVG as a Bitmap (still nicely scalable!)
	or set to false to use an SVGContainer() which converts the SVG to Blob, Squiggle and ZIM Shapes with transforms.
	This allows for editable paths - but perhaps not all aspects of SVGs are supported such as CSS styles on SVGs.
	Alternatively, a single SVG path can be passed to a ZIM Blob() or Squiggle() and SVG() can be avoided.
** these parameters are NOT for the bitmap option but rather for the SVGContainer
splitTypes - (default false) - set to true to split different types of paths into separate objects
geometric - (default true) - set to false to load Rectangle and Circle objects as Blob objects
showControls - (default true) set to false to start with controls not showing
interactive - (default true) set to false to turn off controls, move, toggle, select, edit - leaving just the shapes
style - (default true) set to false to ignore styles set with the STYLE - will receive original parameter defaults
group - (default null) set to String (or comma delimited String) so STYLE can set default styles to the group(s) (like a CSS class)
inherit - (default null) used internally but can receive an {} of styles directly

METHODS
keyOut(color, tolerance, replacement) - for Bitmap setting - remove a certain color in the SVG and make it see-through - with a color tolerance between 0-1
	the default color is "#389b26" which is a medium dark green
	the default tolerance is .1 - the higher the tolerance the less sensitive the keying process - so more colors will be removed similar to the provided color
	color and tolerance can be an array of colors and tolerances (or just one tolerance if all are the same)
	replacement (default clear) a color to replace the keyed out color with or an optional array to match the colors array if an array is used
	
ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - holds the class name as a String
	in this case the type is "SVG" but if the SVG is lazy-loaded then 
	it starts as type "AC" (Asset Container) if no dimensions are provided 
	or "ACWD" (Asset Container With Dimensions) until the SVG is loaded 
	at which point, the type is set to "SVG"
bitmap - reference the the ZIM Bitmap inside the container.
	this exists for both the bitmap setting and the SVGContainer setting 
	but with the SVGContainer setting, the bitmap is not added to the container
svg - reference to the SVG code 
file - the filename used
src - the source with path and filename - available on complete event
item - the CreateJS data item used for preload - available on complete event

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "complete" and a "ready" event (use either one) when the SVG is loaded.
	if preloaded this is dispatched 20 ms after the SVG is made.
	
See the CreateJS Easel Docs for Container events such as:
added, click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+83.09
	zim.SVG = function(svg, width, height, bitmap, splitTypes, geometric, showControls, interactive, style, group, inherit) {
		var sig = "svg, width, height, bitmap, splitTypes, geometric, showControls, interactive, style, group, inherit";
		var duo; if (duo = zob(zim.SVG, arguments, sig, this)) return duo;
		z_d("83.09");	

		this.group = group;
		var DS = style===false?{}:zim.getStyle("SVG", this.group, inherit);
        	
		if (zot(svg)) svg = DS.svg!=null?DS.svg:null;
		if (zot(svg)) {if (zon) zogy("ZIM SVG - needs a svg value"); return;}
		if (zot(bitmap)) bitmap = DS.bitmap!=null?DS.bitmap:true;
		if (zot(splitTypes)) splitTypes = DS.splitTypes!=null?DS.splitTypes:false;
		if (zot(geometric)) geometric = DS.geometric!=null?DS.geometric:true;
		if (zot(showControls)) showControls = DS.showControls!=null?DS.showControls:true;
		if (zot(interactive)) interactive = DS.interactive!=null?DS.interactive:true;

		this.zimContainer_constructor(width, height);            	    	
		var that = this;
		
		if (bitmap) this.mouseChildren = false;

		var originalSVG = svg;
		svg = zim.Pick.choose(svg);   
                    
        if (width && height) this.type = "ACWD"; // AssetContainer with Dimensions - does not recall methods
        else this.type = "AC"; // AssetContainer		
        
		
        var a = zim.assets[svg];
		if (a) {
	        that.src = a.src;
			that.file = a.file;
			that.item = a.item;
			that.svg = a.svg;    
		}		
        if (a && a.type=="Bitmap") {			
            that.type = "SVG";
            that.bitmap = a.clone();
            getSVG();
        } else if (a && a.type=="AC") {
            a.on("complete", function(){
                that.type = "SVG";
                that.bitmap = a.bitmap.clone();
                getSVG(zot(width) && zot(height));
            });
        } else if (a && a.type=="ACWB") {       
            if (zot(width) && zot(height)) that.setBounds(0,0,a.width,a.height);
            a.on("complete", function(){
                that.type = "SVG";
                that.bitmap = a.bitmap.clone();
                getSVG();
            });
        } else if (a && a.type=="SVG") {
            that.type = "SVG";
			if (a.bitmap) that.bitmap = a.bitmap.clone();
			else that.bitmap = a.clone();
            getSVG();
        } else {
			if (svg && svg.match(/<svg/i)) that.svg = svg;
            if (that.svg && that.svg.match(/<svg/i)) {
                that.type = "SVG";
                getSVG();
            } else {				
                var svgFile = zim.asset(svg);
                svgFile.on("complete", function () {				
                    that.type = "SVG";
					if (svgFile.bitmap) {
						that.src = svgFile.bitmap.src;
						that.file = svgFile.bitmap.file;
						that.item = svgFile.bitmap.item;
						that.svg = svgFile.bitmap.svg;    
	                    that.bitmap = svgFile.bitmap.clone();
					}
                    getSVG(zot(width) && zot(height));
                });
            } 
        }
        
        function getSVG(second) {
            if (bitmap) { // svgToBitmap
                if (that.bitmap) {
                    that.svg = that.bitmap.svg;
                    that.bitmap.addTo(that);
                    if (second) {
						applyCommands();
						if (that.stage) that.stage.update();	
					}
                    setTimeout(function () {
                        that.dispatchEvent("ready");
                        that.dispatchEvent("complete");  
                    },20);
                } else {          
                    zim.svgToBitmap(that.svg, function(bitmap) {  
                        that.bitmap = bitmap;
                        that.bitmap.addTo(that);
                        applyCommands();
                        that.dispatchEvent("ready");
                        that.dispatchEvent("complete");
                        if (that.stage) that.stage.update();
                    });
                }
            } else { // SVGContainer			
                if (that.bitmap) that.svg = that.bitmap.svg;
                if (svg.match(/<svg/i) || (a && a.type=="SVG") || second) {
                    var svgContainer = new zim.SVGContainer(that.svg);
                    svgContainer.loop(function (obj) {						
                        if (obj) obj.addTo(that);
                    }, true);    
                    if (second) {
						applyCommands();    
						if (that.stage) that.stage.update();	
					} 
                    setTimeout(function () {
                        that.dispatchEvent("ready");
                        that.dispatchEvent("complete");               
                    },20);
                } else { // file			
                    var svgFile = zim.asset(svg);
					svgFile.on("complete", function() {
						var svgContainer = new zim.SVGContainer(svgFile);
						svgContainer.loop(function (obj) {
							if (obj) obj.addTo(that);                        
						}, true);
						applyCommands();
						that.dispatchEvent("ready");
						that.dispatchEvent("complete");
						if (that.stage) that.stage.update();						
					});
                }
            }
        } 	
        
        function applyCommands() {
            if (zot(width) && zot(height)) that.setBounds(null); // resets size
            that.type = "SVG";
            if (that.commands) {
                for (var i=0; i<that.commands.length; i++) {
                    if (that.commands[i][2]) that[that.commands[i][0]].apply(that, that.commands[i][1]);
                    else zim[that.commands[i][0]].apply(that, that.commands[i][1]);
                }
            }
            that.commands = null;
        }
		
		that.keyOut = function(color, tolerance, replacement) {			
			if (that.type=="AC"&&WW.zdf) {WW.zdf.ac("keyOut", arguments, that); return that;}
			if (that.bitmap) that.bitmap.keyOut(color, tolerance, replacement);
			if (that.stage) that.stage.update();
			return that;
		}    
        
        if (style!==false) zim.styleTransforms(this, DS);
        that.clone = function (exact) {
            return this.cloneProps(new zim.SVG(exact?svg:originalSVG, width, height, bitmap, splitTypes, geometric, showControls, interactive, style, this.group, inherit));
        }      
    }
    zim.extend(zim.SVG, zim.Container, ["clone"], "zimContainer", false);//-83.09

/*--
Speech = function()

Speech
zim class - extends a createjs.EventDispatcher

DESCRIPTION
Create a new Speech() and use talk() or listen()
The talk() will speak words 
The listen() will turn voice into words
This is a short wrapper class for the Web Speech API 
https://developer.mozilla.org/en-US/docs/Web/API/Web_Speech_API/Using_the_Web_Speech_API
Thanks Karel Rosseel for the initial research on Speech.

SEE: https://zimjs.com/016/speech.html

NOTE: The listen() method is currently not supported by Apple iOS Web - only Native apps (grr)
But the talk() method works on iOS and Android Web - however, there seems to be one voice.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const speech = new Speech();
// interact at least once before talking
new Button({label:"TALK"}).center().tap(()=>{
	speech.talk("Hello World");
});
END EXAMPLE 

EXAMPLE 
// let user pick a voice
const speech = new Speech();
// interact at least once before talking
new Button({label:"TALK"}).center().mov(0,-120).tap(()=>{    
	speech.talk("Hello World!", list?list.text:null);
});
let list;
speech.on("voiceschanged", ()=>{ // must wait for voices to be loaded
	if (list) list.dispose(); // seems to run only once but just in case
	list = new List(500,300,speech.voices,6).center().mov(0,120);
	S.update();
});
END EXAMPLE

EXAMPLE 
const speech = new Speech();
new Button({label:"LISTEN"}).center().tap(()=>{
	// Note: iOS does not support 
	speech.listen();
});
speech.on("result", e=>{
	label.text = e.words;
	S.update();
})
const label = new Label({align:CENTER, text:""}).reg(CENTER).pos(0,200,CENTER,BOTTOM);
END EXAMPLE

METHODS
talk(text, voice, volume, lang, rate, pitch) - the computer will say the words
	returns an utterance object on which all these parameter can be dynamically set including the words
	text - the text to say (or see Web Speech API for special formats)
	voice (default "Microsoft David - English (United States)") - the voice 
		also see "voiceschanged" event at which point speech.voices will be a list 
		the voices do not need to be loaded if using the default voice
	volume (default 1) the volume of the voice
	lang (default user system language) the language of the voice 
	rate (default 1) the rate of the voice 
	pitch (default 1) the pitch of the voice
stopTalking() - stop talking
pauseTalking() - pause talking
resumeTalking() - resume talking ;-)
getVoices() - called automatically when the the Voice's voiceschanged event triggers 
	his is set automatically but may take a second or two to load
listen(interim, language) - start listening to the mic to record what is said 
	this will dispatch a "result" event on the Speech object
	interim defaults to true and means it gives a results as each word is spoken 
	set interim to false to give a result only after speaking is done (or a pause in speaking)
	the result event object (often e is used) will have a words property with the words
	and a confidence property with a percent as to how confident the match
stopListening() - stop listening

PROPERTIES
type - holds the class name as a String
voices - an array of string voices available for talk() - loads when "voiceschanged" event is dispatched (automatically set)
voiceObjects - an array of voice objects with name and lang properties used internally by talk() - matches voices indexes
voiceLanguages - an array of languages for the voices - matches voices indexes
recognition - the SpeechRecognition() object created (used internally) has JS properties - see:
	https://wicg.github.io/speech-api/#speechreco-attributes
	for instance, set the default language as mySpeech.recognition.language = "en-US";

EVENTS
dispatches a "voiceschanged" event when voices property will be ready - not needed if just using default voice
dispatches "result" when either as each word is spoken if listen() is used (interim defaults to true) 
	or at the end of speaking words if listen(false) is used (interim is set to false)
	the result event will have an event object (often e is used) that holds a words property with the words spoken 
	and a confidence property that is a ratio (0-1) for confidence in the result
	Note: iOS (at this time) does not support the listen() and result event
dispatches "speechend" events when listen() has detected an end to the talking 
dispatches an "error" event if no words are spoken, etc. the event object has an error property with the error message
dispatches "start", "end" and "error" on the utterance object returned by talk()
	Note: there are more features to the Web Speech API - see the HTML docs
--*///+83.095
	zim.Speech = function() {
		z_d("83.095");
		this.cjsEventDispatcher_constructor();
		this.type = "Speech";
		var that = this;

		if (M!="ios") {  
			
			var SpeechRecognition = WW.SpeechRecognition || WW.webkitSpeechRecognition;
			var SpeechGrammarList = WW.SpeechGrammarList || WW.webkitSpeechGrammarList;
			// this is causing an error on firefox even though they use this in their examples 
			// and we have all the speech about:config setting set to true
			var SpeechRecognitionEvent = WW.SpeechRecognitionEvent || WW.webkitSpeechRecognitionEvent;    
			var recognition = this.recognition = new SpeechRecognition();
			recognition.continuous = false;
			recognition.lang = this.language = "en-US";
			recognition.interimResults = true;
			recognition.maxAlternatives = 1;

			recognition.addEventListener("result", function(e) {
				var ev = new createjs.Event("result");
				ev.words = e.results[0][0].transcript;
				ev.confidence = e.results[0][0].confidence;
				that.dispatchEvent(ev);
			});
			recognition.addEventListener("speechend", function(e) {
				recognition.stop();
				that.dispatchEvent(e);
			});
			recognition.addEventListener("error", function(e) {
				that.dispatchEvent(e);
			});		
			
		}

		this.listen = function(interim, language) {
			if (M=="ios") {zogy("not supported on iOS Web"); return this;}
			if (zot(interim)) interim = true;	
			recognition.interimResults = this.interim = interim;		
			if (zot(language)) recognition.lang = this.language;			
			try {
				if (that.listenInterval) clearInterval(that.listenInterval);
				recognition.start();
			} catch (e) {
				that.listenInterval = setInterval(function() {that.listen(interim, language);}, 200);
			}
			return this;
		}   

		this.stopListening = function() {
			if (recognition) recognition.stop();
			return this;
		}   

		this.talk = function(text, voice, volume, lang, rate, pitch) {
			var sig = "text, voice, volume, lang, rate, pitch";
			var duo; if (duo = zob(this.talk, arguments, sig)) return duo;

			if (typeof speechSynthesis == "undefined") return;
			// https://wicg.github.io/speech-api
			if (zot(text)) return;
			var utter = new SpeechSynthesisUtterance();
			utter.addEventListener("start", function(e) {that.dispatchEvent(e);});
			utter.addEventListener("end", function(e) {that.dispatchEvent(e);});
			utter.addEventListener("error", function(e) {that.dispatchEvent(e);});

			if (voice && typeof voice == "string" && that.voiceLookup) voice = that.voiceLookup[voice];

			if (zot(volume)) volume = 1;
			if (zot(pitch)) pitch = 1;
			if (zot(rate)) rate = 1;

			utter.text = text;
			utter.voice = M=="ios"?null:voice;
			utter.lang = lang;
			utter.volume = volume;
			utter.rate = rate;
			utter.pitch = pitch;
			speechSynthesis.speak(utter);

			return utter;
		}

		this.stopTalking = function() {
			if (speechSynthesis) speechSynthesis.cancel();
		}
		this.pauseTalking = function() {
			if (speechSynthesis) speechSynthesis.pause();
		}
		this.resumeTalking = function() {
			if (speechSynthesis) speechSynthesis.resume();
		}

		this.getVoices = function() {   
			if (typeof speechSynthesis == "undefined") return;       
			var list = that.voiceObjects = speechSynthesis.getVoices();
			that.voices = [];
			that.voiceLanguages = [];
			that.voiceLookup = {};
			for (var i=0; i<list.length; i++) {
				that.voices.push(list[i].name);
				that.voiceLanguages.push(list[i].lang);
				that.voiceLookup[list[i].name] = list[i];
			}
			return that;
		}

		if (typeof speechSynthesis !== "undefined" && speechSynthesis.onvoiceschanged !== undefined) {
			speechSynthesis.addEventListener("voiceschanged", function(e) {
				that.getVoices();
				that.dispatchEvent(e);
			});
		}

	}
	zim.extend(zim.Speech, createjs.EventDispatcher, null, "cjsEventDispatcher", false);//-83.095

/*--
Fonts - loaded into Frame()

Fonts
For a Label object or components with labels

DESCRIPTION
As of ZIM ZIM 02, custom fonts can be loaded by their file name without the need for a font object {}.
Custom fonts must be preloaded in the Frame() or loadAssets() assets parameter.
Supported fonts are "ttf","otf","woff2","woff","fnt" files and Google fonts.
The font is then available to Label and components with labels.
ZIM wraps the CreateJS PreloadJS library to offer simplified loading.

NOTE: do not use uppercase letters on font name or extension - seems to not load on mobile.

NOTE: system fonts can be used without loading the font.

**************
DO NOT make a new Font() - rather, pass the font information into the Frame assets parameter.
Or load fonts when desired with Frame loadAssets() and wait for a complete event.
In either case, the font will then be available for Labels
**************

EXAMPLE
new Frame({ready, assets:"Reuben.otf", path:"assets/"});
function ready() {	
	new Label("Custom Font", 30, "Reuben").center();	
}
END EXAMPLE

EXAMPLE 
// here is the same but with the font object - used pre ZIM ZIM 02 - this still works
new Frame({ready, assets:{font:"Reuben", src:"Reuben.otf"}, path:"assets/"});
function ready() {   
	new Label("Custom Font", 30, "Reuben").center();   
}
END EXAMPLE

EXAMPLE
// use a Google font https://fonts.google.com/ and apply it with a STYLE 
// previously, the whole URL was needed:
// new Frame(FIT, 1024, 768, red, dark, ready, "https://fonts.googleapis.com/css?family=Dancing+Script");
// now, the gf_ shortcut can be used:
new Frame(FIT, 1024, 768, red, dark, ready, "gf_Dancing+Script");
function ready() {
	STYLE = {font:"Dancing Script"}; // or include + but not necessary.
	new Label("Custom Google Font").center();
	new Label("Second Custom Google Font").center().mov(0,100);
}
END EXAMPLE

EXAMPLE 
// with loadAssets, the previous example would be:
F.loadAssets("gf_Dancing+Script");
F.on("complete", ()=>{
	new Label("Custom Google Font", 50, "Dancing Script").center();
});
END EXAMPLE
--*///+83.85
// Fonts are used by Label objects and components with label objects and are loaded
// during Frame asset load or loadAssets() so load fonts there
//-83.85

/*--
Keys - keyboard methods and events

Keys
"keydown" and "keyup" Frame events

DESCRIPTION
The Frame has a "keydown" and "keyup" events to capture key presses 
and a keyboardMessage() method to prompt for keyboard interactivity.

When an app is first loaded it cannot receive keyboard events until it is interacted with.
Interaction must be a mousedown or click - not just an over or move interaction.
Often, we will make an intro Pane() or play Button() for a game, for instance, before playing sounds.
In ZIM 014 we added a keyboardMessage() method to prompt for an interaction so key events are activated.

Also see ZIM Keyboard(), TextEditor(), TextInput() and MotionController() for various keyboard functionality.

EXAMPLE
keyboardMessage(); // will prompt for keyboard control 
F.on("keydown", e=>{
	zog(e.key) // a string of the keypress 
	zog(e.keyCode) // the numeric code of the keypress (older but used in lots of examples)
	zog(F.altKey) // true if alt is pressed - also: ctrlKey, metaKey, shiftKey
});
// for controlling a game object with keyboard please see MotionController(obj, "keydown")
// as the MotionController solves a few tricky issues with key control
END EXAMPLE
--*///+83.865
// Keyboard events are available as Frame events
//-83.865

/*--
Cursors - custom cursors

Cursors
Frame property

DESCRIPTION
In ZIM 014 we added support for custom cursors as a Frame property
to get or set an object literal with custom cursors that override the CSS cursors or act on their own.
See: https://zimjs.com/014/cursors.html
the format is:
   F.cursors = {default:DisplayObject, pointer:DisplayObject, madeUp:DisplayObject, etc.}
   NOTE: use the cur() method to specify which cursor is on an object.
   drag(), tap(), etc. will already work with the custom cursor system
   set F.cursors = null to turn off custom cursors

There is a Frame cursorsExlcude() method to exclude certain objects from the custom cursors.
There is a Frame cursorObj property to indicate the current custom cursor.


EXAMPLE
F.cursors = {
	// the default cursor will be an emitter
	default:new Emitter({
		obj:new Circle({min:3,max:8},white),
		force:1,
		gravity:0
	}), 
	box:new Rectangle(40,40,clear,white,8,0,true)
		.reg(CENTER)
		.animate({props:{dashedOffset:-110}, rewind:true, loop:true})        
}
const rect = new Rectangle(500,500,red).center().cur("box"); // apply the box cursor
END EXAMPLE
--*///+83.867
// See Frame for the cursors property
//-83.867

/*--
Tilt - device motion and orientation events

Tilt
"devicemotion" and "deviceorientation" Frame events

DESCRIPTION
The Frame has a "devicemotion" event to capture device tilt 
and a "deviceorientation" to capture device rotation (like a compass)

Also see the PermissionAsk() class which will handle asking for permission on iOS devices.

NOTE:
For either event the Frame sensors parameter MUST be set to true

EXAMPLE
// for capturing tilt on device (rotation about an axis)
// also SEE the PermissionAsk example below
// also set Frame sensors parameter to true
// and be on a mobile device
const label = new Label().center();
F.on("deviceorientation", e=>{
	label.text = e.rotation.x +","+ e.rotation.y +","+ e.rotation.z;
	S.update();
});
END EXAMPLE

EXAMPLE
// on iOS, the sensors must be allowed first - this example works for all devices
const permissionType = "deviceorientation"; // or "devicemotion"
const ask = new PermissionAsk(init, permissionType);
function init(yes) {
	// if the user answers yes to the PermissionAsk
	const errorPane = new Pane("SENSOR not available",yellow);
	if (yes) {		
		// use the sensors 		
		label.text = decimals(e.rotation.x) +","+ decimals(e.rotation.y) +","+ decimals(e.rotation.z);
		S.update();
	} else { // answered no to PermissionAsk dialog		
		errorPane.show();
	}	
}
END EXAMPLE

EXAMPLE
// for shaking motion - ALSO see the PermissionAsk example above for iOS
// and replace "deviceorientation" with "devicemotion" 
// and replace e.rotation.x, etc. with e.acceleration.x etc.
// also set Frame sensors parameter to true
// and be on a mobile device
const label = new Label().center();
F.on("devicemotion", e=>{
	label.text = e.acceleration.x +","+ e.acceleration.y +","+ e.acceleration.z;
	S.update();
});
END EXAMPLE

EVENTS 
"devicemotion" - for tilt (also set Frame sensors parameter to true)
	fired on moving mobile device - like a tilt or shake - eventObject.acceleration holds x, y and z properties of motion   
"deviceorientation" - for rotation (also set Frame sensors parameter to true)
	fired as device orientation changes:
		eventObject.rotation.x (beta in HTML specs) holds rotation about the x axis between -180 and 180 (tipped forward or backward)
		eventObject.rotation.y (gamma in HTML specs) holds rotation about the y axis between -90 and 90 (tipped left or right)
		eventObject.rotation.z (alpha in HTML specs) holds rotation about the z axis 0-360 clockwise (relative to orientation when app loads)
			note rotation.z is 360-alpha compared to the HTML 5 specs
			note also that beta, gamma and alpha from the HTML 5 specs are also provided
--*///+83.86
// Device motion and orientation events are available as Frame events
//-83.86

/*--
zim.PermissionAsk = function(callback, permissionType, color, backgroundColor, style, group, inherit)

PermissionAsk
zim class - extends a zim.Pane which extends a zim.Container

DESCRIPTION
A circular confirmation widget to ask the user if they want a permission for iOS.
For some iOS permissions, the app needs to be interactive with first before permission can be asked!
This is for iOS only - if not in iOS then will just pass through the test.

NOTE: this started as SensorAsk but the class has been adjusted to handle other permissions and the name has been changed in ZIM 016

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on iOS, the sensors must be allowed first
const permissionType = "deviceorientation"; // or "devicemotion"
const ask = new PermissionAsk(init, permissionType);
function init(yes) {
	// if the user answers yes to the PermissionAsk
	const errorPane = new Pane("SENSOR not available",yellow);
	if (yes) {		
		// use the sensors 
		const label = new Label({text:"test on mobile", align:CENTER}).centerReg();
		F.on("devicemotion", e=>{
			// use the sensors 		
			label.text = decimals(e.rotation.x) +","+ decimals(e.rotation.y) +","+ decimals(e.rotation.z);
			S.update();
		})
	} else { // answered no to PermissionAsk dialog		
		errorPane.show();
	}	
}
END EXAMPLE

EXAMPLE 
// goes right to permissions on computer and android
// pops up a PermissionAsk Pane on iOS then if yes, goes to permissions on iOS
new PermissionAsk(init, "cam");
function init(val) {
	new Label(val).center(); // media stream if yes to permissions otherwise false
	S.update();
}
END EXAMPLE

EXAMPLE 
// on iOS, the app must be interacted with before using mic or cam
// this goes right to permissions on computer and android
// but pops up a PermissionAsk Pane on iOS then if yes, goes to permissions on iOS
new PermissionAsk(init, "mic"); // or "cam" or "miccam"
function init(val) {
	zog(val); // media stream if yes to permissions otherwise false
	S.update();
}
END EXAMPLE

PARAMETERS - accepts ZIM DUO regular parameters in order or a configuration object with parameters as properties
callback - the function to callback when permission is accepted
	if the permissionType is deviceorientation or devicemotion this will receive true for accept or false for no permission 
	if the permissionType is audio, video or audiovideo this will receive a stream if accepted or false if not
	for not iOS, the system permissions will appear 
	for iOS the PermissionAsk Pane will be shown and the system permissions 
	in all cases, the callback will be called on result 
	the parameter given to the callback will be true (sensors) or a media stream (mic / cam) or false if not accepted
permissionType - (default "deviceorientation") the string deviceorientation, devicemotion, mic, cam, or miccam
color - (default zim.dark) the font and border color of the widget
backgroundColor - (default zim.lighter) the backgroundColor of the widget

METHODS
dispose() - dispose the PermissionAsk

ALSO: see all the methods of a zim Pane()
including hide()

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
permissionType - the type of permission requested
label - reference to the zim Label 
yes - reference to the zim Button with YES 
no - reference to the zim Button with NO 

ALSO: see ZIM Pane for properties such as:
backdropColor, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

--*///+83.01
	zim.PermissionAsk = function(callback, permissionType, color, backgroundColor, style, group, inherit) {
		var sig = "callback, permissionType, color, backgroundColor, style, group, inherit";
		var duo; if (duo = zob(zim.PermissionAsk, arguments, sig, this)) return duo;
		z_d("83.01");
		
		this.group = group;
		var DS = style===false?{}:zim.getStyle("PermissionAsk", this.group, inherit);	
		
		if (zot(permissionType)) permissionType = DS.permissionType!=null?DS.permissionType:"deviceorientation";
		this.permissionType = permissionType;
		if (zot(callback)) return;	
		if (zot(color)) color = DS.color!=null?DS.color:zim.dark;
		if (zot(backgroundColor)) backgroundColor = DS.backgroundColor!=null?DS.backgroundColor:zim.lighter;
			
		this.zimPane_constructor("",backgroundColor,color,200,200,false,null,true,100,black.toAlpha(.3), null, null, null, false, false);
		this.type = "PermissionAsk";
		var that = this;
		
		Style.addGroup("PermissionAsk", {            
			width:100,
			color:color,
			rollColor:backgroundColor,
			corner:10,
			backgroundColor:zim.faint,
			rollBackgroundColor:color,
			borderColor:color,
			borderWidth:2         
		});
        var pt = permissionType;
		that.yes = new zim.Button({label:"YES", group:"PermissionAsk"}).sca(.65).pos(0,30,CENTER,TOP,this).tap(function() {
			that.hide(true);            
            if (pt == "mic" || pt == "cam" || pt == "miccam") {
                if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                    navigator.mediaDevices.getUserMedia({audio: (pt=="mic" || pt=="miccam"), video:(pt=="cam" || pt=="miccam") })
                        .then(function(stream) {
                            callback(stream);
                        })
                        .catch(function(err) {
                            callback(false);
                        });
                } else callback(false);
            } else {
                var s = DeviceMotionEvent;
                if (pt != "devicemotion") s = DeviceOrientationEvent;
                s.requestPermission().then(function(result) {
                    if (result != "denied") callback(true);
                    else callback(false);
                }); 
            }
		});
        var words = {deviceorientation:"sensors", devicemotion:"sensors", mic:"mic", cam:"cam", miccam:"mic/cam"};      
		that.label = new zim.Label("Use " + (words[pt]?words[pt]:"feature") + "?", 30, null, color, null, null, null, "center").sca(.9).centerReg(this);
		that.no = new zim.Button({label:"NO", group:"PermissionAsk"}).sca(.65).pos(0,30,CENTER,BOTTOM,this).tap(function() {
			that.hide(false);
			callback(false);
		});
		
		new zim.Circle(110, zim.clear, color, 1).center(this).alp(.8);
		new zim.Circle(120, zim.clear, color, 1).center(this).alp(.5);
		new zim.Circle(130, zim.clear, color, 1).center(this).alp(.2);        
		if (style!==false) zim.styleTransforms(this, DS);

        if (pt == "mic" || pt == "cam" || pt == "miccam") {
            if (M=="ios") {
                that.show();
                return;
            }
            if (navigator.mediaDevices && navigator.mediaDevices.getUserMedia) {
                navigator.mediaDevices.getUserMedia({audio: (pt=="mic" || pt=="miccam"), video:(pt=="cam" || pt=="miccam") })
                    .then(function(stream) {
                        callback(stream);
                    })
                    .catch(function(err) {
                        callback(false);
                    });
            } else callback(false);
            return;
        }

        // sensors only		
		if (typeof DeviceOrientationEvent != "undefined" && DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission == "function") {
			that.show();
		} else {
			var called = false;
			WW.addEventListener(permissionType, testMe);
			// instead of testing for mobile - some laptops like chromebook have sensors so test for a reading
			function testMe(e) {
				if (permissionType=="deviceorientation") {
					if (e.alpha==null || (e.alpha==0&&e.beta==0&&e.gamma==0)) callback(false);
					else callback(true);
				} else {
					if (!e.acceleration || e.acceleration.x==null || (e.acceleration.x==0&&e.acceleration.y==0&&e.acceleration.z==0)) callback(false);
					else callback(true);
				}	
				called = true;
				WW.removeEventListener(permissionType, testMe);					               
            }
			setTimeout(function(){
				if (!called) callback(false);
			}, 100);
		}
	}
	zim.extend(zim.PermissionAsk, zim.Pane, null, "zimPane", false);//-83.01

/*--
Colors - orange, green, pink, blue, brown, yellow, purple, red, interstellar, black, darker, licorice, dark, charcoal, grey, gray, granite, tin, pewter, silver, fog, mist, light, moon, lighter, white, faint, clear

Colors - orange, green, pink, blue, brown, yellow, purple, red, interstellar, black, darker, licorice, dark, charcoal, grey, gray, granite, tin, pewter, silver, fog, mist, light, moon, lighter, wh¡te, faint, clear
zim constants (lowercase)

DESCRIPTION
ZIM colors for convenience - such as blue, green, dark, etc.
Traditional HTML colors as strings can also be used such as "blue", "tomato", etc.
Also available are HEX numbers as strings such as "#333" or "#cc0000"
and RGB and RGBA of 0-255 values for red, green, blue with 0 being no color and 255 being full color 
then alpha from 0 to 1 as a decimal with 0 being transparent to 1 being opaque.
These are in a string such as "rgb(0,0,255)" or "rgba(0,0,0,.2)" (.2 is alpha)

NOTE: ZIM colors started off as properties of the frame so F.blue
but the frame properties have now been removed as they are stored on the zim namespace or as globals

FAINT AND CLEAR 
faint is "rgba(0,0,0,.01)" which is the faintest color that can be interacted with 
clear is "rgba(0,0,0,0)" which is invisble but cannot be interacted with 
However, clear can be used along with expand(0) to be able to interact with an object 
where the expand(0) (or whatever padding is desired) adds a CreateJS hitArea.

DARKEN AND LIGHTEN
ZIM has added darken() and lighten() methods to the JS String prototype to handle easy darkening and lightening of colors
This is very handy in desiging.
https://zimjs.com/docs.html?item=darken
https://zimjs.com/docs.html?item=lighten

COLOR BLENDS 
ZIM has toColor() to move one color towards another color
https://zimjs.com/docs.html?item=toColor

ALPHA 
ZIM has toAlpha() to set the alpha of colors
https://zimjs.com/docs.html?item=toAlpha

GRADIENTS
ZIM DisplayObjects accept GradientColor(), RadialColor() and BitmapColor() objects - see docs under the CODE module for info.
https://zimjs.com/docs.html?item=GradientColor
https://zimjs.com/docs.html?item=RadialColor
https://zimjs.com/docs.html?item=BitmapColor

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Circle(100, blue).center();
// is the same as
new Circle(100, "#50c4b7").center();

// ZIM colors (or HTML colors) can have alpha adjusted as follows:
new Circle(100, blue.toAlpha(.5)).center();

// colors can be darkened or lightened using darken() or lighten()
new Circle(100, blue.darken(.5)).center();

// colors can be blended using toColor()
new Circle(100, blue.toColor(red, .2)).center();
END EXAMPLE
	--*///+83.55
	zim.colorsHex = ["#fb4758","#f58e25","#ebcb35","#acd241","#50c4b7","#993399","#e472c4","#d1a170","#112233","#000000","#111111","#222222","#333333","#444444","#555555","#555555","#666666","#777777","#888888","#999999","#aaaaaa","#bbbbbb","#cccccc","#dddddd","#eeeeee","#ffffff","rgba(0,0,0,.01)","rgba(0,0,0,0)"];
	zim.colors = ["red","orange","yellow","green","blue","purple","pink","brown","interstellar","black","darker","licorice","dark","charcoal","grey","gray","granite","tin","pewter","silver","fog","mist","light","moon","lighter","white","faint","clear"];
	for (z_i=0; z_i<zim.colors.length; z_i++) {
		zim[zim.colors[z_i]] = zim.colorsHex[z_i];
	}
	// zim.red   	= "#fb4758"; // red dedicated to Alexa
	// zim.orange 	= "#f58e25";
	// zim.yellow	= "#ebcb35";
	// zim.green  	= "#acd241";
	// zim.blue  	= "#50c4b7";
	// zim.purple	= "#993399";
	// zim.pink  	= "#e472c4";
	// zim.brown 	= "#d1a170";
	// zim.interestellar	= "#112233";
	// zim.black  	= "#000000";
	// zim.darker 	= "#111111";
	// zim.licorice	= "#222222";
	// zim.dark   	= "#333333";
	// zim.charcoal	= "#444444";
	// zim.grey   	= "#555555";
	// zim.gray   	= "#555555";
	// zim.granite 	= "#666666";
	// zim.tin    	= "#777777";
	// zim.pewter  	= "#888888";
	// zim.silver 	= "#999999";
	// zim.fog    	= "#aaaaaa";
	// zim.mist   	= "#bbbbbb";
	// zim.light	= "#cccccc";
	// zim.moon   	= "#dddddd";
	// zim.lighter	= "#eeeeee";
	// zim.white  	= "#ffffff";
	// zim.clear  	= "rgba(0,0,0,0)";
	// zim.faint	= "rgba(0,0,0,.01)";
	
	String.prototype.darken = function(a) {return zim.darken(this, a);};
	String.prototype.lighten = function(a) {return zim.lighten(this, a);};
	String.prototype.toColor = function(c, a) {return zim.toColor(this, c, a);};
	String.prototype.toAlpha = function(a) {return zim.toAlpha(this, a);};
	//-83.55

/*--
Constants - FIT, FILL, FULL, LEFT, RIGHT, CENTER, MIDDLE, START, END, TOP, BOTTOM, OVER, UNDER, HORIZONTAL, VERTICAL, BOTH, RANDOM, RADIAL, UP, DOWN, NEXT, PREV, AUTO, DEFAULT, ALL, NONE, AVE, GET, POST, LOCALSTORAGE, SOCKET, TO, FROM, BOTH, SINE, SQUARE, TRIANGLE, SAW, ZAP

Constants - FIT, FILL, FULL, LEFT, RIGHT, CENTER, MIDDLE, START, END, TOP, BOTTOM, OVER, UNDER, HORIZONTAL, VERTICAL, BOTH, RANDOM, RADIAL, UP, DOWN, NEXT, PREV, AUTO, DEFAULT, ALL, NONE, AVE, GET, POST, LOCALSTORAGE, SOCKET, TO, FROM, BOTH, SINE, SQUARE, TRIANGLE, SAW, ZAP
zim constants

DESCRIPTION
ZIM positioning, data and sound constants for convenience if desired.
These are all equal to strings with lowercase values.
So using TOP is the same as using TOP

Positioning: FIT, FILL, FULL, LEFT, RIGHT, CENTER, MIDDLE, START, END, TOP, BOTTOM, OVER, UNDER, HORIZONTAL, VERTICAL, BOTH, RANDOM, RADIAL, UP, DOWN, NEXT, PREV, AUTO, DEFAULT, ALL, NONE, AVE
Data: GET, POST, LOCALSTORAGE, SOCKET, TO, FROM, BOTH
Sound: SINE, SQUARE, TRIANGLE, SAW, ZAP

NOTE: there are a set of constants at the start of the CONTROLS module as well

NOTE: for START and END, see DIR constant under CONTROLS module.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Tip("hello", RIGHT, MIDDLE).show();
// same as
new Tip("hello", "right", "middle").show();
END EXAMPLE
	--*///+83.5
	zim.FIT = "fit";
	zim.FILL = "fill";
	zim.FULL = "full";
	zim.LEFT = "left";
	zim.RIGHT = "right";
	zim.CENTER = "center";
	zim.MIDDLE = "middle";
	zim.START = "start";
	zim.END = "end";
	zim.TOP ="top";
	zim.BOTTOM = "bottom";
	zim.OVER = "over";
	zim.UNDER = "under";
	zim.HORIZONTAL = "horizontal";
	zim.VERTICAL = "vertical";
	zim.BOTH = "both";
	zim.RANDOM = "random";
	zim.RADIAL = "radial";
	zim.UP = "up";
	zim.DOWN = "down";
	zim.NEXT = "next";
	zim.PREV = "prev";
	zim.AUTO = "auto";	
	zim.AVE = "ave";	
	zim.DEFAULT = "default";	
	zim.ALL = "all";	
	zim.NONE = "none";	
	zim.GET = "get";
	zim.POST = "post";
	zim.LOCALSTORAGE = "localStorage";
	zim.SOCKET = "socket";
	zim.TO = "to";
	zim.FROM = "from";	
	zim.SINE = "sine";
	zim.SQUARE = "square";
	zim.TRIANGLE = "triangle";
	zim.SAW = "saw";
	zim.SAWTOOTH = "saw";
	zim.ZAP = "zap";
	//-83.5
	
/*--
Globals - F, S, W, H, M

Globals - F, S, W, H, M
zim globals

DESCRIPTION
These are not all the global variables in ZIM.
If zns is not set to true, then all classes in ZIM and functions in the CODE module are global. 
Also note the Constants in the docs listing above.  And the set of constants in the CONTROLS module.

ADDED ZIM ZIM 01:
F - the ZIM default frame - also there is a zimDefaultFrame and zdf global variable made - but F is easier.
	the ZIM default frame is the first frame made - or the frame that last has the setDefault() method called 
S - the Stage of the default frame - this will be the stage that addTo(), center(), etc. get added to if no container is provided 
W - the width of the default frame - this will be updated automatically in FULL mode on window resize.  
H - the height of the default frame - this will be updated automatically in FULL mode on window resize.  
M - false if not on mobile, otherwise reports the mobile device "iOS", "android", etc. - can also use mobile().

There are many previous examples that declare frame, stage, W and H 
this technique can still be used but you are welcome to use the F, S, W, H if desired.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new Frame({ready});
function ready() {
	const c = new Circle().pos(W*.2, H*.2);
	F.on("keydown", e=>{
		c.sca(rand(.5,3));
		S.update();
		zog(M); // false if on desktop/laptop
	});
}
END EXAMPLE
	--*///+83.52
	//-83.52


////////////////  ZIM META  //////////////

// the Meta section is for overall classes that operate on ZIM
// for instance zim.Distill and zim.Wonder

/*--
zim.DISTILL

distill
zim constant

DESCRIPTION
Distill allows you to track which functions you are using in your app
and create a custom minified js file with just those functions.
Set DISTILL to true to record which functions your are using in your app -
default is false.  While running your app, call the distill() function
take the results to https://zimjs.com/distill to create a minified distilled file.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// at the start of your code
DISTILL = true;

// at the end of your code (once everything has run)
// this means we may have to wait for events to happen, etc.
distill();

// this will log to the console a series of numbers
// separated by spaces representing the functions used

1 6 81 81 79 75 77 75 55 54 52 53 55 54 52 53 55 54 52
53 42 80 74 46 46 46 80 74 46 46 46 55 54 52 53 55 54
52 53 55 54 52 53 42 80 74

// copy these into the zim DISTILL form field
// to get the minified JavaScript for these functions
// NOTE: Distill will not duplicate the functions
// data duplication is left in for statistical purposes
END EXAMPLE
--*///+83.1
	zim.DISTILL = false;
	zim.distillery = [];
//-83.1

/*--
distill = function()

distill
zim function

DESCRIPTION
Call the distill function to display which zim functions you are using in your app.
You must set DISTILL constant to true before using (set at the start of your app).
After running through your app, call distill() and see the console (F12).
Take the results to https://zimjs.com/distill to create a minified distilled js file.
You would then host this js file yourself or include it in your mobile files, etc.
NOTE: distill() only records functions that have been used
so you may have functions still to be used in your app.
You will want to make sure you call distill() after you have used all your functions,
for instance, on a restart event, etc.
NOTE: distill() will not be available from your distilled file.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// at the start of your code
DISTILL = true;

// at the end of your code (once everything has run)
// this means we may have to wait for events to happen, etc.
distill();

// this will log to the console a series of numbers
// separated by spaces representing the functions used

1 6 81 81 79 75 77 75 55 54 52 53 55 54 52 53 55 54 52
53 42 80 74 46 46 46 80 74 46 46 46 55 54 52 53 55 54
52 53 55 54 52 53 42 80 74

// copy these into the zim DISTILL form field
// to get the minified JavaScript for these functions
// NOTE: Distill will not duplicate the functions
// data duplication is left in for statistical purposes
END EXAMPLE
--*///+83.2
	zim.distill = function() {
		if (!WW.zns && zim && (zim.DISTILL || WW.DISTILL)) {zim.distillery.push("83.3","83.35");} // zimplify runs before we can set zim.DISTILL
		function onlyUnique(value, index, self) {
			return self.indexOf(value) === index;
		}
		if (zim.distillery.length>0) {			
			zim.distillery = zim.distillery.filter(onlyUnique);		
			zogy("zim.distill() - go to https://zimjs.com/distill and enter the following:");
			zog(zim.distillery.join(" "));
		} else {
			zogy("must set zim.DISTILL = true;");
		}
	};//-83.2

	//-83.1

/*--
zim.parseAudioSprite = function(audioSpriteData, outputAudioSprite)

parseAudioSprite
zim function

DESCRIPTION
Converts an AudioSprite data file from a popular AudioSprite Creation Tool: https://github.com/tonistiigi/audiosprite
To a CreateJS AudioSprite data format to use with Frame loadAssets().

NOTE: only gets the first file from the output and ignores loop and autoplay properties
To loop a sound, use new Aud(id).play({loop:-1});

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// loading JSON data for audio is two step process.
// load the JSON then load the Audio with the converted loaded JSON data
// NOTE - do not have two frame complete events active at the same time!
// unless you assign the loadAssets() to a variable (ZIM Queue) and put the complete events on the variable
F.loadAssets("audioSprite.json", "assets/");
F.on("complete", init, null, true); // run this complete event only once (the true)

function init() {
	// convert imported data to CreateJS AudioSprite data:
	const audioSpriteData = parseAudioSprite(asset("audioSprite.json"));

	// load the audio using the converted data
	F.loadAssets(audioSpriteData, "assets/");
	F.on("complete", ()=>{

		// now all the AudioSprite ids are available
		new Aud("start").play();

	});
}
END EXAMPLE

PARAMETERS
audioSpriteData - an object (not JSON) made from parsed JSON data from https://github.com/tonistiigi/audiosprite example:
	{"resources": ["audiosprite.mp3"],
    "spritemap": {
        "blackball": {"start": 1.041, "end": 2.475, "loop": false},
	    "bounce": {"start": 3.567, "end": 4.232, "loop": false}
	}}
outputAudioSprite - (default false) output to the console the converted CreateJS AudioSprite data
	NOTE: this is in JSON format so will have to JSON.parse() the console text - wrap it in single quotes as they are stripped by the console

RETURNS - a CreateJS AudioSprite data object
--*///+83.25
	zim.parseAudioSprite = function(audioSpriteData, outputAudioSprite) {
		z_d("83.25");

		if (zot(audioSpriteData) || zot(audioSpriteData.resources) || zot(audioSpriteData.spritemap)) return;
		var obj = audioSpriteData;
		var id = obj.resources[0];
		var data = obj.spritemap;
		var newData = [];
		var r;
		var finalData = {src:id, data:{}};
		for (var i in data) {
			r = data[i];
			newData.push({id:i, startTime:Math.round(r.start*1000), duration:Math.round((r.end-r.start)*1000)});
		}
		finalData.data.audioSprite = newData;
		if (outputAudioSprite) zogy(JSON.stringify(finalData));
		return finalData;
	};//-83.25

/*--
zim.previewAudioSprite = function(audioSpriteData, numLetters, frame)

previewAudioSprite
zim function

DESCRIPTION
Creates a ZIM Tabs object with all the audioSprite sounds in each tab sound names are shortened to numLetters
Assumes that the AudioSprite is loaded - see docs on F.loadAssets()

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
var zimAudioSpriteData = {
	src:"audiosprite.mp3",
	audioSprite:[
		// [id, startime(s), endtime(s)]
		// prefer this when making audioSprites by hand in Premiere or Audition
		['noStar', 1.041, 2.475],
		['bounce', 3.567, 4.232],
		['deleted', 5.396, 9.315],
		['click', 10.373, 10.499],
		['noLove', 11.607, 14.254],
		['happy', 15.672, 17.081],
		['draw', 18.354, 19.163],
		['heart', 20.151, 23.594],
		['star', 24.931, 27.673],
		['warning', 28.632, 29.351],
		['navChange', 30.640, 32.323]
	]
}
F.loadAssets(zimAudioSpriteData, "assets/");
F.on("complete", ()=>{
	// will show tabs at top of stage - press to play audio
	previewAudioSprite(zimAudioSpriteData, 2);
	S.update();
});
END EXAMPLE

PARAMETERS
audioSpriteData - an AudioSprite object of ZIM, CreateJS or from JSON parsed https://github.com/tonistiigi/audiosprite format
numLetters - (default 3) how many letters from the sound name to put on each tab
frame - (default zdf) the frame into which the AudioFile is loaded

RETURNS - a ZIM Tab which is automatically added to the frame's stage
--*///+83.26
	zim.previewAudioSprite = function(audioSpriteData, numLetters, frame) {
		z_d("83.26");

		if (zot(audioSpriteData)) return;
		if (zot(numLetters)) numLetters = 3;
		if (typeof frame == "undefined") {
			if (zot(WW.zdf)) return;
			var frame = WW.zdf;
		}
		var sW = frame.width;

		var a = audioSpriteData;
		var tabs = [];
		var sounds = [];
		if (a.constructor == {}.constructor) {
			if (a.resources) a = zim.parseAudioSprite(a); // https://github.com/tonistiigi/audiosprite format
			if (a.audioSprite) { // ZIM format
				zim.loop(a.audioSprite, function(asData) {
					tabs.push(asData[0].substr(0,numLetters));
					sounds.push(asData[0]);
				});
			} else if (a.data && a.data.audioSprite) { // CreateJS AudioSprite
				zim.loop(a.data.audioSprite, function(asData) {
					tabs.push(asData.id.substr(0,numLetters));
					sounds.push(asData.id);
				});
			}
		} else {
			return;
		}
		var soundTab = new zim.Tabs({
			tabs:tabs, width:sW, currentEnabled:true
		}).addTo();
		soundTab.on("change", function() {
			frame.asset(sounds[soundTab.selectedIndex]).play();
		});
		return soundTab;

	};//-83.26

/*--
zim.svgToBitmap = function(svg, callback, width, height, params)

svgToBitmap
zim function

DESCRIPTION
Function to convert SVG to ZIM Bitmap

NOTE: as of ZIM Cat 04, svg passed into the assets parameter of Frame or loadAssets() 
will be converted to a Bitmap automatically and available as an asset() 
prior to ZIM Cat 04 it was available as SVG as an asset and would need to be converted with svgToBitmap()
The original SVG is available as an svg property on the Bitmap asset.

SEE: SVG() under Frame module for new way to load SVG files.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// svg can be a reference to an svg tag on the page zid("svgTagID")
// or an svg string starting with for example:
// var svg = '<svg id="vector" width="500" height="500" xmlns:rdf="https://www.w3.org/1999/02/22-rdf-syntax-ns#" xmlns="https://www.w3.org/2000/svg" xmlns:cc="https://web.resource.org/cc/" xmlns:dc="https://purl.org/dc/elements/1.1/" xmlns:svg="https://www.w3.org/2000/svg" viewBox="0 0 312 521" version="1.0">
// SEE: https://zimjs.com/svg for an example

svgToBitmap(svg, bitmap=>{
	bitmap.center().transform();
	S.update()
});
END EXAMPLE

PARAMETERS
svg - an SVG tag or SVG string
callback - function to call when creation is done
width - (default null) - force a width of the Bitmap
height - (default null) - force a height of the Bitmap
params - (default null) pass an object literal of values, etc. for callback to receive after bitmap

RETURNS - null
--*///+83.27
	zim.svgToBitmap = function(svg, callback, width, height, params) {
		z_d("83.27");
		
		if (!zot(svg.draggable)) {
			// CreateJS seems to wrap up an SVG with loadAssets as an SVG object
			var parser = new DOMParser();
			svg = !svg.innerHTML?svg:parser.parseFromString(svg.innerHTML,"text/xml");
			var list = svg.getElementsByTagName("svg");
			var tag = list?svg.getElementsByTagName("svg")[0]:null;
			svg = tag;
		}

        if (!XMLSerializer) {if (zon) {zogy("ZIM svgToBitmap() - sorry, not supported in Browser"); return;}}
		var svgString = (typeof svg == "string") ? svg : new XMLSerializer().serializeToString(svg);		
		if (svgString) {
			// https does not work
			svgString = svgString.replace(/https:\/\/www.w3/i, "http://www.w3");
			// seem to need width and height parameters in svg tag
			var first = svgString.split(">")[0];
			if (first.length>1) {
				var wid = first.split(/width/i);
				if (wid.length==1) { // no width and assume no height
					var w=100;
					var h=100;
					var box = first.split(/viewBox/i);
					if (box.length>1) {
						var dim = box[1].split("\"")[1];
						if (dim) {
							var d = dim.split(" ");
							if (d.length>1) {
								w = d[d.length-2];
								h = d[d.length-1];
							}
						}
					}
					// remember it is xml - need quotes
					svgString = svgString.replace(/svg /i, "svg  width=\""+w+"\" height=\""+h+"\" ");
				}
			}
			if (!svgString.match(/xmlns/i)) svgString = svgString.replace(/svg /i, "svg  xmlns='http://www.w3.org/2000/svg' ");
		}
		var DOMURL = self.URL || self.webkitURL || self;
		var inte = setTimeout(function() {
			zogy("ZIM SVG() could not be made");
			callback(new zim.Bitmap(), params);
			DOMURL.revokeObjectURL(obu);
		}, 100);
        var img = new Image();
        img.onload = function() {
			clearTimeout(inte);
            var bitmap = new zim.Bitmap(img, width, height);
            callback(bitmap, params);
			DOMURL.revokeObjectURL(obu);
        };		
		var obu;
		if (document && document.Blob) {
			obu = DOMURL.createObjectURL(new document.Blob([svgString], {type: "image/svg+xml"}));
		} else obu = DOMURL.createObjectURL(new Blob([svgString], {type: "image/svg+xml"}));
        img.src = obu;
		
    };//-83.27

/*--
zim.makeContent = function(content, maxWidth, color, scrollBar)

makeContent
zim function

DESCRIPTION
Function that returns ready-made content for Pane(), Window() and Panel() 
or can call and add anywhere.
Primarily used for confirmation or submission dialogs.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const content = makeContent({
	buttonScale:2,
	buttons:[
		{
			label:"ONE",
			bgColor:blue,
			call:(button)=>{zog(button.text);}
		}, {
			label:"TWO",
			bgColor:green,
			call:(button)=>{zog(button.text);}
		}
	]
}).center();
END EXAMPLE

PARAMETERS
content - the content to make - using one of three formats:
	a string or number to add a ZIM Label (also see color parameter and property) 
	a ZIM DisplayObject such as a Circle or a Container with more objects, etc.
	a content configuration object {} with the following properties - any are optional:
		header - a ZIM DisplayObject for the top of the content
		message - text that will put into a ZIM Label default color white
		display - a ZIM DisplayObject for beneath the message
		buttons - an array of ZIM Button objects or configuration objects {} as follows:
			{label, color, rollColor, backgroundColor, rollBackgroundColor, call}
			with call being a callback function for when the button is pressed 
		buttonScale - the scale for the buttons 
		color - the color of the message
		spacingH - horizontal space between the buttons (default 20xbuttonScale) 
		spacingV - vertical space between the content areas	(default 20)
		scrollBar - set to true if a default scrollBar is present in Window or a number if custom	
		align - default CENTER, or use LEFT or RIGHT
maxWidth - (default null) pass in a maximum width to keep scale the content to
color - message color - also see color as property of content config object {}

PROPERTIES 
*** if the content is a content configuration object then the following properties are added the created content 
config - the content configuration object provided
header - a ZIM DisplayObject from the top if provided
message - a ZIM Label from the message if provided
text - the text of the message if provided
display - a ZIM DisplayObject for beneath the message if provided
buttons - an array of ZIM Button objects or configuration objects {} as follows:
	{label, color, rollColor, backgroundColor, rollBackgroundColor, call}
	with call being a callback function for when the button is pressed 
	all if provided

RETURNS - a Label if a string or number is passed as content, a Container if a content config {} is passed or the content if something else is passed 
--*///+83.29
	zim.makeContent = function(obj,maxWidth,color) {
		z_d("83.29");
		var i;
		if (zot(color)) color = zim.dark;
		if (typeof obj == "string" || typeof obj == "number") obj = this.message = new zim.Label(obj, null, null, color);
		else if (obj.constructor == {}.constructor) {
			var data = obj;				
			if (!data.buttonScale) data.buttonScale = .5;
			if (zot(data.spacingH)) data.spacingH = 20 * data.buttonScale;
			if (zot(data.spacingV)) data.spacingV = 20;
			var spacingH = data.spacingH;
			var spacingV = data.spacingV;
			
			if (!data.align) data.align = "center";			
			obj = new zim.Container();
			var spacer = new Container(10,spacingV).addTo(obj);
			if (data.header) data.header.pos(0,spacingV,"left","top",obj);
			if (data.message) var label = new zim.Label({text:data.message, color:zot(data.color)?color:data.color, align:data.align}).reg(LEFT,TOP).loc(0,obj.height+(data.header?spacingV:0),obj);
			if (data.display) data.display.pos(0,-data.display.height-(data.header||data.message?spacingV:0),"left","bottom",obj);
			if (data.buttons) {
				if (!Array.isArray(data.buttons)) data.buttons = [data.buttons]; 	
				var ideal = data.length*100;				
				var buts = new zim.Container().loc(0,obj.height+(data.header||data.message||data.display?spacingV:0),obj);	
				for (var bb=0; bb<data.buttons.length; bb++) {
					var bd = data.buttons[bb];
					var call = bd.call||function(){};
					if (!bd.button) bd.button = new zim.Button({
						width:bd.width,
						label:bd.label,
						backgroundColor:bd.backgroundColor||bd.bgColor,
						color:bd.color,
						rollBackgroundColor:bd.rollBackgroundColor||bd.rollBgColor,
						rollColor:bd.rollColor
					});
					bd.button.call = call;					
					bd.button.sca(data.buttonScale).loc((bb==0?0:buts.width+spacingH),0,buts).tap(function(e){e.target.call(e.target)});					
				}					
			}
			var bb = obj.getBounds();
			obj.setBounds(bb.x, bb.y, bb.width, bb.height);
			for (i=0; i<obj.numChildren; i++) {
				var o = obj.getChildAt(i);
				o.lastY = o.y;
				if (data.align=="center") {
					o.center(obj).loc(null,o.lastY);
				} else if (data.align=="right") {
					o.pos(0,null,"right");
				}
			}	
			if (maxWidth && typeof maxWidth == "number") obj.width = Math.min(obj.width, maxWidth-spacingH*2-(data.scrollBar===true?12:data.scrollBar>0?data.scrollBar:0));	
			new zim.Container(10,spacingV).pos(0,-spacer.height,"center","bottom",obj).bot();

			obj.setBounds(null); // make spacer in bottom adjust bounds
			
			spacer.top();
			obj.config = data;
			obj.header = data.header;
			obj.message = label;
			obj.text = data.message;
			obj.display = data.display;
			if (data.buttons) {
				obj.buttons = [];
				for (i=0; i<buts.numChildren; i++) {
					obj.buttons.push(buts.getChildAt(i));
				}
			}				
		}		
		return obj;
	}//-83.29			

	return zim;
} (zim || {});

// internal global function for the distill process
function z_d(n) {if (zim && (zim.DISTILL || WW.DISTILL)) zim.distillery.push(n);}

// internal global function for adding DisplayMembers to zim Display Objects

/*--
zimify = function(obj, a, b, c, d, list)

zimify
global function

DESCRIPTION
Function to add display methods like drag, hitTests, move, animate, center, etc. to an object.
Also adds width, height, widthOnly and heightOnly properties.
The term "members" is used because we are adding both methods and properties.
All the ZIM 4TH display objects come with these members
BUT... the native CreateJS display objects do not.
When we import assets from Adobe Animate, these are native CreateJS objects.
So we can use zimify() to add these members to a CreateJS Shape, Container, etc.

NOTE: this was formerly zim.addDisplayMembers (which has been replaced by zimify)

ZIM uses zimify internally to add the members
to the ZIM shapes and components (Rectangle, Circle, Triangle, Label, Button, etc.)
as applied through the ZIM Container inheritance
as well as to the ZIM wrappers for CreateJS Container, Shape, Sprite, MovieClip objects.
The display methods call the original ZIM functions
passing the object parameter as the first parameter
or if DUO is being used then adds the object to the configuration object.

Also adds common ZIM DisplayObject properties such as:
width, height, widthOnly, heightOnly, level, depth, blendMode 
draggable, name, hue, saturation, brightness, contrast
hueBatch, saturationBatch, brightnessBatch, contrastBatch
and perhaps more - see zim.displayBase()

EXAMPLE
const cjsShape = new lib.Shape1(); // include the js from Adobe Animate
zimify(cjsShape, 200, 300); // or 0,0,200,300, for x, y, width, height of bounds
cjsShape.center();
cjsShape.drag();

// otherwise would have to use:
zim.center(cjsShape, stage);
zim.drag(cjsShape); // etc.
END EXAMPLE

EXAMPLE
const shape = new createjs.Shape();
shape.graphics.beginFill(red).drawRect(0,0,200,200);
// need to either setBounds() or pass in dimensions
zimify(shape, 200, 200); // add methods like center, drag, etc.
shape.center(); // ZIM 4TH method format
S.update();

// note: even without using zimify()
// we can use the traditional zim.center() function
var shape = new createjs.Shape();
shape.graphics.beginFill(red).drawRect(0,0,200,200);
shape.setBounds(0,0,200,200); // need to set bounds to center
zim.center(shape, stage); // use the zim function rather than the method
S.update();

// of course we can just use a zim.Shape
// then the methods like center, drag, etc. are already added
var shape = new Shape(200, 200).f(red).dr(0,0,200,200).center();
S.update();

// in this case, we may have well used a Rectangle ;-)
var shape = new Rectangle(200, 200, red);
shape.center();
S.update();
END EXAMPLE

PARAMETERS
obj - the object to add the methods and properties to (probably a CreateJS display object)
a,b,c,d - optional bounds - if the bounds are not already set then provide them here
	if only a and b are provided then these are width and height with x, y at 0
	if a, b, c, d are provided then these are x, y, width, height of the bounds
	note: on Adobe Animate MovieClips, the objects are stored in a container 
	and zimify() will automatically zimify the container and set its width and height to stage width and height
	and bring the container to the top()
list - Boolean used internally by zimplify to exclude zim methods (makes zimify return list of methods)

RETURNS - obj for chaining
--*///+83.3

function zimify(obj, a, b, c, d, list) {
	z_d("83.3");
		
	if (obj && obj.noDrag) return obj;
	if (list !== true) list = null;

	var displayMethods = {
		drag:function(boundary, axis, overCursor, dragCursor, all, swipe, localBoundary, onTop, surround, slide, slideFactor, slideSnap, slideSnapDamp, reg, removeTweens, startBounds, rect, currentTarget) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.drag(arguments[0]);}
			else {return zim.drag(this, boundary, axis, overCursor, dragCursor, all, swipe, localBoundary, onTop, surround, slide, slideFactor, slideSnap, slideSnapDamp, reg, removeTweens, startBounds, rect, currentTarget);}
		},
		noDrag:function(recursive) {
			return zim.noDrag(this, recursive);
		},
		mouse:function() {
			return zim.mouse(this);
		},
		noMouse:function() {
			return zim.noMouse(this);
		},
		effect:function(effect, x, y, width, height) {
			return zim.effect(this, effect, x, y, width, height);
		},
		noEffect:function(effects, cache) {
			return zim.noEffect(this, effects, cache);
		},
		updateEffects:function(redoCache) {
			return zim.updateEffects(this, redoCache);
		},
		wire:function(target, prop, twoWay, setSource, filter, call, input) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.wire(arguments[0]);}
			else {return zim.wire(this, target, prop, twoWay, setSource, filter, call, input);}
		},
		noWire:function(target, prop, input) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.noWire(arguments[0]);}
			else {return zim.noWire(this, target, prop, input);}
		},
		wired:function(source, prop, twoWay, setSource, filter, call, input) {	
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.wired(arguments[0]);}
			else {return zim.wired(this, source, prop, twoWay, setSource, filter, call, input);}
		},
		noWired:function(source, prop, input) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.noWired(arguments[0]);}
			else {return zim.noWired(this, source, prop, input);}
		},
		bind:function(id, props, extra, filter, bindObj) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.bind(arguments[0]);}
			else {return zim.bind(this, id, props, extra, filter, bindObj);}
		},
		noBind:function(props, removeConnectionData, call, bindObj) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.noBind(arguments[0]);}
			else {return zim.noBind(this, props, removeConnectionData, call, bindObj);}
		},
		dragBoundary:function(boundary) {
			return zim.dragBoundary(this, boundary);
		},
		dragRect:function(boundary) {
			return zim.dragBoundary(this, boundary);
		},
		transform:function(move, stretchX, stretchY, scale, rotate, allowToggle, visible, onTop, showStretch, showRotate, showScale, showReg, showBorder, borderColor, borderWidth, dashed, customCursors, handleSize, regSize, snapDistance, snapRotation, cache, events, ghostColor, ghostWidth, ghostDashed, ghostHidden, frame, container) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.transform(arguments[0]);}
			else {return zim.transform(this, move, stretchX, stretchY, scale, rotate, allowToggle, visible, onTop, showStretch, showRotate, showScale, showReg, showBorder, borderColor, borderWidth, dashed, customCursors, handleSize, regSize, snapDistance, snapRotation, cache, events, ghostColor, ghostWidth, ghostDashed, ghostHidden, frame, container);}
		},
		setSwipe:function(swipe) {
			return zim.setSwipe(this, swipe);
		},
		gesture:function(move, scale, rotate, boundary, minScale, maxScale, snapRotate, localBoundary, slide, slideFactor, regControl, onTop, surround, circularBounds, rect) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.gesture(arguments[0]);}
			else {return zim.gesture(this, move, scale, rotate, boundary, minScale, maxScale, snapRotate, localBoundary, slide, slideFactor, regControl, onTop, surround, circularBounds, rect);}
		},
		noGesture:function(move, scale, rotate) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.noGesture(arguments[0]);}
			else {return zim.noGesture(this, move, scale, rotate);}
		},
		gestureBoundary:function(boundary, update) {
			return zim.gestureBoundary(this, boundary, update);
		},
		gestureRect:function(boundary, update) {
			return zim.gestureBoundary(this, boundary, update);
		},
		addPhysics:function(dynamic, contract, shape, friction, linear, angular, density, restitution, maskBits, categoryBits, physics) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.addPhysics(arguments[0]);}
			else {return zim.addPhysics(this, dynamic, contract, shape, friction, linear, angular, density, restitution, maskBits, categoryBits, physics);}
		},
		removePhysics:function() {
			return zim.removePhysics(this);
		},
		hitTestPoint:function(x, y, boundsCheck) {
			return zim.hitTestPoint(this, x, y, boundsCheck);
		},
		hitTestReg:function(b, boundsCheck) {
			return zim.hitTestReg(this, b, boundsCheck);
		},
		hitTestRect:function(b, num, boundsCheck, inside) {
			return zim.hitTestRect(this, b, num, boundsCheck, inside);
		},
		hitTestCircle:function(b, num, boundsCheck, inside) {
			return zim.hitTestCircle(this, b, num, boundsCheck, inside);
		},
		hitTestCircleRect:function(b, margin) {
			return zim.hitTestCircleRect(this, b, margin);
		},
		hitTestCircles:function(b, margin) {
			return zim.hitTestCircles(this, b, margin);
		},
		hitTestBounds:function(b, margin, boundsShape) {
			return zim.hitTestBounds(this, b, margin, boundsShape);
		},
		boundsToGlobal:function(rect, flip, inside, globalObj) {
			return zim.boundsToGlobal(this, rect, flip, inside, globalObj);
		},
		resetBounds:function(a, b, c, d, margin) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.resetBounds(arguments[0]);}
			else {return zim.resetBounds(this, a, b, c, d, margin);}			
		},
		hitTestPath:function(b, num, showPoints, returnPoints, returnPercent) {
			return zim.hitTestPath(this, b, num, showPoints, returnPoints, returnPercent);
		},
		hitTestGrid:function(width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type) {
			return zim.hitTestGrid(this, width, height, cols, rows, x, y, offsetX, offsetY, spacingX, spacingY, local, type);
		},
		animate:function(props, time, ease, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startCall, startParams, animateCall, animateParams, sequence, sequenceCall, sequenceParams, sequenceReverse, sequenceRatio, ticker, cjsProps, css, protect, override, from, set, id, events, sequenceTarget, dynamic, drag, clamp, startPaused, clean, obj, seriesWait, sequenceWait, rate, pauseOnBlur, easeAmount, easeFrequency, timeUnit, timeCheck, noAnimateCall, pathDamp) {
			if (props && (props.props || props.obj) && isDUO(arguments)) {
				// run this if duo but only if props object has a props or obj object
				// can you believe that sentence makes sense
				// this is to allow new Circle().loc(100,100).animate({x:200});
				// without ZIM thinking it is a configuration object
				// it can only be a configuration object if there is a props or obj property
				arguments[0].target = this; return zim.animate(arguments[0]);
			}
			else {return zim.animate(this, props, time, ease, call, params, wait, waitedCall, waitedParams, loop, loopCount, loopWait, loopCall, loopParams, loopWaitCall, loopWaitParams, loopPick, rewind, rewindWait, rewindCall, rewindParams, rewindWaitCall, rewindWaitParams, rewindTime, rewindEase, startCall, startParams, animateCall, animateParams, sequence, sequenceCall, sequenceParams, sequenceReverse, sequenceRatio, ticker, cjsProps, css, protect, override, from, set, id, events, sequenceTarget, dynamic, drag, clamp, startPaused, clean, obj, seriesWait, sequenceWait, rate, pauseOnBlur, easeAmount, easeFrequency, timeUnit, timeCheck, noAnimateCall, pathDamp);}
		},
		pauseAnimate:function(){return this;},
		stopAnimate:function(){return this;},
		wiggle:function(property, baseAmount, minAmount, maxAmount, minTime, maxTime, totalTime, type, ease, integer, id, startType, ticker, wait, pauseOnBlur, endOnStart) {
			if (isDUO(arguments)) {arguments[0].target = this; return zim.wiggle(arguments[0]);}
			else {return zim.wiggle(this, property, baseAmount, minAmount, maxAmount, minTime, maxTime, totalTime, type, ease, integer, id, startType, ticker, wait, pauseOnBlur, endOnStart);}
		},
		loop:function(call, reverse, interval, step, start, end, immediate, complete, completeParams, collapse) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.loop(arguments[0]);}
			return zim.loop(this, call, reverse, interval, step, start, end, immediate, complete, completeParams, collapse);
		},
		copyMatrix:function(source) {
			return zim.copyMatrix(this, source);
		},
		duplicate:function(exact) {
			return zim.duplicate(this, exact);
		},
		cur:function(type) {
			return zim.cur(this, type);
		},
		sha:function(color, offsetX, offsetY, blur) {
			return zim.sha(this, color, offsetX, offsetY, blur);
		},
		pos:function(x, y, horizontal, vertical, container, index, add, reg, regX, regY) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.pos(arguments[0]);}
			else {return zim.pos(this, x, y, horizontal, vertical, container, index, add, reg, regX, regY);}
		},
		loc:function(target, y, container, index, add, localToLocal, x) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.loc(arguments[0]);}
			else {return zim.loc(this, target, y, container, index, add, localToLocal, x);}
		},
		mov:function(x, y) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.mov(arguments[0]);}
			else {return zim.mov(this, x, y);}
		},
		top:function() {
			return zim.top(this);
		},
		bot:function() {
			return zim.bot(this);
		},
		ord:function(num) {
			return zim.ord(this, num);
		},
		dep:function(depth) {
			return zim.dep(this, depth);
		},
		nam:function(name) {
			return zim.nam(this, name);
		},
		alp:function(alpha) {
			return zim.alp(this, alpha);
		},
		vis:function(visibility) {
			return zim.vis(this, visibility);
		},
		ble:function(blendMode) {
			return zim.ble(this, blendMode);
		},
		dye:function(color) {
			return zim.dye(this, color);
		},
		hov:function(value, type) {
			return zim.hov(this, value, type);
		},
		rot:function(rotation, x, y) {
			return zim.rot(this, rotation, x, y);
		},
		siz:function(width, height, only) {
			return zim.siz(this, width, height, only);
		},
		ske:function(skewX, skewY) {
			return zim.ske(this, skewX, skewY);
		},
		reg:function(regX, regY, still) {
			return zim.reg(this, regX, regY, still);
		},
		sca:function(scale, scaleY) {
			return zim.sca(this, scale, scaleY);
		},
		scaleTo:function(boundObj, percentX, percentY, type, boundsOnly) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.scaleTo(arguments[0]);}
			else {return zim.scaleTo(this, boundObj, percentX, percentY, type, boundsOnly);}
		},
		fit:function(left, top, width, height, type) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.fit(arguments[0]);}
			else {return zim.fit(this, left, top, width, height, type);}
		},
		outline:function(color, size, boundsOnly) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.outline(arguments[0]);}
			else {return zim.outline(this, color, size, boundsOnly);}
		},
		blendmodes:function(interval) {
			return zim.blendmodes(this, interval);
		},
		addTo:function(container, index, still) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.addTo(arguments[0]);}
			else {return zim.addTo(this, container, index, still);}
		},
		removeFrom:function(container) {
			return zim.removeFrom(this, container);
		},
		added:function(call, interval, maxTime) {
			return zim.added(this, call, interval, maxTime);
		},
		movement:function(call, immediate) {
			return zim.movement(this, call, immediate);
		},
		noMovement:function() {
			return zim.noMovement(this);
		},
		tap:function(call, distance, time, once, dbl, dblTime, call2, call3, call4) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.tap(arguments[0]);}
			else {return zim.tap(this, call, distance, time, once, dbl, dblTime, call2, call3, call4);}			
		},
		noTap:function() {
			return zim.noTap(this);
		},
		hold:function(call, distance, time, once) {
			return zim.hold(this, call, distance, time, once);
		},
		noHold:function() {
			return zim.noHold(this);
		},
		change:function(call, once) {
			return zim.change(this, call, once);
		},
		noChange:function() {
			return zim.noChange(this);
		},
		centerReg:function(container, index, add) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.centerReg(arguments[0]);}
			else {return zim.centerReg(this, container, index, add);}
		},
		center:function(container, index, add) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.center(arguments[0]);}
			else {return zim.center(this, container, index, add);}
		},
		place:function(id) {
			return zim.place(this, id);
		},
		placeReg:function(id) {
			return zim.placeReg(this, id);
		},
		expand:function(padding, paddingV, paddingRight, paddingBottom) {
			if (isDUO(arguments)) {arguments[0].obj = this; return zim.expand(arguments[0]);}
			else {return zim.expand(this, padding, paddingV, paddingRight, paddingBottom);}
		},
		setMask:function(mask, dynamic) {
			return zim.setMask(this, mask, dynamic);
		},
		cloneProps:function(clone) { // from CreateJS DisplayObject
			clone.type = this.type;
			clone.group = this.group;
			clone.style = this.style;
			clone.alpha = this.alpha;
			clone.rotation = this.rotation;
			clone.mouseEnabled = this.mouseEnabled;
			clone.mouseChildren = this.mouseChildren;
			clone.tickEnabled = this.tickEnabled;
			clone.x = this.x;
			clone.y = this.y;
			clone.scaleX = this.scaleX;
			clone.scaleY = this.scaleY;
			clone.skewX = this.skewX;
			clone.skewY = this.skewY;
			if (clone.name) clone.name = this.name;
			clone.regX = this.regX*clone.width/(this.width||1);
			clone.regY = this.regY*clone.height/(this.height||1);
			clone.visible = this.visible;
			clone.shadow = this.shadow;
			if (!this.type || this.type=="Shape") zim.copyMatrix(clone, this);
			clone.compositeOperation = this.compositeOperation;
			clone.snapToPixel = this.snapToPixel;
			if (this.filters && this.filters.length > 0) {
				clone.filters = this.filters.slice(0);
				clone.cache();
			}			
			clone.mask = this.mask;
			clone.hitArea = this.hitArea;
			// clone.cursor = this.cursor;
			// clone._bounds = zim.copy(this._bounds); // can't copy as _bounds is not an {} or []
			if ((!this.type || this.type=="Shape" || this.type=="Blob" || this.type=="Squiggle") && this._bounds) clone.setBounds(this._bounds.x, this._bounds.y, this._bounds.width, this._bounds.height);
			// reverted to above in ZIM ZIM 01 patch
			// because bounds will be set as objects are made
			// copying old bounds breaks ZIM VEE dimension picks
			// if (this._bounds) clone.setBounds(this._bounds.x, this._bounds.y, this._bounds.width, this._bounds.height);
			return clone;
		},
		cloneChildren:function(clone, exact) {
			if (clone.children.length) clone.removeAllChildren();
			var arr = clone.children;
			for (var i=0, l=this.children.length; i<l; i++) {
				var childClone = this.children[i].clone(exact);
				childClone.parent = clone;
				arr.push(childClone);
			}
			return clone;
		}
	};
	if (!zot(list)) {
		list = [];
		for (var m in displayMethods) {
			list.push(m);
		}
		return list;
	}
	for (var i in displayMethods) {		
		if (Object.prototype.hasOwnProperty.call(displayMethods,i)) {
			obj[i] = displayMethods[i];
		}
	}

	if (zim) {
		// adjust localToGlobal, etc.
		obj.cjsLocalToGlobal = obj.localToGlobal; // store the original methods
		obj.cjsGlobalToLocal = obj.globalToLocal;
		obj.cjsLocalToLocal = obj.localToLocal;
		obj.localToGlobal = function(x,y) {
			return zim.localToGlobal(x,y,obj,obj.cjsLocalToGlobal); // call the ZIM methods
		};
		obj.globalToLocal = function(x,y) {
			return zim.globalToLocal(x,y,obj,obj.cjsGlobalToLocal);
		};
		obj.localToLocal = function(x,y,target) {
			return zim.localToLocal(x,y,target,obj);
		};
		
		// ZIM DisplayObjects already have these
		// includes width, height, etc.
		if (!obj.hueBatch) zim.displayBase(obj);
	}
		
	if (!zot(a) && !zot(b) && !zot(c) && !zot(d)) {
		a = a;
	} else if (!zot(a) && !zot(b)) {
		c=a; 
		d=b;
		a=0;
		b=0;
	} 
	if (!zot(a) && !zot(b) && !zot(c) && !zot(d)) {
		obj.setBounds(a,b,c,d);
	} else if (obj.nominalBounds != null && obj.getBounds && obj.getBounds()==null) {
		var n = obj.nominalBounds;	
		obj.setBounds(n.x,n.y,n.width,n.height);
	}
	if (obj.parent && obj.parent.actionFrames && !obj.parent.addPhysics) {
		zimify(obj.parent, zdf?zdf.width:null, zdf?zdf.height:null);		
	}
	
	return obj;

}//-83.3

/*--
zimplify = function(exclude)

zimplify
global function

DESCRIPTION
By default, ZIM runs zimplify() so that the zim namespace is not needed.
This can be prevented by setting the global variable zns = true before calling ZIM.
Then if desired zimplify() can be run manually after ZIM is called. 

Calling zimplify() removes requirement to use the zim namespace in code
Puts the ZIM code, display and controls into the global namespace
Does not put methods in the namespace as using methods as functions is discouraged
With the exception of loop, stopAnimate, pauseAnimate, animate, wiggle

NOTE: By default the CDN version of ZIM stores all ZIM classes globally.
This will overwrite the JavaScript Blob and Window class.
To prevent this, zns can be set to true in a script before zim is imported.
Then import zim and at the top of the app script run zimplify(["Window", "Blob"]);
at which point ZIM Window and ZIM Blob would need the zim namespace 
but the other classes would need no namespace
and the JavaScript Window and Blob would be available as Window and Blob like usual.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// before calling the ZIM script we set the zim namespace to true 
// note, by default, zns=false and no zim namespace is needed
&lt;script>zns=true;&lt;/script>

// then in the script we would have to use the namespace
const circle = new zim.Circle(50, zim.green);

// calling zimplify() will avoid that:
zimplify();
const circle2 = new zim.Circle(50, green);

// and we can use zim functions directly
const random = rand(500);

// note - do not use:
const rand = rand(500); // as you will overwrite the rand() reference
END EXAMPLE

PARAMETERS
exclude - (default null) a String command or an array of command strings to not remove the zim namespace

--*///+83.35
var ignore; // used outside in style?
function zimplify(exclude) {
	z_d("83.35");

	document.Window = Window;
	document.Blob = Blob;

	ignore = "ignore";
	if (zot(exclude)) exclude = [];
	if (!Array.isArray(exclude)) exclude = [exclude];
	var methods = zimify(null, null, null, null, null, true); // get list of zim methods
	var exceptions = ["loop", "stopAnimate", "pauseAnimate", "animate", "wiggle", "wire", "wired"];
	for (var command in zim) {
		if ((methods.indexOf(command) == -1 || exceptions.indexOf(command) >= 0) && exclude.indexOf(command) == -1) {			
			window[command] = zim[command];
		}
	}	
}//-83.35

/*--
fastFrame = function(cjs, stage)

fastFrame
global function

DESCRIPTION
It is recommended to use a ZIM Frame or if using Adobe Animate to use the ZIM Shim
but if you are just wanting to use some ZIM features and are working primarily with CreateJS
or legacy CreateJS code - then just call fastFrame() before using ZIM code.
Pass the createjs namespace and the current stage into fastFrame().
fastFrame() will create and return a very light placeholder frame as a zdf
and will handle various scaling settings due to ZIM Retina.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// fastFrame is not needed with ZIM Frame or with ZIM Shim
// imagine that CreateJS is imported as createjs - or cjs, etc.
const stage = new createjs.Stage("demoCanvas");
fastFrame(createjs, stage);
new Circle().center().drag(); // center will now default to centering on stage
END EXAMPLE

PARAMETERS
createjs - (default null) a reference to the CreateJS namespace
stage - (default null) a reference to the CreateJS stage

--*///+83.355
zim.fastFrame = function(cjs, stage) {
	z_d("83.355");
	createjs = cjs;

	if (zot(WW.zdf)) {
		stage.frame = new zim.Frame({shim:{stage:stage, canvas:stage.canvas}});
		WW.zimDefaultFrame = WW.zdf = stage.frame;
		zim.scaX = createjs.stageTransformable ? 1 : stage.scaleX;
		zim.scaY = createjs.stageTransformable ? 1 : stage.scaleY;
		return stage.frame;
	}
};//-83.355


/*--
addWires = function(obj)

addWires
global function

DESCRIPTION
Add wire(), noWire(), wired(), noWired() methods to any object
See the methods in docs under DiplayObject methods
These can be added to custom objects to wire properties.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
	const slider = new Slider().center();
	const tabs = new Tabs({tabs:["summer", "fall", "winter", "spring"]}).pos(0,0,TOP,RIGHT);
	const data = {size:10, season:"summer"};
	// addWires returns the object data - which will now have the wired method
	// now, when the slider or tabs change the data object will be updated
	// note: we want the slider to be set to the object's start value so set the setSource to "target"
	// note: we want the text of the tabs not the default selectedIndex so need to provide input property
	addWires(data).wired(slider, "size", null, "target").wired({source:tabs, prop:"season", input:"text"});
END EXAMPLE

PARAMETERS
obj - the object to receive the wire and wired methods

RETURNS - obj for chainging
--*///+83.365
zim.addWires = function(obj) {
	z_d("83.365");
	obj.wire = function() {
		Array.prototype.unshift.call(arguments, obj);
		zim.wire.apply(null, arguments);
		return obj;
	};
	obj.noWire = function() {
		Array.prototype.unshift.call(arguments, obj);
		zim.noWire.apply(null, arguments);
		return obj;
	};
	obj.wired = function() {
		Array.prototype.unshift.call(arguments, obj);
		zim.wired.apply(null, arguments);
		return obj;
	};
	obj.noWired = function() {
		Array.prototype.unshift.call(arguments, obj);
		zim.noWired.apply(null, arguments);
		return obj;
	};
	return obj;
};//-83.365


/*--
setBlurDetect = function()

setBlurDetect
global function

DESCRIPTION
Function to detect browser Window being reduced or set to another tab.
Used by animate, interval and timeout to optionally pause these on blur and activate on focus
animate uses zim.pauseAnimateOnBlur and the interval and ticker use a zim.pauseOnBlur array
As of ZIM Cat 02 (patched) animate uses the target object tweenStates object to determine which animations to start again on focus
Used internally by ZIM - if an object has a pause(type) method then can add it to zim.pauseOnBlur array
to pause the object on window blur and unpause the object on focus

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// will count when window is not seen
const test = interval(1, obj=>{
	zog(obj.count);
});
END EXAMPLE

EXAMPLE
// will NOT count when window is not seen
const test = interval(1, obj=>{
	zog(obj.count);
}, null, null, null, true);
END EXAMPLE

EVENTS 
adds a "tabblur" event to the ZIM Default Frame when blurred 
and a "tabfocus" event to the ZIM Default Frame when focused
--*///+83.36

zim.setBlurDetect = function() {
	z_d("83.36");
	
	zim.blurCheck = true;
	zim.pauseAnimateOnBlur = true;
	zim.pauseOnBlur = [];
	zim.blurDetect = (function(){
		var stateKey,
			eventKey,
			keys = {
					hidden: "visibilitychange",
					webkitHidden: "webkitvisibilitychange",
					mozHidden: "mozvisibilitychange",
					msHidden: "msvisibilitychange"
		};
		for (stateKey in keys) {
			if (stateKey in document) {
				eventKey = keys[stateKey];
				break;
			}
		}
		return function(c) {
			if (c) document.addEventListener(eventKey, c);
			return !document[stateKey];
		};
	})();

	zim.blurDetect(function(){
		
		var i,obj,id;
		if(zim.blurDetect()){
			setTimeout(function(){		
				
				// coming back from blur into focus so set back animations									
				if (zim.pauseOnBlur) {					
					for (i=0; i<zim.pauseOnBlur.length; i++) {
						obj = zim.pauseOnBlur[i];
						if (!obj.pauseOnBlurPaused) obj.pause(false);
					}
				}
				if (zim.pauseAnimateOnBlur && zim.animatedObjects) {	
					var emitterCheck = [];
					var lastParent;
					for (i=0; i<zim.animatedObjects.objects.length; i++) {
						obj = zim.animatedObjects.objects[i];	
						var currentStates = zim.copy(obj.tweenStates);							
						if (!obj.tweenStates) {
							obj.pauseAnimate(false);
						} else if (zot(currentStates.all) || currentStates.all) {	
							obj.pauseAnimate(false);
							if (!obj.dynamicAnimation) {
								for (id in currentStates) {
									if (id=="all") continue;
									if (currentStates[id]===false) {
										obj.pauseAnimate(true, id);
									}
								}
							}
						} else {	
							obj.pauseAnimate(true);
							for (id in currentStates) {
								if (id=="all") continue;
								if (currentStates[id]) obj.pauseAnimate(false, id);
							}
						}	
						if (obj.type == "Sprite") obj.paused = true;
						if (
							obj.parent && 
							obj.parent.type == "Particles" 
							&& obj.parent.emitter 
							&& obj.parent.emitter.focusWarm
						) {
							lastParent = obj.parent.emitter;
							if (emitterCheck.indexOf(obj.parent.emitter) < 0) emitterCheck.push(obj.parent.emitter);
						}
					}
					if (emitterCheck.length>0) {
						for (i=0; i<emitterCheck.length; i++) {
							emitterCheck[i].doWarm(emitterCheck[i].focusWarm);
                            emitterCheck[i].clearPool();
						}
					}
				}
			},300);
			if (WW.zdf) WW.zdf.dispatchEvent("tabfocus");
		} else {
			
			// going out of focus so set pauses 
				
			if (zim.pauseOnBlur) {
				for (i=0; i<zim.pauseOnBlur.length; i++) {
					obj = zim.pauseOnBlur[i];
					obj.pauseOnBlurPaused = obj.paused;
					obj.pause(true);
				}
			}
			if (zim.pauseAnimateOnBlur && zim.animatedObjects) {
				// zim.loop(zim.animatedObjects.objects, function(obj) {
				// 	obj.pauseOnBlurPaused = obj.type=="Sprite"?obj.runPaused:obj.paused; 
				// });
				zim.pauseAnimate(true, "pauseOnBlur");
			}
			if (WW.zdf) WW.zdf.dispatchEvent("tabblur");
		}
	});

};//-83.36


/*--
ZIMONON

ZIMONON (note the extra ON at the end of ZIMON - so ZIMONON)
ZIM constant

*** this just turns ZIMON on - see docs for ZIMON next!

DESCRIPTION
Default is false - set to true to record arguments needed for ZIMON.stringify()
If not using ZIMON.stringify() then do not set this to true
See also Docs for Static Class ZIMON

BACKGROUND
Arguments are the values passed in to parameters.
These are stored in a LOCAL variable called arguments that belongs to the object
For ZIMON to stringify an object, it needs to have access to the arguments
So ZIMON requires objects to keep a PUBLIC record in an arguments property
This can add up in memory when the app has hundreds or thousands of objects
For instance, every rectangle, circle and line in a blob control would keep a record of its arguments

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
ZIMONON = true
new Frame({ready});
function ready() {

	const circle = new Circle(100, blue);
	const c = ZIMON.stringify(circle);
	// store string c in localStorage or send to database
	// ZIMON would only make a default circle if ZIMONON were not true

	// we can parse a ZIMON string without needing ZIMONON set to true
	// so if the app only read in a ZIMON string
	// then there would be no reason to set ZIMONON to true
	const cc = ZIMON.parse(cc).center(); // centers a blue circle

}
END EXAMPLE
--*///+83.37
WW.ZIMONON = false;
//-83.37



// back into zim
zim = function(zim) {

/*--
ZIMON = {}

ZIMON
zim static class

DESCRIPTION
ZIMON stands for ZIM Object Notation
It turns any prepared** object to a string using ZIMON.stringify(object)
It turns a ZIMON string back into and object using ZIMON.parse(string)
The object can be inside an array [] or an object literal {}
These can be nested and filled with any type of object (that is prepared**)
See https://zimjs.com/zimon/ for an example

NOTE: must set ZIMONON=true at START of app to record arguments (note the extra ON)
it is not that much extra data but it is prudent to conserve memory when not using ZIMON
ZIMONON is needed only to stringify(), for parse() it does not matter

KEY
An optional key object can be used to specify the scope of the class
and to specify which properties to store for objects made from a class.
The scope must be a string accessible from where you stringify - it can contain dots (.)
The key can be passed as the second parameter to ZIMON.stringify().
The key is sent in the ZIMON string and nothing extra is needed when parsing.

PURPOSE
The purpose is similar to JSON - to save to localStorage or databases or share between languages.
Indeed, the final ZIMOM format is JSON.
Like JSON, ZIMON can be used outside of ZIM and outside JavaScript if implemented in another language.
See https://github.com/danzen/zimon/ for generic JS code to port to other languages.

** PREPARED OBJECTS
Any objects NOT supported by JSON must be prepared
so objects other than string, number, array, object literal, boolean or null
need to have the following:
1. A type property that matches the class name as a string
2. An arguments property that holds an array of the arguments passed to make the object
The ZIM Objects are already prepared - so no extra work is required

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const objects = [new Rectangle(100,100,red), new Circle(50, blue)];
const zimon = ZIMON.stringify(objects); // could save in localStorage or send to database

const newObjects = ZIMON.parse(zimon); // makes a Rectangle and Circle in a []
newObjects[0].center();
newObjects[1].center().animate({scale:.5}, 1);
zog(newObjects[0].color); // #fb4758 zim red
END EXAMPLE

EXAMPLE
// pass a key for any properties to remember
const objects = [new Rectangle(100,100,red).alp(.5), new Circle(50, blue).sca(2).loc({x:200,y:200,add:false})];
const key = {Rectangle:{props:["alpha"]}, Circle:{props:["scale", "x", "y"]}};
const zimon = ZIMON.stringify(objects, key); // could save in localStorage or send to database

const newObjects = ZIMON.parse(zimon); // makes a Rectangle and Circle in a []
newObjects[0].center(); // would have alpha .5
newObjects[1].addTo().animate({scale:.5, x:W/2, y:H/2}, 1); // would start at scale 2 and x,y of 100,100
END EXAMPLE

EXAMPLE
// To prepare custom objects:
Custom = function(a, b, c) { // ** global scope
	this.type = "Custom"; // ZIMON uses a type property that matches the class name
	// best to take copy of arguments and turn them into array
	// otherwise any changes to argument values (setting defaults, etc) will be needlessly recorded
	// when ZIMON.stringify() is eventually called
	this.arguments = Array.prototype.slice.call(arguments);
	this.write = function() {console.log(a, b, c);}
}
const c = new Custom("one", "two", "three");
const c2 = ZIMON.stringify(c);
const c3 = ZIMON.parse(c2);
c3.write(); // logs one two three

// ** or save in some namespace or on an object
F.Custom = function(a, b, c) {// same as above}
const c = new F.Custom("one", "two", "three");
// then use key as second parameter to specify scope
const c2 = ZIMON.stringify(c, {Custom:{scope:"frame"}}); // key
const c3 = ZIMON.parse(c2);
c3.write(); // logs one two three
END EXAMPLE

EXAMPLE
// a built-in JavaScript Object:
const date = new Date(1982, 0, 10);
date.type = "Date"; // add date
date.arguments = [1982, 0, 10]; // and manual arguments
const d = ZIMON.stringify(date);
const d2 = ZIMON.parse(d);
zog(d2.getYear()); // 82
END EXAMPLE


STATIC METHODS
stringify(obj, key) - supply an object to convert to a ZIMON string
	the object can be any JSON ready object - string, number, array, object literal, boolean or null
	the object can be any ZIM DisplayObject - Circle, Blob, Button, Tile, Emitter, etc.
	the object can be a prepared custom or built in object
		with a type property of the class name
		with an arguments property of the arguments - see ** PREPARED OBJECTS above
	Or any combination of these - ZIMON is recursive so checks parameters, etc.
	the optional key can be used to specify scope for the class if not in global scope
	and used to specify which properties should be recorded
	the key has the following format:
	 	{ClassName:{scope:"inScope.nested.etc", props:["prop1", "prop2", "etc"]}, ClassName2:{}, etc.}
	stringify returns a ZIMON string in JSON format
	eg.'{"obj":{"zimon":"Rectangle","args":[30,30,"#e472c4"]},"props":[0.3,212,184]},"key":{"Tile":{"props":["alpha","x","y"]}},"zimon":1,"info":"https://zimjs.com/zimon/"}';
parse(string) - pass in the ZIMON string to turn back into an object (or objects within objects)


--*///+83.39
zim.ZIMON = {
	stringify:function(obj, key) {
		z_d("83.39");
		// Assumes all non-JSON objects have a type property matching its class name.
		// If the class is not in the global scope then a key object must be used:
		// key = {scope:"zim"}; // where zim is in the global scope
		// the string value can contain dots for nested scope {scope:"zim.game"}
		// If different functions have different scopes use a specific scope:
		// key = {Person:{scope:"zim"}, Orb:{scope:"zim.game"}};
		// or key = {scope:"zim", Person:{scope:"zim"}};
		// Use a props property to transfer property values from old to new objects
		// key = {Person:{scope:"zim", props:["rotation", "alpha"]}};

		if (zot(obj)) return;
		if (!ZIMONON) {
			if (zon) zogy("ZIMON - set ZIMONON=true before using ZIMON.stringify()");
			return;
		}
		obj = zim.copy(obj);
		process(obj);
		return JSON.stringify({obj:obj, key:key, zimon:1, info:"https://zimjs.com/zimon/"});
		function process(data, parent, index) {
			if (zot(data)) return;
			if (Array.isArray(data)) {
				zim.loop(data, function (d, i) {
					process(d, data, i);
				});
			} else if (data.constructor == {}.constructor) {
				zim.loop(data, function (p,v) {
					process(v, data, p);
				});
			} else {
				if (data.type) {
					var proxy = {zimon:data.type};
					if (data.arguments) {
						proxy.args = Array.prototype.slice.call(data.arguments);
						process(proxy.args);
					}
					if (data.type == "series") {
						proxy.args = Array.prototype.slice.call(data.array);
						process(proxy.args);
					}
					if (key && key[data.type] && key[data.type].props) {
						proxy.props = [];
						zim.loop(key[data.type].props, function (p) {
							proxy.props.push(data[p]);
						});
					}
					if (parent) {
						parent[index] = proxy;
					} else {
						obj = proxy;
					}
				} else {
					if (
						typeof data != "string" &&
						typeof data != "number" &&
						typeof data != "boolean" &&
						data !== null
					) {
						if (zon) zogy("ZIMON - potentially bad JSON value" + data);
					}
				}
			}
		}
	},
	parse:function(string, key) {
		z_d("83.39");
		if (zot(string)) return;
		var o = JSON.parse(string);
		var obj = o.obj; // could use ES6 deconstruct
		key = o.key;
		process(obj);
		return obj;
		function translate(n) {
			try {
				return Function('return('+n+')')();
			} catch (err) {
				if (zon) zogy("ZIMON - bad function scope or name: " + n);
				return null;
			}
		}
		function process(data, parent, index) {
			if (zot(data)) return;
			if (Array.isArray(data)) {
				zim.loop(data, function (d, i) {
					process(d, data, i);
				});
			} else if (zot(data.zimon) && data.constructor == {}.constructor) {
				zim.loop(data, function (p,v) {
					process(v, data, p);
				});
			} else {
				if (data.zimon) {
					// turn the zimon format into an object using scope in key
					var cl = data.zimon; // the class name					
					var scope = "";
                    if (key) {
						if (key[cl] && key[cl].scope) {
							scope = key[cl].scope+".";
						} else if (key.scope) {
							scope = key.scope+".";
						}
                    }
					var fn = translate(scope+cl);

					var args = data.args;
					if (zot(args)) args = [];
					process(args);
					var z;
					if (data.type == "series") {
						z = zim.series(args);
					} else {
						z = !fn?null:new (fn.bind.apply(fn,[null].concat(Array.prototype.slice.call(args))))();
					}
					if (parent) {
						parent[index] = z;
					} else {
						obj = z;
					}
					if (key && key[cl] && key[cl].props) {
						if (z) {
							zim.loop(key[cl].props, function (p, i) {
								if (!zot(data.props[i])) z[p] = data.props[i];
							});
						}
					}
				}
			}
		}
	}
};//-83.39

/*--
zim.Wonder = function(wid, client, app, notes, server)

Wonder
zim class

DESCRIPTION
Wonder sends counts, times, and orders to a server for user testing or statistical purposes.
Go to https://zimjs.com/wonder/ to get a Wonder ID (wid) and set up Wonder stats with ZIM
or make up your own wid and use your own server script to collect data.
See the zim Wonder site for the data fields that are sent.
NOTE: all records at ZIM are archived NEW YEARS DAY and kept for a year after that.
Service is provided as is and ZIM and Dan Zen are not responsible for lost data.

USAGE
count will count things like app loads, button clicks within an app, how many monsters they killed
time will tell you the time the user took to do something - like solve a puzzle, or locate the witch
order will record the order items were done - which section did they go to first, second, third, etc.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// make a Wonder object
// wonderID is e-mailed to you when you sign up
// client is your client's name that you provide
// app is the app for which you are recording data
// you can also pass an optional note
var wonder = new Wonder("wonderID", "client", "app");

// COUNT EXAMPLE
// for this example we count times a button is pressed
const button = new Button("CLICK").center();
button.on("click", ()=>{
	// records an entry for this keyword in your stats
	// along with date, time, session, etc.
	wonder.count("wow");
});

// TIME EXAMPLE
// assuming we have our Wonder object from above
// (you only need one Wonder object)
// start the timer counting for a keyword called "test"
// this will record nothing until you timeEnd()
// or you timeStart() again
// you can also timePause() and timeUnpause()
// see DOCS for more functionality and information
wonder.timeStart("test");

// add the circle
const circle = new Circle(100, red).center().drag();
circle.on("pressup", function(){
	if (circle.hitTestRect(square)) {
		// if the shapes are hitting then end the timer
		// this will send data to your Wonder report
		wonder.timeEnd("test");
	}
});

// add the square to a random location on stage
const square = new Rectangle(100, "yellow").loc(rand(W-square.width), rand(H-square.height));

// ORDER EXAMPLE
// assuming we have our Wonder object from above
// (you only need one Wonder object)

// make tabs
const tabs = new Tabs(400, 40, ["MOUSE", "CAT", "MONKEY"]);
tabs.selectedIndex = -1; // start with no selection
let count = 0; // perhaps get the first four presses
tabs.center().change(()=>{
	// record which tab was pressed
	// this gets stored under keyword animal
	wonder.order("animal", tabs.text);
	count++;
	// turn the order recording off for "animal"
	if (count == 4) wonder.orderOff("animal");
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
wid - string with your company wonder ID for example z14i46m3z29
	  this is the ID you are e-mailed when you sign up or sign in with your company name
	  this is NOT your company name that you log into Wonder with
	  NOTE: recording to a non-registered wid on the ZIM server will not work and there is no error message
client - the client the app is for - if it is for your company, just put your company
app - the app or site the Wonder stats are for
notes - (default null) any extra notes like any user data (limit 256 characters as it is stored each record)
server - a server with zim Wonder running
	Note: the default value for the server parameter has been removed as it risks being out-of-date
	If you have signed up for ZIM Wonder at https://zimjs.com/wonder/ then
	import https://zimjs.org/cdn/zimserver_urls.js in your code (script tag up top)
	this gives a global zimWonderURL variable for you to pass into the server parameter
	the zimserver_url.js script will always hold the latest domain:port for the zim server

METHODS
count(keyword) - sends a line to the server script with the given keyword as well as date and time
timeStart(keyword) - starts timing for the specified keyword (nothing sent to server yet)
timePause(keyword) - pauses the timing for this keyword
timeUnpause(keyword) - unpauses the timing for this keyword
timeEnd(keyword) - ends timing for the specific keyword and sends the time to the server
	NOTE: if the user exits the app (or leaves page) nothing gets sent to the server
		  due to unreliable beforeUnload events in the HTML world (otherwise all this would be batched)
order(keyword, item) - sends a line to the server for this item along with a unique order id for the keyword for the user

countOff(keyword) - prevents counts from being sent for this keyword
countOn(keyword) - allows counts from being sent for this keyword (default)
timeOff(keyword) - prevents sending time to the server for this keyword
timeOn(keyword) - allows sending time to the server for this keyword (default)
orderOff(keyword) - prevents sending orders to the server for this keyword
orderOn(keyword) - allows sending orders for this keyword (default)

dispose() - clear any event listeners, etc.
--*///+82
	zim.Wonder = function(wid, client, app, notes, server) {
		var sig = "wid, client, app, notes, server";
		var duo; if (duo = zob(zim.Wonder, arguments, sig, this)) return duo;
		z_d("82");
		if (zot(wid)) {zogy("zim.Wonder() - please provide Wonder ID (see https://zimjs.com/wonder/)"); return;}
		if (zot(server)) server = "https://wonder.zimjs.org/wonder";
		var that = this;
		if (zot(zim.wonderSession)) zim.wonderSession = "W"+zim.rand(100000,999999); // session id
		var data = [];
		// buffer to send at most every second
		var wonderInterval = setInterval(sendData,1000);
		var sendCount = 0;
		function sendData() {
			if (data.length > 0) {
				zim.async(server + "?wonder=" + JSON.stringify(data));
				data = [];
				sendCount++;
			}
		}
		var lastKeyword;
		var wonderCheck = setInterval(function(){
			if (sendCount > 28) {
				data.push({id:wid, c:client, a:app, n:notes, k:lastKeyword, t:"e", v:"frequency max - terminated", s:zim.wonderSession});
				zogy("zim.Wonder() - frequency max - terminated");
				that.dispose();
			}
			sendCount=0;
		}, 30*1000); // 30 seconds
		this.countsOff = {};
		this.timesOff = {};
		this.ordersOff = {};
		function kw(k,t){
			if (zot(k)) {
				zogy("zim.Wonder "+t+" - please provide a keyword"); return false;
			} else { // check if in off lists
				if (that[t+"sOff"][k]) return false;
				return true;
			}
		}
		this.count = function(keyword) {
			if (!kw(keyword, "count")) return;
			lastKeyword = keyword;
			data.push({id:wid, c:client, a:app, n:notes, k:keyword, t:"c", v:1, s:zim.wonderSession});
		};
		var times = {};
		this.timeStart = function(keyword) {
			if (!kw(keyword, "time")) return;
			that.timeEnd(keyword);
			lastKeyword = keyword;
			times[keyword] = new Date().getTime();
		};
		var pauseTimes = {};
		this.timePause = function(keyword) {
			if (!kw(keyword, "time")) return;
			if (pauseTimes[keyword]) return; // already pausing
			pauseTimes[keyword] = new Date().getTime();
		};
		this.timeUnpause = function(keyword) {
			if (!kw(keyword, "time")) return;
			if (!pauseTimes[keyword]) return; // no pauses
			var pausedTime = new Date().getTime() - pauseTimes[keyword];
			if (times[keyword]) times[keyword] += pausedTime;
			delete pauseTimes[keyword];
		};
		this.timeEnd = function(keyword) {
			if (!kw(keyword, "time")) return;
			if (!times[keyword]) return;
			var t1 = (pauseTimes[keyword]) ? pauseTimes[keyword] : new Date().getTime();
			var time = Math.round((t1 - times[keyword])/1000);
			delete pauseTimes[keyword];
			delete times[keyword];
			data.push({id:wid, c:client, a:app, n:notes, k:keyword, t:"t", v:time, s:zim.wonderSession});
		};
		this.order = function(keyword, item) {
			if (!kw(keyword, "order")) return;
			lastKeyword = keyword;
			if (zot(item)) {zogy("zim.Wonder order() - please provide an item"); return;}
			data.push({id:wid, c:client, a:app, n:notes, k:keyword, t:"o", v:item, s:zim.wonderSession});
		};
		this.countOff = function(keyword) {that.countsOff[keyword] = 1;};
		this.countOn = function(keyword) {delete that.countOff[keyword];};
		this.timeOff = function(keyword) {that.timesOff[keyword] = 1;};
		this.timeOn = function(keyword) {delete that.timesOff[keyword];};
		this.orderOff = function(keyword) {that.ordersOff[keyword] = 1;};
		this.orderOn = function(keyword) {delete that.ordersOff[keyword];};

		this.dispose = function() {
			sendData();
			clearInterval(wonderInterval);
			clearInterval(wonderCheck);
			return true;
		};
	};//-82

/*--
zim.VERSION

VERSION
zim constant

DESCRIPTION
The version of the ZIM code that is running.
The version is considered the file name after the CDN and before the .js or _doc.js.
For example, the first version of ZIM Cat is cat/00/zim for both the docs version and the minified version
See also the ZIM getLatestVersions() function for the latest versions of ZIM and other ZIM related files.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// the latest versions are on the CDN
// getLastestVersions will access them with ZIM async()
// and provide an versions object in the parameter of the callback function
getLatestVersions(function(versions) {
	if (VERSION == versions.zim) zogg(VERSION + " is the latest version");
	else zogy(VERSION + " is not the latest version");
});
END EXAMPLE
--*///+82.1
zim.VERSION = "016/zim";
//-82.1

/*--
zim.getLatestVersions = function(call)

getLatestVersions
zim function

DESCRIPTION
Gets the latest versions of ZIM and other ZIM related files.
A version is considered the file name after the CDN and before the .js or _doc.js.
For example, the first version of ZIM Cat is cat/00/zim for both the docs version and the minified version.
The versions for CreateJS on ZIM CDN might be 1.3.0/createjs and for Pizzazz 3 is pizzazz_03
Also see the ZIM VERSION constant for the current version

NOTE: also see the top of the Docs for all the latest files

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// the latest versions are on the CDN
// getLastestVersions will access them with ZIM async()
// and provide an versions object in the parameter of the callback function
getLatestVersions(function(versions) {
	if (VERSION == versions.zim) zogg(VERSION + " is the latest version");
	else zogy(VERSION + " is not the latest version");
});
END EXAMPLE

PARAMETERS
call - a callback function with a versions object is provided to the parameter
	the version object has version properties for the following:
		zim, createjs,
		pizzazz01, pizzazz02, pizzazz03,
		physics, three, game, socket,
		threejs, orbitcontrols, box2d, socketio, easystar
--*///+82.2
	zim.getLatestVersions = function(call) {
		z_d("82.2");
		var latestURL = "https://zimjs.com/live/getLatestVersions.php";
		function returnLatestVersions(data) {
			call(JSON.parse(data));
		}
		zim.async(latestURL, returnLatestVersions, "returnLatestVersions");
	};//-82.2
	
/*--
zim.PWA = function(call, label, backgroundColor, color, backdropColor, pane, noScale)

PWA
zim class extends a CreateJS EventDispatcher

DESCRIPTION
Class to insert a message for the user to add the app 
to their mobile device home screen.

PWA
Progressive Web Apps (PWA) are a way to run Web apps similar to native apps.
These are used primarily for mobile so the app runs without the Browser interface 
and also can run without the Internet, if a proper service worker is set up.
See https://zimjs.com/mobile 

ZIM ZAPPS
There are a few requirements and files that need to be set up for PWA.
See the ZIM Zapps PWA page at https://zimjs.com/zapps.html 
The extra PWA files can be made with a tool at https://zimjs.com/zapps 

The PWA class inserts a message into a ZIM app if both the following are true:

1. the app is on mobile
2. the app is not being launched already from the device home screen 

The message encourages the user to add the file to the home screen (A2HS).
https://developer.mozilla.org/en-US/docs/Web/Progressive_web_apps/Add_to_home_screen

HOW IT WORKS 
Make a new PWA() object and pass it an optional function that runs your app.
In either case, an invite the user to add to the home screen message will pop up 
if the app is on mobile running from a browser - otherwise there will be no message.

A. If there is no function then the pane can be closed and that is it.
If you want the pane to show up on top then add new PWA() at the end.
 
B. If a function is provided - eg. new PWA(init); then
when the pane is closed it will call the init function.
If there is no need for a message then PWA() calls the init function right away.

NOTE: the ZIM Zapps tool will insert a PWA call - which can be adjusted if necessary.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
function ready() { // Frame ready callback
	
	// PWA will show a message if user is on mobile and launching from a browser 
	// The app will wait until the message is closed then start 
	// or will run right away if there is no message needed 
	// such as when not on mobile or already launching from home screen on mobile
	// to test the app on desktop, use new PWA(init).show();
	
	new PWA(init);
	function init() {
		// your app code
		// init is a common function name to start an app 
		// but the function can be called whatever you want 
		// such as startApp, playGame, etc.
	}
} // end ready 
END EXAMPLE

EXAMPLE
function ready() { // Frame ready callback
	
	// Here we run the app and just add a PWA message on top 
	// only if user is on mobile and launching from a browser
	// no message would appear if not on mobile or already running from home screen on mobile
	
	// add app code here
	
	new PWA(); // add at end to pop on top of app
	
} // end ready 
END EXAMPLE

EXAMPLE
function ready() { // Frame ready callback
	
	// like the last example but may want to start the app 
	// when the user closes the message or if there is no message
	
	// add app code here
	// etc.
	
	// function to start animation, for example
	function startAnimation() {
	
	}
	
	const pwa = new PWA(); // add at end to pop on top of app
	// this event will fire if there is no message or when message is closed
	pwa.on("ready", startAnimation);
	
} // end ready 
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
call - (default null) the function to call to start the app 
	if left out then nothing will happen when the PWA closes (also see ready event)
label - (default "Please add to home screen as an app") along with an icon at left
	can add different words here or add a custom ZIM Label
backgroundColor - (default yellow) background color of pane (any CSS color)
color - (default black) font color of label on pane (any CSS color)
backdropColor - (default "rgba(0,0,0,.2)") the color of the background that fills the stage
pane - (default null) can specify a custom Pane instead of the last four parameters 
	this will be scaled to the 105% the stage width unless noScale is set to true (see below)
noScale - (default false) set to true to not scale the Pane (see pane parameter for custom pane)

METHODS 
show() - test the PWA message on desktop for instance - remember to remove the show!


EVENTS 
dispatches a ready event if the pane is closed or if there was no pane
but usually, just pass the callback as the first parameter
--*///+82.4
	if (typeof createjs != "undefined") {
	zim.PWA = function(call, label, backgroundColor, color, backdropColor, pane, noScale) {
		var sig = "call, label, backgroundColor, color, backdropColor, pane, noScale";
		var duo; if (duo = zob(zim.PWA, arguments, sig, this)) return duo;
		z_d("82.4");
		
		this.cjsEventDispatcher_constructor();
		this.type = "PWA";
							
		var pwa;
		var that = this;	

		var text = WW.M == "ios"?"In Safari, please add to\nhome screen as an app":"Please add to\nhome screen as an app";
				
		if (zot(label)) label = new zim.Label({text:text, align:zim.LEFT, lineHeight:44, color:color});
		if (zot(backgroundColor)) backgroundColor = zim.yellow;
		if (zot(pane)) {
			pane = new zim.Pane({
				width:1200,
				height:230,			
				content:label,  
				backgroundColor:backgroundColor,
				backdropColor:backdropColor
			});			
			var icon = new zim.Container();
			new zim.Shape(50,30).s(zim.dark).ss(3,1,0,3).p("AAAj0IAAFJAA8hoIBuAAIAAFdIlTAAIAAldIBuAA")
				.sca(1.7).addTo(icon);
			new zim.Shape(50,30).s(zim.dark).ss(3,1,0,3).p("AhGAlIBGhGIBHBG")
				.sca(1.7).addTo(icon).mov(0,-38);			
			var tile = new zim.Tile([icon, label], 2, 1, 20, 0, true)	
			if (tile.width > zdf.stage.width*.7) tile.width = zdf.stage.width*.7;
			tile.setBounds(-90,-10,480,100);
			tile.noMouse();
			icon.mov(-30,0);
			tile.center(pane);	
		}
					
		if (M && !( WW.matchMedia('(display-mode: standalone)').matches || (WW.navigator.standalone) || document.referrer.includes('android-app://') )) {		
			showMessage();
		} else {
			if (call && call.constructor === Function) call();
			setTimeout(function () {
				that.dispatchEvent("ready");
			},20); // cannot dispatch directly in a constructor
		}	
		
		function showMessage() {
			that.pane = pwa = pane.show();			
			pwa.on("close", function () {
				if (call && call.constructor === Function) call();
				if (that.scaleEvent) frame.off("resize", that.scaleEvent);
				that.dispatchEvent("ready");
				WW.zdf.stage.update();
			});			
			var frame = frame || WW.zdf;
			if (frame && !noScale) {
				pwa.scaleTo(frame.stage, 105).center();
				if (frame.scaling == "full" || frame.scaling == "tag") {
					that.scaleEvent = frame.on("resize", function () {
						pwa.scaleTo(frame.stage, 105).center();
					});
				}
				frame.stage.update();
			}
		}
		
		this.show = function() {
			showMessage();
			return this;
		}	
		
	};//-82.4
	zim.extend(zim.PWA, createjs.EventDispatcher, null, "cjsEventDispatcher", false);
	}

/*--
zim.QR = function(url, color, backgroundColor, size, clickable, correctLevel)

QR
zim class extends a ZIM Bitmap which extends a CreateJS Bitmap

DESCRIPTION
Class to make a QR Code Bitmap from a QRCode library by David Shim

NOTE: must import https://zimjs.org/cdn/qrcode.js in a script tag

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
new QR("https://danzen.com").sca(.5).pos(40,40,RIGHT,BOTTOM);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
url - (default "https://zimjs.com") url string the QR code will open
color - (default black) the darker color
backgroundColor - (default white) the lighter color
size - (default 256) the width and height of the QR code
clickable - (default true) set to false to not click the QR code to go to the URL
correctLevel - (default 2) numbers from 0(M), 1(L), 2(H), 3(Q) corresponding to density
	Info from: https://blog.qrstuff.com/2011/12/14/qr-code-error-correction
		The lower the error correction level, the less dense the QR code image is, which improves minimum printing size.
		The higher the error correction level, the more damage it can sustain before it becomes unreadabale.
		Level L or Level M represent the best compromise between density and ruggedness for general marketing use.
		Level Q and Level H are generally recommended for industrial environments where keeping the QR code clean or un-damaged will be a challenge. 
--*///+82.5
	zim.QR = function(url, color, backgroundColor, size, clickable, correctLevel) {
		var sig = "url, color, backgroundColor, size, clickable, correctLevel";
		var duo; if (duo = zob(zim.QR, arguments, sig, this)) return duo;
		z_d("82.5");
		
		if (zot(url)) url = "https://zimjs.com";
		if (zot(size)) size = 256;
		if (zot(color)) color = zim.black;
		if (zot(backgroundColor)) backgroundColor = zim.white;
		if (zot(clickable)) clickable = true;
		if (zot(correctLevel)) correctLevel = 2;
		
		var div = document.createElement("div");
		if (typeof QRCode == "undefined") {
			zogy("ZIM QR - needs qrcode.js library - see docs");
			return;
		}
		var qr = new QRCode(div, {
			text:url,
			width:size,
			height:size,
			colorDark:color,
			colorLight:backgroundColor,
			correctLevel:correctLevel
		});	
		this.zimBitmap_constructor(qr._oDrawing._oContext.canvas);
		if (clickable) {
			this.cur().on("click", function() {
				zgo(url, "_blank");
			});
		}		
		div = null;
		
	};//-82.5
	zim.extend(zim.QR, zim.Bitmap, null, "zimBitmap", false);

/*--
zim.GIF = function(file, width, height, startPaused)

GIF
zim class extends a ZIM Bitmap which extends a CreateJS Bitmap

DESCRIPTION
Class to make an animated gif from the gifler library by madCreator
https://themadcreator.github.io/gifler/

See: https://zimjs.com/nft/bubbling/gif.html

NOTE: must import https://zimjs.org/cdn/gifler.js in a script tag

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// dimensions must be provided otherwise will be 100x100
new GIF("path/file.gif", 200, 100).pos(40,40,RIGHT,BOTTOM);
END EXAMPLE

EXAMPLE
const gif = new GIF("path/file.gif", 200, 100)
	.center()
	.tap(()=>{
		gif.pause(!gif.paused);
	});
END EXAMPLE

EXAMPLE 
const gif = new GIF("path/file.gif", 200, 100).center();
timeout(1, ()=>{
	gif.reset(); // goes back to start and would play from start
	// to pause on reset seems to need a little time...
	timeout(.05, ()=>{
		gif.pause(); 
		timeout(1, ()=>{
			// start again
			gif.pause(false);
		});
	});
});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
file - url string to the animated gif
	also see ZIM PATH global variable as will get added to the start of the file
	and is also automatically set if a path is added to Frame() or loadAssets() parameters
width - (default 100) the width to show the gif
height - (default 100) the height to show the gif
startPaused - (default false) set to true to startPaused 
	also see the pause() method - but do not use the method to start paused

METHODS 
pause(state) - pause or unpause the gif 
	state defaults to true, set to false to unpause the gif 
	see also the startPaused parameter
stop() - stop the gif (same as dispose())
keyout(color, tolerance, replacement) - remove color from Bitmap and a tolerance between 0-1
   the default color is "#389b26" which is a medium dark green
   the default tolerance is .1 - the higher the tolerance the less sensitive the keying process - so more colors will be removed similar to the provided color
   color and tolerance can be an array of colors and tolerances (or just one tolerance if all are the same)
   replacement (default clear) a color to replace the keyed out color with or an optional array to match the colors array if an array is used
reset() - restarts the GIF
dispose() - delete the GIF and remove Ticker

ALSO see the gifler property to access the Gifler object and its methods
at https://themadcreator.github.io/gifler/

ALSO see ZIM Bitmap for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group
blendMode, hue, saturation, brightness, contrast, etc.

PROPERTIES 
type - holds the class name as a String
paused - get whether the animated gif is paused - see pause() to change
ticker - the ZIM Ticker function that is updating the stage 
gifler - the Gifler object - see https://themadcreator.github.io/gifler/
animator - the Gifler animator
--*///+82.7
	zim.GIF = function(file, width, height, startPaused) {
		var sig = "file, width, height, startPaused";
		var duo; if (duo = zob(zim.GIF, arguments, sig, this)) return duo;
		z_d("82.7");
		
		if (typeof gifler == "undefined") {
			zogy("ZIM GIF - needs gifler.js library - see docs");
			return;
		}
		
		if (zot(width)) width = 100;
		if (zot(height)) height = 100;
		
		var that = this;
		that.paused = false;
		
		this.zimBitmap_constructor(null, width, height);
		this.cache();

		var ti;
		var to;
		var f;
		if (WW.PATH!=null) zim.PATH = WW.PATH;
		if (file.match(/http/) || file.match(/^\//)) f = file;
		else f = (zim.PATH?zim.PATH:"")+file;
		that.gifler = gifler(f)
			.animate(this.cacheCanvas)
			.then(function(a) {
				that.animator = a;	
				if (startPaused) {
					ti = setInterval(function() {
						if (that.animator.running()) {
							to = setTimeout(function () {
								that.animator.stop();
								that.paused = true;
							},.1);
							clearInterval(ti);							
						}						
					}, .05);					
				}			
		});		

		if (!that.ticker) {
			if (that.keyObj) {
				var color = that.keyObj.color;
				var tolerance = that.keyObj.tolerance;
				var replacement = that.keyObj.replacement;
				that.ticker = zim.Ticker.add(function(){
					that.keyOut(color, tolerance, replacement);
				});
			} else {
				that.ticker = zim.Ticker.add(function(){});
			}
		}         
		
		that.keyOut = function(color, tolerance, replacement) {
			if (that.ticker) {
				zim.Ticker.remove(that.ticker);
				that.ticker = zim.Ticker.add(function () {
					that.keyOut(color, tolerance, replacement);				
				});         
			} else {
				that.keyObj = {color:color, tolerance:tolerance, replacement:replacement};
			}   
			return that;
		}
        
		this.pause = function(state) {
			if (zot(state)) state = true;
			if (that.animator) {
				if (ti) clearInterval(ti);
				if (to) clearTimeout(to);
				if (state && that.animator.running()) {
					that.animator.stop();
					zim.Ticker.remove(that.ticker);
				} else if (!state && !that.animator.running()) {
					that.animator.start();
					zim.Ticker.add(that.ticker);					
				}
			}
			that.paused = state;
			return that;
		}
		
		this.stop = function() {
			that.dispose();
		}
		
		this.reset = function() {
			that.animator.reset();
			if (that.paused) {
				that.animator.start();
				zim.Ticker.add(that.ticker);	
			}	
			return that;
		}
		
		this.clone = function() {
			return this.cloneProps(new zim.GIF(file,width,height,startPaused));
		};
		
		this.dispose = function() {
			that.animator.stop();
			if (that.parent) that.removeFrom();
			zim.Ticker.remove(that.ticker);
			zim.gD(this); 	
		};
		
	};//-82.7
	zim.extend(zim.GIF, zim.Bitmap, ["clone", "dispose", "keyOut"], "zimBitmap", false);
	
/*--
zim.THEME = function()

THEME
zim static class

DESCRIPTION
ZIM Theme changes the ZIM colors to themed sets of colors 
and it can set darkness (and lightness with negative) and tint as well.

Use the class directly like: Theme.set("themeName");
This affects everywhere a ZIM color is used AFTER the theme is set. 
This includes default colors for components like Button colors, etc. 
but not some interface colors like Squiggle and Blob control colors.
Use Theme.set("zim") to go back to traditional ZIM colors.
This will go back to ZIM colors for anything made afterwards
but will not change objects that are already made.

To change colors of objects already made, use Theme.apply("themeName");
Warning: using Theme.apply() will reload the page. 
To apply new theme colors to objects already made without reloading the page 
use Theme.set() and then adjust button.backgroundColor = red; etc.
A read-only THEME global object is set when a theme is set or applied. 
An applied theme will be re-applied when the page is reloaded.
Use Theme.clear() to reload the page with no theme set.

COLORS AND SHADES
Themes will work on the following built in ZIM colors and shades (no quotes):
red, orange, yellow, green, blue, purple, pink, brown, interstellar
black, licorice, darker, dark, charcoal, grey, granite, tin, pewter, silver, fog, mist, light, moon, lighter, white
Note: the shades are #000, #111, etc. to #eee, #fff

THEMES  
There are colors and greys (including white and black).
"zim" - the original ZIM colors and greys 
"html" - the colors are replaced with HTML version so blue is "blue".  Greys left the same.
"future" - the colors and greys are taken from AI visions of the future. 
"invert" - the colors and the greys are inverted - as in a difference against white. 
"greyscale" - the colors are set to greys. 
"neon" - even more vibrant than ZIM colors! Greys are set towards white and black. 
"seventies" - check out the shag on my app - greys are adjusted too.
"warm" - lovely mediterranean colors... mmm - greys are adjusted too.

CUSTOMIZE 
An object literal with colors and values can be passed to set() or apply() as the first parameter 
And a lightness ratio from -1 to 1 can be applied with negative making the colors darker 
So Theme.set("zim", .3); would lighten all the regular ZIM colors and greys by 30% for objects made after setting. 
Theme.apply("future", -.2); would reload the page and apply a future colors and greys 20% darker. 
The 3rd and 4th parameters are for tint and tintRatio - just like ZIM toColor().
So Theme.set("zim", 0, red, .5) would make all ZIM colors and greys be half way to red. 
The last parameter is exceptions which can be one color or an array of colors to not apply the theme to. 
Special "colors" and "greys" strings can be used to not include all colors or all greys.
So Theme.set("zim", 0, red, .5, "greys"); would redden only the colors. 
Theme.set("future", .2, null, null, ["yellow", "white"]); would except yellow and white.

See: https://zimjs.com/zim/theme.html 

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
	// This will make three buttons, two with zim theme and one with greyscale theme
	new Button().loc(100,100); // will be ZIM colors 
	Theme.set("greyscale");
	new Button().center(); // will be in greyscale
	Theme.set("zim");
	new Button().pos(100,100,RIGHT,BOTTOM); // will be ZIM colors 
END EXAMPLE

EXAMPLE 
	F.color = darker;
	new Tile(new Circle(30, [blue, green, red, orange, yellow]), 12, 5, 20, 20).center();
	const button = new Button({label:THEME.name=="neon"?"ZIM":"NEON"}).pos(0,30,CENTER,BOTTOM).tap(()=>{
		if (button.text=="NEON") Theme.apply("neon"); // will reload page as neon
		else Theme.apply("zim"); // will reload page as zim
	});
END EXAMPLE

EXAMPLE 	
	Theme.set("zim", .1, red, .2, "greys");
	// anything that gets made from now on will have slightly lighter zim colors tinted a little red 
	// but the greys will remain default
END EXAMPLE

EXAMPLE 	
	Theme.set("zim", -.5, null, null, "colors");
	// anything that gets made from now on will have darker greys
END EXAMPLE

METHODS 
set(name, lightenRatio, tint, tintRatio, exclude) |ZIM DUO| - set a theme to be used after setting 
	name (default "zim") one of "zim", "html", "future", "invert", "neon", "seventies", "warm"
	lightenRatio (default null) set between -1 and 1 to darken (to black) if negative or lighten (to white) if positive
		this works like ZIM lighten()
	tint (default null) a color to tint to
		this works like ZIM toColor(tint, ratio)
	tintRatio (default 0) set between 0-1 to apply a ratio of tint
	exclude (default none) a color or array of colors to exclude - these will stay ZIM default colors 
		convenience colors: "colors" and "greys" can also be used to exclude all colors or all greys
apply(name, lightenRatio, tint, tintRatio, exclude) |ZIM DUO| - relaod the app with the applied theme
	see the parameters for set() above
clear() - reloads the page with no theme set 
	to stop applying a theme going forward, use set("zim") for the default ZIM colors

CONSTANTS
THEME - a Theme object literal with name, lightnessRatio, tint, tintRatio and exclude properties - see set() method parameters
--*///+82.8

	zim.Theme = {
		set:function(name, lightenRatio, tint, tintRatio, exclude) {			
			var sig = "name, lightenRatio, tint, tintRatio, exclude";
			var duo; if (duo = zob(zim.Theme.set, arguments, sig)) return duo;		
			z_d("82.8");	
		    if (zot(name)) name = "zim";
		    var theme = name.toLowerCase();  
			if (zot(lightenRatio)) lightenRatio = 0;
		    if (tint==-1) tint = null;
		    if (zot(tintRatio)) tintRatio = 0;
			if (exclude==-1) exclude = null;
		    if (!zot(exclude) && !Array.isArray(exclude)) exclude = [exclude];
		    zim.THEME = window.THEME = {name:theme, lightenRatio:lightenRatio, tint:tint, tintRatio:tintRatio, exclude:exclude};
		    var colors = {};
			var c;
			var cn = zim.colors.slice(0,8); 
			// ["red", "orange", "yellow", "green", "blue", "purple", "pink", "brown", "interstellar"];
			var gn = zim.colors.slice(8,25); 
			// ["black","licorice","darker","dark","charcoal","grey","gray","granite","tin","pewter","silver","fog","mist","light","moon","lighter","white"];
			if (theme == "zim") {
				zim.loop(zim.colors, function(color, i) {
					if (color == "clear" || color == "faint") return;
					colors[color] = zim.colorsHex[i];
				});	       
		    } else if (theme == "html") {
				zim.loop(cn, function(color) {
					colors[color] = color;
				});
				zim.loop(gn, function(color, i) {
 				   colors[color] = zim.colorsHex[i+8];
 			   	});	 
			} else if (theme == "future") {
				c = ["f25019","fd8918","ffc955","1dcfae","00a5ab","007175","00969b","d6b361"];
				zim.loop(cn, function(color, i) {
					colors[color] = "#"+c[i];
				});		
				zim.loop(gn, function(color, i) {					
					colors[color] = zim.colorsHex[i+8].toColor("#1dcfae",.4-i*.025); 
 			   	});	  
		   } else if (theme == "invert") {
			   colors = {};
			   zim.loop(zim.colorsHex, function(color, i, t) {				   
				   if (i == t-2) return 1; // exit
				   colors[zim.colors[i]] = zim.invertColor(color);
			   });
		   } else if (theme == "greyscale") {
				c = ["222222","aaaaaa","dddddd","888888","333333","111111","777777","bbbbbb"];
				zim.loop(cn, function(color, i) {
					colors[color] = "#"+c[i];
				});	
			} else if (theme == "neon") {
				c = ["FF3624","ff6f00","e2f705","a3f307","05f9e2","ED0AF5","ff33c9","e16d00"];
				zim.loop(cn, function(color, i) {
					colors[color] = "#"+c[i];
				});		
				zim.loop(gn, function(color, i) {
					colors[color] = zim.colorsHex[i+8].toColor("#000",.9);
				});	
				colors["light"] = zim.lighter;	  
				colors["moon"] = zim.lighter;	  
				colors["lighter"] = zim.white;	  
				colors["white"] = zim.white;	  
		  	} else if (theme == "seventies") {
				c = ["e5771e","f4a127","ffecb4","6F8212","75c8ae","5a3d2b","956e4e","4c3607"];
				zim.loop(cn, function(color, i) {
					colors[color] = "#"+c[i];
				});	
				zim.loop(gn, function(color, i) {
					// colors[color] = zim.colorsHex[i+8].toColor("#568203",1-i*.06);
					colors[color] = zim.colorsHex[i+8].toColor(i<8?"#344f00":"#f4a127",.8-i*.04);
				});	 
			} else if (theme == "warm") {
				c = ["965746","c07768","ffecb4","8da279","6da0b1","745c58","9a7e79","be8858"];
				zim.loop(cn, function(color, i) {
					colors[color] = "#"+c[i];
				});	
				zim.loop(gn, function(color, i) {
					// colors[color] = zim.colorsHex[i+8].toColor("#965746",.1);
					colors[color] = zim.colorsHex[i+8].toColor(i<8?"#4e352e":"#745c58",.8-i*.05);
				});				
		   	} else if (theme.constructor == {}.constructor) {
		        colors = theme;
		        zim.loop(colors, function(color) {
		            if (zim.colors.indexOf(color) == -1) delete colors[color];
		        });
		    }
			zim.loop(exclude, function(item) {
				if (item.toLowerCase()=="colors") {
					zim.loop(zim.colors, function(color, i) {
						if (i >= 8) return 1;
						exclude.push(color);
					});
				} else if (item.toLowerCase()=="greys" || item.toLowerCase()=="grays") {
					zim.loop(zim.colors, function(color, i) {
						if (i < 8) return;
						exclude.push(color);
					});
				}
			})
		    zim.loop(colors, function(color, val) {  
		        if (exclude && exclude.indexOf(color) != -1) return; 
		        if (tint) val = val.toColor(tint, tintRatio);
		        if (lightenRatio != 0) val = val.lighten(lightenRatio);
		        if (!zns) window[color] = val;
		        zim[color] = val;
		    });
		    
		},		
		apply:function(name, lightenRatio, tint, tintRatio, exclude) {
			var sig = "name, lightenRatio, tint, tintRatio, exclude";
			var duo; if (duo = zob(zim.Theme.apply, arguments, sig)) return duo;
			try {
				if (localStorage) {
					if (zot(name)) name = "zim";
					var theme = name.toLowerCase();  
					if (zot(lightenRatio)) lightenRatio = 0;
					if (zot(tint)) tint = -1;
					if (zot(tintRatio)) tintRatio = 0;
					if (zot(exclude)) exclude = -1;
					else if (!Array.isArray(exclude)) exclude = [exclude];
					localStorage.setItem(themeID, JSON.stringify({name:theme, lightenRatio:lightenRatio, tint:tint, tintRatio:tintRatio, exclude:exclude}));  
					window.location.reload();
				} else zogy("ZIM applyTheme() - needs localStorage");
			} catch(e) {
				zogy("ZIM applyTheme() - needs localStorage");
			}
		},		
		clear:function() {
			try {
				if (localStorage && localStorage.getItem(themeID)) {
					localStorage.removeItem(themeID);        
				}    
				window.location.reload();
			} catch(e) {}		
		}			
	}
	
	var themeID = window.location.href.replace(/[.\/:]/g,"");
	try {
		if (localStorage && localStorage.getItem(themeID)) {
			zim.THEME = window["THEME"] = JSON.parse(localStorage.getItem(themeID));
			zim.Theme.set(THEME.name, THEME.lightenRatio, THEME.tint, THEME.tintRatio, THEME.exclude);
		} else {
			zim.THEME = window["THEME"] = null;
		}
	} catch(e) {
		zim.THEME = window["THEME"] = null;
	}
	//-82.8

////////////////  ZIM GAME  //////////////

// the Game section is for the game helper library

/*--
zim.LeaderBoard = function(data, title, width, height, corner, backgroundColor, titleColor, colors, total, scoreWidth, scorePlaces, scoreZeros, spacing, arrows, borderColor, borderWidth, shadowColor, shadowBlur, reverse, allowZero, font, fontSize, nameShift, scoreShift, rankShift)

LeaderBoard
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Shows leaders in a game.  Allows player to enter initials if in top players as set by the total parameter (default 10)
For the data parameter you can set an ID for ZIM data storage - get the ID at https://zimjs.com/leaderboard/
Or you can set the data parameter to "localStorage" for device only or "manual" for data from a custom database
See the ZIM ZONG game example for putting a LeaderBoard in a zim.Pane https://zimjs.com/zong/

NOTE as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const lb = new LeaderBoard({
	data:"E-MAILED CODE FROM zimjs.com/leaderboard/",
	corner:0,
	backgroundColor:dark,
	titleColor:light
}).center();

// then to record a score at some point later:
lb.score(500);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
data - (default "localStorage") localStorage will let a user keep their high score on a computer
	set data to an ID that is provided at https://zimjs.com/leaderboard/ to use the free ZIM data service
	set data to an Array of score objects: [{player:"RAJ", score:20}, {player:"DAN", score:18}] for manual database usage
title - (default null) - set to a String to create a title above the board
width - (default 400) - the width of the board
height - (default 600) - the height of the board
corner - (default 20) - the rounded corner of the board - set to 0 for no corner
backgroundColor - (default white) - the backing color of the board
titleColor - (default licorice) - the title text color if a title is provided
colors - (default the object detailed below) - an object literal that sets the colors of the boxes and texts
	the object holds rank, name and score backing colors, font colors, and current colors for each
	whatever properties you provide will overwrite the default color - but you do not have to provide them all
	Note: that darker is just a ZIM shortcut to #111111, etc. you can use any CSS style color like "green", etc.
	{
		rankColor: light,
		rankBackgroundColor: darker,
		currentRankColor: white,
		currentRankBackgroundColor: pink,

		nameColor: darker,
		nameBackgroundColor: lighter,
		currentNameColor: darker,
		currentNameBackgroundColor: "#f0d2e8",

		scoreColor: darker,
		scoreBackgroundColor: light,
		currentScoreColor: darker,
		currentScoreBackgroundColor: "#f0d2e8"
	}
total - (default 10) the number of rows to show
scoreWidth - (default 300) the width of the score field (the whole grid will be scaled to fit inside the width and height)
scorePlaces - (default 6) the maximum number of digits expected
scoreZeros - (default false) set to true to fill in zeros up to the scorePlaces- ie. 00023
spacing - (default 10) the spacing between the fields (the whole grid will be scaled to fit inside the width and height)
arrows - (default false) set to true to show arrows above and below the name when the player enters their name
borderColor - (default null) the border color
borderWidth - (default null unless borderColor then default 2) the border thickness
shadowColor - (default rgba(0,0,0,.3)) the shadow color - set to -1 for no shadow
shadowBlur - (default 14) set to 0 for no shadow
reverse - (default false) put smallest score at top
allowZero - (default false) allow a zero score - good for when reverse is set
font - (default courier) the font for the store name and score
fontSize - (default 60) the font size
nameShift - (default 0) vertical shift for the name if the font is off center
scoreShift - (default 0) vertical shift for the score if the font is off center
rankShift - (default 0) vertical shift for the rank if the font is off center

METHODS
score(score) - set a score - will allow user to enter initials - returns a position number
save() - this method is automatically done by save button when initials are filled in
cancel() - this method is automatically called when the user presses off the board without saving
startTime() - start timing the game - if a points per minute was provided during ZIM LeaderBoard setup (not for localStorage or manual)
stopTime() - stop timing the game - if a points per minute was provided during ZIM LeaderBoard setup (not for localStorage or manual)
redraw(newData, newWinner) - this method is automatically done at various points to redraw the grid with new data
	newData is in an array with score objects like so: [{player:"RAJ", score:20}, {player:"DAN", score:18}]
	newWinner is an optional index of the winner - who will then be able to enter their id
	leave out the newWinner to show the board with current scores set (no blanks for entering name)
dispose() - remove event listeners - you need to remove the LeaderBoard from the stage

NOTE: if you are using manual data then you can use any of these methods manually
NOTE: the leaderBoard extends a zim.Container so also has all container methods

PROPERTIES
winner - the index of the current winner if there is one (name getting entered) otherwise null
place - the index of the player's score even if not on the LeaderBoard
backing - reference to the zim.Rectangle used for the backing
backdrop - reference to the zim.Rectangle used for the backdrop to press off the LeaderBoard
filled - true if the winner name is filled in with three characters else false
grid - reference to the zim.Container used for the grid
	the grid has row containers and each row has a rank stepper, three name steppers and a score Label
	access these with:
		var score2 = grid.getChildAt(1).getChildAt(4);
	or to loop through all:
		zim.loop(grid, function(row, i) {
			var rank = row.getChildAt(0);
			var name1 = row.getChildAt(1);
			var name2 = row.getChildAt(2);
			var name3 = row.getChildAt(3);
			var score = row.getChildAt(4);
		});
titleText - reference to the zim.Label used for the title if the title parameter is provided
dataSource - get the data used as a string: database (using an ID), localStorage or manual (custom)
	NOTE: if there is a problem with your data ID then this will revert from database to localStorage
	You can tell when you save a score / name the save button says LOCAL if localStorage and SENT if database or manual
key - the ID (from https://zimjs.com/leaderboard/) if provided

NOTE: the leaderBoard extends a zim.Container so also has all container properties

EVENTS
dispatches a change event for each time the name letters are changed changed
dispatches a press event for when the save button is pressed
dispatches a save event for when the data is saved in localStorage or database (key) mode but not manual mode
dispatches a close event only when the board is closed by pressing off the board
dispatches an error event if data connection is not made properly
dispatches a cancel event when a new score is requested before an older score is saved
--*///+100

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-100

/*--
zim.Meter = function(stage, vertical, horizontal, color, textColor, padding, decimals, alpha, skew)

Meter
zim class - extends a zim.Label
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A meter that shows measured FPS in a text label

NOTE as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const meter = new Meter(stage, TOP, LEFT); // adds to stage at top left - default bottom left
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below

stage - the stage
vertical (default "bottom") set to TOP for top - no middle
horizontal (default LEFT) set to RIGHT for right - no middle
color (default green) color of backing
textColor (default black) color of text
padding (default 20) the distance from Meter to edge
decimals (default 0) the number of decimals to show
alpha (default .6) the alpha of the Meter
skew (default 10) the skewX of the Meter

METHODS
position(vertical, horizontal) - reset the position - returns object for chaining
dispose()

PROPERTIES
text - the text of the meter

Plus all the methods and properties of a Label
--*///+105

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-105

/*--
zim.Board = function(size, cols, rows, backgroundColor, rollBackgroundColor, borderColor, borderWidth, isometric, indicatorColor, indicatorBorderColor, indicatorBorderWidth, indicatorSize, indicatorType, arrows, arrowColor, arrowRollColor, swipe, info, labels, color, scaleMin, scaleMax, buffer)

Board
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Creates a square tiled board with num columns and rows.
This can be either isometric (default) or top view.
The info for the board can be for any number of rows and columns
that is the same size or bigger than the num for the board.
The info does not need to have the same number of columns and rows
The info holds data, color, icon and items properties
and is an outer array of rows and inner arrays for columns.
The info array can be specified as a parameter
or adjusted as a property later with array manipulations
but board.update() must be called to view the changes.

Board offers many properties and methods
to add and remove items, set colors, icons and data per square,
move the board and move items along paths, etc.

There is a powerful filter parameter that uses subsets of the info
This can be used to find random tiles with certain info
or to allow key presses only to certain tiles.
The filter is positive and negative to include or not include the following:
data, notData, color, notColor, icon, notIcon, info, notInfo, col, notCol, row, notRow
in each case it can be a single value or an array of values
for instance board.getRandomTile({data:"x", notItem:[tree, bush, rock]}); etc.

See: https://zimjs.com/iso/ for a full example

Note: as of game 2.0, the zim namespace is not required unless zns is true

EXAMPLE
// for a more complete example see https://zimjs.com/iso/
const board = new Board().center();
const person = new Person();
board.add(person, 5, 5);
const tile = board.getTile(2,3);
board.setColor(tile,red);
board.setData(tile,"0");
board.addKeys(person,"arrows",{notData:"0"});
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
size - (default 50) the square tile size in pixels
cols - (default 8) the number of visible columns on the board
rows - (default cols) the number of visible rows on the board
backgroundColor - (default lighter) the square color of the board
	see the info parameter/property and setColor() to set individual colors
rollBackgroundColor - (default fog) the rollover square color of the board
borderColor - (default darker) the border color of the squares
borderWidth - (default 2) the border width of the squares
icon - (default null) the default DisplayObject to clone add to each tile
	set the icon.type property to be included in filters - eg. icon.type = "poisonivy"
	see the info parameter/property and setTile() to set individual tiles
isometric - (default true) set to false to see a top view
	isometric is rotating the board 45 and scaling the container by 2 in the width
indicatorColor - (default black) the indicator shows a path with showPath()
indicatorBorderColor - (default darker) the border color of the indicator
indicatorBorderWidth - (default 8) the width of the border
indicatorSize - (default 2)
indicatorType - (default "circle") set to "circle" or "square" for the whole tile
arrows - (default true) show (auto) arrows if info is larger than board view
	arrows will move the "camera" rather than move the board
	so pressing right will move the board to the left, etc.
arrowColor - (default "rgba(0,0,0,.4)") the arrow color
arrowRollColor - (default white) the arrow roll color
swipe - (default true) set to false to not swipe on the board to move the board (like arrows)
info - (default null) set to an array of rows and cols in the following format:
	Rows are the outer array and cols are the inner arrays with {} being the info
	[[{data:"x", color:blue, items:[new Person()]},{},{},,,,,], [,,],,,,,,,,,,,,,,,]
		data (default "x"): any data desired - could be data for path finding or an array, etc.
		color (default backgroundColor): the color of the tile on the board when showing this info
		items (default []): a list of items to display on the tile when showing this info
	The info will be automatically filled in so just commas will do as placeholders
	The max length of the inner arrays will be used for all inner arrays
	The final length of rows and cols will be available as numCols and numRows
	See also the methods for ways to add data, color, icon and items
	Or use the board.info property any time to change the info - may need to board.update() after
	The info may be bigger than the board size and does not have to be square like the board
labels - (default false) set to true to display the data from info in tiles - for debugging
color - (default granite) color of the labels
scaleMin - (default 1.2) the minimum items will be scaled when farther (top) from user
scaleMax - (default 1.8) the maximum items will be scaled when closer (bottom) to user
buffer - (default 3) nudge camera when moving item is this many tiles from the edge
	applies when info is larger than board and keys or path is used to move item
	set to 0 to not nudge camera

METHODS
**FILTER - some methods have an optional filter parameter
	this will limit the method to work on a subset of the info array or tiles
	the filter parameter is an object {} with any number of the following properties:
	Note: for convenience, these also work in plural - for instance colors, notItems, cols, etc.
		data - a value or array of data the info/tile must have
		notData - a value or array of data the info/tile must NOT have
		color - a value or array of color the info/tile must have
		notColor - a value or array of color the info/tile must NOT have
		icon - a value or array of the icon's type property the info/tile must have
		notIcon - a value or array of the icon's type property the info/tile must NOT have
		item - a value or array of items the info/tile must have
		notItem - a value or array of items the info/tile must NOT have
		col - a value or array of cols (in visible board) the info/tile must be in
		notCol - a value or array of cols (in visible board) the info/tile must NOT be in
		row - a value or array of rows (in visible board) the info/tile must be in
		notRow - a value or array of rows (in visible board) the info/tile must NOT be in
positionBoard(i, j) - move the board to show data from info at j row and i col
	see also startCol and startRow properties and moveRow() below
moveCamera(dir) - moves the camera LEFT, RIGHT, UP or DOWN
	this moves the board the opposite direction by one tile
	used internally by arrows and swiping
addCol(index) - add a column of default data at the given index (optional - at end of info if not provided)
addRow(index) - add a row of default data at the given index (optional - at end of info if not provided)
update() - updates data, colors and pieces for currently visible board
	call this if the info is manually updated with array manipulation
getTile(col, row) - get the tile at a given col and row
	isometric has cols from top to right and rows from top to left
getRandomTile(filter**) - get a random tile
	or a random tile within a filtered set - see **FILTER at top of METHODS
getIndexes(tile) - get an object with col and row properties for tile
	isometric has 0,0 is at top of board with cols going to right and rows going to left
getPoint(a,b) - get tile point (x, y) in items container
	a is either tile (leave b blank) or pass in i and j info indexes
getGlobalPoint(a,b) - get the tile point (x, y) on global stage
	a is either tile (leave b blank) or pass in i and j info indexes
getInfo(a,b) - get the info object for a tile {data:data, color:color, items:[items]}
	a is either tile (leave b blank) or pass in i and j info indexes
getData(a,b) - get the data for a tile
	a is either tile (leave b blank) or pass in i and j info indexes
getColor(a,b) - get the color for a tile
	a is either tile (leave b blank) or pass in i and j info indexes
getIcon(a,b) - get the icon for a tile
	a is either tile (leave b blank) or pass in i and j info indexes
getItems(a,b) - get the items array for a tile
	a is either tile (leave b blank) or pass in i and j info indexes
getAllItems(filter**) - get an array of all items
	or pass in a filter to get a filtered set - see **FILTER at top of METHODS
getTilesAround(a,b) - get an array of tiles around a tile [8 items clockwise from top]
	a is either tile (leave b blank) or pass in i and j info indexes
setData(tile, value) - set the data for a tile
setColor(tile, color) - set the color of a tile
	for setting items on the board use add() method
	for setting items off the board or for setting the info
	use board.info[j][j] = {data:data, color:color, items:[item, item, etc.]}
setIcon(tile, icon) - set the icon for the tile - also see icons parameter
clearInfo(filter**) - clear all the info or a filtered set - see **FILTER at top of METHODS
clearData(filter**) - clear all the info data or a filtered set - see **FILTER at top of METHODS
clearColors(filter**) - clear all the colors (to default color) or a filtered set - see **FILTER at top of METHODS
clearIcons(filter**) - clear all the icons (to default icon) or a filtered set - see **FILTER at top of METHODS
clearItems(filter**) - clear all the items or a filtered set - see **FILTER at top of METHODS
setArrows() - sets arrows to handle moving camera
	these will automatically be show when needed (info is bigger than cols or rows)
removeArrows() - remove arrows
setArrowHover() - update hover - ZIM will do this automatically
setDepth() - set the stacking order of an item in items - ZIM will do this automatically
add(obj, col, row, data, color, icon) - add a DisplayObject to the board
	this adds the object to the items container - and adds various properties (so do not addTo manually)
	data is additional data - for instance that could be used in path finding
	icon is any DisplayObject that will be centered in the Rectangle of the tile
	set icon.type to be included in the filters - for instance, icon.type = "stone", icon.type = "trap"
remove(obj) - removes an object from the board
position(obj, col, row) - position an item at the col and row on the board
	to position an object off the board remove the object and use board.info[j][i].items.push(obj);
	the board will add the object when it needs to be shown
move(obj, cols, rows, time) - (relative) animates or places object a certain number of rows or cols on the board
	time (default .5s) is the seconds to move ONE square!  Also see ZIM TIME constant
moveTo(obj, col, row, time) - (absolute) animates or places object to a certain row or col on the board
	time (default .5s) is the seconds to move ONE square!  Also see ZIM TIME constant
showPath(path, time) - shows path indicators for a path
	path has a format of [[x,y],[x,y]] or [{x:col, y:row}, {etc.}, {etc.}]
	This accommodates an EasyStar path - see https://zimjs.com/iso/
	time is in seconds.  Also see ZIM TIME constant
clearPath() - clears the path
followPath(obj, path, time, animation, buffer) - animates object along a provided path
	path has a format of [[x,y],[x,y]] or [{x:col, y:row}, {etc.}, {etc.}]
	time (default .6s) is how long to take from one step to the next.  Also see ZIM TIME constant
	animation (default .3s) is how long to animate to get to the next step.  Also see ZIM TIME constant
	buffer (default 0) how many tiles from the edge before the camera is nudged
		a buffer of 0 will not nudge the camera
		but if the camera is moved, the path could lead the item off the board
		which is fine - if that is what is desired
stopFollowPath() - stops animation along path
shiftPath(lastStartX, startX, lastStartY, startY, obj) - move the path
	lastStartX is board startX before shifting and startX is the new board startX - same for y
	As the camera or board moves, the path coordinates need to change too
	ZIM does this automatically when using arrows or swiping and a path is visible
addKeys(obj, type, filter**) - add keyboard control to item - type is "arrows" or "wasd"
	optionally pass in a filter object - see **FILTER at top of METHODS
	to limit the parts of the board the item can be keyed to
	for instance, {data:["x", "g"]} allows moving to tiles with info data of "x" or "g" but not anything else
	Note: followPath() can only follow data so to sync these use the data filter
	Note: to change the filter, use removeKeys() and then addKeys() with a different filter
removeKeys(type) - remove the keyboard controls for a certain type - "arrows" or "wasd"

NOTE: the Board extends a zim.Container so also has all container methods

PROPERTIES
type - a reference to the type of object as a string
tiles - a reference to the ZIM Tile object that makes the board
pieces - a reference to the ZIM Container that holds all items on the board
num - a read only number of rows and cols in the board
size - a read only width and height of the tile (before isometrics applied)
info - the info array of rows and cols - see the info parameter for more... info
	when making an update to info, the update() method will be needed to see a change in the board
	note: using the arrows or swiping will automatically update so items off screen do not need updating
data - an array of rows and cols that represents the info's data property of the current board squares
	this can be passed in to path finding such as EasyStar to find a path on the board
	note: this is info data only for the tiles, not all of the info data from the info array
numCols - the total number of columns in the info (not the board)
numRows - the total number of rows in the info (not the board)
startCol - the index of the info to place at the left of the board
	this is one way to move the board and is used by the arrows and swiping
	also see the positionBoard(col, row) method
startRow - the index of the info to place at the top of the board
buffer - get or set how many squares moving item is from edge before camera is nudged
arrows - Boolean to get or set the arrows - if true, arrows will be applied when needed
isometric - get or set the isometric (true) or flat (false) view of the board
	the board is scaled up 20% going from iso to flat and down 20% going from flat to iso
	this just helps it visually appear similar in size
currentTile - a reference to the selected tile
lastTile - a reference to the tile selected before the current selected tile
path - a reference to the visible path if there is one showing

PROPERTIES for Tile
boardCol - the visible column index of the tile
boardRow - the visible row index of the tile

PROPERTIES for item
boardCol - get the visible column index of the tile (negative if left of board)
boardRow - get the visible column index of the tile (negative if right of board)
moving - get whether the item is moving (also moving event on board)
nextCol - after movingstart event, get the next visible column index of the tile (negative if left of board)
nextRow - after movingstart event, get the visible column index of the tile (negative if right of board)
boardTile - get the tile under the item
square = a string of "row-col" - so "0-0", "0-1", "0-2", etc. and "3-2" is third row, second column

NOTE: the Board extends a zim.Container so also has all container properties

EVENTS
dispatches a "change" event on board for each time a different tile is selected or rolled over
dispatches a "positioned" event on item when item is finally placed on a tile
dispatches a "movingstart" event on item when item starts being animated from tile to tile
dispatches a "moving" event on item when item is being animated from tile to tile
dispatches a "movingdone" event on item when item is finished being animated (500ms delay)
--*///+110

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-110

/*--
zim.Person = function(shirt, pants, head, outline, player, cache)

Person
zim class - extends a zim.Container which extends a CreateJS Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A very generic person in isometric view sized to work with ZIM Board

See: https://zimjs.com/iso/ for a full example

EXAMPLE
const board = new Board().center();
board.add(new Person(), 5, 4); // random person
// or specify:
board.add(new Person(green,brown,dark), 4, 5);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
shirt - (default random ZIM color) the shirt color - any CSS color is fine "gold", "#C33", etc.
pants - (default random ZIM color) the pants color
head - (default random skin color) the head color
outline - (default dark) the outline color for the head
player - (default false) set to true if main player - then type="Me" not "Player"
cache - (default false) probably only cache if lots of players

PROPERTIES
type - either "Person" or "Me" if player parameter is true
** If added to ZIM Board receives these properties:
boardCol - get the visible column index of the tile (negative if left of board)
boardRow - get the visible column index of the tile (negative if right of board)
moving - get whether the item is moving (also moving event on board)
boardTile - get the tile under the item
square = a string of "row-col" - so "0-0", "0-1", "0-2", etc. and "3-2" is third row, second column

Plus all the methods and properties of a ZIM Container and CreateJS Container
Note: if added to a ZIM Board, use the Board methods to manipulate
--*///+115

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-115

/*--
zim.Orb = function(radius, color, color2, accentColor, accentColor2, flat, alpha, time, delay)

Orb
zim class - extends a zim.Container which extends a CreateJS Container

DESCRIPTION
A very generic orb with two styles - flat and shaded
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

See: https://zimjs.com/iso/ for a full example

EXAMPLE
const board = new Board().center();
board.add(new Orb(), 2, 2); // flat
// or shaded with pulse:
board.add(new Orb({flat:false, color2:pink, accentColor2:white, delay:5000}), 4, 2);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
radius (default 16 flat or 22 not) - the radius of the orb
color (default blue flat or purple not) - the color of the orb - any CSS color is fine too
color2 (default darker flat or null (color) not) - core color if flat, pulse color if shaded
accentColor (default null flat or pink not) - border color if flat, highlight color if shaded
accentColor2 (default null) - border color of core if flat, highlight color of pulse if shaded
flat (default true) - set to false to see shaded orb
alpha (default .5) - the alpha to animate the color to if flat (keeps core) or the pulse to if shaded
time (default 1s) - the time to animate the pulse (shaded only).  Also see ZIM TIME constant
delay (default 1s) - the delay until the animation of the pulse happens (shaded only).  Also see ZIM TIME constant

PROPERTIES
type - "Orb"
** If added to ZIM Board receives these properties:
boardCol - get the visible column index of the tile (negative if left of board)
boardRow - get the visible column index of the tile (negative if right of board)
color - the color of the orb 
color2 - the color2 of the orb
moving - get whether the item is moving (also moving event on board)
boardTile - get the tile under the item
square = a string of "row-col" - so "0-0", "0-1", "0-2", etc. and "3-2" is third row, second column

Plus all the methods and properties of a ZIM Container and CreateJS Container
Note: if added to a ZIM Board, use the Board methods to manipulate
--*///+120

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-120

/*--
zim.Tree = function()

Tree
zim class - extends a zim.Container which extends a CreateJS Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A very generic tree in isometric view sized to work with ZIM Board

See: https://zimjs.com/iso/ for a full example

EXAMPLE
const board = new Board().center();
board.add(new Tree(), 6, 6);
END EXAMPLE

PROPERTIES
type - "Tree"
** If added to ZIM Board receives these properties:
boardCol - get the visible column index of the tile (negative if left of board)
boardRow - get the visible column index of the tile (negative if right of board)
moving - get whether the item is moving (also moving event on board)
boardTile - get the tile under the item
square = a string of "row-col" - so "0-0", "0-1", "0-2", etc. and "3-2" is third row, second column

Plus all the methods and properties of a ZIM Container and CreateJS Container
Note: if added to a ZIM Board, use the Board methods to manipulate
--*///+125

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-125

/*--
zim.Timer = function(time, step, colon, down, isometric, startPaused, size, font, color, backgroundColor, borderColor, borderWidth, align, valign, bold, italic, variant, width, height, decimals)

Timer
zim class - extends a zim.Label which extends a CreateJS Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A timer that can count up or down and be set to isometric

See: https://zimjs.com/iso/ for a full example

EXAMPLE
const timer = new Timer({
	time:60,
	borderColor:dark,
	isometric:LEFT // isometric for left side of board
}).loc(100,100);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
time - (default 60) time in seconds to start the timer
step - (default 1) step in s to show a change in timer
colon - (default false) add colon and seconds eg. 1:30 instead of 90 seconds
down - (default true) set to false to count up
isometric - (default null) set to LEFT or RIGHT to position an isometric timer
startPaused - (default false) set to true to start the timer paused - then use timer.start(num)
size - (default 36) the size of the font in pixels
font - (default arial) the font or list of fonts for the text
color - (default black) color of font (any CSS color)
backgroundColor - (default yellow) color of background (any CSS color)
borderColor - (default null) the color of the border
borderWidth - (default null) thickness of the border
align - ((default CENTER) text registration point alignment also LEFT and RIGHT
valign - (default CENTER) vertical registration point alignment alse "middle / center", "bottom"
borderColor - (default null) the color of the border
borderWidth - (default null) thickness of the border
bold - (default false) set the font to bold
italic - (default false) set the font to italic
variant - (default false) set to true to set the font to "small-caps"
width - (default 150) the width of the timer - can also leave defaults and scale timer
height - (default 60) the height of the timer
decimals - (default 1 when no colon) the places parameter to pass to zim decimals internally

METHODS
start(time) - start the timer
pause(state) - state defaults to true to pause, set to false to unpause
stop() - stop the timer and set paused to null - does not change time property

PROPERTIES
type - "Timer"
time - get or set the time of the timer
totalTime - get the start time of the timer
paused - get or set the paused state of the timer with Boolean true or false
isometric - get or set the isometric - false, LEFT, RIGHT
intervalID - access to the intervalID of the timer - use clearInterval(timer.intervalID)

Plus all the methods and properties of a ZIM Label and CreateJS Container

EVENTS
Dispatches a "step" event for each step the timer takes
Dispatches a "complete" event when the timer counts down to 0
there is no complete event for counting up - use logic in step event function to handle that
--*///+130

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-130

/*--
zim.Scorer = function(score, isometric, size, font, color, backgroundColor, borderColor, borderWidth, align, valign, bold, italic, variant, width, height)

Scorer
zim class - extends a zim.Label which extends a CreateJS Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A score label with backing set and isometric settings

See: https://zimjs.com/iso/ for a full example

EXAMPLE
const scorer = new Scorer({backgroundColor:yellow, color:black, isometric:RIGHT}).loc(W-100,100);
END EXAMPLE

PARAMETERS supports DUO - parameters or single object with properties below
score - (default 0) set the start score
isometric - (default null) set to LEFT or RIGHT to position an isometric scorer
size - (default 36) the size of the font in pixels
font - (default arial) the font or list of fonts for the text
color - (default black) color of font (any CSS color)
backgroundColor - (default green) the color of the background (any CSS color)
borderColor - (default null) the color of the border
borderWidth - (default null) thickness of the border
align - ((default CENTER) text registration point alignment also LEFT and RIGHT
valign - (default CENTER) vertical registration point alignment also MIDDLE / CENTER, "bottom"
bold - (default false) set the font to bold
italic - (default false) set the font to italic
variant - (default false) set to true to set the font to "small-caps"
width - (default 150) the width of the scorer - can also leave defaults and scale scorer
height - (default 60) the height of the scorer

PROPERTIES
type - "Scorer"
score - get or set the score
isometric - get or set the isometric - false, LEFT, RIGHT

Plus all the methods and properties of a ZIM Label and CreateJS Container
--*///+135

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-135
	
/*--
zim.Dialog = function(width, height, words, dialogType, tailType, fill, size, font, color, backgroundColor, borderColor, borderWidth, align, valign, corner, shadowColor, shadowBlur, padding, paddingH, paddingV, shiftH, shiftV, slantLeft, slantRight, slantTop, slantBottom, tailH, tailV, tailShiftH, tailShiftV, tailShiftAngle, arrows, arrowsInside, arrowsFlip, selectedIndex)

Dialog
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_game - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Shows a Dialog in various formats with or without a tail.
This can have multiple sets of words to show with optional arrows.
The text can be made to fill the dialog - use padding to make it fit well due to corners.
Or a if fill is turned off then use a font size to keep constant size across word sets.

The dialogTypes are slant (default), rectangle (can have corners set), oval and poly.
The tailTypes are triangle (default), line, circles and none.

SEE: https://zimjs.com/nft/bubbling/dialog.html

NOTE: the Dialog backing is made up of multiple shapes to get a proper border effect
if an alpha is desired then cache the backingContainer and set its alpha

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
const dialog = new Dialog(300,200,"HELLO!").center();
END EXAMPLE

EXAMPLE
const words = [
	"Welcome, Creators!", 
	"To ZIM NFT 01", 
	"We have a new Dialog"
];

STYLE = {lineHeight:35}
new Dialog({
	width:300,
	height:200,
	words:words,
	dialogType:"rectangle",
	tailType:"line",
	fill:false,
	size:30,
	font:"Comic Sans MS",
	color:dark,
	backgroundColor:yellow,
	borderColor:grey,
	borderWidth:2,
	corner:100,
	padding:50,
	tailH:RIGHT,
	tailV:BOTTOM 
}).pos(100,50,LEFT,TOP);
END EXAMPLE

EXAMPLE
const dialog = new Dialog(300,200,"HELLO!").center();
dialog.backingContainer.cache().alp(.5); // adjusting alpha of backing
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
width - (default 640) width of dialog
height - (default 480) height of dialog
words - (default "HELLO!") words to say in the dialog - or an array of words 
	if an array is chosen then arrows will be added (unless arrows is set to false)
	arrows can be used to go to sets of words - or use selectedIndex property to change
	the setWords() method can be used to change the words in a Dialog 
dialogType - (default "slant") the shape of the dialog box
	set to slant will make a slanted box that can be controlled with slantLeft, slantRight, slantTop, slantBottom parameters
	set to "rectangle" for dialog box.  Can use corner of half the height to make a longer rounded box 
	set to "oval" for traditional speach bubble - use width and height to adjust 
	set to "poly" for a Pow! dialog - probably set the tailType to "none"
tailType - (default "triangle") the shape of the tail of the dialog 
	types are "triangle", "line", "circles" or "none"
	circles gives a thought bubble 
	the tail can be positioned with tailH and tailV parameters 
	the tail can be shifted with  tailShiftH, tailShiftV and tailShiftAngle
fill - (default true) set to false to not fill the dialog with text 
	when true, use the padding (or paddingH and paddingV) to addjust the size of the text in the dialog
	fill of true will ignore size 
size - (default 40) the size of the font
	size is ignored if fill is set to true
font - (default "verdana") the font of the text
color - (default dark) the color of the text
backgroundColor - (default light) the color of the dialog box
borderColor - (default dark) the border color of the dialog box 
	set the border color to -1 to have no border
borderWidth - (default 3) the size of the border
	set the borderWidth to 0 to have no border
align - (default CENTER) the horizontal alignment of the text (also LEFT and RIGHT)
	see also shiftH
valign - (default CENTER) the vertical alignment of the text (also TOP and BOTTOM)
	see also shiftV
corner - (default 0) the corner of rectangle with the "rectangle" dialogType set
	can also be an array of [leftTop, rightTop, rightBottom, leftBottom]
shadowColor - (default rgba(0,0,0,.3)) the shadow color 
	set to -1 for no shadow
shadowBlur - (default 10) the shadow blur
padding - (default 20) the padding between the border of the dialog and the text
paddingH - (default padding) the vertical horizontal
paddingV - (default padding) the vertical padding
shiftH - (default 0) an amount (+ or -) to shift the text horizontally after it is placed
shiftV - (default 0) an amount (+ or -) to shift the text vertically after it is placed
slantLeft - (default -10) when dialogType "slant" is chosen, relative angle to slant the left side 
slantRight - (default 10) when dialogType "slant" is chosen, relative angle to slant the right side 
slantTop - (default -10) when dialogType "slant" is chosen, relative angle to slant the top side  
slantBottom - (default 10) when dialogType "slant" is chosen, relative angle to slant the bottom side  
tailH - (default LEFT) where to put the tail in the horizontal - options are LEFT, CENTER, RIGHT
	also see the tail property and the three tailShift parameters
tailV - (default BOTTOM) where to put the tail in the vertical - options are BOTTOM, CENTER, TOP 
	also see the tail property and the three tailShift parameters
tailShiftH - (default 0) an amount (+ or -) to shift the tail horizontally after it is placed
tailShiftV - (default 0) an amount (+ or -) to shift the tail vertically after it is placed
tailShiftAngle - (default 0) an amount (+ or -) to shift the tail angle after it is placed
arrows - (default false - true if words is array) set to false to not show arrows
	also see the arrowNext and arrowPrev property
arrowsInside - (default false) set to true to show arrows inside the dialog
	to shift the arrows afterwards, use the arrowNext and arrowPrev properties along with mov()
arrowsFlip - (default false) make the next arrow on the left and the prev arrow on the right
selectedIndex - (default 0) set the selected index of the word groups if words is an array 
	also see the selectedIndex property

METHODS
setWords(words, selectedIndex) - pass in a string of words to show or an array
	this will change the words in the dialog 
	also pass in an optional index to jump to
	returns object for chaining
next() - go to next words - returns object for chaining
	see also selectedIndex property
prev() - go to previous words - returns object for chaining
	see also selectedIndex property
clone() - clone the dialog
dispose() - remove the dialog and its parts

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
color - get or set the color of the text
backgroundColor - get or set the backgroundColor of the dialog
	// see backingContainer for setting alpha
borderColor - get or set the borderColor of the dialog
	// NOTE: must start with border when object made to then change a borderColor
backingContainer - a reference to the container that holds all the backing 
	including backing, backingShadow and tail
	cache this and set its alpha if a different alpha is desired 
	otherwise all the parts keep overlapping alpha and revealed
backing - reference to backing of dialog
backingShadow - if a shadow is set then this is the container that holds a clone of the backing and tail 
	and then it is cached and a shadow added
label - the ZIM Label with the current text
labels - an array of ZIM labels matching the words 
words - an array of sets of words in the dialog - if only one set of words then the words are words[0]
selectedIndex - get or set the index of the word sets (will adjust arrows if there are arrows)
tail - reference to the tail object
arrows - reference to the container that holds both arrows
arrowNext - reference to the next arrow
arrowPrev - reference to the prev arrow

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "change" event when arrows are pressed to go to next or prev page 

See the CreateJS Easel Docs for Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+136

	// THE CODE FOR THE GAME MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-136

////////////////  ZIM THREE  //////////////

// the Three section is for the ZIM Three helper library

/*--
zim.Three = function(width, height, color, cameraPosition, cameraLook, interactive, resize, frame, ortho, textureActive, colorSpace, colorManagement, legacyLights, throttle, lay, full, xr, VRButton, xrBufferScale)

Three
zim class
** MUST import zim_three - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
three.js is a 3D JavaScript Library at https://threejs.org.
The ZIM Three class along with the ZIM three.js helper module
will make a three.js renderer, scene and camera
that are integrated into ZIM with the DOMElement from CreateJS.
The Three class handles positioning, scaling and resizing.
Or, the Three class can be used to help show ZIM in threejs 
as an interactive and animated canavs texture.
See also TextureActive and TextureActives in the main ZIM docs.

three.js examples - with three.js inside ZIM
https://zimjs.com/bits/view/three.html
https://zimjs.com/three/
https://codepen.io/zimjs/pen/abzXeZX
https://codepen.io/zimjs/pen/qGPVqO

TextureActive examples - with ZIM inside three.js
https://zimjs.com/015/textureactive.html 
https://zimjs.com/015/textureactive2.html 
https://zimjs.com/015/textureactive3.html 
https://zimjs.com/015/textureactive4.html 
https://zimjs.com/015/textureactive5.html 
https://zimjs.com/015/textureactive_hud.html 
https://zimjs.com/015/textureactive_hud_raw.html 
https://zimjs.com/015/textureactive_raw.html 

ZIM in VR
https://zimjs.com/015/vr.html - use triggers (drag), sticks (motion) and b and y buttons (teleport)  

Z-Dog is a quick alternative for three.js - here are a couple examples
https://codepen.io/zimjs/pen/joXxGJ
https://codepen.io/zimjs/pen/rgEEXy

NOTE as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// up top after loading CreateJS and ZIM add the latest versions of these files
// https://zimjs.org/cdn/r109/three.min.js
// https://zimjs.org/cdn/r109/OrbitControls.js
// https://zimjs.org/cdn/three_2.2.js

// In the ZIM Frame create a backing rectangle that will show where the three.js scene is
new Rectangle(500,500,dark).center();

// Create the Three object and scene (just store that in an easy variable)
// We set threejs interactive so we can use three.js orbit controls (needs a separate file imported)
// In the above examples at the URLs, we use a ZIM Swiper instead
const three = new Three({frame:F, width:500, height:500, interactive:true});
const scene = three.scene;

// Here we make a three.js Cube - note the THREE namespace
// There are all sorts of Geometries (shapes) - see the three.js Docs
// We will give each side a color using a Material
const geometry = new THREE.CubeGeometry(100, 100, 100);
const materials = [];
// x+,x-,y+,y-,z+,z- (+x right, +y up and +z out)
const colors = [green, blue, brown, yellow, orange, pink];
loop(colors, color=> {
	materials.push(new THREE.MeshBasicMaterial({color:color, side:THREE.FrontSide}));
});

// We mesh the Geometry and the Material to get a Mesh object that we put on the Scene
const mesh = new THREE.Mesh(geometry, materials);
mesh.position.set(0,0,0);
scene.add(mesh);

// Here we add optional the three.js OrbitControls
const controls = new THREE.OrbitControls(three.camera, three.renderer.domElement);

// This is an example of controlling the three.js object with ZIM
// Remember that rotation in three.js is in Radians so multiply degrees by ZIM RAD
const dial = new Dial({min:0, max:360, step:0, continuous:true}).pos(70,0,LEFT,CENTER).change(()=>{
	mesh.rotation.y = dial.currentValue*RAD;
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
width - (default ZIM Frame width) the width to make the three.js canvas
height - (default ZIM Frame height) the height to make the three.js canvas
color - (default null - transparent) a CSS color (no transparency on color - just leave off to set transparent)
cameraPosition - (default new THREE.Vector3(0, 200, 200)) to position the camera in x, y and z
cameraLook - (default scene.position) where the camera should look
interactive - (default false) set to true to be able to use addEventListener on three.js canvas rectangle
	note: you will not be able to use ZIM interaction that overlaps the three.js canvas
	note: this will be set to true if textureActive is true
resize - (default true) set to false to not automatically resize (position and scale three object)
frame - (default the zimDefaultFrame) the ZIM Frame object
ortho - (default false) set to true to add an orthographic camera basically a flat scene 
	the normal camera is there still but the ortho camera sits on top from z depth of 0 to 10 
	this is good for HUD elements around the edges of scene or a pop-up panel, etc.
textureActive - (default false) set to true to configure proper scaling for TextureActive objects 
	where ZIM is inside three.js on textures
	also see the makePanel() and flipMaterial() methods below
	also overrides interactive and sets it as true
colorSpace - (default THREE.LinearSRGBColorSpace) set to THREE.SRGBColorSpace, etc.
	https://threejs.org/docs/#manual/en/introduction/Color-management
colorManagement - (default false) set to true to activate three.js colorManagement 
	https://threejs.org/docs/#manual/en/introduction/Color-management
legacyLights - (default false) set to true to activate legacyLights - depricated
throttle - (default false) set to a whole number like 2 to only update every second requestAnimationFrame
lay - (default null) set to OVER or UNDER to overlay or underlay full window three.js
	Also use interactive:true for interacting with three.js or interactive:false for interacting with ZIM 
full - (default false) set to true to force three.js to full window
	Use ZIM in Frame scaling:FULL and ZIM Central() to match ZIM scaling with three.js fullscreen scaling
	See: https://zimjs.com/three/central.html
xr - (default false) set to true to make the renderer prepared for XR (AR/VR)
	this works with TextureActive as well
	also see XRControllers(), XRMovement() and XRTeleport() classes
VRButton - (default true if xr is true and will add a VRButton if using zim_three import) adds an ENTER VR button 
	or pass in the VRButton class from three.js if not using the zim_three import
xrBufferScale - (default 2) magnification of scene - 2 makes for better quality in VR

METHODS
position(x, y) - position the three.js canvas (registration point in center) to the stage coordinates
scale(s) - (default 1) scale the three.js canvas relative to the stage scale
rotateAroundAxis(obj, axis, radians) - rotates an obj around a world axis (THREE.Vector3(x,y,z)) a certain amount of Radians
rotateAroundObjectAxis(obj, axis, radians) - rotates an object around an internal axis (THREE.Vector3(x,y,z)) a certain amount of Radians
makePanel(textureActive, textureActives, scale, curve, opacity, material, doubleSide, colorSpace) | supports DUO
	used for textureActives to make a panel based on the tetureActive size
		textureActive - a ZIM TextureActive object see https://zimjs.com/docs.html?item=TextureActive 
		textureActives - a ZIM TextureActives object see https://zimjs.com/docs.html?item=TextureActives 
		scale (default .5) change to adjust the width and height of the geometry 
		curve (default null) change the z amount to curve the geometry - also can use negative amount
		opacity (default 1) change to set the opacity of the material, can also set opacity on the TextureActve
		material (default THREE.MeshBasicMaterial) a three.js material 
			example THREE.MeshPhongMaterial, THREE.MeshLamberMaterial - both these need lights
		doubleSide (default false) set to true to do double sided material
		colorSpace (default null) see https://threejs.org/docs/#manual/en/introduction/Color-management
	returns a three.js mesh with the textureActive object set as a CanvasTexture 
	This will also have the TextureActives.addMesh() method applied with the layer matching the TextureActives layer setting
	All this can be done manually in three.js - it is just a wrapper function to make panels 
	See https://zimjs.com/015/textureactive_raw.html for a manual example - scroll down to the THREE section and see MENU
	** if being used for a HUD in sceneOrtho then see the pos() method below for METHODS ON MESH
posMesh(mesh, x, y, horizontal, vertical, gutter) - use for sceneOrtho makePanel meshes
	position a mesh on the sceneOrtho around the edges or middle as follows:
		x - default 0 - the distance in the x
		y - default 0 - the distance in the y
		horizontal - default LEFT - set to LEFT, CENTER, RIGHT to specify where the distance is applied horizontally
		horizontal - default TOP - set to TOP, CENTER, BOTTOM to specify where the distance is applied vertically 
		gutter - default 0 - distance in the horizontal middle to keep left and right away from each other 
			the left and right will stop squeezing and possibly go off the screen when the window is reduced
flipMaterial(materialType, params) - flip about the y access a material 
	This will set the userData.ta_flipped to true which guides the TextureActives raycasting on the UV x coordinate
	The params are the regular parameter object that would be passed to the material such as color, map, transparency, alpha, etc.
	Used primarily on a THREE.BoxGeometry where the back of the box by default is flipped so words would be backwards... this puts them frontwards
	See https://zimjs.com/015/textureactive4.html scroll down to the THREE section and see PICKERS
	Note a second texture must be made and passed to flipMaterial in the params as the map
curvePlane(geometry, z) - curves a THREE.PlaneGeometry but a z value (positive or negative)
	adjusts the Geometry in place -	used internally by makePanel
dispose() - clears geometries, materials, stops the renderer, removes scene and sets internal variables to null 
	make sure the three reference is set to null:
		myThree.dispose();
		mythree = null; // same for any dispose - ZIM cannot set your variables to null
METHODS ON MESH 
pos(x,y,horizontal,vertical,gutter) - DEPRECATED - see posMesh() method

PROPERTIES
renderer - the three.js WebGLRenderer (see three.js Docs)
preRender - a function to call just before rendering
	three.preRender = ()=>{controls.update();} // will run in renderer just before rendering
postRender - a function to call just after rendering
	three.postRender = ()=>{controls.update();} // will run in renderer just after rendering
canvas - the HTML canvas tag for the three.js scene with id=zimThree0 for first, zimThree1 for second, etc.
	can use if you need to set z-index for multiple three canvas objects
DOMElement - the CreateJS DOMElement object - see CreateJS EaselJS docs
scene - the three.js scene object created (see three.js Docs)
sceneOrtho - the three.js orthographic scene if ortho is set to true
	this has a near/far setting of 0/10 so the z value of an object in this scene must be between 0 and 10
camera - the three.js PerspectiveCamera object created (See the three.js Docs)
cameraOrtho - the three.js OrthographicCamer object if orth is set to true
resizeEvent - a handle to the resize event so it can be cleared:
	F.off("resize", threeObj.resizeEvent);
	then make your own resize event to custom position and scale your three object
	use threeObj.position() and threeObj.scale() see ZIM Bits example
vrButton - reference to the VRButton if xr and VRButton is true

--*///+140

	// THE CODE FOR THE THREE MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-140

/*--
zim.XRControllers = function(three, type, color, highlightColor, lineColor, lineLength, threshhold)

XRControllers
zim class - extends a createjs.EventDispatcher
** MUST import zim_three - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Adds XR (AR/VR) controllers to three.js.
This comes with built in ZIM controllers or can pass in three.js controllers.
ZIM Controllers are laser, pen, gun, raygun and sword or line.
They will highlight when trigger is pressed.
They provide events for all the buttons and axes.
See https://zimjs.com/015/vr/controllers.jpg for details.
The XRControllers object holds controller1 and controller2.
Both are not required, an array of two items can be used as type input.
Passing in -1 will not make a controller.
The XRControllers object can be passed to XRMovement() and XRTeleport() to handle motion.

There is a three.js class that will mimic the best model for the actual controllers.
import { XRControllerModelFactory } from 'three/addons/webxr/XRControllerModelFactory.js';
and then you have to use the whole GitHub structure of three.js to get them to work.
See: https://github.com/mrdoob/three.js/blob/dev/examples/webxr_vr_teleport.html
The three.js controller objects you can then pass in to type:[obj, obj]

SEE: https://zimjs.com/015/vr.html and use triggers (drag), sticks (motion) and b and y buttons (teleport)  

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// import zim_three
const three = new Three({
	width:window.innerWidth, 
	height:window.innerHeight, 
	cameraPosition:new THREE.Vector3(0,3,6),
	textureActive:true, // if wanting TextureActives
	xr:true 
});

// make skybox, add meshes to scene, etc.
// might add a floor mesh 

// xrControllers parameters: 
// three, type, color, highlightColor, lineColor, lineLength, threshhold

const xrControllers = new XRControllers(three, "laser"); // "laser" is default

xrControllers.on("xrconnected", () => {

	// wait for controllers to connect before adding movement and teleport
	
	// XRMovement parameters: 
	// three, XRControllers, speed, acceleration, rotationSpeed, rotationAcceleration, hapticMax, verticalStrafe, radiusMax
	var xrMovement = new XRMovement(three, xrControllers);

	// XRTeleport parameters: 
	// three, XRControllers, XRMovement, floor, offsetHeight, button, hand, markerColor, markerBlend
	new XRTeleport(three, xrControllers, xrMovement, floor, 4); // top front round buttons (B and Y)

	// note: to teleport through a mesh, set the mesh.userData.xrteleportignore = true;

});   
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
three - the ZIM Three object
type - (default "laser") type of controllers or an array of [type, type]
	can be: laser, pen, gun, raygun, sword, line or -1 in the array. 
	or can be a three.js model from XRControllerModelFactory
	if using a three.js model, must use the array with the desired model objects
	any of these can be a mix or just one (set the other to -1)
color - (default light) set the color of the material (can also be an array for left and right)
highlightColor - (default ["violet", blue]) an array for the highlight colors
lineColor - (default light) set the color of the line or use an array for left and right
lineLength - (default 5) the line length or pass in an array for left right 
	one day, this may adjust to whatever it is hitting
threshhold - (default .2) a sensitivity filter - use a higher number to avoid drift

METHODS
dispose() - remove controllers

PROPERTIES
type - name of class as a string
XR - read only - will be true when XR is active (see xrconnected event)
controller1 - a reference to the renderer.xr.getController(0)
controller2 - a reference to the renderer.xr.getController(1)
threshhold - get or set the controller threshhold

Controller properties:
grip - if a three.js model is provided, it is stored in a grip three.js Group 
holder - if a ZIM controller are used it is stored in a holder three.js Group 
gamepad - lots of data once the xrconnected event is triggered
userData.highlights - an array of materials to change to the highlight color
	this already will have materials so perhaps use push()

EVENTS (also see GENERAL EVENTS)
xrconnected - dispatched when XR controllers connect - has an event object with data property
xrdisconnected - dispatched when XR controllers disconnect
** below events have the following event object (eg. e) properties:
	e.controller - the controller
	e.num - the number of the button - see https://zimjs.com/015/vr/controllers.jpg
		0 - trigger 
		1 - squeeze 
		2 - touchpad (basic only - not complex controllers)
		3 - top of stick 
		4 - A or X raised button on top 
		5 - B or Y raised button on top 		
	e.hand - "left" (controller1) or "right" (controller2)
	e.value - normalized number from 0-1 of touch pressure
pressdown - dispatched when any XR controller button is down
pressup - dispatched when any XR controller button is up
touchstart - dispatched when XR controller touch starts
touchend - dispatched when XR controller touch ends
** the axes event object (eg. e) has an additional property to the above
** to tell if the value is horizontal or vertical
	e.dir - "horizontal" or "vertical"
axes - dispatched when XR controller stick pushed 

GENERAL EVENTS 
selectstart - dispatched when either controller trigger is pressed down
selectend - dispatched when either controller trigger is pressed up
move - dispatched when either controller is moved
controllerleftdown - dispatched when left XR controller trigger is pressed down
controllerrightdown - dispatched when right XR controller trigger is pressed down
controllerleftup - dispatched when left XR controller trigger is pressed up
controllerrightup - dispatched when right XR controller trigger is pressed up
controllerleftmove - dispatched when left XR controller is moving
controllerrightmove - dispatched when right XR controller is moving
--*///+140.22

	// THE CODE FOR THE THREE MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-140.22

/*--
zim.XRMovement = function(three, XRControllers, speed, acceleration, rotationSpeed, rotationAcceleration, hapticMax, verticalStrafe, radiusMax, threshhold, directionFix, boxMax, rotationAngle, rotationInterval)

XRMovement
zim class
** MUST import zim_three - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Adds XR (AR/VR) movement to three.js.
Pass in ZIM XRControllers and use thumbsticks to move.
By default both hands move forward and backwards with vertical stick motion.
The left hand strafes left and right with horizontal stick motion.
The right hand rotates left and right with horizontal stick motion.
The squeeze (handle grips) will increase the speed.
Pressing the left thumbstick top will reset the position.

SEE: https://zimjs.com/015/vr.html and use triggers (drag), sticks (motion) and b and y buttons (teleport)  

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// import zim_three
const three = new Three({
	width:window.innerWidth, 
	height:window.innerHeight, 
	cameraPosition:new THREE.Vector3(0,3,6),
	textureActive:true, // if wanting TextureActives
	xr:true 
});

// make skybox, add meshes to scene, etc.
// might add a floor mesh 

// xrControllers parameters: 
// three, type, color, highlightColor, lineColor, lineLength, threshhold

const xrControllers = new XRControllers(three, "laser"); // "laser" is default

xrControllers.on("xrconnected", () => {

	// wait for controllers to connect before adding movement and teleport
	
	// XRMovement parameters: 
	// three, XRControllers, speed, acceleration, rotationSpeed, rotationAcceleration, hapticMax, verticalStrafe, radiusMax
	var xrMovement = new XRMovement(three, xrControllers);

	// XRTeleport parameters: 
	// three, XRControllers, XRMovement, floor, offsetHeight, button, hand, markerColor, markerBlend
	new XRTeleport(three, xrControllers, xrMovement, floor, 4); // top front round buttons (B and Y)

	// note: to teleport through a mesh, set the mesh.userData.xrteleportignore = true;

});   
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
three - the ZIM Three object
XRControllers - the ZIM XRControllers object
speed - (default 1) the speed of motion
acceleration - (default .3) the acceleration of motion
rotationSpeed - (default 1) the turning speed
rotationAcceleration - (default .2) the turning acceleration
hapticMax - (default 0) motion will trigger this much haptic response if available (handle vibration)
verticalStrafe - (default false) make left controller change up and down (elevation) rather than forward backwards motion
radiusMax - (default -1) set to a number to prevent movement beyond this radius
threshhold - (default .2) a sensitivity filter - use a higher number to avoid drift
directionFix - (default true) adjust direction from absolute to relative - needed in R155
	set to false for R149 - or if three.js version seems to have direction wrong when using controllers
boxMax - (default null) set to an array with 6 numbers for min/max in x, y, z [xMin, xMax, yMin, yMax, zMin, zMax]
	this prevents the dolly from going past these values 
	can still use radiusMax but will probably use one or the other
rotationAngle - (default null) set to an angle in degrees to override rotationSpeed and rotate specific angles 
	also see rotationInterval which sets how long to wait if rotation is held active 
	set rotationAngle to 0 to not rotate
rotationInterval - (default .5 seconds) time in seconds to rotate again if rotationAngle is set and control rotation held down 
	
METHODS
doHaptic() - trigger haptic response if available (amount, hand, max)
dispose() - remove movement

PROPERTIES
type - name of class as a string
dolly - the three.js Group that holds the controllers and the camera
	dolly has a userData.rotationY property for radians of rotation about y 
	it seems to have some sort of Euler rotations which just go from -90 to 90 annoying
	so this is a record of rotation applied - use with multi-user for instance to send data
speed - get or set the speed of motion
acceleration - get or set the acceleration of motion
rotationSpeed - get or set the turning speed
rotationAcceleration - get or set the turning acceleration
hapticMax - get or set the maximum haptic response if available on motion (handle vibration)
verticalStrafe - get or set whether the left controller will change up and down (elevation) instead of forward backwards motion
radiusMax - get or set set the number to prevent movement beyond this radius
threshhold - get or set the sensitivity filter - use a higher number to avoid drift
--*///+140.24

	// THE CODE FOR THE THREE MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-140.24

/*--
zim.XRTeleport = function(three, XRControllers, XRMovement, floor, offsetHeight, button, hand, markerColor, markerBlend, markerRadius)

XRTeleport
zim class
** MUST import zim_three - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Adds XR (AR/VR) teleport to three.js.
Pass in ZIM XRControllers and XRMovement and use buttons to teleport - requires some sort of floor.
By default the B and Y top front buttons will teleport.
This could be changed to the triggers or all could do a teleport.
There can be multiple floors.
Meshes can be teleported through by setting the mesh.userData.xrteleportignore = true;
Teleport will leave a circle on the floor on press down and then activate on press up.

SEE: https://zimjs.com/015/vr.html and use triggers (drag), sticks (motion) and b and y buttons (teleport)  

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// import zim_three
const three = new Three({
	width:window.innerWidth, 
	height:window.innerHeight, 
	cameraPosition:new THREE.Vector3(0,3,6),
	textureActive:true, // if wanting TextureActives
	xr:true 
});

// make skybox, add meshes to scene, etc.
// might add a floor mesh 

// xrControllers parameters: 
// three, type, color, highlightColor, lineColor, lineLength, threshhold

const xrControllers = new XRControllers(three, "laser"); // "laser" is default

xrControllers.on("xrconnected", () => {

	// wait for controllers to connect before adding movement and teleport
	
	// XRMovement parameters: 
	// three, XRControllers, speed, acceleration, rotationSpeed, rotationAcceleration, hapticMax, verticalStrafe, radiusMax
	var xrMovement = new XRMovement(three, xrControllers);

	// XRTeleport parameters: 
	// three, XRControllers, XRMovement, floor, offsetHeight, button, hand, markerColor, markerBlend
	new XRTeleport(three, xrControllers, xrMovement, floor, 4); // top front round buttons (B and Y)

	// note: to teleport through a mesh, set the mesh.userData.xrteleportignore = true;

});   
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
three - the ZIM Three object
XRControllers - the ZIM XRControllers object
XRMovement - (default null) if an XRMovement object is being used then pass it in here
	if provided then teleport moves the XRMovement dolly
floor - (default null) provide a three.js mesh or an array of three.js meshes
offsetHeight - (default 0) keep the dolly or camera this high above the floor
button - (default 4) the B and Y buttons but can be an array of numbers - see https://zimjs.com/015/vr/controllers.jpg
hand - (default "both") set to "left" or "right" (or "both") to set the controllers for teleporting
markerColor - (default silver) the color of the circular marker
markerBlend - (default THREE.AdditiveBlending) the blend of the circular marker
markerRadius - (default) set the marker radius

METHODS
dispose() - remove teleport

PROPERTIES
type - name of class as a string
floor - get or set the array of floor meshes 
button - get or set the array of buttons to activate the teleport
hand - get or set the hand(s) to use for the teleport ("left", "right", "both")
marker - get the marker mesh
--*///+140.26

	// THE CODE FOR THE THREE MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-140.26

////////////////  ZIM SOCKET  //////////////

// the Socket section is for the ZIM Socket library

/*--
zim.Socket = function(server, appName, roomName, maxPeople, fill, initObj)

Socket
zim class extends a zim EventDispatcher (with the normal event object replaced by a data param)
** MUST import socket.io.js with a script tag - SEE link at top of Docs for socket.io.js under ZIM works with...
** MUST import zim_socket - see https://zimjs.com/es6.html#MODULES
** MUST request a ZIM Socket Server ID or have a NodeJS server running zimserver.js with SocketIO on server (and client as mentioned)
** MUST test on a server to avoid CORS errors
See: https://zimjs.com/es6.html#MODULES

OVERVIEW
Sockets are how multiuser games, chats, avatars, etc. work.
ZIM Socket provides code for multiuser sockets to share properties.
A client (user) sends properties and receives objects of other clients' properties
requires a NodeJS server running zimserver.js with SocketIO on server and client
See https://zimjs.com/socket/ for details and to request using the ZIM server.

DESCRIPTION
ZIM Socket sets up a multiuser socket with apps and rooms (sets of rooms if max is set)
There is an option to fill in empty spots from people leaving with new people or not.
A client sends property changes and receives objects of other clients' properties.
The server handles data, joining, leaving, changing rooms and history.
This means that there is no need for server side programming.

Socket examples:
https://zimjs.com/cat/gallery.html
https://zimjs.com/socket - there is an EXAMPLE multi-user selectable paragraph
https://zimjs.com/avatar.html
https://zimjs.com/chat.html
https://zimjs.com/egg.html
https://zimjs.com/remote.html // works with remote.html
https://zimjs.com/control.html // works with control.html

NOTE as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// up top after loading CreateJS and ZIM add the latest versions of these files
// https://zimjs.org/cdn/2.3.0/socket.io.js
// https://zimjs.org/cdn/zimserver_urls.js
// https://zimjs.org/cdn/zimsocket_1.1.js

// We will make a single Ball that multiple people can drag around
// In the ZIM Frame here is the preparation and the code:

// For the first parameter:
// The zimSocketURL comes from zimserver_urls.js and points to the ZIM Socket server.
// This way, if we change the server, the app will still work.

// For the second parameter:
// Went to this URL https://zimjs.com/request.html from the ZIM Socket page
// and requested a keyword "sharedball" for this app
// do not use a keyword that is already in use

const socket = new Socket(zimSocketURL, "sharedball");

// When the socket is ready we get this event
// It receives a data event of all the current data - or just ask socket.
// There is also a history of any data stored in history - like for a chat.

socket.on("ready", ()=>{
	const ball = new Circle(100, red).drag(S);

	// We will get the lastest x and y of the ball
	// all latest values are automatically loaded by Socket to start
	const x = socket.getLatestValue("x");
	const y = socket.getLatestValue("y");

	// if someone has already moved the ball then start at that position
	// otherwise, tell others to come where the ball is located
	if (x != null) {
		ball.loc(x,y);
	} else {
		ball.center();
		// we can set a single property like:
		// socket.setProperty("x", ball.x);
		// but each time we do it is a call to the server
		// so it is better to set multiple properties like so:
		socket.setProperties({x:ball.x, y:ball.y});
	}
	S.update();

	// here is the event for when we receive data from others
	// so set the ball to the latest value
	// we can also grab this information from the data parameter
	socket.on("data", data=>{
		let x = socket.getLatestValue("x");
		let y = socket.getLatestValue("y");
		if (x != null) ball.loc(x,y);
		S.update();
	});

	// send data when ball is moved
	ball.on("pressmove", ()=>{
		socket.setProperties({x:ball.x, y:ball.y});
	});

});

socket.on("error", ()=>{
	new Pane("SORRY, COULD NOT CONNECT").show();
});
END EXAMPLE

EXAMPLE 
// Code to handle dragging multiple objects in a Container 

// There exists a letters Container holding all the letters 
// There exists a lettersArray holding all the letters 
// The letters are being dragged (with the default onTop:true)
// which changes the letter layer in the letters container
// sendData is being called by mousedown and pressmove events on each letter

function sendData(e) {
	let letter = e.target;
	let obj = {};
	obj["l_"+letter.num] = [letter.x, letter.y, letter.level];
	socket.setProperties(obj);
}
socket.on("data", data=>{
	loop(data, (p,d)=>{
		let [g,n] = p.split("l_"); // grab the number
		if (n >= 0) {
			// set the x, y and layer
			lettersArray[n].loc(d[0], d[1], letters, d[2]);
			S.update();              
		}
	});            
});

// When a new person arrives we want to recreate locations and layers
// Use socket.getLatestValue(letter); to get its location {l_0:[x,y,level]}
// The level property is only useful as the letter is being dragged 
// it may become out of date as other letters are dragged 
// So when recreating the layer levels, we cannot rely on the level 
// Instead, we will rely on the time that the letter was last moved

// Use socket.getLatestTime(letter) to get the update time of the letter
// Store the time and index of all letters that have changed in an array
// Sort the array from smallest time to biggest time 
// then loop through the array and set the letter 
// in the lettersArray at the index to the top() 
// NOTE - we must use the lettersArray - not the letters

const order = [];
loop(lettersArray, (letter,i)=>{
	let d = socket.getLatestValue("l_"+i);
	if (d) {
		let t = socket.getLatestTime("l_"+i);
		letter.loc(d[0], d[1], letters);
		order.push({t, i});
	}             
});
order.sort((a, b) => (a.t > b.t) ? 1 : -1); // smallest to biggest
loop(order, data=>{
	lettersArray[data.i].top();
});
END EXAMPLE

EXAMPLE 
// Imagine that we have a Tile with thousands of colored pixels. 
// we do not want to send the full data for every change. 
// so we send each person's individual change to be collected and adjusted live (not shown below).
// But, when a new person arrives we want the full data. 
// The trick is to use the master socket to send the data to new person as follows:

const c = [black, dark, grey, light, white, purple, pink, red, orange, yellow, green, blue];

socket.on("otherjoin", d => {        
	if (socket.master) { // this socket is the current master so send data
		const colors = [];
		loop(tile.items, item=>{
			colors.push(c.indexOf(item.color));
		});
		// d.id is the id of who just joined   
		socket.setProperty("colors", {id:d.id, array:colors});   
	}  
}); 

socket.on("data", d => {
	// if we are the person that just joined
	if (d.colors && d.colors.id==socket.id) { 
		loop(d.colors.array, (item,i)=>{
			tile.items[i].color = c[item];
		});
		S.update();
	}
	// also there would be code to update everyone's individual changes
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
server - (default https://localhost:3000) the server that is running node and the zimsocket.js : portNumber
appName - (required) a string id (one word or joined words) and unique for your app
roomName - (default "default") optional room name otherwise just uses a default room (can represent many rooms if maxPeople is set)
maxPeople - (default 0) how many people are allowed per room - default is 0 which is virtually unlimited
	setting this to 4 will let four people share the socket and the next person in starts sharing with the next three, etc.
fill - (default true) - set to false to not fill in vacated spots in a room
initObj - (default null) - pass an object literal of initial properties

METHODS
changeRoom(appName, roomName, maxPeople, fill, initObj) - this removes socket from current room and joins appName, roomName - socket.id remains the same
requestTime() - triggers a time event with parameter object holding masterTime, joinTime and currentTime
requestSync() - resyncs your other clients' data, time, history and last info with the server data
on(), off(), offAll() - methods inherited from zim.EventDispatcher- these work like the CreateJS on() and off() methods

** SETTING YOUR PROPERTIES
setProperty(propertyName, propertyValue) - sets your property to the value and sends out change to all in room (distributes)
setProperties(objectOfPropertiesToSet) - pass in an object with properties and values and it sets yours to match and distributes them

** GETTING PROPERTIES AND PROPERTY OBJECTS
** note: the relevant property objects are sent as a parameter on join, otherjoin and data events
** which means we often do not need these methods
** note: the data event sends a parameter with only the data currently being sent
** so if you want all the data belonging to the sender, use getSenderData() below
getMyProperty(propertyName) - gets your own value for property name
getMyData() - gets your own data object
getOtherProperty(id, propertyName) - gets another client's value for property name
getOtherData(id) - gets another client's object of properties
getSenderProperty(propertyName) - gets sender client's value for property name
getSenderData() - gets sender client's object of properties
getProperties(propertyName) - returns an array of values for the propertyName of others - for x we might get [12, 14, 33, etc.]
getData() - returns an object of all client objects by id (does not include this (my) client)

** GETTING LATEST INFORMATION
getLatestValue(propertyName) - returns the last distributed value for the property you pass to it - could be yours
getLatestTime(propertyName) - returns the server timestamp (ms from 1970) for when the latest value of the property was updated - could be yours
getLatestValueID(propertyName) - returns the id of the last person to distribute a value for the property you pass to it
getLatestProperties(propertyName) - returns an array of the last property names to be distributed (sometimes multiple properties are distributed at once)

** HISTORY
appendToHistory(someText) - adds the text passed to it to the history file for the room (deleted if room is empty)
clearHistory() - sets the history for the room to ""

** TO DISCONNECT
dispose() returns void - removes listeners, closes socket, deletes data objects - must make a new Socket object to connect

PROPERTIES (READ ONLY)
server - the server you set
applicationName - the name of your application
roomName - the room name (may represent many rooms if maxPeople is set)
maxPeople - see PARAMETERS
fill - see PARAMETERS
socket - the SocketIO client socket object
ready - a ready event has been dispatched
masterTime - when the server started
joinTime - when socket joined the current room
id - the id of the client socket
master - true if the socket is the current master
	this can be used to run functions only once for everyone in the room
	see the example above.
	The master may change as people leave the room
senderID - the id of the last person to send out data
lastJoinID - the id of the last person to join (not you)
lastLeaveID - the id of the last person to leave (not you)
history - the history text for your room at the time of application start
size - how many other people are in the room (not including you)

EVENTS
ready -	socket is connected and a room has been assigned (receives room data)
roomchange - this socket joined another room (receives room data)
error - trouble connecting - make sure server is running and you have the right port
data - dispatched when someone in the room makes a change (receives other's data)
otherjoin - dispatched when another person joins (receives other's data)
otherleave - dispatched when another person leaves (receives other's data)
time - event from requestTime method with event object having masterTime and currentTime properties
synch - event from requestSync method with event object has all the data from the server
disconnect - the socket is closed - could be that socketIO stops for some reason - all data on the server will be lost
--*///+140

	// THE CODE FOR THE SOCKET MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-140
	

////////////////  ZIM CAM  //////////////

// the Cam section is for the ZIM Cam library

/*--
zim.Cam = function(width, height, flip, facingMode, config)

Cam
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_cam - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Shows the output from the Webcam after user permits access. 
Will stretch to fit in dimensions and can choose to flip (default) or not.
Used by ZIM CamMotion, CamCursor, CamAlpha and CamControls classes 

SEE: https://zimjs.com/nft/bubbling/cam.html and use right arrow to see all four examples

NOTE: on a Mac, the canvas must be interacted with before showing cam video 
recommend using the ZIM CamAsk() widget to do solve this.

NOTE: noMouse() has been set on Cam - to make the cam mouseEnabled set mouse() on the Cam object;

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on a PC - this is all that is needed
const cam = new Cam().scaleTo().center(); // will fill the stage with a Webcam
END EXAMPLE

EXAMPLE
// on a Mac, the canvas must be interacted with first 
// so would recommend always using CamAsk first:
const ask = new CamAsk().show(yes=>{
	// if the user answers yes to the CamAsk
	if (yes) {
		// use scaleTo() to FILL the cam in the Frame
		// new Cam() will trigger the Browser asking for permission 
		// unless already have given permission in this session
		let cam = new Cam().scaleTo().center();		
		cam.on("ready", ()=>{
			// code here
		});				
		// if the user does not accept the browser asking about cam
		cam.on("error", ()=>{
			new Pane("CAM not accepted",yellow).show();
		});		
	} else { // answered no to CamAsk dialog
		new Pane("CAM not accepted",yellow).show();
	}	
}); 
END EXAMPLE

EXAMPLE 
// keyOut a web cam - see https://zimjs.com/zim/camkey.html
// for two colors keyed out - see https://zimjs.com/zim/camkey2.html
// Apple still makes us interact with the canvas before showing video (sigh)
// so use CamAsk widget that has a callback on show() which is true for yes and false for no    
const ask = new CamAsk().show(yes => {

	// if the user answers yes to the CamAsk
	if (yes) {   
		// set the facingMode to "environment" for back cam (or set to "user" for front cam) if available 
		// this is for mobile probably and would be ignored on desktop 
		const cam = new Cam({facingMode:"environment"}).scaleTo().center();
		cam.on("ready", ()=>{   
			const picker = new ColorPicker({
				tolerancePicker:true,              
				spectrumOk:false,
				spectrumClose:false,
				dropperTarget:cam,
				collapsed:true
			}).show().pos(100,100,RIGHT).change(() => {
				cam.keyOut(picker.selectedColor, picker.selectedTolerance);
			});   
			// keying will pause the cam so start with picker collapsed             
			const label = new Label("Expand to pick color to keyout",20,null,light).pos(20,0,LEFT,CENTER,picker.bar);
			picker.on("expanded", ()=>{
				label.removeFrom();
				S.update();
			});
		});      
	}        
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
width - (default 640) width of cam output - see also resetSize()
height - (default 480) height of cam output 
flip - (default true) set to false to not horizontally flip the video
facingMode - (default true) set to "user", "exact_user", "environment", "exact_environment", "auto"
	will try and set cameras on mobile to front or back - ignored on PC
	warning, the exact versions might cause an error on PC
	also see setFacingMode() method to change dynamically
config - an optional configuration object {} with properties for media settings - such as:
	width, height, facingMode, aspectRatio, autoGainControl, brightness, channelCount, colorTemperature, contrast, deviceId, echoCancellation, exposureCompensation, exposureMode, exposureTime, 
	facingMode, focusDistance, focusMode, frameRate, groupId, iso, latency, noiseSuppression, pan, pointsOfInterest, resizeMode, sampleRate, sampleSize, 
	saturation, sharpness, tilt, torch, whiteBalanceMode, zoom
	see: https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API/Constraints

METHODS
** these methods are available only once the WebCam "ready" event has happened.
resetSize() - adjusts the size of the WebCam to the actual WebCam size
pause(state) - state defaults to true to pause cam or pass false to unpause cam 
	also see toggle() method and paused property
toggle() - swap the paused state - also see pause() method and paused property
flip(state) - state defaults to true to mirror the cam or pass false to not mirror the cam  
	also see flipped property
snapshot() - make a Bitmap of the current webcam frame
keyOut(color, tolerance, replacement) - remove color from Cam's bitmap and a tolerance between 0-1
	the default color is "#389b26" which is a medium dark green
	the default tolerance is .1 - the higher the tolerance the less sensitive the keying process - so more colors will be removed similar to the provided color
	color and tolerance can be an array of colors and tolerances (or just one tolerance if all are the same)
	replacement (default clear) a color to replace the keyed out color with or an optional array to match the colors array if an array is used
setFacingMode(mode) - set to "user", "exact_user", "environment", "exact_environment", "auto" to choose camera on mobile
	see facingMode parameter for more info
dispose() - close the cam and remove events

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
ready - read only if the ready event has happened
** these properties are available only once the WebCam "ready" event has happened
tag - reference to the HTML video tag (created by ZIM to hold the cam video)
display - reference to the ZIM Container that holds the bitmap of the video
	this is what is cached and has its cacheCanvas analyzed for motion
bitmap - reference to the ZIM Bitmap that displays the video on the canvas
	when flipped this is scaled -1 in x and reg moved to be flipped inside the display
paused - get or set whether the cam is paused (also see pause() and toggle())
flipped - get or set whether the cam is mirrored (also see flip())
facingMode - get which camera is being used - "user", "environment", etc. might be undefined 
	see facingMode parameter and setFacingMode() method for more details

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "ready" event when the user has accepted webcam usage
dispatches an "error" event if access to the WebCam is unsuccessful

See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+142

	// THE CODE FOR THE CAM MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-142
	
/*--
zim.CamMotion = function(obj, preview, smooth, damp, sensitivity, precision, period, colorFilter, colorSensitivity, mode, visualizerObj, visualizerColor, visualizerBaseColor, visualizerScale, visualizerBaseScale, guideH, guideV, randomize, cam, frame, facingMode, config)

CamMotion
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_cam - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Captures motion data from a ZIM WebCam at a certain object - by default the stage. 
CamMotion makes a grid of points and checks to see if the color has changed under the points.
The location of changed points is stored is a data property 
and averaged to provide a single cursor location.
This location of motion is used by the ZIM CamCursor class.

The CamMotion class has adjustable parameters to capture motion in different settings.
See the CamControls class for a panel of controls to change the settings.
There is also a visualizer which adds circles at the data points with motion.
The data points default to be in a randomized grid but can be set to a regular grid.

SEE: https://zimjs.com/nft/bubbling/cam.html and use right arrow to see all four examples

NOTE: noMouse() has been set on CamMotion
to make the cam mouseEnabled set mouse() on the CamMotion object and the cam property of the CamMotion object; 

NOTE: see also ZIM CamCursor which has other features - see examples too. 
A CamCursor is not always needed and is sometimes used 
as well as CamMotion objects on specific buttons that trigger on any motion. 
The cursor may just be there to help people know where the motion is heading.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on a Mac, the canvas must be interacted with first 
// so would recommend always using CamAsk first:
const ask = new CamAsk().show(yes=>{	
	if (yes) {
		// a CamMotion with visualizer
		// CamMotion will make a Cam and FILL the screen with the cam
		// for instance, if the Frame was a square and the webcam a 4x3 aspect ratio
		// then the stage would be filled and the left and right of the cam would be off stage
		const camMotion = new CamMotion({
			visualizerColor:[green,orange,yellow,red,blue,purple,pink], 
			visualizerBaseColor:clear, 
			visualizerScale:6, 
			visualizerBaseScale:1
		}).center();

		// Optionally adjust the circles 
		// A custom visualizer can also be easily made 
		// by looping through the CamMotion data points
		camMotion.on("ready", ()=>{        
			camMotion.visualizer.loop(circle=>{circle.ble("color-dodge")})
		});
	}
}); // end CamAsk show() - see CamAsk docs for error checking example
END EXAMPLE

EXAMPLE 
const ask = new CamAsk().show(yes=>{	
	if (yes) {
		// capture any motion over a button (or a press) 
		// and change frame color for 1 second
		const button = new Button(null,null,"HOLD").pos(200,200).tap(activate);
		const camMotion = new CamMotion(button);
		camMotion.on("active", activate);
		function activate() {
			F.color = yellow;
			if (button.resetID) button.resetID.clear();        
			button.resetID = timeout(.5, ()=>{
				F.color = darker;
			});        
		}
	}
});
END EXAMPLE 

EXAMPLE
// hold on object to pick up then
// drag object and hold to drop 
// dedicated to Elisha!
const ask = new CamAsk().show(yes=>{

	let holding = false;
	const circle = new Circle(100,red)
		.pos(100, 100, LEFT, CENTER);        

	// if the user answers yes to the CamAsk
	if (yes) {   
		const camCursor = new CamCursor();
		camCursor.on("ready", ()=>{   
			circle.top().ord(-1); // under cursor above cam
			new CamAlpha(camCursor).pos(50,50,RIGHT,TOP); 

			let moveEvent;
			camCursor.on("still", ()=>{
				if (!holding && camCursor.hitTestCircles(circle)) {
					holding = true;
					circle.sha();
					circle.diffX = camCursor.x-circle.x;
					circle.diffY = camCursor.y-circle.y;

					moveEvent = camCursor.on("cursor", ()=>{                            
						circle.loc(
							camCursor.x-circle.diffX,
							camCursor.y-circle.diffY
						);
					});                   
				} else if (holding) {
					holding = false;
					circle.sha(-1);
					camCursor.off("cursor", moveEvent)
					circle.addTo().ord(-2);
				}
			});
		});
	}    
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
obj - (default - stage) can set a DisplayObject on which to capture motion
	for instance, add a Rectangle as a button and capture motion only on that button 
	or have multiple CamMotion or CamCursor each with such buttons
	if so, then use a single cam for all of them
preview - (default .1) the alpha of the WebCam - or set to false or 0 to not see the cam 
	usually when making a CamCursor it is advisable to let people see themselves
smooth - (default 1) a number between 0 and 1 with 1 being smoothest but a little slower 
	smooth gets multiplied by 10 to average over a buffer of readings (at the period)
	lower numbers will be jittery but a little faster 
damp - (default .05) the damp for the cursor data movement 
	a damp of 1 will be very jittery whereas .01 will be slow moving 
	also see smooth and sensitivity
sensitivity - (default .5) set higher to capture more motion or lower to capture less motion 
	cams can toggle colors even if no motion so set a lower sensitivity if capturing false motion
	basically, motion is detected by color difference and sensitivity adjusts the detection range
	the range is shades of 256 reds - or 256 greens - or 256 blues depending on the mode parameter
	of the 256 shades, a sensitivity of 0 is 100 shades and a sensitivity of 1 is 10 shades 
precision - (default .5) set a higher precision for more test points and a lower precision for less points 
	a precision of 0 will be a point every 100 pixels and a precision of 1 is every 10 pixels
	higher precision may slow down the data reading, lower precision may cause bigger cursor jumps 
period - (default .05) seconds to test for motion - uses a ZIM interval 
	will have its data averaged over a buffer that is set by the smooth parameter
colorFilter - (default null) set to a color such as "green" to move to that color also see colorSensitivity 
	note that "red" occurs a fair bit in skin so perhaps do not use red 
colorSensitivity - (default .5) 0 is exact and 1 is 20 in hue comparison so .5 is 10 in hue comparison 
	meaning if colors converted to HSL have hues within colorSensitivity*20 of each other then it will check for motion
	can be bigger than 1 so 2 would be a hue range of 40
mode - (default 0) 0 tests red shades, 1 tests green shades and 2 tests blue shades 
	from testing, there seems no difference with different shades or indeed all shades at once 
	so a single shade is used - possibly a different shade may work better in a certain environment  
visualizerObj - |ZIM VEE| (default null) - set to "circle" or pass in any DisplayObject
	this places a circle at the data points
	also see randomize to adjust how the visualizer points are distributed 
	and the precision which will set the number of points 
	A custom visualizer can also be made by passing in no visualizerObj
	and using the data in the data event     
visualizerColor - |ZIM VEE| (default zim.red) - the color for the circle - or a DisplayObject with a color property	
	the visualizerColor is the color when there is motion at its point	
visualizerBaseColor - |ZIM VEE| (default zim.dark) visualizer circle color when no motion is detected
visualizerScale - |ZIM VEE| (default 1) the scale of the visualizerObj when when motion is detected 
visualizerBaseScale - |ZIM VEE| (default 0) the scale of the visualizerObj when no motion is detected 
guideH - (default AUTO) where to place the motionX of the motion point
	the points of motion make up a motion box
	AVE - places motion point at average of points
	AUTO - places the motion point proportionally on the motion box 
		with respect to the box's location on the obj provided for the cam (stage is default) 
		if motion box is at left of obj then motion point is at left of box 
		if motion box is in middle of obj then motion point is in middle of box 
		if motion box is at right of obj then motion point is at right of box 
		and anything proportionally between 
		so as one reaches to the right, the point is more to the right of the motion box, etc. 
	LEFT - places motion point at left of motion box 
	CENTER - places motion point at center of motion box 
	RIGHT - places motion point at right of motion box   
guideV - (default TOP) where to place the motionY of the motion point
	the points of motion make up a motion box
	AVE - places motion point at average of points
	AUTO - places the motion point proportionally on the motion box 
		with respect to the box's location on the obj provided for the cam (stage is default) 
		if motion box is at top of obj then motion point is at top of box 
		if motion box is in middle of obj then motion point is in middle of box 
		if motion box is at bottom of obj then motion point is at bottom of box 
		and anything proportionally between 
		so as one reaches to the top, the point is more to the top of the motion box, etc. 
	TOP - places motion point at top of motion box 
	CENTER - places motion point at center of motion box 
	BOTTOM - places motion point at bottom of motion box 
randomize - (default true) - make the grid but then randomly move the points 
	up to 1/3 the spacing on either side 
	this somewhat masks the jumping about of the average motion point 
	and affects the outcome of the randomizer to look perhaps more natural 
	but if a regular grid is desired, set randomize to false
cam - (default ZIM WebCam) will default to a flipped WebCam 
frame - set to desired frame if not the ZIM Default Frame
facingMode - (default true) set to "user", "exact_user", "environment", "exact_environment", "auto"
	will try and set cameras on mobile to front or back - ignored on PC
	warning, the exact versions might cause an error on PC
	also see setFacingMode() method to change dynamically
config - an optional configuration object {} with properties for media settings - such as:
	width, height, facingMode, aspectRatio, autoGainControl, brightness, channelCount, colorTemperature, contrast, deviceId, echoCancellation, exposureCompensation, exposureMode, exposureTime, 
	facingMode, focusDistance, focusMode, frameRate, groupId, iso, latency, noiseSuppression, pan, pointsOfInterest, resizeMode, sampleRate, sampleSize, 
	saturation, sharpness, tilt, torch, whiteBalanceMode, zoom
	see: https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API/Constraints
	
METHODS
** these methods are available only once the WebCam "ready" event has happened.
dispose() - close the cam and remove events

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
obj - reference to the object passed to the cam to define a motion capture region
smooth - get or set the smoothness (0-1) - see parameter for info
sensitivity - get or set the sensitivity (0-1) - see parameter for info
precision - get or set the precision (0-1) - see parameter for info
colorFilter - get or set the colorFilter - see parameter for info
colorSensitivity - get or set the colorFilter - see parameter for info
motionX - get the reported x damped position of the motion - relative to the guideH parameter setting
motionY - get the reported y damped position of the motion - relative to the guideV parameter setting
rawX - get the reported x undamped position of the motion - relative to the guideH parameter setting
rawY - get the reported y undamped position of the motion - relative to the guideH parameter setting
cam - reference to the ZIM WebCam object
dampX - the horizontal Damp object
dampY - the vertical Damp object
** these properties are available only once the WebCam "ready" event has happened
data - an array of motion data for each point with 0 for no motion and 1 for motion 
points - an array of point objects {x, y} that locate the test points relative to the obj parameter (default stage)
camPoints - (used internally) an array of point objects {x, y} that locate the test points relative to the cam.bitmap
interval - a reference to the ZIM interval that runs to collect the data 
ticker - a reference to the ZIM Ticker function id
visualizer - a reference to the ZIM Container that holds visualizer visualizerObj objects

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "ready" event when the WebCam is ready (the user has accepted web cam usage)
dispatches a "data" event when the interval collects new motion data
dispatches a "cursor" event constantly (in a Ticker function)
dispatches an "active" event when motion is detected by interval - will repeat at period rate 
dispatches an "inactive" event when motion is not detected by interval - will repeat at the period rate 
dispatches an "error" event if access to the WebCam is unsuccessful 

See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+142.2

	// THE CODE FOR THE CAM MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-142.2	
	
/*--
zim.CamCursor = function(cursor, preview, camMotion, radius, color, borderColor, borderWidth, stillColor, stillBorderColor, stillTime, colorFilter, colorSensitivity, cam, facingMode, config)

CamCursor
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_cam - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Places a cursor at the motion location calculated by ZIM CamMotion.
This can be used to make objects follow the cursor or activate buttons with motion. 

SEE: https://zimjs.com/nft/bubbling/cam.html and use right arrow to see all four examples

NOTE: noMouse() has been set on CamMotion and Cam objects - set them to mouse() if desired;

NOTE: see also ZIM CamMotion which has other features - see examples too. 
A CamCursor is not always needed and is sometimes used 
as well as CamMotion objects on specific buttons that trigger on any motion. 
The cursor may just be there to help people know where the motion is heading.

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on a Mac, the canvas must be interacted with first 
// so would recommend always using CamAsk first:
const ask = new CamAsk().show(yes=>{	
	if (yes) {
		const cursor = new CamCursor();
		cursor.on("ready", ()=>{
			zog("ready");
		});
		cursor.on("still", ()=>{
		    zog("still");
		});
		cursor.on("motion", ()=>{
			zog("motion");
		});
	}
}); // end CamAsk show() - see CamAsk docs for error checking example
END EXAMPLE

EXAMPLE 
const ask = new CamAsk().show(yes=>{	
	if (yes) {
		var button = new Button(null,null,"HOLD").pos(200,200).tap(activate);
		const cursor = new CamCursor();
		cursor.on("still", ()=>{
			if (cursor.hitTestBounds(button)) activate();
		});
		cursor.on("cursor", ()=>{
			if (cursor.hitTestBounds(button)) button.backgroundColor = green;
			else button.backgroundColor = "orange";
		});
		function activate() {
			F.color = yellow;
			if (button.resetID) button.resetID.clear();        
			button.resetID = timeout(.5, ()=>{
				F.color = darker;
			});    
		}
	}
});
END EXAMPLE 

EXAMPLE 
// use this for a CamCursor to track motion of green pixels
// increase the precision if tracking a marker for instance
const camCursor = new CamCursor({
	camMotion:new CamMotion({precision:.8, colorFilter:"green", colorSensitivity:.5})
});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
cursor - (default new Circle()) the DisplayObject for the cursor 
	can be any DisplayObject like a Bitmap, Sprite, Emitter, etc.
preview - (default .1) the alpha of the WebCam - or set to false or 0 to not see the cam 
	usually when making a CamCursor it is advisable to let people see themselves
camMotion - (default new CamMotion()) add a CamMotion to calculate the cursor motion
** the following parameters are for the cursor if a default cursor is used
radius - (default 10) the radius of the circle cursor
color - (default zim.blue) the color of the circle cursor when in motion
borderColor - (default zim.purple) the color of the circle cursor when in motion
borderWidth - (default 5) the border width of the circle cursor
stillColor - (default color) the color of the circle cursor when still
stillBorderColor - (default borderColor) the border color of the circle cursor when still
stillTime - (default 1) seconds of no motion until considered still
	will then set a "still" event and set motion to false
colorFilter - (default null) set to a color such as "green" to move to that color also see colorSensitivity 
	note that "red" occurs a fair bit in skin so perhaps do not use red 
colorSensitivity - (default .5) 0 is exact and 1 is 20 in hue comparison so .5 is 10 in hue comparison 
	meaning if colors converted to HSL have hues within colorSensitivity*20 of each other then it will check for motion
	can be bigger than 1 so 2 would be a hue range of 40
cam - (default camMotion.cam) will use the camMotion cam 
	but a specific cam can be passed in
facingMode - (default true) set to "user", "exact_user", "environment", "exact_environment", "auto"
	will try and set cameras on mobile to front or back - ignored on PC
	warning, the exact versions might cause an error on PC
	also see setFacingMode() method to change dynamically
config - an optional configuration object {} with properties for media settings - such as:
	width, height, facingMode, aspectRatio, autoGainControl, brightness, channelCount, colorTemperature, contrast, deviceId, echoCancellation, exposureCompensation, exposureMode, exposureTime, 
	facingMode, focusDistance, focusMode, frameRate, groupId, iso, latency, noiseSuppression, pan, pointsOfInterest, resizeMode, sampleRate, sampleSize, 
	saturation, sharpness, tilt, torch, whiteBalanceMode, zoom
	see: https://developer.mozilla.org/en-US/docs/Web/API/Media_Streams_API/Constraints

METHODS
** these methods are available only once the WebCam "ready" event has happened.
dispose() - close the cam and remove events

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
cursorObj - reference to the cursor object 
camMotion - reference to the CamMotion object 
colorFilter - get or set the colorFilter - see parameter for info
colorSensitivity - get or set the colorFilter - see parameter for info
cam - reference to the CamMotion's Cam object
motion - read only true if moving and false if not moving - see stillTime
	and "motion" and "still" events

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
dispatches a "ready" event when the WebCam is ready (the user has accepted web cam usage)
dispatches a "motion" event when the cursor starts to move 
	a little different than the CamMotion "active" event which triggers constantly on the interval
dispatches a "still" event when the cursor starts to be still (after stillTime with no motion)
	a little different than the CamMotion "inactive" event which triggers constantly on the interval
dispatches a "cursor" event constantly (from the CamMotion cursor event)
dispatches an "error" event if access to the WebCam is unsuccessful 

See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+142.5

	// THE CODE FOR THE CAM MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-142.5
	
/*--
zim.CamAlpha = function(cam, color)

CamAlpha
zim class - extends a zim.Container which extends a createjs.Container
** MUST import zim_cam - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A widget with a slider that sets the alpha of the ZIM Cam or CamMotion provided. 
The initial alpha is set by setting the alpha of the Cam()
or by using the preview parameter of CamMotion() or CamCursor().

SEE: https://zimjs.com/nft/bubbling/cam.html and use right arrow to see all four examples

NOTE: make the CamAlpha in the ready event of the Cam() or CamMotion()

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on a Mac, the canvas must be interacted with first 
// so would recommend always using CamAsk first:
const ask = new CamAsk().show(yes=>{	
	if (yes) {
		const camMotion = new CamMotion({preview:.5}).center(); 
		camMotion.on("ready", ()=>{   
			new CamAlpha(camMotion).pos(50,50,RIGHT,TOP);
		});
	}
}); // end CamAsk show() - see CamAsk() docs for error checking example
END EXAMPLE

PARAMETERS
cam - a ZIM Cam or CamMotion object.
color - (default white) the color of the parts
 	will also set certain alpha on whole object  

METHODS
** these methods are available only once the WebCam "ready" event has happened.
dispose() - close the cam and remove events

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
cam - get or set the cam being controlled
backing - reference to the backing zim Rectangle 
label - reference to the zim Label
slider - reference to the zim Slider

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+142.6

	// THE CODE FOR THE CAM MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-142.6
	
/*--
zim.CamControls = function(camMotion, close, collapse)

CamControls
zim class - extends a zim.List which extends a zim.Container
** MUST import zim_cam - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A widget with a slider for CamMotion smooth, sensitivity, precision, damp and flip properties.
This can be used to experiment with settings or to give end user control. 

SEE: https://zimjs.com/nft/bubbling/cam.html and use right arrow to see all four examples

NOTE: the values in the sliders are 0-100 whereas the parameter values are 0-1.
An exception is damp where the value for the tool range is 0-.1.  So 100 is .1 damp.

NOTE: make the CamControls in the ready event of the CamMotion

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on a Mac, the canvas must be interacted with first 
// so would recommend always using CamAsk first:
const ask = new CamAsk().show(yes=>{	
	if (yes) {
		const camMotion = new CamMotion({preview:.5}).center(); 
		camMotion.on("ready", ()=>{   
			new CamControls(camMotion).pos(50,50,RIGHT,TOP);
		});
	}
}); // end CamAsk show() - see CamAsk docs for error checking example
END EXAMPLE

PARAMETERS
camMotion - a ZIM CamMotion object - or a CamCursor object
close - (default false) set to true to add a close icon 
collapse - (default true) set to false to remove the collapse icon

METHODS
dispose() - dispose the camControls

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
cam - reference to the Cam object
camMotion - reference to the CamMotion object
camCursor - reference to the CamCursor object if there is one
reset - reference to the reset Button

ALSO: see ZIM List for properties such as:
items and then item[0].slider, items[0].stepper, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+142.7

	// THE CODE FOR THE CAM MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-142.7

/*--
zim.CamAsk = function(color, backgroundColor)

CamAsk
zim class - extends a zim.Pane which extends a zim.Container
** MUST import zim_cam - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
A circular confirmation widget to ask the user if they want to use the cam.
This is before the Browser will ask for permission.
The reason is that Macs do not treat giving cam permission as intercting with the Browser (sigh).
So, before video can be played interaction has to happen.
Using this widget to ask is interacting and is probably best to use on any platform. 

SEE: https://zimjs.com/nft/bubbling/cam.html and use right arrow to see all four examples

NOTE: as of ZIM 5.5.0 the zim namespace is no longer required (unless zns is set to true before running zim)

EXAMPLE
// on a Mac, the canvas must be interacted with first 
// so would recommend always using CamAsk first:
const ask = new CamAsk().show(yes=>{
	// if the user answers yes to the CamAsk
	if (yes) {		
		let cam = new Cam().scaleTo().center();		
		cam.on("ready", ()=>{
			// code here
		});				
		// if the user does not accept the browser asking about cam
		cam.on("error", ()=>{
			new Pane("CAM not accepted",yellow).show();
		});		
	} else { // answered no to CamAsk dialog
		new Pane("CAM not accepted",yellow).show();
	}	
});
END EXAMPLE

PARAMETERS
color - (default zim.dark) the font and border color of the widget
backgroundColor - (default zim.lighter) the backgroundColor of the widget

METHODS
show(call) - shows the pane and receives an optional callback parameter 
	that will call the function passed to it when YES or NO is pressed 
	the function will receive a parameter with a true for YES answer and false for NO answer
dispose() - dispose the camAsk

ALSO: see all the methods of a zim Pane()
including hide()

ALSO: ZIM 4TH adds all the methods listed under Container (see above), such as:
drag(), hitTestRect(), animate(), sca(), reg(), mov(), center(), centerReg(),
addTo(), removeFrom(), loop(), outline(), place(), pos(), alp(), rot(), setMask(), etc.
ALSO: see the CreateJS Easel Docs for Container methods, such as:
on(), off(), getBounds(), setBounds(), cache(), uncache(), updateCache(), dispatchEvent(),
addChild(), removeChild(), addChildAt(), getChildAt(), contains(), removeAllChildren(), etc.

PROPERTIES
type - name of class as a string
label - reference to the zim Label 
yes - reference to the zim Button with YES 
no - reference to the zim Button with NO 

ALSO: see ZIM Pane for properties such as:
backdropColor, etc.

ALSO: see ZIM Container for properties such as:
width, height, widthOnly, heightOnly, draggable, level, depth, group 
blendMode, hue, saturation, brightness, contrast, etc.

ALSO: see the CreateJS Easel Docs for Container properties, such as:
x, y, rotation, scaleX, scaleY, regX, regY, skewX, skewY,
alpha, cursor, shadow, name, mouseChildren, mouseEnabled, parent, numChildren, etc.

EVENTS
Dispatches a "yes" event when YES button is pressed 
	but also see the show(call) parameter 
	where the call parameter recieves a function 
	the function receives true for yes or false for no 
	this is an easier way to handle the event
Dispatches a "no" event when NO button is pressed 

See the CreateJS Easel Docs for Stage events, such as:
mouseenter, mouseleave, stagemousedown, stagemousemove, stagemouseup, drawstart, drawend, etc.
and all the Container events such as:
click, dblclick, mousedown, mouseout, mouseover, pressdown (ZIM), pressmove, pressup, removed, rollout, rollover
--*///+142.8

	// THE CODE FOR THE CAM MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-142.8
		
////////////////  ZIM PIZZAZZ  //////////////

// the Pizzazz section is for the Pizzazz 01, 02 and 03 libraries

/*--
makeShape = function(type, color, width, height)

makeShape 
zim libraries - PIZZAZZ 1
** MUST import zim_pizzazz - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Pizzazz is a set of modules that help assets such as shapes, icons, patterns and paths.
To some degree they are examples that ZIM can make use of such assets.
The modules were put together in a day or two and you could add your own assets of these types.

Call the listShapes() to see a list of available methods in the console (F12) - or see below:

PIZZAZZ SHAPES:
menu
bat
lips
magnet
stash
bolt
cloud
pow
drip
drop
circle
folds
oval
kidney
boom
roadside

Pizzazz Shapes example:
https://zimjs.com/bits/view/pizzazz.html

EXAMPLE
// import zim_pizzazz up top rather than just zim 

// In the ZIM Frame create the shape:
makeShape("drip", blue, 250).center();

// This can be used anywhere a zim Shape is used:
// tiled as part of the display or used as a background for a Label or Button, etc.
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
** Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
type - |ZIM VEE| (default "cloud") the shape name - see list below
color - |ZIM VEE| (default black) a color for the shape - ZIM color, HTML string or HEX
width (default as drawn) the width of the shape
height (default as drawn) the height of the shape

RETURNS
a ZIM Shape
--*///+145

	// THE CODE FOR THE PIZZAZZ MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-145


/*--
makeIcon = function(type, color, scale, multi, multiAlpha, multiScale, multiX, multiY, skewX, skewY, backing)

makeIcon
zim libraries - PIZZAZZ 2
** MUST import zim_pizzazz - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Pizzazz is a set of modules that help assets such as shapes, icons, patterns and paths.
To some degree they are examples that ZIM can make use of such assets.
The modules were put together in a day or two and you could add your own assets of these types.

Call the listIcons() to see a list of available methods in the console (F12) - or see below:

PIZZAZZ ICONS:
play
stop
pause
restart
rewind
fastforward
sound
mute
close
settings
menu
maximize
arrow
arrowthin
arrowstick
arrowhollow
arrowline
rotate
heart
marker
info
home
edit
magnify
checkmark
angle
garbage
move
resize
rotate2
save
mark

Pizzazz Icons example:
https://zimjs.com/bits/view/icons.html

EXAMPLE
// import zim_pizzazz up top rather than just zim

const icon = makeIcon("home", white, 2).pos(40,40,RIGHT);

// Or pass the icon into the Button class as the icon parameter
// Optionally provide a second shape for the rollIcon, etc. of the Button

var info = new Button({
	width:50,
	height:50,
	color:blue, // or "red", "#666" etc.
	rollColor:pink,
	corner:0,
	label:"",
	icon:makeIcon("info", "white")
})
	.pos(100, 50, RIGHT)
info.on("click", function(){zgo("https://zimjs.com/bits/view/icons.html")});
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
** Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
type - |ZIM VEE| (default "play") 0 the shape name - see list below
color - |ZIM VEE| (default black) a color for the icon - ZIM color, HTML string or HEX
scale - |ZIM VEE| (default 1) the scale of the icon
multi (default 1) how many icons to show
multiAlpha (default .5) alpha for other icons
multiScale (default .3) scale for each subsequent icons
multiX (default 0) x shift for each subsequent icons
multiY (default 0) y shift for each subsequent icons
skewX (default 0) horizontal skew of icon
skewY (default 0) vertical skew of icon
backing (default null) a DisplayObject for the backing

RETURNS
a ZIM Container
--*///+147

	// THE CODE FOR THE PIZZAZZ MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-147


/*--
makePattern = function(type, colors, size, cols, rows, spacingH, spacingV, interval, startPaused, backgroundColor, gradient, cache)

makePattern
zim libraries - PIZZAZZ 3
** MUST import zim_pizzazz - see https://zimjs.com/es6.html#MODULES

DESCRIPTION
Pizzazz is a set of modules that help assets such as shapes, icons, patterns and paths.
To some degree they are examples that ZIM can make use of such assets.
The modules were put together in a day or two and you could add your own assets of these types.

Call the listPatterns() to see a list of available methods in the console (F12) - or see below:

PIZZAZZ PATTERNS:
pixels
noise
dots
stripes
slants
hatch
plaid
bling

Pizzazz Patterns example:
https://zimjs.com/patterns.html


EXAMPLE
// import zim_pizzazz up top rather than just zim

// In the ZIM Frame ready function:

// 1. Simple pattern
const pixels = makePattern().center(); // adds a pixel pattern to the stage

// 2. Pattern for ProgressBar (use the backing parameter)
const pattern = makePattern({type:"slants", colors:makeSeries(brown, grey), size:5, rows:20, cols:60, interval:.5})
const bar = new ProgressBar({barType:"Rectangle", color:zim.dark, backing:pattern}).show();
bar.percent = 40; // or use with loadAssets() or Frame() progress parameter

// 3. Pattern for Button wait state (use the waitBacking parameter)
new Button({
	wait:"STOP!",
	waitTime:2,
	waitBacking:makePattern({type:"stripes", backgroundColor:red, colors:black, size:30})
}).center();
END EXAMPLE

PARAMETERS
** supports DUO - parameters or single object with properties below
** supports VEE - parameters marked with ZIM VEE mean a zim Pick() object or Pick Literal can be passed
** Pick Literal formats: [1,3,2] - random; {min:10, max:20} - range; series(1,2,3) - order, function(){return result;} - function
type - |ZIM VEE| (default "pixels") the pattern name - see list below:
	// pixels, noise, dots, stripes, slants, hatch, plaid, bling, check
colors - |ZIM VEE| (default black) CSS colors for the pattern
	// this uses ZIM VEE to apply multiple, random, or a series of colors, etc.
size - |ZIM VEE| (default 10) the size of the shape used for the pattern
cols - (default 30) the columns to tile
rows - (default 10) the rows to tile
spacingH - (default 0) a spacing between columns
spacingV - (default 0) a spacing between rows
interval - (default 0) the time to animate in s
	for pixels, noise, dots and bling this is the time between showing different patterns
	for stripes, slants, hatch, plaid this is the time to move the pattern to the right
	different patterns may seem to move at different speeds due to the pattern repeat distance
startPaused - (default false) set to true to start the interval for animation to paused
backgroundColor - (default 0) a CSS color for the background of the pattern
gradient - (default 0) 0-1 for how much gradient to show - try .2 for a decent looking gradient
cache - (default true except for dots) if the pattern is cached - dots look better not cached

RETURNS
a ZIM Container
--*///+149

	// THE CODE FOR THE PIZZAZZ MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-149

/*--
makePath = function() ** there is no makePath() - please read details

makePath
zim libraries - PIZZAZZ 4
** there is no makePath() - use Blob() and Squiggle() instead

DESCRIPTION
Pizzazz is a set of modules that help assets such as shapes, icons, patterns and paths.
To some degree they are examples that ZIM can make use of such assets.
The modules were put together in a day or two and you could add your own assets of these types.

PIZZAZZ 04 is a little different - here we provide data to make Blob and Squiggle shapes
see https://zimjs.com/paths/
where various Blob and Squiggle shapes can be selected from a menu
or custom Blob And Squiggle shapes can be made.
The code for the shapes can be copied into your app 
as the Blob or Squiggle points parameter.
Please contact us at https:forum.zimjs.com
and we can perhaps add your Blob or Squiggle in the menu!

Note that PIZZAZZ 04 was created during ZIM NIO (version 9)
where work was done to animate along Blob and Squiggle paths.
https://zimjs.com/nio/

In ZIM TEN, shape tweens, hitTestPath, LabelOnPath, traverse and Beads were added
along with SVGContainer and SVG to the path parameter of Blob and Squiggle
https://zimjs.com/animation/shapetween.html
https://zimjs.com/hittestpath.html
https://zimjs.com/explore/labelonpath.html
https://zimjs.com/ten/traverse.html
https://zimjs.com/ten/beads.html
https://zimjs.com/svg/index.html

Paths are very powerful in ZIM - here are some CodePen examples:

Bat Puppet - change in small path changes big path
https://codepen.io/danzen/pen/VwLKNJE

Ball is animated along path that says word loop (comparing to GSAP)
https://codepen.io/zimjs/pen/PooyqPe

Emitter is animated along path and changes size based on height on page
https://codepen.io/zimjs/pen/dyyYKrg

Points of Squiggle are animated in form of arrow
https://codepen.io/danzen/pen/pozGEZo

Points of Blob are animated to make art
https://codepen.io/danzen/pen/YzKJxpJ

Rocket animates along path that is bigger than the stage (uses F.follow)
https://codepen.io/zimjs/pen/EzpOPP

Animating a ball along a long Squiggle path (comparing to PaperJS)
https://codepen.io/zimjs/pen/GLLvoP

Zinkle - Squiggles animate along two Blob paths
https://codepen.io/danzen/pen/dgrMMX

Light a fuse the makes an Emitter spark along a wire to explode a bomb
https://codepen.io/danzen/pen/vQyoNx

Blobatar - adding LabelLetters along a Blob path
https://codepen.io/danzen/pen/daBdVP

Dancing Blob - animated Blob points
https://codepen.io/zimjs/pen/rPgmGb

Whale - turn a Squiggle into a Blob
https://codepen.io/danzen/pen/wXXzzb

Pink Blob - animated points including animating scale 
https://codepen.io/danzen/pen/ErYqvJ

Drag along Blob NIO example with Dr Abstract in bubble
https://codepen.io/zimjs/pen/ZqNYxX
--*///+151

	// THE CODE FOR THE PIZZAZZ MODULE IS LINKED TO AT THE TOP OF THE DOCS

	//-151

	return zim;
} (zim || {});

var globalFunctions =   [
  ["zog", zog],
  ["zid", zid],
  ["zss", zss],
  ["zgo", zgo],
  ["zum", zum],
  ["zot", zot],
  ["zop", zop],
  ["zil", zil],
  ["zet", zet],
  ["zob", zob],
  ["zik", zik],
  ["zta", zta],
  ["zor", zor],
  ["zogg", zogg],
  ["zogp", zogp],
  ["zogb", zogb],
  ["zogr", zogr],
  ["zogy", zogy],
  ["zogo", zogo],
  ["zogl", zogl],
  ["zogd", zogd],
  ["zimplify", zimplify],
  ["zimify", zimify]
];

for (z_i = 0; z_i < globalFunctions.length; z_i++) {
  var pair = globalFunctions[z_i];  
  WW[pair[0]] = zim[pair[0]] = pair[1];
}


	// these are global regardless
	var globalsConstants = [
		["FIT", zim.FIT],
		["FILL", zim.FILL],
		["FULL", zim.FULL],
		["LEFT", zim.LEFT],
		["RIGHT", zim.RIGHT],
		["CENTER", zim.CENTER],
		["MIDDLE", zim.MIDDLE],
		["START", zim.START],
		["END", zim.END],
		["TOP", zim.TOP],
		["BOTTOM", zim.BOTTOM],
		["OVER", zim.OVER],
		["UNDER", zim.UNDER],
		["HORIZONTAL", zim.HORIZONTAL],
		["VERTICAL", zim.VERTICAL],
		["BOTH", zim.BOTH],
		["RADIAL", zim.RADIAL],
		["UP", zim.UP],
		["DOWN", zim.DOWN],
		["NEXT", zim.NEXT],
		["PREV", zim.PREV],
		["AUTO", zim.AUTO],
		["AVE", zim.AVE],
		["DEFAULT", zim.DEFAULT],
		["ALL", zim.ALL],
		["NONE", zim.NONE],
		["GET", zim.GET],
		["POST", zim.POST],
		["LOCALSTORAGE", zim.LOCALSTORAGE],
		["SOCKET", zim.SOCKET],
		["TO", zim.TO],
		["FROM", zim.FROM],		
		["SINE", zim.SINE],
		["SQUARE", zim.SQUARE],
		["TRIANGLE", zim.TRIANGLE],
		["SAW", zim.SAW],
		["SAWTOOTH", zim.SAWTOOTH],
		["ZAP", zim.ZAP],
		["TAU", zim.TAU],
		["DEG", zim.DEG],
		["RAD", zim.RAD],
		["PHI", zim.PHI],
	  ];
	  
	  for (z_i = 0; z_i < globalsConstants.length; z_i++) {
		var pair = globalsConstants[z_i];  
		WW[pair[0]] = pair[1];
	  }
	  
	  for (z_i = 0; z_i < zim.colors.length; z_i++) {
		WW[zim.colors[z_i]] = zim.colorsHex[z_i];
	  }


WW.zim = zim;
export default zim;
export {zimplify,zimify};
export let chop = zim.chop;
export let shuffle = zim.shuffle;
export let pluck = zim.pluck;
export let rand = zim.rand;
export let seedRandom = zim.seedRandom;
export let odds = zim.odds;
export let rarity = zim.rarity;
export let repeats = zim.repeats;
export let series = zim.series;
export let loop = zim.loop;
export let getTIME = zim.getTIME;
export let timeout = zim.timeout;
export let interval = zim.interval;
export let async = zim.async;
export let couple = zim.couple;
export let decouple = zim.decouple;
export let convertColor = zim.convertColor;
export let colorRange = zim.colorRange;
export let lighten = zim.lighten;
export let darken = zim.darken;
export let toColor = zim.toColor;
export let toAlpha = zim.toAlpha;
export let toBW = zim.toBW;
export let invertColor = zim.invertColor;
export let zimEase = zim.zimEase;
export let spline = zim.spline;
export let getPointAtPercent = zim.getPointAtPercent;
export let pointAlongCurve = zim.pointAlongCurve;
export let distanceAlongCurve = zim.distanceAlongCurve;
export let closestPointAlongCurve = zim.closestPointAlongCurve;
export let transformPoints = zim.transformPoints;
export let trimEndPoints = zim.trimEndPoints;
export let reversePoints = zim.reversePoints;
export let appendPoints = zim.appendPoints;
export let prependPoints = zim.prependPoints;
export let splitPoints = zim.splitPoints;
export let makeID = zim.makeID;
export let makeSyllable = zim.makeSyllable;
export let makePrimitive = zim.makePrimitive;
export let makeMath = zim.makeMath;
export let swapProperties = zim.swapProperties;
export let setProps = zim.setProps;
export let mobile = zim.mobile;
export let vee = zim.vee;
export let extend = zim.extend;
export let copy = zim.copy;
export let merge = zim.merge;
export let sortObject = zim.sortObject;
export let arraysEqual = zim.arraysEqual;
export let arrayMinMax = zim.arrayMinMax;
export let isEmpty = zim.isEmpty;
export let isPick = zim.isPick;
export let isJSON = zim.isJSON;
export let parseJSON = zim.parseJSON;
export let decimals = zim.decimals;
export let countDecimals = zim.countDecimals;
export let sign = zim.sign;
export let constrain = zim.constrain;
export let dist = zim.dist;
export let rectIntersect = zim.rectIntersect;
export let boundsAroundPoints = zim.boundsAroundPoints;
export let angle = zim.angle;
export let smoothStep = zim.smoothStep;
export let unicodeToUTF = zim.unicodeToUTF;
export let capitalizeFirst = zim.capitalizeFirst;
export let Ajax = zim.Ajax;
export let Noise = zim.Noise;
export let Point = zim.Point;
export let Bezier = zim.Bezier;
export let Boundary = zim.Boundary;
export let GradientColor = zim.GradientColor;
export let RadialColor = zim.RadialColor;
export let BitmapColor = zim.BitmapColor;
export let Damp = zim.Damp;
export let Proportion = zim.Proportion;
export let ProportionDamp = zim.ProportionDamp;
export let Dictionary = zim.Dictionary;
export let Hierarchy = zim.Hierarchy;
export let Pick = zim.Pick;
export let scrollX = zim.scrollX;
export let scrollY = zim.scrollY;
export let windowWidth = zim.windowWidth;
export let windowHeight = zim.windowHeight;
export let browserZoom = zim.browserZoom;
export let getQueryString = zim.getQueryString;
export let swapHTML = zim.swapHTML;
export let urlEncode = zim.urlEncode;
export let urlDecode = zim.urlDecode;
export let setCookie = zim.setCookie;
export let getCookie = zim.getCookie;
export let deleteCookie = zim.deleteCookie;
export let Stage = zim.Stage;
export let StageGL = zim.StageGL;
export let Container = zim.Container;
export let Shape = zim.Shape;
export let Bitmap = zim.Bitmap;
export let Sprite = zim.Sprite;
export let MovieClip = zim.MovieClip;
export let SVGContainer = zim.SVGContainer;
export let Tag = zim.Tag;
export let Shader = zim.Shader;
export let ShaderOverlay = zim.ShaderOverlay;
export let makeShader = zim.makeShader;
export let Uniforms = zim.Uniforms;
export let CustomShape = zim.CustomShape;
export let Circle = zim.Circle;
export let Rectangle = zim.Rectangle;
export let Triangle = zim.Triangle;
export let Poly = zim.Poly;
export let Line = zim.Line;
export let Squiggle = zim.Squiggle;
export {zimBlob as Blob};
export let Flare = zim.Flare;
export let MultiFlare = zim.MultiFlare;
export let FlareBox = zim.FlareBox;
export let Label = zim.Label;
export let LabelOnPath = zim.LabelOnPath;
export let LabelOnArc = zim.LabelOnArc;
export let LabelLetters = zim.LabelLetters;
export let LabelWords = zim.LabelWords;
export let Emoji = zim.Emoji;
export let Button = zim.Button;
export let CheckBox = zim.CheckBox;
export let RadioButtons = zim.RadioButtons;
export let Toggle = zim.Toggle;
export let Tip = zim.Tip;
export let Pane = zim.Pane;
export let Panel = zim.Panel;
export {zimWindow as Window};
export let Page = zim.Page;
export let Central = zim.Central;
export let Layer = zim.Layer;
export let Waiter = zim.Waiter;
export let ProgressBar = zim.ProgressBar;
export let Indicator = zim.Indicator;
export let TextInput = zim.TextInput;
export let List = zim.List;
export let Stepper = zim.Stepper;
export let Slider = zim.Slider;
export let Selector = zim.Selector;
export let Dial = zim.Dial;
export let Tabs = zim.Tabs;
export let Pad = zim.Pad;
export let NumPad = zim.NumPad;
export let DPad = zim.DPad;
export let Radial = zim.Radial;
export let RadialMenu = zim.RadialMenu;
export let ColorPicker = zim.ColorPicker;
export let EmojiPicker = zim.EmojiPicker;
export let TextEditor = zim.TextEditor;
export let Keyboard = zim.Keyboard;
export let Organizer = zim.Organizer;
export let Connectors = zim.Connectors;
export let Marquee = zim.Marquee;
export let Carousel = zim.Carousel;
export let Loader = zim.Loader;
export let TextArea = zim.TextArea;
export let localToGlobal = zim.localToGlobal;
export let globalToLocal = zim.globalToLocal;
export let localToLocal = zim.localToLocal;
export let addTo = zim.addTo;
export let removeFrom = zim.removeFrom;
export let added = zim.added;
export let centerReg = zim.centerReg;
export let center = zim.center;
export let place = zim.place;
export let placeReg = zim.placeReg;
export let pos = zim.pos;
export let loc = zim.loc;
export let mov = zim.mov;
export let sca = zim.sca;
export let alp = zim.alp;
export let vis = zim.vis;
export let ble = zim.ble;
export let dye = zim.dye;
export let hov = zim.hov;
export let rot = zim.rot;
export let siz = zim.siz;
export let ske = zim.ske;
export let reg = zim.reg;
export let top = zim.top;
export let bot = zim.bot;
export let ord = zim.ord;
export let cur = zim.cur;
export let sha = zim.sha;
export let dep = zim.dep;
export let nam = zim.nam;
export let movement = zim.movement;
export let noMovement = zim.noMovement;
export let tap = zim.tap;
export let noTap = zim.noTap;
export let hold = zim.hold;
export let noHold = zim.noHold;
export let change = zim.change;
export let noChange = zim.noChange;
export let drag = zim.drag;
export let noDrag = zim.noDrag;
export let dragBoundary = zim.dragBoundary;
export let mouse = zim.mouse;
export let noMouse = zim.noMouse;
export let wire = zim.wire;
export let noWire = zim.noWire;
export let wired = zim.wired;
export let noWired = zim.noWired;
export let bind = zim.bind;
export let noBind = zim.noBind;
export let transform = zim.transform;
export let gesture = zim.gesture;
export let noGesture = zim.noGesture;
export let gestureBoundary = zim.gestureBoundary;
export let effect = zim.effect;
export let updateEffects = zim.updateEffects;
export let noEffect = zim.noEffect;
export let addPhysics = zim.addPhysics;
export let removePhysics = zim.removePhysics;
export let hitTestPoint = zim.hitTestPoint;
export let hitTestReg = zim.hitTestReg;
export let hitTestRect = zim.hitTestRect;
export let hitTestCircle = zim.hitTestCircle;
export let hitTestCircleRect = zim.hitTestCircleRect;
export let hitTestCircles = zim.hitTestCircles;
export let hitTestBounds = zim.hitTestBounds;
export let hitTestPath = zim.hitTestPath;
export let hitTestGrid = zim.hitTestGrid;
export let animate = zim.animate;
export let stopAnimate = zim.stopAnimate;
export let pauseAnimate = zim.pauseAnimate;
export let wiggle = zim.wiggle;
export let scaleTo = zim.scaleTo;
export let fit = zim.fit;
export let boundsToGlobal = zim.boundsToGlobal;
export let resetBounds = zim.resetBounds;
export let copyMatrix = zim.copyMatrix;
export let duplicate = zim.duplicate;
export let expand = zim.expand;
export let setSwipe = zim.setSwipe;
export let setMask = zim.setMask;
export let outline = zim.outline;
export let blendmodes = zim.blendmodes;
export let Pages = zim.Pages;
export let Arrow = zim.Arrow;
export let HotSpot = zim.HotSpot;
export let HotSpots = zim.HotSpots;
export let Guide = zim.Guide;
export let Grid = zim.Grid;
export let Wrapper = zim.Wrapper;
export let Tile = zim.Tile;
export let Pack = zim.Pack;
export let Beads = zim.Beads;
export let Layout = zim.Layout;
export let Accessibility = zim.Accessibility;
export let TextureActive = zim.TextureActive;
export let TextureActives = zim.TextureActives;
export let TextureActivesManager = zim.TextureActivesManager;
export let Manager = zim.Manager;
export let ResizeManager = zim.ResizeManager;
export let TransformManager = zim.TransformManager;
export let GuideManager = zim.GuideManager;
export let GridManager = zim.GridManager;
export let LayoutManager = zim.LayoutManager;
export let SelectionSet = zim.SelectionSet;
export let SelectionManager = zim.SelectionManager;
export let Bind = zim.Bind;
export let Swipe = zim.Swipe;
export let Swiper = zim.Swiper;
export let MotionController = zim.MotionController;
export let GamePad = zim.GamePad;
export let Portal = zim.Portal;
export let Physics = zim.Physics;
export let TimeLine = zim.TimeLine;
export let BlurEffect = zim.BlurEffect;
export let GlowEffect = zim.GlowEffect;
export let ShadowEffect = zim.ShadowEffect;
export let ThresholdEffect = zim.ThresholdEffect;
export let ColorEffect = zim.ColorEffect;
export let MultiEffect = zim.MultiEffect;
export let AlphaEffect = zim.AlphaEffect;
export let Pixel = zim.Pixel;
export let Parallax = zim.Parallax;
export let Flipper = zim.Flipper;
export let Book = zim.Book;
export let Scrambler = zim.Scrambler;
export let Scroller = zim.Scroller;
export let Dynamo = zim.Dynamo;
export let Accelerator = zim.Accelerator;
export let Emitter = zim.Emitter;
export let Generator = zim.Generator;
export let Pen = zim.Pen;
export let SoundWave = zim.SoundWave;
export let Synth = zim.Synth;
export let VR = zim.VR;
export let Frame = zim.Frame;
export let Pic = zim.Pic;
export let Aud = zim.Aud;
export let Vid = zim.Vid;
export let SVG = zim.SVG;
export let Speech = zim.Speech;
export let PermissionAsk = zim.PermissionAsk;
export let distill = zim.distill;
export let parseAudioSprite = zim.parseAudioSprite;
export let previewAudioSprite = zim.previewAudioSprite;
export let svgToBitmap = zim.svgToBitmap;
export let makeContent = zim.makeContent;
export let fastFrame = zim.fastFrame;
export let addWires = zim.addWires;
export let setBlurDetect = zim.setBlurDetect;
export let Wonder = zim.Wonder;
export let getLatestVersions = zim.getLatestVersions;
export let PWA = zim.PWA;
export let QR = zim.QR;
export let GIF = zim.GIF;
export let THEME = zim.THEME;
export let Theme = zim.Theme;
export let Ticker = zim.Ticker;
export let Style = zim.Style;
export let assets = zim.assets;
export let assetIDs = zim.assetIDs;
export let ZIMON = zim.ZIMON;